Var* syn_new_vars(SynPtrn ptrn):
    ptrn_var()      = {ptrn.var} & syn_new_vars(ptrn.ptrn),
    ptrn_tag_obj()  = syn_new_vars(ptrn.tag) & syn_new_vars(ptrn.obj),
    _               = {};


Var* syn_new_vars(SynStmt stmt):
  assignment_stmt() = set(stmt.vars),
  if_stmt()         = {
    bodies = {b.body : b <- set(stmt.branches)} & {stmt.else};
    return intersection({syn_new_vars(ss) : ss <- bodies, not never_falls_through(ss)});
  },
  let_stmt()        = syn_new_vars(stmt.body),
  proc_call()       = {stmt.res_var if stmt.res_var?},
  _                 = {};


Var* syn_new_vars([<SynStmt, SynClause>] objs) = seq_union([syn_new_vars(obj) : obj <- objs]);


Var* syn_new_vars(SynClause clause):
  in_clause()           = syn_new_vars(clause.ptrn),
  map_in_clause()       = syn_new_vars(clause.key_ptrn) & syn_new_vars(clause.value_ptrn),
  eq_clause()           = {clause.var},
  and_clause(cs?)       = seq_union([syn_new_vars(c) : c <- cs]),
  or_clause()           = intersection(syn_new_vars(clause.left), syn_new_vars(clause.right));


Var* syn_new_vars(SynIter iter):
  seq_iter()    = set(iter.vars) & {iter.idx_var if iter.idx_var?},
  range_iter()  = {iter.var if iter.var?};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

TypeSymbol syn_type_symbol_to_type_symbol(SynTypeSymbol ts):
  BasicTypeSymbol   = ts,
  par_type_symbol() = par_type_symbol(ts.symbol, [syn_type_to_user_type(p) : p <- ts.params]);


UserType syn_type_to_user_type(SynType type):
  LeafType                = type,
  TypeVar                 = type,
  type_ref(ts?)           = type_ref(syn_type_symbol_to_type_symbol(ts)),
  syn_int_range()         = int_range(type.min, type.max),
  ne_seq_type()           = ne_seq_type(syn_type_to_user_type(type.elem_type)),
  ne_set_type()           = ne_set_type(syn_type_to_user_type(type.elem_type)),
  ne_map_type()           = ne_map_type(syn_type_to_user_type(type.key_type), syn_type_to_user_type(type.value_type)),
  record_type([...] fs?)  = record_type((f.label => (type: syn_type_to_user_type(f.type), optional: f.optional) : f <- set(fs))),
  record_type((...))      = type,
  tuple_type(ts?)         = tuple_type([syn_type_to_user_type(t) : t <- ts]),
  tag_obj_type()          = tag_obj_type(type.tag_type, syn_type_to_user_type(type.obj_type)),
  union_type(ts?)         = union_type({syn_type_to_user_type(t) : t <- ts}),
  syn_union_type(ts?)     = union_type({syn_type_to_user_type(t) : t <- set(ts)});


UserExtType syn_type_to_user_type(SynClsType type) =
  user_cls_type([syn_type_to_user_type(t) : t <- type.in_types], syn_type_to_user_type(type.out_type));

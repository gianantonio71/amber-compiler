
type SynParTypeSymbol = par_type_symbol(symbol: BasicTypeSymbol, params: [SynType^]);
type SynTypeSymbol    = BasicTypeSymbol, SynParTypeSymbol;

/////////////////////////////////////////////////////////////////////////////////////

type SynType        = SynLeafType, SynTypeRef, TypeVar, SynNeSeqType, SynNeSetType,
                      SynNeMapType, SynRecordType, SynTupleType, SynTagObjType, SynUnionType;

type SynLeafType    = LeafType, syn_int_range(min: Int, max: Int);
type SynTypeRef     = type_ref(SynTypeSymbol);

type SynNeSeqType   = ne_seq_type(elem_type: SynType);
type SynNeSetType   = ne_set_type(elem_type: SynType);
type SynNeMapType   = ne_map_type(key_type: SynType, value_type: SynType);

type SynRecordType  = record_type([SynRecordField^]);
type SynRecordField = (label: SymbObj, type: SynType, optional: Bool);

type SynTupleType   = tuple_type([SynType^]);

type SynTagObjType  = tag_obj_type(tag_type: SynType, obj_type: SynType);

type SynUnionType   = union_type([SynType^]);

/////////////////////////////////////////////////////////////////////////////////////

type SynClsType  = cls_type(in_types: [SynType^], out_type: SynType);
type SynAnyType  = SynType, SynClsType;

/////////////////////////////////////////////////////////////////////////////////////

type SynTypedef    = typedef(name: BasicTypeSymbol, type: SynType);

type SynParTypedef = par_typedef(name: BasicTypeSymbol, params: [TypeVar^], type: SynType);

type SynAnyTypedef = SynTypedef, SynParTypedef;

/////////////////////////////////////////////////////////////////////////////////////

type SynExpr  = LeafObj, FloatLit, FnPar, ConstOrVar, ClsPar, MembCopyVar,
                SynSeqExpr, SynTupleExpr, SynSetExpr, SynMapExpr, SynTagObjExpr,
                SynFnCall, SynBuiltInCall,
                SynBoolExpr, SynCmpExpr,
                SynMembExpr, SynCastExpr,
                SynAccExpr, SynAccTestExpr,
                SynExQualExpr, SynSCExpr, SynMCExpr, SynLCExpr, SynRCExpr,
                SynIfExpr, SynTryExpr,
                SynDoExpr, SynLetExpr,
                SynIsSetExpr,
                OutputIsDefExpr;

type ConstOrVar       = const_or_var(Atom); //## NOT SURE ATOM IS THE RIGHT THING HERE

type ClsPar           = cls_par(Nat);

type SynSeqExpr       = seq_expr([SynSubExpr]), seq_tail_expr(seq: SynExpr, tail: [SynExpr^]);
type SynTupleExpr     = tuple_expr([SynExpr^]);
type SynSetExpr       = set_expr(SynSubExpr*);
type SynMapExpr       = map_expr(SynMapExprEntry*);
type SynTagObjExpr    = tag_obj_expr(tag: SynExpr, obj: SynExpr);

                      //## ANY POINT IN USING NamedArg INSTEAD OF JUST Atom?
                      //## SAME GOES FOR <name> FIELD, AND ALSO ALL OTHER TYPES OF EXPRESSIONS AND OTHER THINGS
type SynFnCall        = fn_call(name: FnSymbol, args: [SynExpr^], named_args: [(NamedArg, [StdVar], SynExpr)]);
type SynBuiltInCall   = builtin_call(name: BuiltIn, args: [SynExpr^]);

type SynBoolExpr      = and(left: SynExpr, right: SynExpr),
                        or(left: SynExpr, right: SynExpr),
                        not(SynExpr);

type SynCmpExpr       = eq(left: SynExpr, right: SynExpr),
                        neq(left: SynExpr, right: SynExpr);

type SynMembExpr      = membership(obj: SynExpr, type: SynType);
type SynCastExpr      = cast_expr(expr: SynExpr, type: SynType);

type SynAccExpr       = accessor(expr: SynExpr, field: SymbObj);
type SynAccTestExpr   = accessor_test(expr: SynExpr, field: SymbObj);

type SynExQualExpr    = ex_qual(source: [SynClause^], cond: SynExpr);
type SynSCExpr        = set_comp(expr: SynExpr, source: [SynClause^]);
type SynMCExpr        = map_comp(key_expr: SynExpr, value_expr: SynExpr, source: [SynClause^]);
type SynLCExpr        = seq_comp(expr: SynExpr, vars: [StdVar^], idx_var: StdVar?, src_expr: SynExpr, sel_expr: SynExpr?);
type SynRCExpr        = range_comp(expr: SynExpr, var: StdVar, bound_expr: SynExpr, inclusive: Bool, sel_expr: SynExpr?);

type SynIfExpr        = if_expr(branches: [(cond: SynExpr, expr: SynExpr)^], else: SynExpr);
type SynTryExpr       = match_expr(exprs: [SynExpr^], cases: [SynCase^]);

type SynDoExpr        = do_expr([SynStmt^]);

type SynLetExpr       = let_expr(expr: SynExpr, stmts: [SynAsgnStmt^]);

type SynIsSetExpr     = IsSetExpr;

type SynAccIsDefExpr  = OutputIsDefExpr;

/////////////////////////////////////////////////////////////////////////////////////

type SynCondExpr      = cond_expr(expr: SynExpr, cond: SynExpr);
type SynSubExpr       = SynExpr, SynCondExpr;

type SynMapExprEntry  = (key: SynExpr, value: SynExpr, cond: SynExpr?);

/////////////////////////////////////////////////////////////////////////////////////

type SynPtrn    = ptrn_symbol,
                  ptrn_float,
                  ptrn_seq,
                  ptrn_set,
                  ptrn_map,
                  ptrn_tag_obj,
                  ptrn_any,
                  ptrn_symbol(SymbObj),
                  ptrn_integer(<integer, IntObj>), //## COULD JUST BE A PATTERN JUST FOR INTEGERS IN GENERAL, THE ABILITY TO SPECIFY A PARTICULAR INTEGER SEEMS TO BE PRETTY USELESS
                  ptrn_tag_obj(tag: TagPtrn, obj: SynPtrn),
                  ptrn_var(var: StdVar, ptrn: SynPtrn),
                  ptrn_type(SynType);

type SynClause  = set_elem_clause(var: StdVar, src: SynExpr),
                  map_entry_clause(key_var: StdVar, value_var: StdVar, src: SynExpr),
                  seq_elem_clause(var: StdVar, src: SynExpr),
                  and_clause([SynClause^]),
                  or_clause(left: SynClause, right: SynClause),
                  match_clause(ptrn: SynPtrn, expr: SynExpr),
                  asgnm_clause(var: StdVar, expr: SynExpr),
                  filter_clause(cond: SynExpr);

type SynCase    = case(patterns: [SynPtrn^], expr: SynExpr);

/////////////////////////////////////////////////////////////////////////////////////

type SynStmt  = SynAsgnStmt, SynReturnStmt, SynIfStmt, SynLoopStmt, SynInfLoopStmt,
                SynForStmt, SynLetStmt, SynBreakStmt, SynFailStmt, SynAssertStmt,
                SynPrintStmt, SynImpUpdateStmt, SynFnDefStmt,
                SynSetMembVarStmt, SynMethodCallStmt,
                SynProcOnlyStmt;  //## BAD: MIXING PURE AND IMPURE STATEMENTS

type SynAsgnStmt      = assignment_stmt(vars: [StdVar^], value: SynExpr);
type SynReturnStmt    = return_stmt(SynExpr);
type SynIfStmt        = if_stmt(branches: [(cond: SynExpr, body: [SynStmt^])^], else: [SynStmt]);
type SynLoopStmt      = loop_stmt(cond: SynExpr, skip_first: Bool, body: [SynStmt^]);
type SynInfLoopStmt   = inf_loop_stmt([SynStmt^]);
type SynForStmt       = for_stmt(loops: [SynIter^], body: [SynStmt^]);
type SynLetStmt       = let_stmt(asgnms: [(NamedArg, SynExpr)^], body: [SynStmt^]);
type SynBreakStmt     = break_stmt; //## REPLACE WITH BreakStmt
type SynFailStmt      = fail_stmt;  //## REPLACE WITH FailStmt
type SynAssertStmt    = assert_stmt(cond: SynExpr, file: String, line: NzNat, text: Maybe[String]);
type SynPrintStmt     = print_stmt(SynExpr);
type SynImpUpdateStmt = imp_update_stmt(obj: StdVar, idx: SynExpr, value: SynExpr);

type SynSetMembVarStmt  = set_memb_var_stmt(var: PendingStateVar, value: SynExpr);
type SynMethodCallStmt  = method_call_stmt(var: Atom?, channel: Atom, args: [SynExpr]);

type SynProcCallStmt      = proc_call(res_var: StdVar?, proc_name: ProcSymbol, args: [SynExpr]); //## RENAME IN proc_call_stmt(...)

type SynAutoSetInputStmt  = auto_set_input_stmt(var: LocAutoVar, input: Atom, value: Maybe[SynExpr]);
type SynAutoUpdateStmt    = auto_update_stmt(var: LocAutoVar, elapsed_time: SynExpr?);

type SynProcOnlyStmt      = return_stmt, SynProcCallStmt, SynAutoSetInputStmt, SynAutoUpdateStmt;

type SynFnDefStmt   = fn_def_stmt(SynFnDef);

type SynSeqIter     = seq_iter(vars: [StdVar^], idx_var: StdVar?, values: SynExpr);
type SynRangeIter   = range_iter(var: StdVar?, start_val: SynExpr, end_val: SynExpr, end_val_incl: Bool);

type SynIter = SynSeqIter, SynRangeIter;

/////////////////////////////////////////////////////////////////////////////////////

type SynFnDef       = syn_fn_def(
                        name:       FnSymbol,
                        args:       [SynFnArg],
                        res_type:   SynType,
                        expr:       SynExpr,
                        local_fns:  [SynFnDef]
                      );

type SynScalarFnArg = (type: SynType, var_name: Atom?);
type SynClsFnArg    = (type: SynClsType, var_name: Atom);
type SynFnArg       = SynScalarFnArg, SynClsFnArg;

type SynProcDef     = syn_proc_def(
                        name:       ProcSymbol,
                        args:       [(var: StdVar, type: SynType)],
                        res_type:   Maybe[SynType],
                        auto_vars:  [(var: LocAutoVar, type: Atom)],
                        body:       [SynStmt]
                      );

type SynSgn         = syn_sgn(
                        name:     NamedArg,
                        args:     [SynType],
                        res_type: SynType
                      );

type SynUsingBlock  = using_block(
                        signatures: [SynSgn^],
                        fn_defs:    [SynFnDef^]
                      );

type SynSubtypeDecl = SubtypeDecl;

////////////////////////////////////////////////////////////////////////////////

type SynInputDecl   = syn_input(name: Atom, type: SynType, discrete: Bool);
type SynOutputDecl  = syn_output(name: Atom, type: SynType, discrete: Bool);
type SynStateDecl   = syn_state(name: Atom, type: SynType, init_value: SynExpr);

type SynPlainRule   = syn_plain_rule(name: Atom, expr: SynExpr, discrete: Bool);
type SynCondRule    = syn_cond_rule(name: Atom, branches: [(expr: SynExpr, cond: SynExpr)^], discrete: Bool);
type SynForeachRule = syn_foreach_rule(name: Atom, value: SynExpr, signals: [Atom^], cond: SynExpr?, discrete: Bool);

type SynTimeVaryingCond = time_varying_cond(cond: SynExpr, time_expr: TimeExpr);

type SynTimeVaryingRule = syn_time_varying_rule(name: Atom, value: SynTimeVaryingCond);

type SynNestedAuto  = syn_nested_auto(name: Atom, auto_name: Atom, args: [(Atom, SynExpr)]);

type SynMethodCall  = syn_method_call(
                        target:   Atom,
                        method:   Atom,
                        message:  SynExpr,
                        cond:     Maybe[SynExpr],
                        signals:  [Atom]
                      );

type AutoDecl       = SynInputDecl, SynOutputDecl, SynStateDecl, SynPlainRule, SynCondRule,
                      SynForeachRule, SynTimeVaryingRule, SynNestedAuto, SynMethodCall;

type SynMethodStmt  = syn_memb_asgnm(memb_var: Atom, value: SynExpr),
                      syn_nested_call(auto_var: Atom, method: MethodSymbol, args: [SynExpr]);

type SynMethodDef   = syn_method_def(
                        automaton:  AutoSymbol,
                        name:       MethodSymbol,
                        args:       [(SynType, StdVar)],
                        body:       [SynStmt]
                      );

type SynAutoDef     = syn_auto_def(name: AutoSymbol, pos_args: [Atom], decls: [AutoDecl]); //## SHOULD I ALLOW EMPTY AUTOMATON DEFINITIONS?

////////////////////////////////////////////////////////////////////////////////

type PrgDecl        = SynTypedef, SynParTypedef, SynFnDef, SynUsingBlock, SynSubtypeDecl,
                      SynProcDef, SynAutoDef, SynMethodDef;

type SynPrg         = prg([PrgDecl]);
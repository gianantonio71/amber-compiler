
type SynParTypeSymbol = par_type_symbol(symbol: BasicTypeSymbol, params: SynType+);
type SynTypeSymbol    = BasicTypeSymbol, SynParTypeSymbol;

/////////////////////////////////////////////////////////////////////////////////////

type SynType        = SynLeafType, SynTypeRef, TypeVar, SynNeSeqType, SynNeSetType,
                      SynNeMapType, SynRecordType, SynTupleType, SynTagObjType, SynUnionType;

type SynLeafType    = LeafType, syn_int_range(min: Int, max: Int);
type SynTypeRef     = type_ref(SynTypeSymbol);

type SynNeSeqType   = ne_seq_type(elem_type: SynType);
type SynNeSetType   = ne_set_type(elem_type: SynType);
type SynNeMapType   = ne_map_type(key_type: SynType, value_type: SynType);

type SynRecordType  = record_type(SynRecordField+);
type SynRecordField = [label: SymbObj, type: SynType, optional: Bool];

type SynTupleType   = tuple_type(SynType+);

type SynTagObjType  = tag_obj_type(tag_type: SynType, obj_type: SynType);

type SynUnionType   = union_type(SynType+);

/////////////////////////////////////////////////////////////////////////////////////

type SynClsType  = cls_type(in_types: SynType+, out_type: SynType);
type SynAnyType  = SynType, SynClsType;

/////////////////////////////////////////////////////////////////////////////////////

type SynTypedef    = typedef(name: BasicTypeSymbol, type: SynType);

type SynParTypedef = par_typedef(name: BasicTypeSymbol, params: TypeVar+, type: SynType);

type SynAnyTypedef = SynTypedef, SynParTypedef;

/////////////////////////////////////////////////////////////////////////////////////

type SynExpr  = LeafObj, FloatLit, FnPar, ConstOrVar, ClsPar, MembCopyVar,
                SynSeqExpr, SynSetExpr, SynMapExpr, SynTagObjExpr,
                SynFnCall, SynBuiltInCall,
                SynPseudoCallExpr, SynMapSearchExpr, SynKeySearchExpr, SynOnlyElemExpr,
                SynBoolExpr, SynCmpExpr,
                SynMembExpr, SynCastExpr,
                SynAccExpr, SynAccTestExpr,
                SynExQualExpr, SynSCExpr, SynMCExpr, SynLCExpr, SynRCExpr,
                SynIfExpr, SynTryExpr,
                SynDoExpr, SynLetExpr,
                SynMethodCallExpr,
                SynIsSetExpr,
                OutputIsDefExpr;

type ConstOrVar       = const_or_var(Atom); //## NOT SURE ATOM IS THE RIGHT THING HERE

type ClsPar           = cls_par(Nat);

type SynSeqExpr       = seq_expr(SynSubExpr*), seq_tail_expr(seq: SynExpr, tail: SynExpr+);
type SynSetExpr       = set_expr([SynSubExpr]);
type SynMapExpr       = map_expr([SynMapExprEntry]);
type SynTagObjExpr    = tag_obj_expr(tag: SynExpr, obj: SynExpr);

                      //## ANY POINT IN USING NamedArg INSTEAD OF JUST Atom?
                      //## SAME GOES FOR <name> FIELD, AND ALSO ALL OTHER TYPES OF EXPRESSIONS AND OTHER THINGS
type SynFnCall        = fn_call(name: FnSymbol, args: SynExpr*, named_args: (NamedArg, StdVar*, SynExpr)*);
type SynBuiltInCall   = builtin_call(name: BuiltIn, args: SynExpr+);

type SynPseudoCallExpr  = unary_pseudo_call(target: SynExpr, param: SynExpr);
type SynMapSearchExpr = map_search(map: SynExpr, key: SynExpr, value: SynExpr);
type SynKeySearchExpr = key_search(map: SynExpr, key: SynExpr);
type SynOnlyElemExpr  = singl_only_elem(set: SynExpr);

type SynBoolExpr      = and(left: SynExpr, right: SynExpr),
                        or(left: SynExpr, right: SynExpr),
                        not(SynExpr);

type SynCmpExpr       = eq(left: SynExpr, right: SynExpr),
                        neq(left: SynExpr, right: SynExpr);

type SynMembExpr      = membership(obj: SynExpr, type: SynType);
type SynCastExpr      = cast_expr(expr: SynExpr, type: SynType);

type SynAccExpr       = accessor(expr: SynExpr, field: Atom);
type SynAccTestExpr   = accessor_test(expr: SynExpr, field: Atom);

type SynExQualExpr    = ex_qual(source: SynClause+, cond: SynExpr);
type SynSCExpr        = set_comp(expr: SynExpr, source: SynClause+);
type SynMCExpr        = map_comp(key_expr: SynExpr, value_expr: SynExpr, source: SynClause+);
type SynLCExpr        = seq_comp(expr: SynExpr, vars: StdVar+, idx_var: StdVar?, src_expr: SynExpr, sel_expr: SynExpr?);
type SynRCExpr        = range_comp(expr: SynExpr, var: StdVar, bound_expr: SynExpr, inclusive: Bool, sel_expr: SynExpr?);

type SynIfExpr        = if_expr(branches: [cond: SynExpr, expr: SynExpr]+, else: SynExpr);
type SynTryExpr       = match_expr(exprs: SynExpr+, cases: SynCase+);

type SynDoExpr        = do_expr(SynStmt+);

type SynLetExpr       = let_expr(expr: SynExpr, stmts: SynAsgnStmt+);

type SynMethodCallExpr  = method_call_expr(var: Atom, name: MethodSymbol, args: SynExpr*);

type SynIsSetExpr     = IsSetExpr;

type SynAccIsDefExpr  = OutputIsDefExpr;

/////////////////////////////////////////////////////////////////////////////////////

type SynCondExpr      = cond_expr(expr: SynExpr, cond: SynExpr);
type SynSubExpr       = SynExpr, SynCondExpr;

type SynMapExprEntry  = [key: SynExpr, value: SynExpr, cond: SynExpr?];

/////////////////////////////////////////////////////////////////////////////////////

type SynPtrn    = ptrn_symbol,
                  ptrn_float,
                  ptrn_seq,
                  ptrn_set,
                  ptrn_map,
                  ptrn_tag_obj,
                  ptrn_any,
                  ptrn_symbol(SymbObj),
                  ptrn_integer(<integer, IntObj>), //## COULD JUST BE A PATTERN JUST FOR INTEGERS IN GENERAL, THE ABILITY TO SPECIFY A PARTICULAR INTEGER SEEMS TO BE PRETTY USELESS
                  ptrn_tuple(SynPtrn+),
                  ptrn_tag_obj(tag: TagPtrn, obj: SynPtrn),
                  ptrn_var(var: StdVar, ptrn: SynPtrn),
                  ptrn_type(SynType),
                  ptrn_union(SynPtrn+);

type SynClause  = set_elem_clause(var: StdVar, src: SynExpr),
                  map_entry_clause(key_var: StdVar, value_var: StdVar, src: SynExpr),
                  seq_elem_clause(var: StdVar, src: SynExpr),
                  and_clause(SynClause+),
                  or_clause(left: SynClause, right: SynClause),
                  match_clause(ptrn: SynPtrn, expr: SynExpr),
                  asgnm_clause(var: StdVar, expr: SynExpr),
                  filter_clause(cond: SynExpr);

type SynCase    = case(patterns: SynPtrn+, expr: SynExpr);

/////////////////////////////////////////////////////////////////////////////////////

type SynStmt  = SynAtomicFnStmt, SynAtomicMethStmt, SynAtomicProcStmt,
                SynAutoOrDBCtrlStmt, SynCompStmt[SynStmt], SynFnDefStmt;

type SynAtomicFnStmt  = SynAsgnStmt, SynReturnStmt, SynBreakStmt, SynFailStmt,
                        SynAssertStmt, SynPrintStmt, SynImpUpdateStmt;

type SynAsgnStmt      = assignment_stmt(vars: StdVar+, value: SynExpr);
type SynReturnStmt    = return_stmt(SynExpr);
type SynBreakStmt     = break_stmt;
type SynFailStmt      = fail_stmt;
type SynAssertStmt    = assert_stmt(cond: SynExpr, file: String, line: NzNat, text: Maybe[String]);
type SynPrintStmt     = print_stmt(SynExpr);
type SynImpUpdateStmt = imp_update_stmt(obj: StdVar, idx: SynExpr, value: SynExpr);

type SynAtomicMethStmt  = send_msg_stmt(var: Atom, msg: SynExpr),
                          try_update_stmt(name: Atom, args: SynExpr*),
                          set_memb_var_stmt(var: Atom, value: SynExpr);

type SynAtomicProcStmt  = SynNoValRetStmt, SynProcCallStmt;

type SynNoValRetStmt  = return_stmt;
type SynProcCallStmt  = proc_call_stmt(res_var: StdVar?, proc_name: ProcSymbol, args: SynExpr*);

type SynAutoOrDBCtrlStmt  = set_input_ctrl_stmt(var: Atom, input: Atom, value: SynExpr),
                            clear_input_ctrl_stmt(var: Atom, input: Atom),
                            apply_ctrl_stmt(var: Atom, elapsed_time: SynExpr?),
                            send_msg_ctrl_stmt(res_var: Atom, db_var: Atom, msg: SynExpr);

type SynCompStmt[T] = SynIfStmt[T], SynLoopStmt[T], SynInfLoopStmt[T], SynForStmt[T], SynLetStmt[T];

type SynIfStmt[T]       = if_stmt(branches: [cond: SynExpr, body: T+]+, else: T*);
type SynLoopStmt[T]     = loop_stmt(cond: SynExpr, skip_first: Bool, body: T+);
type SynInfLoopStmt[T]  = inf_loop_stmt(T+);
type SynForStmt[T]      = for_stmt(loops: SynIter+, body: T+);
type SynLetStmt[T]      = let_stmt(asgnms: (NamedArg, SynExpr)+, body: T+);

type SynFnDefStmt   = fn_def_stmt(fn_def: SynFnDef);

/////////////////////////////////////////////////////////////////////////////////////

type SynSeqIter     = seq_iter(vars: StdVar+, idx_var: StdVar?, values: SynExpr);
type SynRangeIter   = range_iter(var: StdVar?, start_val: SynExpr, end_val: SynExpr, end_val_incl: Bool);

type SynIter = SynSeqIter, SynRangeIter;

/////////////////////////////////////////////////////////////////////////////////////

type SynFnDef       = syn_fn_def(
                        name:       FnSymbol,
                        args:       SynFnArg*,
                        res_type:   SynType,
                        expr:       SynExpr,
                        local_fns:  SynFnDef*
                      );

type SynScalarFnArg = [type: SynType, var_name: Atom?];
type SynClsFnArg    = [type: SynClsType, var_name: Atom];
type SynFnArg       = SynScalarFnArg, SynClsFnArg;

type SynProcDef     = syn_proc_def(
                        name:       ProcSymbol,
                        args:       [var: StdVar, type: SynType]*,
                        res_type:   Maybe[SynType],
                        auto_vars:  [var: Atom, type: Atom]*,
                        db_vars:    [var: Atom, type: Atom]*,
                        body:       SynStmt*
                      );

type SynSgn         = syn_sgn(
                        name:     NamedArg,
                        args:     SynType*,
                        res_type: SynType
                      );

type SynImplBlock   = implicit_block(
                        signatures: SynSgn+,
                        fn_defs:    SynFnDef+
                      );

////////////////////////////////////////////////////////////////////////////////

type InputDecl      = input_decl(name: Atom, type: SynType, discrete: Bool);
type OutputDecl     = output_decl(name: Atom, type: SynType, discrete: Bool);
type StateVarDecl   = state_var_decl(name: Atom, type: SynType, init_value: SynExpr);
type ConstDecl      = const_decl(name: Atom, type: SynType?, value: SynExpr);

type SynPlainRule   = syn_plain_rule(name: Atom, expr: SynExpr, discrete: Bool);
type SynCondRule    = syn_cond_rule(name: Atom, branches: [expr: SynExpr, cond: SynExpr]+, discrete: Bool);
type SynForeachRule = syn_foreach_rule(name: Atom, value: SynExpr, signals: Atom+, cond: SynExpr?, discrete: Bool);

type SynTimeVaryingRule = syn_time_varying_boolean_rule(name: Atom, cond: SynExpr, time_expr: TimeExpr),
                          syn_time_varying_unchanged_rule(name: Atom, cond: SynExpr, time_expr: TimeExpr),
                          syn_time_varying_inactive_rule(
                            name:             Atom,
                            signals:          Atom+,
                            time_expr:        TimeExpr,
                            starts_at_time_0: Bool
                          );

type SynNestedAuto  = syn_nested_auto(name: Atom, auto_name: Atom, args: (Atom, SynExpr)*);

type SynMsgSend     = syn_msg_send(
                        target:   Atom,
                        message:  SynExpr,
                        cond:     Maybe[SynExpr],
                        signals:  Atom*
                      );

type RuleDecl       = SynPlainRule, SynCondRule, SynForeachRule, SynTimeVaryingRule, SynNestedAuto, SynMsgSend;

type SynMethodStmt  = syn_memb_asgnm(memb_var: Atom, value: SynExpr),
                      syn_nested_call(auto_var: Atom, method: UpdateSymbol, args: SynExpr*);

type SynMethodDef = syn_method_def(
                      target:     <AutoSymbol, DBSymbol>,
                      name:       MethodSymbol,
                      args:       (SynType, StdVar)*,
                      ret_type:   SynType,
                      expr:       SynExpr
                    );

type SynUpdateDef   = syn_update_def(
                        target:   DBSymbol,
                        name:     UpdateSymbol,
                        args:     (SynType, StdVar)*,
                        body:     SynStmt*
                      );

type HandlerDef     = handler_def(target: DBSymbol, type: SynType, body: SynStmt*);

type SynAutoDef     = syn_auto_def(
                        name:       AutoSymbol,
                        pos_inputs: Atom*,
                        res_type:   SynType?,
                        parent:     Atom?,
                        inputs:     InputDecl*,
                        outputs:    OutputDecl*,
                        state_vars: StateVarDecl*,
                        nested_dbs: NestedDBDecl*,
                        consts:     ConstDecl*,
                        rules:      RuleDecl*
                      );

type NestedDBDecl   = nested_db_decl(name: Atom, type: Atom);

type DataBaseDecl   = StateVarDecl, NestedDBDecl;

type SynDBDef       = syn_db_def(
                        name:   Atom,
                        decls:  DataBaseDecl*
                      );

////////////////////////////////////////////////////////////////////////////////

type PrgDecl        = SynTypedef, SynParTypedef, SynFnDef, SynImplBlock, SynProcDef,
                      SynAutoDef, SynDBDef, SynMethodDef, HandlerDef, SynUpdateDef;

type SynPrg         = prg(PrgDecl*);
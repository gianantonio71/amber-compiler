
SymbObj object(Atom a) = :object(a);
IntObj  object(Int n)  = :object(n);

////////////////////////////////////////////////////////////////////////////////

BasicTypeSymbol type_symbol(Atom a)         = :type_symbol(a);
BasicTypeSymbol builtin_type_symbol(<any>)  = :builtin_type_symbol(:any);

ParTypeSymbol par_type_symbol(BasicTypeSymbol s, Type+ ps) = par_type_symbol(symbol: s, params: ps);

TypeName type_name(BasicTypeSymbol ts, Nat arity) = type_name(symbol: ts, arity: arity);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

<empty_type> empty_type = :empty_type;

<atom_type> atom_type = :atom_type;

<float_type> float_type = :float_type;

SymbType symb_type(SymbObj obj) = :symb_type(obj);
SymbType symb_type(Atom symbol) = :symb_type(:object(symbol));

<integer> integer = :integer; //## IT HAS TO BE <integer> AND NOT IntType BECAUSE THE SAME SYMBOL IS USED FOR A DIFFERENT PURPOSE IN PARSING
IntType low_ints(Int max) = low_ints(max: max);
IntType high_ints(Int min) = high_ints(min: min);
IntType int_range(Int min, Int max) = int_range(min: min, size: nz_nat(max-min+1)); //## BUG: WHAT HAPPENS IF max IS LOWER THAN min?

TypeRef type_ref(TypeSymbol s) = :type_ref(s);

TypeVar type_var(<Atom, Nat> n) = :type_var(n);

<empty_seq_type> empty_seq_type = :empty_seq_type;
<empty_set_type> empty_set_type = :empty_set_type;
<empty_bin_rel_type> empty_bin_rel_type = :empty_bin_rel_type;
<empty_tern_rel_type> empty_tern_rel_type = :empty_tern_rel_type;

<empty_type> ne_seq_type(<empty_type>)  = empty_type;
NeType ne_seq_type(NeType t)            = ne_seq_type(elem_type: t);

<empty_type> ne_set_type(<empty_type>)  = empty_type;
NeType ne_set_type(NeType t)            = ne_set_type(elem_type: t);

<empty_type> ne_map_type(<empty_type>, <empty_type>)  = empty_type;
<empty_type> ne_map_type(NeType, <empty_type>)        = empty_type;
<empty_type> ne_map_type(<empty_type>, NeType)        = empty_type;
NeType ne_map_type(NeType kt, NeType vt)              = ne_map_type(key_type: kt, value_type: vt);

Type ne_bin_rel_type(Type t1, Type t2) =
  if t1 != empty_type and t2 != empty_type
    then ne_bin_rel_type(args_types: (t1, t2))
  else
    empty_type;

Type ne_tern_rel_type(Type t1, Type t2, Type t3) =
  if t1 != empty_type and t2 != empty_type and t3 != empty_type
    then ne_tern_rel_type(args_types: (t1, t2, t3))
  else
    empty_type;

RecordType ne_record_type(RecordTypeFields fs) = :ne_record_type(fs);

//## BAD: IF THE LANGUAGE HAD SUBSIGNATURES, THIS FUNCTION WOULD NOT BE NEEDED
NeType record_type_nonempty([SymbObj -> (type: NeType, optional: Bool)] fs)
{
  return empty_bin_rel_type if fs == [:];
  nonempty = (l, f <- fs : not f.optional);
  return union_type_nonempty([:ne_record_type(fs); empty_bin_rel_type if not nonempty]);
}

Type record_type([SymbObj -> (type: Type, optional: Bool)] fs)
{
  return empty_type if (unused_var, f <- fs : f.type == empty_type and not f.optional);
  rfs = [l -> (type: t, optional: f.optional) : l, f <- fs; t = f.type; t != empty_type];
  return record_type_nonempty(rfs);
}

//## BAD: IF THE LANGUAGE HAD SUBSIGNATURES, THIS FUNCTION WOULD NOT BE NEEDED
NeType tuple_type_nonempty(NeType+ ts) = :tuple_type(ts);

Type tuple_type(Type+ ts)
{
  ne_ts = ();
  for t <- ts:
    return empty_type if t == empty_type;
    ne_ts = (ne_ts | t);
  ;
  return :tuple_type(nonempty(ne_ts));
}

<empty_type> tag_obj_type(TagType, <empty_type>) = empty_type;
TagObjType   tag_obj_type(TagType tt, NeType ot) = tag_obj_type(tag_type: tt, obj_type: ot);

//## BAD: IF THE LANGUAGE HAD SUBSIGNATURES, THIS FUNCTION WOULD NOT BE NEEDED
NeType union_type_nonempty([+NeType] ts)
{
  nu_ts = union([nu_types(t) : t <- ts]);
  return if size(nu_ts) == 1 then only(nu_ts) else :union_type(nonempty(nu_ts));

  [+NeType] nu_types(NeType type):
    union_type(ts?)  = nonempty(union([nu_types(t) : t <- ts])),
    _                = [type];
}

Type union_type([Type] ts)
{
  nu_ts = union([nu_types(t) : t <- ts; t != empty_type]);
  return if   nu_ts == []       then empty_type
         elif size(nu_ts) == 1  then only(nu_ts)
                                else :union_type(nu_ts);

  [+NeType] nu_types(NeType type):
    union_type(ts?)  = nonempty(union([nu_types(t) : t <- ts])),
    _                = [type];
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ClsType cls_type(Type+ its, Type ot) = cls_type(in_types: its, out_type: ot);

FnType fn_type(AnyType* ps, Type rt) = fn_type(ps, [:], rt);
FnType fn_type(AnyType* ps, [NamedArg -> AnyType] nps, Type rt) = fn_type(params: ps, named_args: nps, ret_type: rt);

BuiltInType builtin_type(Type+ pts, Type rt) = builtin_type(param_types: pts, ret_type: rt);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

TagPtrn ptrn_symbol                             = :ptrn_symbol;
Pattern ptrn_integer                            = :ptrn_integer(:integer);
<ptrn_float> ptrn_float                         = :ptrn_float;

Pattern ptrn_empty_seq                          = :ptrn_empty_seq;
Pattern ptrn_ne_seq                             = :ptrn_ne_seq;

Pattern ptrn_empty_set                          = :ptrn_empty_set;
Pattern ptrn_ne_set                             = :ptrn_ne_set;
Pattern ptrn_empty_bin_rel                      = :ptrn_empty_bin_rel;
Pattern ptrn_ne_map                             = :ptrn_ne_map;
Pattern ptrn_ne_bin_rel                         = :ptrn_ne_bin_rel;
Pattern ptrn_empty_tern_rel                     = :ptrn_empty_tern_rel;
Pattern ptrn_ne_tern_rel                        = :ptrn_ne_tern_rel;

Pattern ptrn_seq                                = ptrn_union([ptrn_empty_seq; ptrn_ne_seq]);
Pattern ptrn_set                                = ptrn_union([ptrn_empty_set; ptrn_ne_set]);
Pattern ptrn_map                                = ptrn_union([ptrn_empty_bin_rel; ptrn_ne_map]);
Pattern ptrn_bin_rel                            = ptrn_union([ptrn_empty_bin_rel; ptrn_ne_bin_rel]);
Pattern ptrn_tern_rel                           = ptrn_union([ptrn_empty_tern_rel; ptrn_ne_tern_rel]);

<ptrn_any> ptrn_any                             = :ptrn_any;
TagPtrn ptrn_symbol(Atom a)                     = :ptrn_symbol(:object(a));
TagPtrn ptrn_symbol(SymbObj s)                  = :ptrn_symbol(s);
Pattern ptrn_integer(Int n)                     = ptrn_integer(int_range(n, n));
Pattern ptrn_integer(IntObj n)                  = ptrn_integer(_obj_(n));
Pattern ptrn_integer(IntType type)              = :ptrn_integer(type);
Pattern ptrn_tuple(Pattern+ ps)                 = :ptrn_tuple(ps);
Pattern ptrn_tag_obj(TagPtrn tag, Pattern obj)  = ptrn_tag_obj(tag: tag, obj: obj);
Pattern ptrn_var(StdVar v, Pattern p)           = ptrn_var(var: v, ptrn: p);

Pattern ptrn_union([+Pattern] ps)
{
  return only(ps) if size(ps) == 1;
  return ptrn_any if in(ptrn_any, ps);
  norm_ps = union([patterns(p) : p <- ps]);
  //## HERE I SHOULD LOOK OUT FOR THE CASE WHEN THE SET OF PATTERNS COLLECTIVELY FORM A PATTERN "ANY"
  //## I COULD ALSO ELIMINATE PATTERNS THAT ARE SUBSETS OF OTHER PATTERNS IN THE SET
  return :ptrn_union(ps);

  [Pattern] patterns(Pattern ptrn):
    ptrn_union(ps?)   = union([patterns(p) : p <- ps]),
    _                 = [ptrn];
}

////////////////////////////////////////////////////////////////////////////////

Pattern ptrn_tag_objs   = ptrn_tag_obj(ptrn_symbol, ptrn_any);

////////////////////////////////////////////////////////////////////////////////

StdFnSymb         fn_symbol(Atom a)                                 = :fn_symbol(a);
OpSymb            op_symbol(Operator op)                            = :op_symbol(op);
UniqueFnSymb      unique_fn_symbol(AtomicFnSymb s, Nat id)          = unique_fn_symbol(symbol: s, id: id);
NestedFnSymb      nested_fn_symbol(BasicFnSymb o, UniqueFnSymb i)   = nested_fn_symbol(outer: o, inner: i);
NestedFnFamilyId  nested_fn_symbol(BasicFnSymb o, AtomicFnSymb i)   = nested_fn_symbol(outer: o, inner: i);

FnClassId fn_class_id(FnFamilyId n, Nat a)  = fn_class_id(name: n, arity: a);

MethodSymbol  method_symbol(Atom n) = :method_symbol(n);
UpdateSymbol  update_symbol(Atom n) = :update_symbol(n);
<msg_handler> msg_handler           = :msg_handler;

AutoSymbol auto_symbol(Atom a)  = :auto_symbol(a);
DBSymbol   db_symbol(Atom a)    = :db_symbol(a);

StdVar          var(Atom a)                 = :var(a);
FnPar           fn_par(Nat n)               = :fn_par(n);
NamedArg        named_arg(Atom a)           = :named_arg(a);
CaptVar         cls_ext_par(Nat n)          = :cls_ext_par(n);
MembVar         memb_var(Atom a)            = :memb_var(a);
MembCopyVar     memb_copy_var(Atom a)       = :memb_copy_var(a);
PendingStateVar pending_state_var(Atom a)   = :pending_state_var(a);

QualDBMembVar   qual_db_memb_var(AnyDBVar dbv, MembVar mv)    = qual_db_memb_var(db_var: dbv, memb_var: mv);
QualAutoMembVar qual_auto_memb_var(AnyAutoVar av, MembVar mv) = qual_auto_memb_var(auto_var: av, memb_var: mv);

LocAutoVar  loc_auto_var(Atom a)  = :loc_auto_var(a);
MembAutoVar memb_auto_var(Atom a) = :memb_auto_var(a);

LocDBVar    loc_db_var(Atom a)  = :loc_db_var(a);
MembDBVar   memb_db_var(Atom a) = :memb_db_var(a);

NestedDBVar nested_db_var(AnyDBVar ov, MembDBVar iv) = nested_db_var(outer: ov, inner: iv);

RelVar rel_var(Atom a)  = :rel_var(a);

QualRelVar qual_rel_var(AnyDBVar dbv, RelVar rv) = qual_rel_var(db_var: dbv, rel_var: rv);

ClsVar cls_var(<Atom, Nat> a)     = :cls_var(a);

FloatLit float_lit(Int m, Int e)  = float_lit(mantissa: m, dec_exp: e);

Expr seq_expr(SubExpr* es)          = :seq_expr(es);
Expr seq_tail_expr(Expr s, Expr+ t) = seq_tail_expr(seq: s, tail: t);

Expr tuple_expr(Expr+ es) = :tuple_expr(es);

Expr set_expr([SubExpr] ses) = :set_expr(ses);

Expr map_expr([(key: Expr, value: Expr, cond: Expr?)] es) = :map_expr(es);

BinRelExpr  bin_rel_expr([(args: (Expr, Expr), cond: Expr?)] es)        = :bin_rel_expr(es);
TernRelExpr tern_rel_expr([(args: (Expr, Expr, Expr), cond: Expr?)] es) = :tern_rel_expr(es);

Expr tag_obj_expr(Expr t, Expr o)   = tag_obj_expr(tag: t, obj: o);

FnCallExpr fn_call(FnFamilyId n, AnyExpr* as) = fn_call(n, as, [:]);
FnCallExpr fn_call(FnFamilyId n, AnyExpr* as, [NamedArg -> AnyExpr] nas) = fn_call(name: n, args: as, named_args: nas);

Expr builtin_call(BuiltIn n, Expr+ as) = builtin_call(name: n, args: as);
Expr cls_call(<ClsVar, NamedArg> n, Expr+ as) = cls_call(name: n, args: as);

UnaryPseudoCall unary_pseudo_call(Expr c, Expr v) = unary_pseudo_call(target: c, arg: v);

RelMembTest rel_memb_test(Expr r, Maybe[Expr]+ as) = rel_memb_test(rel: r, args: as);

RelVarMembTest relvar_memb_test(AnyRelVar v, Maybe[Expr]+ as) = relvar_memb_test(rel_var: v, args: as);

RelVarLookup relvar_lookup(AnyRelVar v, Expr+ as, Nat i) = relvar_lookup(rel_var: v, set_args: as, unknown_arg_idx: i);

Expr singl_only_elem(Expr s)              = singl_only_elem(set: s);

Expr and_expr(Expr l, Expr r) = and_expr(left: l, right: r);
Expr or_expr(Expr l, Expr r) = or_expr(left: l, right: r);
Expr not_expr(Expr e) = :not_expr(e);

Expr and_expr(Expr+ es)
{
  expr = last(es);
  for i = 1..length(es):
    expr = and_expr(rev_at(es, i), expr);
  ;
  return expr;
}

Expr or_expr(Expr+ es)
{
  expr = last(es);
  for i = 1..length(es):
    expr = or_expr(rev_at(es, i), expr);
  ;
  return expr;
}

Expr eq(Expr l, Expr r) = eq(left: l, right: r);

Expr accessor(Expr e, SymbObj f) = accessor(expr: e, field: f);
Expr accessor_test(Expr e, SymbObj f) = accessor_test(expr: e, field: f);

OutputIsDefExpr output_is_def(LocAutoVar v, Atom o)  = output_is_def(var: v, output: o);

AutoMethodCall auto_method_call(AnyAutoVar v, MethodSymbol m, Expr* as)  = auto_method_call(var: v, name: m, args: as);
AutoMethodCall auto_method_call(MethodSymbol m, Expr* as)                = auto_method_call(name: m, args: as);

DBMethodCall db_method_call(AnyDBVar v, MethodSymbol m, Expr* as)  = db_method_call(var: v, name: m, args: as);
DBMethodCall db_method_call(MethodSymbol m, Expr* as)              = db_method_call(name: m, args: as);

Expr cast_expr(Expr, <empty_type>)  = {fail;}; //## TRY TO REMOVE...
Expr membership(Expr, <empty_type>) = {fail;}; //## TRY TO REMOVE...

Expr cast_expr(Expr e, NeType t) = cast_expr(expr: e, type: t);
Expr membership(Expr obj, NeType type) = membership(obj: obj, type: type);

Expr if_expr(Expr cond, Expr true_expr, Expr false_expr) = if_expr(cond: cond, then: true_expr, else: false_expr);

Expr match_expr(Expr+ es, (ptrns: Pattern+, expr: Expr)+ cs) = match_expr(exprs: es, cases: cs);

Expr do_expr(Statement+ ss) = :do_expr(ss);

ExQualExpr  ex_qual(Clause s, Expr c)                           = ex_qual(source: s, cond: c);
SetCompExpr set_comp(Expr e, Clause c)                          = set_comp(expr: e, source: c);
MapCompExpr map_comp(Expr ke, Expr ve, Clause c)                = map_comp(key_expr: ke, value_expr: ve, source: c);
BinRelCompExpr bin_rel_comp((Expr, Expr) es, Clause c)          = bin_rel_comp(exprs: es, source: c);
TernRelCompExpr tern_rel_comp((Expr, Expr, Expr) es, Clause c)  = tern_rel_comp(exprs: es, source: c);

IsSetExpr is_set(<MembVar, QualAutoMembVar> v)  = :is_set(v);

////////////////////////////////////////////////////////////////////////////////

CondExpr cond_expr(Expr e, Expr c) = cond_expr(expr: e, cond: c);

////////////////////////////////////////////////////////////////////////////////

ClsExpr fn_ptr(FnFamilyId s, NzNat a)           = fn_ptr(name: s, arity: a);
ClsExpr cls_expr(Maybe[StdVar]+ as, Expr e)     = cls_expr(args: as, expr: e);
ClsExpr no_args_cls_expr(NzNat a, Expr e)       = cls_expr((nil : unused_var < a), e);
ClsExpr named_args_cls_expr(StdVar+ as, Expr e) = cls_expr(args: (just(a) : a <- as), expr: e);

////////////////////////////////////////////////////////////////////////////////

Clause set_clause(StdVar v, Expr e)         = set_clause(var: v, src: e);
Clause seq_clause(StdVar v, Expr e)         = seq_clause(var: v, src: e);
Clause and_clause(Clause l, Clause r)       = and_clause(left: l, right: r);
Clause or_clause(Clause l, Clause r)        = or_clause(left: l, right: r);
Clause match_clause(Pattern p, Expr e)      = match_clause(ptrn: p, expr: e);
Clause asgnm_clause(StdVar v, Expr e)       = asgnm_clause(var: v, expr: e);
Clause filter_clause(Expr e)                = :filter_clause(e);

Clause rel_clause(StdVar+ vs, Expr e, Maybe[Expr]+ as)
{
  assert length(vs) == count(as, $ == nil) and (length(as) == 2 or length(as) == 3);
  return rel_clause(vars: vs, src: e, args: as);
}

Clause relvar_clause(StdVar+ vs, AnyRelVar rv, Maybe[Expr]+ as)
{
  assert length(vs) == count(as, $ == nil) and length(as) >= 1 and length(as) <= 3;
  return relvar_clause(vars: vs, rel_var: rv, args: as);
}

////////////////////////////////////////////////////////////////////////////////

AtomicFnStmt assignment_stmt(StdVar+ vs, Expr v)        = assignment_stmt(vars: vs, value: v);
AtomicFnStmt return_stmt(Expr e)                        = :return_stmt(e);
AtomicFnStmt print_stmt(Expr e)                         = :print_stmt(e);
AtomicFnStmt imp_update_stmt(StdVar o, Expr i, Expr v)  = imp_update_stmt(obj: o, idx: i, value: v);
AtomicFnStmt assert_stmt(Expr c, [<StdVar, NamedArg>] vs, String f, NzNat l, Maybe[String] t) = assert_stmt(cond: c, env: vs, file: f, line: l, text: t);
<break_stmt> break_stmt                                 = :break_stmt;
<fail_stmt>  fail_stmt                                  = :fail_stmt;

AtomicUpdateStmt send_msg_stmt(MembDBVar v, Expr m)           = send_msg_stmt(target: v, msg: m);
AtomicUpdateStmt try_update_stmt(UpdateSymbol n, Expr* as)    = try_update_stmt(name: n, args: as);
AtomicUpdateStmt set_memb_var_stmt(PendingStateVar v, Expr e) = set_memb_var_stmt(var: v, value: e);
AtomicUpdateStmt delete_stmt(RelVar v, Maybe[Expr]+ fs)       = delete_stmt(var: v, fields: fs);
AtomicUpdateStmt insert_stmt(RelVar v, Expr+ fs, Bool f)      = insert_stmt(var: v, fields: fs, force: f);

<return_stmt> return_stmt = :return_stmt;

AutoOrDBCtrlStmt set_input_ctrl_stmt(LocAutoVar v, Atom i, Expr e)        = set_input_ctrl_stmt(var: v, input: i, value: e);
AutoOrDBCtrlStmt clear_input_ctrl_stmt(LocAutoVar v, Atom i)              = clear_input_ctrl_stmt(var: v, input: i);
AutoOrDBCtrlStmt apply_ctrl_stmt(LocAutoVar v)                            = apply_ctrl_stmt(var: v);
AutoOrDBCtrlStmt apply_ctrl_stmt(LocAutoVar v, Expr t)                    = apply_ctrl_stmt(var: v, elapsed_time: t);
AutoOrDBCtrlStmt send_msg_ctrl_stmt(StdVar rv, LocDBVar dbv, Expr m)      = send_msg_ctrl_stmt(res_var: rv, db_var: dbv, msg: m);
AutoOrDBCtrlStmt read_state_ctrl_stmt(StdVar rv, LocDBVar dv)             = read_state_ctrl_stmt(res_var: rv, db_var: dv);
AutoOrDBCtrlStmt restore_state_ctrl_stmt(StdVar rv, LocDBVar dv, Expr e)  = restore_state_ctrl_stmt(res_var: rv, db_var: dv, state: e);

CompositeStmt[T] if_stmt(Expr c, T+ b, T* e)            = if_stmt(cond: c, body: b, else: e);
CompositeStmt[T] loop_stmt(T+ ss)                       = :loop_stmt(ss);
CompositeStmt[T] let_stmt([NamedArg -> Expr] as, T+ b)  = let_stmt(asgnms: as, body: b);

CompositeStmt[T] foreach_stmt(StdVar+ vs, Maybe[StdVar] iv, Expr svs, T+ b) =
  foreach_stmt(vars: vs, idx_var: value(iv) if iv != nil, values: svs, body: b);

CompositeStmt[T] for_stmt(Maybe[StdVar] v, Expr sv, Expr ev, Bool evi, T+ b) =
  for_stmt(var: value(v) if v != nil, start_val: sv, end_val: ev, end_val_incl: evi, body: b);

////////////////////////////////////////////////////////////////////////////////

ProcSymbol proc_symbol(Atom a) = :proc_symbol(a);

////////////////////////////////////////////////////////////////////////////////

FormalObjArg formal_obj_arg(Type t)               = formal_obj_arg(type: t);
FormalObjArg formal_obj_arg(StdVar v, Type t)     = formal_obj_arg(var: v, type: t);
FormalClsArg formal_cls_arg(ClsVar v, ClsType t)  = formal_cls_arg(var: v, type: t);

////////////////////////////////////////////////////////////////////////////////

Function function(FnSymbol n, FormalArg* as, [NamedArg -> AnyType] ias, Type rt, Expr e) =
  function(name: n, args: as, impl_args: ias, res_type: rt, expr: e);

////////////////////////////////////////////////////////////////////////////////

AutoUpdate      state_update(Atom a, Expr e)          = state_update(target: a, value: e);
AutoSetDiscrete discrete_signal_def(Atom a, Expr e)   = discrete_signal_def(target: a, value: e);
AutoMsgSend     msg_send(MembDBVar t, Expr m)         = msg_send(target: t, message: m);

AutoCondAction cond_action(Expr c, [AutoAnyCondAction] b, [AutoAnyCondAction] e)
{
  assert b != [] or e != [];
  return cond_action(cond: c, body: b, else: e);
}

AutoRepAction rep_action(Expr c, [AutoAnyRepAction] b, [AutoAnyRepAction] e)
{
  assert b != [] or e != [];
  return rep_action(cond: c, body: b, else: e);
}

Method method(MethodSymbol n, (NeType, Maybe[StdVar])* as, NeType t, Expr e) = method(name: n, args: as, ret_type: t, expr: e);

Update update(UpdateSymbol n, (NeType, StdVar)* as, Statement* ss)    = update(name: n, args: as, body: ss);

Handler handler(NeType t, Statement* ss)  = handler(type: t, body: ss);

////////////////////////////////////////////////////////////////////////////////

BasicTimeExpr at_least(Nat ns)                                = at_least(nanosecs: ns);
BasicTimeExpr time_neg(BasicTimeExpr te)                      = :time_neg(te);
BasicTimeExpr time_and(BasicTimeExpr te1, BasicTimeExpr te2)  = time_and(left: te1, right: te2);
BasicTimeExpr time_or(BasicTimeExpr te1, BasicTimeExpr te2)   = time_or(left: te1, right: te2);

CyclicTimeExpr every(BasicTimeExpr te, NzNat ns)  = every(expr: te, nanosecs: ns);

TimeVaryingCond time_varying_boolean_cond(Expr c, TimeExpr te) = time_varying_boolean_cond(expr: c, time_expr: te);
TimeVaryingCond time_varying_unchanged_cond(Expr c, TimeExpr te) = time_varying_unchanged_cond(expr: c, time_expr: te);
TimeVaryingCond time_varying_since_cond([+MembVar] ss, TimeExpr te, Bool at0) = time_varying_since_cond(signals: ss, time_expr: te, starts_at_time_0: at0);

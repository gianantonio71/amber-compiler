implicit syn_prg : SynPrg {
  ExprWFError* reactive_auto_wf_errors(SynAutoDef auto_def) {
    errs = if auto_def.res_type? then plain_type_wf_errors(auto_def.res_type) else ();
    let artifact = auto_def:
      errs = errs & join(
        (input_decl_wf_errors(i)     : i <- auto_def.inputs) &
        (output_decl_wf_errors(o)    : o <- auto_def.outputs) &
        (state_var_decl_wf_errors(v) : v <- auto_def.state_vars) &
        (nested_db_decl_wf_errors(a) : a <- auto_def.nested_dbs) &
        (const_decl_wf_errors(c)     : c <- auto_def.consts) &
        (rule_decl_wf_error(r)       : r <- auto_def.rules)
      );
    ;
    return errs;
  }
}


implicit syn_prg : SynPrg, artifact : SynAutoDef {
  ExprWFError* auto_expr_wf_errors(SynExpr expr) = expr_wf_errors(expr, [], impl_args=[], actual_arg_arity=0);

  ExprWFError* input_decl_wf_errors(InputDecl input) = plain_type_wf_errors(input.type);

  ExprWFError* output_decl_wf_errors(OutputDecl output) = plain_type_wf_errors(output.type);

  ExprWFError* state_var_decl_wf_errors(StateVarDecl decl) {
    type_errs = plain_type_wf_errors(decl.type);
    expr_errs = auto_expr_wf_errors(decl.init_value);
    return type_errs & expr_errs;
  }

  ExprWFError* nested_db_decl_wf_errors(NestedDBDecl decl) = (
    unknown_auto(db_symbol(decl.type)) if not db_defs_by_id(db_symbol(decl.type), *)
  );

  ExprWFError* const_decl_wf_errors(ConstDecl decl) {
    type_errs = if decl.type? then plain_type_wf_errors(decl.type) else ();
    expr_errs = auto_expr_wf_errors(decl.value);
    return type_errs & expr_errs;
  }

  ExprWFError* rule_decl_wf_error(PlainRuleDecl decl) =
    if is_disguised_auto(decl, auto_def=artifact)
      then rule_decl_wf_error(rewrite_disguised_auto(decl, auto_def=artifact))
      else auto_expr_wf_errors(decl.expr);

  ExprWFError* rule_decl_wf_error(CondRuleDecl decl) = auto_expr_wf_errors(decl.expr) & auto_expr_wf_errors(decl.cond);

  ExprWFError* rule_decl_wf_error(ForeachRuleDecl decl) {
    value_errs = auto_expr_wf_errors(decl.value);
    cond_errs = if decl.cond? then auto_expr_wf_errors(decl.cond) else ();
    let impl_args = [], actual_arg_arity = 0:
      signal_errs = (not_a_signal(s) : s, unused_var <- decl.signals, not resolve_symbol(s, [])(auto_memb_var(s))); ## BIT UGLY...
    ;
    return value_errs & cond_errs & signal_errs;
  }

  ExprWFError* rule_decl_wf_error(TimeRuleDecl decl) =
    true_for_rule_decl()      |
    unchanged_for_rule_decl() = auto_expr_wf_errors(decl.cond),
    inactive_for_rule_decl()  = ();

  ExprWFError* rule_decl_wf_error(NestedAutoDecl decl) = join((auto_expr_wf_errors(e) : unused_var, e <- decl.args));

  ExprWFError* rule_decl_wf_error(MsgSendDecl decl) {
    msg_errs = auto_expr_wf_errors(decl.message);
    cond_errs = if decl.cond != nothing then auto_expr_wf_errors(value(decl.cond)) else ();
    return msg_errs & cond_errs;
  }
}

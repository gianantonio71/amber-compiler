
type UserErr      = dup_tdef(BasicTypeSymbol),
                    dup_par_tdef(name: BasicTypeSymbol, arity: NzNat),
                    incomp_fndefs(name: FnSymbol, arity: Nat, params: [PseudoType]+),
                    tdef_err(type: SynTypeSymbol, errs: TDefUserErr*),
                    fndef_err(name: FnSymbol, params: [<SynType, nil>], errs: SynObjErr*),
                    ublock_err(errs: UBlockErr*);

type TDefUserErr  = undef_type_name(BasicTypeSymbol),
                    undef_par_type_name(name: BasicTypeSymbol, arity: NzNat),
                    undef_type_var(TypeVar),
                    //incompatible_types_in_set_type(SynType++),
                    incompatible_types_in_union_type(SynType++),
                    invalid_type_for_tag(SynType),
                    rep_labels_in_map(SymbObj*),
                    single_element_tuple_type;

type UBlockErr    = TDefUserErr,
                    dupl_type_pars(Var+);

type SynObjErr    = TDefUserErr,
                    undef_var(Var),
                    undef_var_or_const(Atom),
                    almost_def_const(Atom),
                    undef_fn(name: FnSymbol, arity: NzNat),
                    almost_def_fn(name: FnSymbol, arity: NzNat),
                    no_ret_stmt,
                    no_way_out_loop,
                    break_outside_loop,
                    var_redef(Var),
                    asgnm_readonly_var(Var),
                    
                    dup_closure_def(BasicUntypedSgn),

                    free_var_in_try_expr(Var), //## THIS COULD BE MORE LIKE A WARNING...
                    
                    undef_bound_ptrn_var(Var),
                    already_def_ptrn_var(Var),
                    loc_bound_var_with_ptrn(Var),
                    //incomp_ptrn_branches(SynPtrnBranch+),
                    mult_vars_in_mult_ptrn_branch,
                    nested_mult_ptrn_branch,
                    vars_repeated_in_diff_branches(Var*),
                    
                    unreachable_code,
                    
                    diff_vars_in_or_clause(Var+),  //## IS THIS STILL USED?
                    invalid_pos_for_cls_par,
                    
                    //## NOT CHECKED YET
                    nested_local_fn(outer_fn: BasicUntypedSgn, inner_fn: BasicUntypedSgn),
                    rep_asgn_var(Var);


//## NOT SURE IF IT IS CHECKED OR NOT:
//##   FUNCTION AND CLOSURE PARAMETERS MUSTN'T BE DUPLICATED

//## ERRORS LEFT TO CHECK:
//##   FUNCTIONS WITH INCOMPATIBLE SIGNATURES
//##   NO RECURSION FOR FUNCTIONS WITH NO RETURN TYPE (IS THIS THE RIGHT PLACE TO CHECK?)
//##   NO ASSIGNMENT TO FOR LOOP VARIABLES
//##   IN FUNCTIONS INSIDE USING BLOCKS THE IMPLICIT PARAMETER CHECKING IS BROKEN.
//##     SEE CHECKS FOR THE CORE REPRESENTATION
//##   SEE THE FUNCTION THAT CHECKS SYN_CASES

//## IN A MATCH EXPRESSION, THE NUMBER OF PATTERNS IN ANY OF THE CASES
//## MUST BE THE SAME AS THE NUMBER OF EXPRESSIONS

//## CAN A CLOSURE REFER TO ITSELF? THERE'S THE RISK THAT IT MIGHT INTENDED TO REFER
//## TO THE CLOSURE WITH THE SAME NAME/ARITY PREVIOSLY IN SCOPE...

//## BUG IN well-formedness checking: it doesn't check that two functions
//## with the same name/arity have the same "hidden" parameters

//## NOT SURE IF THEY ARE CHECKED OR NOT:
//##   THE ONLY PLACE WHERE A TYPE IN A FUNCTION CAN CONTAIN A TYPE VAR IS IN ITS SIGNATURE, NOT THE BODY


//## BUG BUG BUG: IF A TYPE REFERENCE IS "DANGLING", THE PROGRAM CRASHES

UserErr* wf_errors(SynPrg prg)
{
  decls       = set(_obj_(prg));
  
  tdefs         = {d : typedef()       d <- decls};
  par_tdefs     = {d : par_typedef()   d <- decls};
  fndefs        = {d : syn_fn_def()    d <- decls};
  ublocks       = {d : using_block()   d <- decls};
  proc_defs     = {d : syn_proc_def()  d <- decls};
  subtype_decls = {d : subtype_decl()  d <- decls};

  assert tdefs & par_tdefs & fndefs & ublocks & proc_defs & subtype_decls == decls;
  
  all_def_fns = {untyped_sgn(fd) : fd <- fndefs} &
                 for (ub <- ublocks, fd <- set(ub.fn_defs)) {
                   untyped_sgn(fd, set(ub.signatures))
                 };

  inst_tdefs  = create_syn_type_map(prg);
  
  dup_tdef_errs = for (td1 <- tdefs, td2 <- tdefs)
                     if (td1 /= td2 and td1.name == td2.name)
                       {:dupl_tdef(td1.name)};

  dup_par_tdef_errs = for (td1 <- tdefs, td2 <- tdefs)
                         if (td1 /= td2 and td1.name == td2.name and length(td1.params) == length(td2.params)) {
                           dupl_par_tdef(name: td1.name, arity: length(td1.params))
                         };

  all_fndefs  = fndefs & union({set(ub.fn_defs) : ub <- ublocks});
  
  //## BAD BAD BAD THIS IS VERY INEFFICIENT...
  fn_groups   = for (n <- {untyped_sgn(fd) : fd <- all_fndefs})
                  (n => {fd : fd <- all_fndefs, untyped_sgn(fd) == n});

  //## BAD BAD BAD, INEFFICIENT
  //## BUG THIS STATEMENT WILL FAIL IF A FUNCTION SIGNATURE USES A TYPE THAT IS NOT DEFINED
  incomp_fn_sgns = for (s => fns <- fn_groups, fd1 <- fns, fd2 <- fns)
                      if (fd1 /= fd2, not syn_fns_are_compatible(fd1, fd2, typedefs = inst_tdefs)) {
                        incomp_fndefs(
                          name:   s.name,
                          arity:  s.arity,
                          params: {par_parts(fd, typedefs = inst_tdefs) : fd <- {fd1, fd2}}
                        )
                      }
                    ;

  //## DOES THIS HAVE TO BE DONE BEFORE CREATING THE TYPE MAP, THAT IS, CAN
  //## THE CREATION OF THE TYPE MAP FAIL IN THE PRESENCE OF ONE OF THESE ERRORS?
  undef_type_symb_errs = undef_type_symbol_errs(fndefs, ublocks, typedefs = inst_tdefs);

  //## ALSO CHECK FOR TOP-LEVEL CYCLES IN THE OBJECT GRAPH

  errs_so_far = dup_tdef_errs & dup_par_tdef_errs & incomp_fn_sgns & undef_type_symb_errs;
  return errs_so_far if errs_so_far /= {};

  proc_to_arity = (p.name => arity(p) : p <- proc_defs) & builtin_proc_arities;

  fn_param_arities = get_fn_param_arities(fndefs, ublocks);

  let (fns_in_scope         = all_def_fns,
       typedefs             = inst_tdefs,
       proc_to_arity        = proc_to_arity,
       all_par_type_symbols = {(symbol: p.name, arity: length(p.params)) : p <- par_tdefs})

    decl_errs = tdef_errs(tdefs)                                          &
                par_tdef_errs(par_tdefs)                                  &
                inst_tdef_errs(inst_tdefs)                                &
                fn_def_errs(fndefs, all_def_fns, fn_param_arities, {})    &
                proc_def_errors(proc_defs, all_def_fns, fn_param_arities) &
                ublock_errors(ublocks, all_def_fns, fn_param_arities);
  ;

  return decl_errs;
}


(ProcSymbol => Nat) builtin_proc_arities = (
  proc_symbol(:file_read)     => 1,
  proc_symbol(:file_write)    => 3,
  proc_symbol(:print)         => 1,
  proc_symbol(:get_char)      => 0
);


using (SynTypeSymbol => SynType) typedefs
{
  //## THIS IS ALL WRONG. IT SHOULD BE DONE BEFORE CREATING THE TYPE MAP
  UserErr* undef_type_symbol_errs(SynFnDef* fndefs, SynUsingBlock* ublocks)
  {
    used_type_symbs = all_type_symbols([fndefs, ublocks, values(typedefs)]);
    def_type_symbs  = keys(typedefs);
    
    missing_type_symbs = used_type_symbs - def_type_symbs;

    //## USING THE WRONG ERROR TYPE HERE.
    //## TO FIX THIS PROBLEM I SHOULD DO THE ERROR CHECKING SOMEWHERE ELSE
    return {tdef_err(type: ts, errs: {make_err_obj(ts)}) : ts <- missing_type_symbs};
    
    TDefUserErr make_err_obj(SynTypeSymbol ts):
      type_symbol()     = :undef_type_name(ts),
      par_type_symbol() = undef_par_type_name(name: ts.symbol, arity: length(ts.params));
    
    SynTypeSymbol* all_type_symbols(Any obj)
    {
      type_symbs = select(obj, $ :: SynTypeSymbol);
      loop
        new_type_symbs = union({all_type_symbols(ts.params) : par_type_symbol() ts <- type_symbs});
        new_type_symbs = new_type_symbs - type_symbs;
        return type_symbs if new_type_symbs == {};
        type_symbs = type_symbs & new_type_symbs;
      ;
    }
  }

  Bool syn_fns_are_compatible(SynFnDef fd1, SynFnDef fd2)
  {
    assert fd1.name == fd2.name;
    assert arity(fd1) == arity(fd2);
    
    for (p1 @ i : fd1.params)
      p2 = fd2.params[i];
      return true if p1.type? and p2.type? and are_part_compatible(p1.type, p2.type);
    ;
    
    return false;

    // Types are supposed to have already passed the "no direct ref cycles" test
    //## IMPLEMENT THE ABOVE TEST

    Bool are_part_compatible(SynType t1, SynType t2) = are_disjoint(syn_pseudotype(t1), syn_pseudotype(t2));

    //Bool are_part_compatible(SynType t1, SynType t2):
      //IntType,  IntType   = separated(t1, t2),
      //_,        _         = are_disjoint(syn_pseudotype(t1), syn_pseudotype(t2));
  }

  [PseudoType] par_parts(SynFnDef fd) = [if p.type? then syn_pseudotype(p.type) else :all_objs : p <- fd.params];
}


using
{
  (SynTypeSymbol => SynType)                typedefs,
  (symbol: BasicTypeSymbol, arity: NzNat)*  all_par_type_symbols,
  (ProcSymbol* => Nat)                      proc_to_arity;


  UserErr* tdef_errs(SynTypedef* tdefs) =
    for (td <- tdefs, es = type_wf_errors(td.type, type_vars_in_scope = {}))
      if (es /= {}) {
        tdef_err(
          type: td.name,
          errs: es
        )
      };

  //## NOT SURE THIS IS THE RIGHT WAY TO CHECK FOR UNDEFINED TYPE VARIABLES
  UserErr* par_tdef_errs(SynParTypedef* par_tdefs) =
    for (td <- par_tdefs, es = type_wf_errors(td.type, type_vars_in_scope = set(td.params)))
      if (es /= {}) {
        tdef_err(
          type: td.name,
          errs: es
        )
      };

  UserErr* inst_tdef_errs((SynTypeSymbol => SynType) inst_tdefs) =
    for (s => t <- inst_tdefs, es = type_wf_errors(t, type_vars_in_scope = select(s, $ :: TypeVar)))
      if (es /= {}) {
        tdef_err(
          type: s,
          errs: es
        )
      };

  UserErr* fn_def_errs(SynFnDef* fndefs, UntypedSgn* global_fns, ((FnSymbol, Nat) => [Nat]) fn_param_arities, BasicUntypedSgn* impl_pars) =
    for (fd <- fndefs, es = fndef_wf_errors(fd, global_fns, fn_param_arities, impl_pars))
      if (es /= {}) {
        fndef_err(
          name: fd.name,
          params:  [if p.type? then p.type else :nil : p <- fd.params],
          errs:    es
        )
      };

    UserErr* proc_def_errors(SynProcDef* proc_defs, UntypedSgn* global_fns, ((FnSymbol, Nat) => [Nat]) fn_param_arities) =
    for (pd <- proc_defs, es = proc_def_wf_errors(pd, global_fns, fn_param_arities))
      if (es /= {}) {
        proc_def_err(name: pd.name, errs: es)
      };

  UserErr* ublock_errors(SynUsingBlock* ublocks, UntypedSgn* global_fns, ((FnSymbol, Nat) => [Nat]) fn_param_arities) =
    union({block_wf_errors(b, global_fns, fn_param_arities) : b <- ublocks});

  UserErr* block_wf_errors(SynUsingBlock ublock, UntypedSgn* global_fns, ((FnSymbol, Nat) => [Nat]) fn_param_arities)
  {
    //## UGLY UGLY
    block_errs = seq_union([sgn_wf_errors(s) : s <- ublock.signatures]);
    err        = if block_errs == {} then {} else {ublock_err(errs: block_errs)};
    req_fns    = {untyped_sgn(s) : s <- set(ublock.signatures)};
    all_fns    = merge_and_override(global_fns, {untyped_sgn(s) : s <- set(ublock.signatures)});
    new_fpas   = (({assert s.name :: NamedPar; return fn_symbol(_obj_(s.name));}, arity) => arity * [0] : s <- set(ublock.signatures), arity = length(s.params));
    all_fpas   = update(fn_param_arities, new_fpas);
    return err & fn_def_errs(set(ublock.fn_defs), all_fns, all_fpas, req_fns);
  }

  TDefUserErr* sgn_wf_errors(SynSgn sgn)
  {
    type_vars = select(sgn, $ :: TypeVar); //## BAD BAD BAD THIS IS ALL WRONG.
    in_errs   = seq_union([type_wf_errors(t, type_vars_in_scope = type_vars) : t <- sgn.params]);
    out_errs  = type_wf_errors(sgn.res_type, type_vars_in_scope = type_vars);
    return in_errs & out_errs;
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

type BasicUntypedSgn  = untyped_sgn(name: FnSymbol, arity: Nat);

type UntypedSgn       = untyped_sgn(
                          name:         FnSymbol,
                          arity:        Nat,
                          named_params: BasicUntypedSgn+?
                        );

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

BasicUntypedSgn untyped_sgn(FnSymbol n, Nat a) = untyped_sgn(name: n, arity: a);

BasicUntypedSgn untyped_sgn(NamedPar var, Type type)    = untyped_sgn(name: :fn_symbol(_obj_(var)), arity: 0);
BasicUntypedSgn untyped_sgn(NamedPar var, ClsType type) = untyped_sgn(name: :fn_symbol(_obj_(var)), arity: length(type.in_types));

BasicUntypedSgn untyped_sgn(ClsVar var, SynClsType type) = untyped_sgn(name: :fn_symbol(_obj_(var)), arity: length(type.in_types));

UntypedSgn untyped_sgn(FnDef fd) =
  untyped_sgn(
    name:         fd.name,
    arity:        arity(fd),
    named_params: untyped_sgns(fd.named_params) if fd.named_params /= ()
  );

UntypedSgn untyped_sgn(NamedPar np, [<var(Atom)>] vs) = untyped_sgn(name: fn_symbol(_obj_(np)), arity: length(vs));


BasicUntypedSgn untyped_sgn(Var v, Expr e)    = untyped_sgn(name: :fn_symbol(_obj_(v)), arity: 0);
BasicUntypedSgn untyped_sgn(Var v, ClsExpr e) = untyped_sgn(name: :fn_symbol(_obj_(v)), arity: length(e.params));

BasicUntypedSgn* untyped_sgns((NamedPar => <AnyType, AnyExpr>) nps) = {untyped_sgn(v, type_or_expr) : v => type_or_expr <- nps};

////////////////////////////////////////////////////////////////////////////////

BasicUntypedSgn untyped_sgn(SynFnDef fd) = untyped_sgn(fd.name, arity(fd));

BasicUntypedSgn untyped_sgn(SynSgn s) = untyped_sgn(fn_symbol(_obj_(s.name)), arity(s));

UntypedSgn untyped_sgn(SynFnDef fd, SynSgn+ named_params) =
  untyped_sgn(
    name:         fd.name,
    arity:        arity(fd),
    named_params: {untyped_sgn(p) : p <- named_params} 
  );

Nat arity(SynSgn s) = length(s.params);

UntypedSgn* merge_and_override(UntypedSgn* low_priority_sgns, UntypedSgn* high_priority_sgns)
{
  sgns = {s : s <- low_priority_sgns, not (? os <- high_priority_sgns : s.name == os.name, s.arity == os.arity)};
  return sgns & high_priority_sgns;
}


Bool is_def(FnSymbol name, Nat arity, UntypedSgn* env, BasicUntypedSgn* actual_named_params)
{
  return (? sgn <- env : could_match(name, arity, sgn, actual_named_params));
  
  Bool could_match(FnSymbol name, Nat arity, UntypedSgn sgn, BasicUntypedSgn* actual_named_params)
  {
    return false if sgn.name /= name or sgn.arity /= arity;
    //## IGNORING THE DIFFERENCE BETWEEN SCALARS AND CLOSURES FOR POSITIONAL PARAMETERS
    //## NOT SURE ABOUT NAMED PARAMETERS, I SEEM TO REMEMBERS THE ORIGINAL VERSION OF THIS FUNCTION (THE ONE THAT GOT DELETED) WAS DIFFERENT
    formal_named_params = if sgn.named_params? then sgn.named_params else {};
    return subset(formal_named_params, actual_named_params);
  }
}

//## FIND BETTER NAME
Bool is_almost_def(FnSymbol name, Nat arity, UntypedSgn* env) = (? s <- env : s.name == name, s.arity == arity);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// PseudoType syn_pseudotype(SynType type, (TypeName => AType) typedefs) = pseudotype(syn_type_to_type(type), typedefs);
// PseudoType syn_pseudotype(SynType type, (TypeName => AType) typedefs) = pseudotype(Type(type), typedefs);

//## BAD: THIS SHOULD BE IMPLEMENTED AS SHOWN ABOVE. IT IS STILL IN USE ONLY BECAUSE ALL THE LEVEL 1 ERROR
//## CHECKING CODE HAS TO BE REWRITTEN FROM SCRATCH AND IT DOESN'T MAKE ANY SENSE TO CHANGE IT NOW
using (SynTypeSymbol => SynType) typedefs
{
  PseudoType syn_pseudotype(SynType type):
    LeafType                = pseudotype(type, ()),
    syn_int_range()         = pseudotype_integers,
    //## BUG BUG BUG ASSUMING THERE ARE NO DIRECT CYCLES IN TYPEDEFS
    //## BUG BUG BUG ALSO ASSUMING NO TYPE REFERENCE IS "DANGLING"
    type_ref(ts?)           = syn_pseudotype(typedefs[ts]),
    TypeVar                 = pseudotype_any,
    ne_set_type()           = pseudotype_ne_seqs,
    ne_seq_type()           = pseudotype_ne_sets,
    ne_map_type()           = pseudotype_ne_maps,
    record_type()           = pseudotype_maps, //## THIS IS WRONG BUT WHO CARES...
    tuple_type()            = pseudotype_ne_seqs,
    union_type(ts?)         = pseudotype_union({syn_pseudotype(t) : t <- set(ts)}),
    tag_obj_type()          = match (type.tag_type)
                                symb_type(object(a?)) = pseudotype_tag_obj(a),
                                atom_type             = pseudotype_tag_objs;
                              ;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//## DOES IT MAKE SENSE TO MAKE INSTANTIATIONS CONTAINING TYPE VARIABLES?
//## ARE THEY REALLY NEEDEED? AND WOULD IT BE ANY USEFUL TO CREATE THE
//## SAME INSTANTIATIONS BUT WITH THE TYPE VARIABLES REPLACED BY ANY?

(SynTypeSymbol => SynType) create_syn_type_map(SynPrg prg)
{
  tdef_map     = (td.name => td.type : typedef() td <- set(_obj_(prg)));
  par_tdef_map = inst_req_par_types(prg);
  
  return tdef_map & par_tdef_map;
}


(SynParTypeSymbol => SynType) inst_req_par_types(SynPrg prg)
{
  decls     = set(_obj_(prg));
  par_tdefs = {d : par_typedef() d <- decls};

  symbs_to_inst     = get_type_symbols_to_instantiate(decls) & {par_type_symbol(ptd.name, ptd.params) : ptd <- par_tdefs};
  inst_symbs_so_far = {};
  inst_par_tdefs    = ();

  while (symbs_to_inst /= {})
  
    new_insts = (s => inst_par_type(s, par_tdefs) : s <- symbs_to_inst);
    
    inst_symbs_so_far = inst_symbs_so_far & symbs_to_inst;
    inst_par_tdefs    = inst_par_tdefs & new_insts;
    
    symbs_to_inst     = get_type_symbols_to_instantiate({t : s => t <- new_insts}) - inst_symbs_so_far;
  ;

  return inst_par_tdefs;
}


SynParTypeSymbol* get_type_symbols_to_instantiate(Any obj)
{
  src        = obj;
  type_symbs = {};

  loop
    new_type_symbs = select(obj, $ :: SynParTypeSymbol) - type_symbs;
    fail if not new_type_symbs :: SynParTypeSymbol*; //## BAD: THIS IS HERE ONLY TO SHUT UP THE TYPE CHECKER
    return type_symbs if new_type_symbs == {};
    type_symbs = type_symbs & new_type_symbs;
    src = {ts.params : ts <- new_type_symbs};
  ;
} 


SynType inst_par_type(SynParTypeSymbol symb, SynParTypedef* par_tdefs)
{
  arity = length(symb.params);
  //## BUG BUG: CAN THIS POSSIBLY FAIL?
  par_tdef = only_element({d : d <- par_tdefs, d.name == symb.symbol, length(d.params) == arity});
  res = replace(par_tdef.type, $ :: TypeVar, symb.params[index_first($, par_tdef.params)]);
  fail if not res :: SynType; //## BAD: THIS IS HERE ONLY TO SHUT UP THE TYPE CHECKER
  return res;
}

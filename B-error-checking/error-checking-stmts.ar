using
{
  (BasicTypeSymbol => Nat+)                           type_arity_map,
  (NamedPar => Nat)                                   curr_function_named_params,
  (FnSymbol => (Nat => ([Nat], (NamedPar => Nat)+)))  global_functions,
  (FnSymbol => (Nat => [Nat]))                        local_functions,
  (FnSymbol => NzNat)                                 closures,
  (ProcSymbol => (Nat, Bool))                         procedures,
  (AutoVar => AutoSymbol)                             auto_vars,
  (AutoSymbol => SynAutoDef)                          automata,
  Nat                                                 actual_param_arity;


  [ExprWFError] root_stmt_block_wf_errors([SynStmt^] stmts, Var* ext_vars, Bool has_ret_val, Bool allow_proc_calls)
  {
    let (allow_proc_calls=allow_proc_calls, has_return_value=has_ret_val, is_inside_loop=false)
      errs = stmts_wf_errors(stmts, ext_vars, {});
    ;
    return if errs != [] then errs else [missing_ret_stmt(stmts) if has_ret_val and not never_falls_through(stmts)];
  }
}


using
{
  (BasicTypeSymbol => Nat+)                           type_arity_map,
  (NamedPar => Nat)                                   curr_function_named_params,
  (FnSymbol => (Nat => ([Nat], (NamedPar => Nat)+)))  global_functions,
  (FnSymbol => (Nat => [Nat]))                        local_functions,
  (FnSymbol => NzNat)                                 closures,
  (ProcSymbol => (Nat, Bool))                         procedures,
  (AutoVar => AutoSymbol)                             auto_vars,
  (AutoSymbol => SynAutoDef)                          automata,
  Nat                                                 actual_param_arity,

  Bool                                                allow_proc_calls,
  Bool                                                has_return_value,
  Bool                                                is_inside_loop;


  [ExprWFError] stmts_wf_errors([SynStmt^] stmts, Var* ro_vars, StdVar* rw_vars)
  {
    curr_rw_vars = rw_vars;
    for (s : stmts)
      errs = stmt_wf_errors(s, ro_vars, curr_rw_vars);
      return errs if errs != [];
      new_vars = syn_new_vars(s);
      fail if not new_vars :: StdVar*; //## BAD BAD BAD: FIX THIS
      curr_rw_vars = curr_rw_vars & new_vars;
    ;
    return [];
  }


  [ExprWFError] stmt_wf_errors(SynStmt stmt, Var* ro_vars, StdVar* rw_vars)
  {
    errs = stmt_interesting_wf_errors(stmt, ro_vars, rw_vars);
    return if errs != [] then errs else stmt_standard_wf_errors(stmt, ro_vars, rw_vars);
  }


  [ExprWFError] stmt_standard_wf_errors(SynStmt stmt, Var* ro_vars, StdVar* rw_vars)
  {
    all_vars = ro_vars & rw_vars;
    return match (stmt)
      assignment_stmt()         = expr_wf_errors(stmt.value, all_vars),
      return_stmt(e?)           = expr_wf_errors(e, all_vars),
      if_stmt()                 = if_stmt_wf_errors(stmt, ro_vars, rw_vars, all_vars),
      loop_stmt()               = expr_wf_errors(stmt.cond, ro_vars & rw_vars) &
                                  stmts_wf_errors(stmt.body, ro_vars, rw_vars, is_inside_loop=true),
      inf_loop_stmt(ss?)        = stmts_wf_errors(ss, ro_vars, rw_vars, is_inside_loop=true),
      for_stmt()                = for_stmt_wf_errors(stmt, ro_vars, rw_vars, all_vars),
      let_stmt()                = let_stmt_standard_wf_error(stmt, ro_vars, rw_vars, all_vars),
      break_stmt                = [],
      fail_stmt                 = [],
      assert_stmt(e?)           = expr_wf_errors(e, all_vars),
      print_stmt(e?)            = expr_wf_errors(e, all_vars),
      imp_update_stmt()         = expr_wf_errors(stmt.idx, all_vars) & expr_wf_errors(stmt.value, all_vars),
      return_stmt               = [],
      proc_call()               = join([expr_wf_errors(e, all_vars) : e <- stmt.params]),
      auto_input_update_stmt()  = join([expr_wf_errors(a.value, all_vars) : a <- stmt.inputs]),
      fn_def_stmt()             = {fail;};


    [ExprWFError] if_stmt_wf_errors(SynIfStmt stmt, Var* ro_vars, StdVar* rw_vars, Var* all_vars)
    {
      branches_errs = join([expr_wf_errors(b.cond, all_vars) & stmts_wf_errors(b.body, ro_vars, rw_vars) : b <- stmt.branches]);
      else_body = stmt.else;
      else_errs = if else_body != [] then stmts_wf_errors(else_body, ro_vars, rw_vars) else [];
      return branches_errs & else_errs;
    }


    [ExprWFError] for_stmt_wf_errors(SynForStmt stmt, Var* ro_vars, StdVar* rw_vars, Var* all_vars)
    {
      iter_errs = [];
      new_vars = {};
      for (it : stmt.loops)
        iter_errs = iter_errs & iter_wf_errors(it, new_vars & all_vars);
        new_vars = new_vars & syn_new_vars(it);
      ;
      assert disjoint(new_vars, all_vars);
      body_errs = stmts_wf_errors(stmt.body, ro_vars & new_vars, rw_vars - new_vars, is_inside_loop=true);
      return iter_errs & body_errs;
    }


    [ExprWFError] iter_wf_errors(SynIter iter, Var* vars):
      seq_iter()    = expr_wf_errors(iter.values, vars),
      range_iter()  = expr_wf_errors(iter.start_val, vars) & expr_wf_errors(iter.end_val, vars);


    [ExprWFError] let_stmt_standard_wf_error(SynLetStmt stmt, Var* ro_vars, StdVar* rw_vars, Var* all_vars)
    {
      exprs_errs = join([expr_wf_errors(right(a), all_vars) : a <- stmt.asgnms]);
      new_vars = set([left(a) : a <- stmt.asgnms]);
      // No need to remove the new variables from the set of read-write ones,
      // as they are all (kind of) read-only named parameters
      body_errs = stmts_wf_errors(stmt.body, ro_vars & new_vars, rw_vars, closures=remove_keys(closures, new_vars));
      return exprs_errs & body_errs;
    }
  }

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

  [ExprWFError] stmt_interesting_wf_errors(SynStmt stmt, Var* ro_vars, StdVar* rw_vars):
    assignment_stmt()         = asgn_stmt_interesting_wf_errors(stmt, ro_vars, rw_vars),
    return_stmt()             = ret_stmt_interesting_wf_errors(stmt, true),
    for_stmt()                = for_stmt_interesting_wf_errors(stmt, ro_vars, rw_vars),
    let_stmt()                = [],
    imp_update_stmt()         = imp_update_stmt_interesting_wf_errors(stmt, ro_vars, rw_vars),
    proc_call()               = proc_call_stmt_interesting_wf_errors(stmt, ro_vars, rw_vars),
    return_stmt               = ret_stmt_interesting_wf_errors(stmt, false),
    break_stmt                = [break_outside_loop(stmt) if not is_inside_loop],
    auto_input_update_stmt()  = auto_input_update_stmt_interesting_wf_errors(stmt.var, stmt.inputs, ro_vars, rw_vars),
    fn_def_stmt()             = {fail;},
    assert_stmt(e?)           = [],
    print_stmt(e?)            = [],
    fail_stmt                 = [],
    if_stmt()                 = [],
    loop_stmt()               = [],
    inf_loop_stmt(ss?)        = [];


  [ExprWFError] asgn_stmt_interesting_wf_errors(SynAsgnStmt stmt, Var* ro_vars, StdVar* rw_vars)
  {
    bad_vars = already_def_vars(set(stmt.vars), ro_vars);
    dupl_vars = dupl_elems(stmt.vars);
    return [ro_vars_asgnm(stmt, bad_vars) if bad_vars != {}] & [dupl_var_mult_asgnm(v) : v <- rand_sort(dupl_vars)];
  }


  [ExprWFError] ret_stmt_interesting_wf_errors(<SynReturnStmt, return_stmt> stmt, Bool has_value) =
    [wrong_return(stmt) if has_value != has_return_value];


  [ExprWFError] for_stmt_interesting_wf_errors(SynForStmt stmt, Var* ro_vars, StdVar* rw_vars)
  {
    errs = [];
    new_vars = {};
    for (it : stmt.loops)
      dupl_vars = match (it)
        seq_iter()    = dupl_elems(it.vars & [it.idx_var if it.idx_var?]),
        range_iter()  = {};
      errs = errs & [dupl_var_mult_asgnm(v) : v <- rand_sort(dupl_vars)];
      it_vars = syn_new_vars(it);
      bad_vars = already_def_vars(it_vars, union({ro_vars, rw_vars, new_vars}));
      errs = [errs | vars_redef(stmt, bad_vars)] if bad_vars != {};
      new_vars = new_vars & it_vars;
    ;
    return errs;
  }


  [ExprWFError] imp_update_stmt_interesting_wf_errors(SynImpUpdateStmt stmt, Var* ro_vars, StdVar* rw_vars)
  {
    var = stmt.obj;
    // The variable whose content is update must already exist.
    // Does it have to be a read/write one, or can it be a read-only one too?
    // It has to be a standard variable, so no searching through named parameters
    var_errs = [undef_update_var(stmt, var) if not in(var, ro_vars) and not in(var, rw_vars)];
    return var_errs;
  }


  [ExprWFError] proc_call_stmt_interesting_wf_errors(SynProcCallStmt stmt, Var* ro_vars, StdVar* rw_vars)
  {
    return [proc_call_not_allowed(stmt)] if not allow_proc_calls;
    var_errs = [ro_vars_asgnm(stmt, {stmt.res_var}) if stmt.res_var? and already_def(stmt.res_var, ro_vars)];
    if (has_key(procedures, stmt.proc_name))
      arity, has_ret_val = procedures[stmt.proc_name];
      proc_errs = [
        wrong_proc_arity(stmt, arity) if length(stmt.params) != arity,
        uncaught_ret_val(stmt)        if has_ret_val and not stmt.res_var?,
        proc_has_no_ret_val(stmt)     if not has_ret_val and stmt.res_var?
      ];
    else
      proc_errs = [undef_proc(stmt)];
    ;
    return var_errs & proc_errs;
  }


  [ExprWFError] auto_input_update_stmt_interesting_wf_errors(AutoVar var, [(input: Atom, value: SynExpr)] input_asgnms, Var* ro_vars, StdVar* rw_vars)
  {
    return [auto_var_not_defined(var, already_def(name(var), ro_vars & rw_vars))] if not has_key(auto_vars, var);
    auto_def = automata[auto_vars[var]];
    inputs = inputs(auto_def);
    return [unknown_input(a.input, auto_def) : a <- input_asgnms, not has_key(inputs, a.input)];
  }
}

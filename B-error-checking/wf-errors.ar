type WFError            = dupl_typedef((SynAnyTypedef, SynAnyTypedef)),
                          typedef_errors(typedef: SynAnyTypedef, errors: TypeWFError+),
                          dupl_using_block_param((SynSgn, SynSgn)),
                          signature_errors(sgn: SynSgn, errors: TypeWFError+),
                          incomp_pos_args(fndefs: (SynFnDef, SynFnDef), arg_indexes: Nat+),
                          overlapping_pos_args_types((SynFnDef, SynFnDef)),
                          fndef_errors(fndef: SynFnDef, errors: FnDefWFError+),
                          proc_def_errors(proc_def: SynProcDef, errors: ProcDefWFError+),
                          same_name_proc_defs(SynProcDef+);

type TypeWFError        = invalid_int_range(<syn_int_range(min: Int, max: Int)>),
                          undef_type_var(TypeVar),
                          invalid_tag_type(SynType),
                          undef_type(BasicTypeSymbol),
                          undef_type_arity(type_symb: BasicTypeSymbol, arity: Nat, actual_arities: [+Nat]),
                          dupl_record_field((SynRecordField, SynRecordField)),
                          type_var_in_union(TypeVar),
                          type_vars_not_allowed(type: SynType, vars: [+TypeVar]);

type ExprSpecWFError    = already_def_var(Var),
                          undef_var_or_const(Atom),
                          wrong_builtin_arity(name: BuiltIn, args: SynExpr+),
                          invalid_named_arg(NamedArg),
                          missing_named_arg(NamedArg),
                          invalid_named_arg_arity(arg: NamedArg, exp_arity: Nat, actual_arity: Nat),
                          undef_impl_cls_arg(ClsPar),
                          dupl_named_args(expr: SynFnCall, bad_args: [+NamedArg]),
                          wrong_fn_arity(expr: SynFnCall, actual_arities: [+Nat]),
                          calling_unknown_function(SynFnCall),
                          wrong_cls_arg_arity(expr: ConstOrVar, exp_arity: NzNat, arities: [+Nat]),
                          wrong_cls_call_arity(expr: SynFnCall, exp_arity: Nat),
                          named_args_not_allowed(expr: SynFnCall),
                          not_a_scalar_var(name: Atom),
                          dupl_var_mult_asgnm(StdVar),
                          diff_var_sets_in_ptrn_union(SynPtrn+),

                          ro_vars_asgnm(stmt: <SynAsgnStmt, SynProcCallStmt>, vars: [+Var]),
                          wrong_return(<SynReturnStmt, return_stmt>),
                          vars_redef(stmt: SynForStmt, vars: [+Var]),
                          undef_update_var(stmt: SynImpUpdateStmt, var: StdVar),
                          wrong_proc_arity(stmt: SynProcCallStmt, exp_arity: Nat),
                          uncaught_ret_val(SynProcCallStmt),
                          proc_has_no_ret_val(SynProcCallStmt),
                          undef_proc(SynProcCallStmt),
                          proc_call_not_allowed(SynProcCallStmt),
                          break_outside_loop(SynBreakStmt),
                          missing_ret_stmt(SynStmt+),

                          auto_var_not_defined(var: AnyAutoVar, is_other_var_type: Bool),
                          unknown_input(name: Atom, automaton: SynAutoDef),

                          annotated_syn_expr_error(error: ExprWFError, expr: SynExpr);

type GenDefSpecWFError  = dupl_par_names(dupl_pos_pars: [Atom], dupl_named_args: [Atom]);

type FnDefSpecWFError   = invalid_cls_type_vars(par_idx: Nat, var_name: Atom, type_vars: [+TypeVar]),
                          invalid_res_type_vars(type_vars: [+TypeVar]),
                          nested_functions_errors(WFError+);

type ProcDefSpecWFError = builtin_proc_redef, wrong_main_proc_arity;

type ExprWFError        = TypeWFError, ExprSpecWFError;
type FnDefWFError       = ExprWFError, GenDefSpecWFError, FnDefSpecWFError;
type ProcDefWFError     = ExprWFError, GenDefSpecWFError, ProcDefSpecWFError;

////////////////////////////////////////////////////////////////////////////////

WFError dupl_typedef(SynAnyTypedef td1, SynAnyTypedef td2)        = :dupl_typedef((td1, td2));
WFError typedef_errors(SynAnyTypedef td, TypeWFError+ errs)     = typedef_errors(typedef: td, errors: errs);
WFError dupl_using_block_param(SynSgn s1, SynSgn s2)              = :dupl_using_block_param((s1, s2));
WFError signature_errors(SynSgn s, TypeWFError+ es)             = signature_errors(sgn: s, errors: es);
WFError incomp_pos_args(SynFnDef fd1, SynFnDef fd2, Nat+ is)    = incomp_pos_args(fndefs: (fd1, fd2), arg_indexes: is);
WFError overlapping_pos_args_types(SynFnDef fd1, SynFnDef fd2)    = :overlapping_pos_args_types((fd1, fd2));
WFError fndef_errors(SynFnDef fd, FnDefWFError+ errs)           = fndef_errors(fndef: fd, errors: errs);
WFError proc_def_errors(SynProcDef pd, ProcDefWFError+ es)      = proc_def_errors(proc_def: pd, errors: es);
WFError same_name_proc_defs(SynProcDef+ pds)                    = :same_name_proc_defs(pds);

////////////////////////////////////////////////////////////////////////////////

TypeWFError invalid_int_range(<syn_int_range(min: Int, max: Int)> t)  = :invalid_int_range(t);
TypeWFError undef_type_var(TypeVar v)                                 = :undef_type_var(v);
TypeWFError invalid_tag_type(SynType t)                               = :invalid_tag_type(t);
TypeWFError undef_type(BasicTypeSymbol ts)                            = :undef_type(ts);
TypeWFError undef_type_arity(BasicTypeSymbol ts, Nat a, [+Nat] as)      = undef_type_arity(type_symb: ts, arity: a, actual_arities: as);
TypeWFError dupl_record_field(SynRecordField f1, SynRecordField f2)   = :dupl_record_field((f1, f2));
TypeWFError type_var_in_union(TypeVar v)                              = :type_var_in_union(v);
TypeWFError type_vars_not_allowed(SynType t, [+TypeVar] vs)             = type_vars_not_allowed(type: t, vars: vs);

////////////////////////////////////////////////////////////////////////////////

GenDefSpecWFError dupl_par_names([Atom] pps, [Atom] nps) = dupl_par_names(dupl_pos_pars: pps, dupl_named_args: nps);

////////////////////////////////////////////////////////////////////////////////

FnDefSpecWFError invalid_cls_type_vars(Nat i, Atom n, [+TypeVar] vs)  = invalid_cls_type_vars(par_idx: i, var_name: n, type_vars: vs);
FnDefSpecWFError invalid_res_type_vars([+TypeVar] vs)                 = invalid_res_type_vars(type_vars: vs);
FnDefSpecWFError nested_functions_errors(WFError+ es)             = :nested_functions_errors(es);

////////////////////////////////////////////////////////////////////////////////

ProcDefSpecWFError builtin_proc_redef                   = :builtin_proc_redef;
ProcDefSpecWFError wrong_main_proc_arity                = :wrong_main_proc_arity;

////////////////////////////////////////////////////////////////////////////////

ExprSpecWFError already_def_var(Var v)                                  = :already_def_var(v);
ExprSpecWFError undef_var_or_const(Atom v)                              = :undef_var_or_const(v);
ExprSpecWFError wrong_builtin_arity(BuiltIn b, SynExpr+ ps)             = wrong_builtin_arity(name: b, args: ps);
ExprSpecWFError invalid_named_arg(NamedArg p)                           = :invalid_named_arg(p);
ExprSpecWFError missing_named_arg(NamedArg p)                           = :missing_named_arg(p);
ExprSpecWFError invalid_named_arg_arity(NamedArg p, Nat ea, Nat aa)     = invalid_named_arg_arity(arg: p, exp_arity: ea, actual_arity: aa);
ExprSpecWFError undef_impl_cls_arg(ClsPar p)                            = :undef_impl_cls_arg(p);
ExprSpecWFError dupl_named_args(SynFnCall c, [+NamedArg] ps)            = dupl_named_args(expr: c, bad_args: ps);
ExprSpecWFError wrong_fn_arity(SynFnCall c, [+Nat] as)                  = wrong_fn_arity(expr: c, actual_arities: as);
ExprSpecWFError calling_unknown_function(SynFnCall c)                   = :calling_unknown_function(c);
ExprSpecWFError wrong_cls_arg_arity(ConstOrVar e, NzNat ea, [+Nat] as)  = wrong_cls_arg_arity(expr: e, exp_arity: ea, arities: as);
ExprSpecWFError wrong_cls_call_arity(SynFnCall c, Nat ea)               = wrong_cls_call_arity(expr: c, exp_arity: ea);
ExprSpecWFError named_args_not_allowed(SynFnCall c)                     = named_args_not_allowed(expr: c);
ExprSpecWFError not_a_scalar_var(Atom a)                                = not_a_scalar_var(name: a);
ExprSpecWFError dupl_var_mult_asgnm(StdVar v)                           = :dupl_var_mult_asgnm(v);
ExprSpecWFError diff_var_sets_in_ptrn_union(SynPtrn+ ps)                = :diff_var_sets_in_ptrn_union(ps);

ExprSpecWFError ro_vars_asgnm(<SynAsgnStmt, SynProcCallStmt> s, [+Var] vs)  = ro_vars_asgnm(stmt: s, vars: vs);
ExprSpecWFError wrong_return(<SynReturnStmt, return_stmt> s)                = :wrong_return(s);
ExprSpecWFError vars_redef(SynForStmt s, [+Var] vs)                         = vars_redef(stmt: s, vars: vs);
ExprSpecWFError undef_update_var(SynImpUpdateStmt s, StdVar v)              = undef_update_var(stmt: s, var: v);
ExprSpecWFError wrong_proc_arity(SynProcCallStmt s, Nat a)                  = wrong_proc_arity(stmt: s, exp_arity: a);
ExprSpecWFError uncaught_ret_val(SynProcCallStmt s)                         = :uncaught_ret_val(s);
ExprSpecWFError proc_has_no_ret_val(SynProcCallStmt s)                      = :proc_has_no_ret_val(s);
ExprSpecWFError undef_proc(SynProcCallStmt s)                               = :undef_proc(s);
ExprSpecWFError proc_call_not_allowed(SynProcCallStmt s)                    = :proc_call_not_allowed(s);
ExprSpecWFError break_outside_loop(SynBreakStmt s)                          = :break_outside_loop(s);
ExprSpecWFError missing_ret_stmt(SynStmt+ ss)                               = :missing_ret_stmt(ss);

ExprSpecWFError auto_var_not_defined(AnyAutoVar v, Bool b)  = auto_var_not_defined(var: v, is_other_var_type: b);
ExprSpecWFError unknown_input(Atom n, SynAutoDef a)         = unknown_input(name: n, automaton: a);

ExprSpecWFError annotated_syn_expr_error(ExprWFError er, SynExpr en)  = annotated_syn_expr_error(error: er, expr: en);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Any anchor_obj(TypeWFError err)     = nil;


Any anchor_obj(ExprSpecWFError err):
  already_def_var(v?)               = v,
  undef_var_or_const(a?)            = nil,
  wrong_builtin_arity()             = nil,
  invalid_named_arg()               = nil,
  missing_named_arg()               = nil,
  invalid_named_arg_arity()         = nil,
  undef_impl_cls_arg(p?)            = nil,
  dupl_named_args()                 = err.expr,
  wrong_fn_arity()                  = err.expr,
  calling_unknown_function(c?)      = c,
  wrong_cls_arg_arity()             = err.expr,
  wrong_cls_call_arity()            = err.expr,
  named_args_not_allowed()          = err.expr,
  not_a_scalar_var()                = nil,
  dupl_var_mult_asgnm()             = nil,
  diff_var_sets_in_ptrn_union(ps?)  = head(ps),

  ro_vars_asgnm()                   = err.stmt,
  wrong_return(s?)                  = s,
  vars_redef()                      = err.stmt,
  undef_update_var()                = err.stmt,
  wrong_proc_arity()                = err.stmt,
  uncaught_ret_val(s?)              = s,
  proc_has_no_ret_val(s?)           = s,
  undef_proc(s?)                    = s,
  proc_call_not_allowed()           = {fail;},
  break_outside_loop(s?)            = s,
  missing_ret_stmt(ss?)             = head(ss),

  auto_var_not_defined()            = nil,
  unknown_input()                   = nil,

  annotated_syn_expr_error()        = err.expr;

////////////////////////////////////////////////////////////////////////////////

ExprWFError attach_anchor_obj_if_needed(ExprWFError error, SynExpr anchor_obj)
{
  obj = anchor_obj(error);
  att = _fetch_(obj);
  return error if att != [];
  new_att = _fetch_(anchor_obj);
  return error if new_att == [];
  return annotated_syn_expr_error(error, anchor_obj);
}

////////////////////////////////////////////////////////////////////////////////

(String, NzNat, NzNat) source_code_location(<PrgDecl, SynSgn> decl_or_sgn)
{
  data = _fetch_(decl_or_sgn);
  print data if not data :: [(String, NzNat, NzNat)] or size(data) != 1;
  return ("Unknown source file", 1, 1) if data == [];
  fail if not data :: [+(String, NzNat, NzNat)];
  return only_element(data);
}


String source_code_loc_str(<PrgDecl, SynSgn> decl_or_sgn)
{
  fn, sl, el = source_code_location(decl_or_sgn);
  return "file " & fn & " line" & if sl == el then " " & printed(sl) else "s " & printed(sl) & "-" & printed(el);
}


String source_code_loc_str(SynSgn sgn1, SynSgn sgn2)
{
  fn1, sl1, el1 = source_code_location(sgn1);
  fn2, sl2, el2 = source_code_location(sgn2);
  ls1_str = if sl1 == el1 then printed(sl1) else printed(sl1) & "-" & printed(el1);
  ls2_str = if sl2 == el2 then printed(sl2) else printed(sl2) & "-" & printed(el2);
  return "file " & fn1 & " lines " & ls1_str & " and " & ls2_str;
}

////////////////////////////////////////////////////////////////////////////////

String user_name(SynTypedef td)     = user_repr(td.name);
String user_name(SynParTypedef td)  = user_repr(td.name) & "/" & printed(length(td.params));
String user_name(SynSgn s)          = match (s.name) named_arg(n?) = _str_(n);
String user_name(SynFnDef fd)       = user_repr(fd.name) & "/" & printed(arity(fd));
String user_name(SynProcDef pd)     = match (pd.name) proc_symbol(n?) = capitalize(_str_(n), false);


String user_repr(ClsPar):
  cls_par(n?) = string((ascii_dollar, nat(ascii_lower_a + n)));

String user_repr(ConstOrVar):
  const_or_var(a?)  = _str_(a);


String plural(Any+ objs)  = if length(objs) > 1 then "s" else "";
String plural([+Any] objs)    = if size(objs)   > 1 then "s" else "";

////////////////////////////////////////////////////////////////////////////////

String* create_error_msg(WFError err):
  dupl_typedef(tds?)                  = create_dupl_typedef_error_msg(left(tds), right(tds)),
  typedef_errors()                    = create_typedef_error_msg(err.typedef, err.errors),
  dupl_using_block_param(ss?)         = create_dupl_using_block_param_err_msg(left(ss), right(ss)),
  signature_errors()                  = create_signature_errors_err_msg(err.sgn, err.errors),
  incomp_pos_args()                   = create_incomp_pos_pars_err_msg(left(err.fndefs), right(err.fndefs), err.arg_indexes),
  overlapping_pos_args_types(fds?)    = create_overlapping_pos_pars_types_err_msg(left(fds), right(fds)),
  fndef_errors()                      = create_fndef_errs_msg(err.fndef, err.errors),
  proc_def_errors()                   = create_proc_def_errs_msg(err.proc_def, err.errors),
  same_name_proc_defs(pds?)           = create_same_name_proc_defs_err_msg(pds);


String* create_dupl_typedef_error_msg(SynAnyTypedef td1, SynAnyTypedef td2) = (
    "Duplicated type definition: " & user_name(td1),
    "    " & source_code_loc_str(td1),
    "    " & source_code_loc_str(td2)
  );


String* create_typedef_error_msg(SynAnyTypedef tdef, TypeWFError+ errs) =
  ("Type definition errors: " & user_name(tdef), source_code_loc_str(tdef)) &
  ("    " & l : l <- join((create_error_msg(e) : e <- errs)));


String* create_dupl_using_block_param_err_msg(SynSgn sgn1, SynSgn sgn2) =
  ("Duplicate using block parameter: " & user_name(sgn1), source_code_loc_str(sgn1, sgn2));


String* create_signature_errors_err_msg(SynSgn sgn, TypeWFError+ errs) =
  (join((create_error_msg(e) : e <- errs)) | "    " & source_code_loc_str(sgn));


String* create_incomp_pos_pars_err_msg(SynFnDef fd1, SynFnDef fd2, Nat+ par_idxs) = (
    "Incompatible argument types in polymorphic function: " & user_name(fd1) & ", arguments: " & append((printed(i) : i <- par_idxs)),
    "    " & source_code_loc_str(fd1),
    "    " & source_code_loc_str(fd2)
  );


String* create_overlapping_pos_pars_types_err_msg(SynFnDef fd1, SynFnDef fd2) = (
    "Overlapping argument types in polymorphic functions: " & user_name(fd1),
    "    " & source_code_loc_str(fd1),
    "    " & source_code_loc_str(fd2)
  );


String* create_fndef_errs_msg(SynFnDef fndef, FnDefWFError+ errs) =
  ("Error" & plural(errs) & " in function definition: " & user_name(fndef), source_code_loc_str(fndef)) &
  ("    " & l : l <- join((create_error_msg(e) : e <- errs)));


String* create_proc_def_errs_msg(SynProcDef proc_def, ProcDefWFError+ errs) =
  ("Error" & plural(errs) & " in procedure definition: " & user_name(proc_def), source_code_loc_str(proc_def)) &
  ("    " & l : l <- join((create_error_msg(e) : e <- errs)));


String* create_same_name_proc_defs_err_msg(SynProcDef+ proc_defs) =
  ("Multiple definitions of the same procedure: " & user_name(head(proc_defs))) &
  ("    " & source_code_loc_str(pd) : pd <- proc_defs);

////////////////////////////////////////////////////////////////////////////////

String* create_error_msg(ExprWFError err)
{
  msg = basic_err_msg(err);
  loc = source_code_location(err);
  if loc != nil:
    start_line = left(left(value(loc)));
    msg = (l & " (line " & printed(start_line) & ")" : l <- msg);
  ;
  return msg;
}


String* basic_err_msg(TypeWFError err):
  invalid_int_range(r?)     = ("Invalid integer range: [" & printed(r.min) & ".." & printed(r.max) & "]"),
  undef_type_var(v?)        = ("Undefined type variable: " & user_repr(v)),
  invalid_tag_type(t?)      = ("Invalid tag type"),
  undef_type(ts?)           = ("Undefined type: " & user_repr(ts)),
  undef_type_arity()        = { suffix = if size(err.actual_arities) > 1 then "y" else "ies";
                                arity_str = append((printed(a) : a <- rand_sort(err.actual_arities)));
                                type_name = user_repr(err.type_symb);
                                return ("Wrong parametric type arity: " & type_name & ", actual arit" & suffix & ": " & arity_str);
                              },
  dupl_record_field(rs?)    = ("Duplicated record field: " & user_repr(left(rs).label)),
  type_var_in_union(v?)     = ("Type variables not allowed in union types: " & user_repr(v)),
  type_vars_not_allowed()   = ("Type variables not allowed here: " & append((user_repr(v) : v <- rand_sort(err.vars)), ", "));


String* basic_err_msg(ExprSpecWFError err):
  already_def_var(v?)         = ("Variable redefinition: " & user_repr(v)),
  undef_var_or_const(a?)      = ("Undefined variable or constant: " & _str_(a)),
  wrong_builtin_arity()       = ("Wrong builtin function arity: " & user_repr(err.name)),
  invalid_named_arg(p?)       = ("Invalid named argument: " & user_repr(p)),
  missing_named_arg(p?)       = ("Undefined named argument: " & user_repr(p)),
  invalid_named_arg_arity()   = { msg_prefix = "Named argument '" & user_repr(err.arg) & "' ";
                                  if err.exp_arity == 0:
                                    msg_content = "cannot be a closure";
                                  elif err.actual_arity == 0:
                                    msg_content = "must be a closure";
                                  else
                                    msg_content = "has the wrong arity. Expected arity: " & printed(err.exp_arity) &
                                                  ", actual arity: " & printed(err.actual_arity);
                                  ;
                                  return (msg_prefix & msg_content);
                                },
  undef_impl_cls_arg(p?)      = ("Invalid implicit closure argument: " & user_repr(p)),
  dupl_named_args()           = ("Duplicated named parameter" & plural(err.bad_args) & ": " & user_repr(np) : np <- rand_sort(err.bad_args)),
  wrong_fn_arity()            = ("Wrong number of arguments: " & user_repr(err.expr.name) &
                                ", actual arity: " & append((printed(a) : a <- rand_sort(err.actual_arities)), ", ")),
  calling_unknown_function(c?)  = ("Unknown function: " & user_repr(c.name)),
  wrong_cls_arg_arity()       = ("Closure has wrong arity: " & user_repr(err.expr) &
                                ", expected arity: " & printed(err.exp_arity) &
                                ", actual arity: " & append((printed(a) : a <- rand_sort(err.arities)), ", ")),
  wrong_cls_call_arity()      = ("Wrong number of arguments: " & user_repr(err.expr.name) & ", actual arity: " & printed(err.exp_arity)),
  named_args_not_allowed()    = ("Closures cannot have named parameters: " & user_repr(err.expr.name)),
  not_a_scalar_var()          = ("Invalid use of closure variable: " & _str_(err.name)),
  dupl_var_mult_asgnm(v?)     = ("Duplicated variable in multiple assignment: " & user_repr(v)),
  diff_var_sets_in_ptrn_union(ps?)  = ("Individual patterns in a union must define the same set of variables"),

  ro_vars_asgnm()             = ("Invalid assignment to read-only variable: " & user_repr(v) : v <- rand_sort(err.vars)),
  wrong_return(s?)            = (if s == return_stmt then "Return value required" else "Cannot return a value"),
  vars_redef()                = ("Variable is already defined: " & user_repr(v) : v <- rand_sort(err.vars)),
  undef_update_var()          = ("Variable is not defined: " & user_repr(err.var)),
  wrong_proc_arity()          = ("Wrong number of arguments: " & user_repr(err.stmt.proc_name) & ", expected arity: " & printed(err.exp_arity)),
  uncaught_ret_val(p?)        = ("Return value cannot be ignored: " & user_repr(p.proc_name)),
  proc_has_no_ret_val(p?)     = ("Procedure has no return value: " & user_repr(p.proc_name)),
  undef_proc(p?)              = ("Undefined procedure: " & user_repr(p.proc_name)),
  proc_call_not_allowed()     = {fail;},
  break_outside_loop()        = ("Break statement outside a loop"),
  missing_ret_stmt()          = ("Missing return statement"),

  auto_var_not_defined()      = ({if err.is_other_var_type then "Not an automaton" else "Undefined"} & " variable: " & user_repr(err.var)),
  unknown_input()             = ("Automaton " & user_repr(err.automaton.name) & " has no such input: " & _str_(err.name)),

  annotated_syn_expr_error()  = basic_err_msg(err.error);


String* create_error_msg(GenDefSpecWFError err) =
  ("Duplicated parameter name: " & _str_(a) : a <- rand_sort(err.dupl_pos_pars)) &
  ("Implicit and standard arguments cannot have the same name: " & _str_(a) : a <- rand_sort(err.dupl_named_args));


String* create_error_msg(FnDefSpecWFError err):
  invalid_cls_type_vars()       = ("Invalid type variable: " & user_repr(v)  & " in argument type: " & _str_(err.var_name) : v <- rand_sort(err.type_vars)),
  invalid_res_type_vars()       = ("Invalid type variable in function result: " & user_repr(v) : v <- rand_sort(err.type_vars)),
  nested_functions_errors(es?)  = ("Errors in nested functions") & ("    " & l : l <- join((create_error_msg(e) : e <- es)));


String* create_error_msg(ProcDefSpecWFError err):
  builtin_proc_redef     = ("Redefinition of builtin procedure"),
  wrong_main_proc_arity  = ("Main procedure can only have one parameter");

////////////////////////////////////////////////////////////////////////////////

Maybe[((NzNat, NzNat), (NzNat, NzNat))] source_code_location(ExprWFError err)
{
  obj = anchor_obj(err);
  return nil if obj == nil;
  info = _fetch_(obj);
  assert size(info) <= 1;
  return nil if size(info) != 1;
  loc_info = only_element(info);
  return nil if not loc_info :: ((NzNat, NzNat), (NzNat, NzNat));
  return just(loc_info);
}

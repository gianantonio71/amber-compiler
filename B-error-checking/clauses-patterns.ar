implicit syn_prg : SynPrg, syn_artifact : SynArtifact, impl_args : [NamedArg -> Nat], actual_arg_arity : Nat
{
  ExprWFError* clause_wf_errors(SynClause cls, [DefVar] def_vars):
    iter_clause()       = iter_clause_wf_errors(cls.vars, cls.src, def_vars),
    and_clause(cs?)     = and_clause_wf_errors(cs, def_vars),
    or_clause()         = clause_wf_errors(cls.left, def_vars) & clause_wf_errors(cls.right, def_vars),
    match_clause()      = ptrn_wf_errors(cls.ptrn, def_vars) & expr_wf_errors(cls.expr, def_vars),
    asgnm_clause()      = (already_def_var(cls.var) if already_def(cls.var, def_vars)) & expr_wf_errors(cls.expr, def_vars), //## BAD: ALMOST THE SAME AS THE TWO ABOVE
    filter_clause()     = expr_wf_errors(cls.cond, def_vars);


  ExprWFError* iter_clause_wf_errors(StdVar+ vars, SynExpr src_expr, [DefVar] def_vars)
  {
    if src_expr :: <rel_memb_test(target: IdChain, args: Maybe[SynExpr]+)>:
      args = src_expr.args;
      if at_least_one((a == nil | a <- args)):
        target = src_expr.target;
        symbols = destructure_id_chain(target);
        resols = resolve_by_priority_as_rel_var(symbols, def_vars);
        return (ambiguous_expr(target, resols)) if size(resols) > 1;
        if resols == []:
          //## TODO: ADD BETTER MESSAGES HERE
          return (invalid_expr(target));
        ;
        relvar = only(resols);
        relvar_arity = relvar_arity(relvar);
        exp_clause_arity = nz_nat(count(args, $ == nil));
        args_errs = join((expr_wf_errors(value(a), def_vars) | a <- args, a != nil));
        arity_errs = (
          invalid_rel_var_arity(last(symbols), length(args), relvar_arity) if length(args) != relvar_arity,
          iter_clause_wrong_arity(vars, [exp_clause_arity]) if length(vars) != exp_clause_arity
        );
        return args_errs & arity_errs;
      ;

    elif src_expr :: IdChain:
      symbols = destructure_id_chain(src_expr);
      resols = resolve_by_priority_as_rel_var(symbols, def_vars);
      if size(resols) == 1:
        relvar_arity = relvar_arity(only(resols));
        return (iter_clause_wrong_arity(vars, [relvar_arity]) if length(vars) != relvar_arity);
      ;
    ;

    arity = length(vars);
    arity_errs = (iter_clause_wrong_arity(vars, [1, 2]) if arity != 1 and arity != 2);
    var_errs = (already_def_var(v) | v <- vars, already_def(v, def_vars));
    dupl_vars = dupl_elems(vars);
    dupl_vars_errs = (dupl_var_mult_asgnm(v) | v <- rand_sort(dupl_vars));

    return arity_errs & var_errs & dupl_vars_errs & expr_wf_errors(src_expr, def_vars);
  }


  ExprWFError* and_clause_wf_errors(SynClause+ clauses, [DefVar] def_vars)
  {
    errs = ();
    curr_vars = def_vars;
    for c <- clauses:
      errs = errs & clause_wf_errors(c, curr_vars);
      curr_vars = curr_vars & syn_new_vars(c);
    ;
    return errs;
  }


  ExprWFError* ptrn_wf_errors(SynPtrn ptrn, [DefVar] def_vars):
    ptrn_symbol       = (),
    ptrn_float        = (),
    ptrn_seq          = (),
    ptrn_set          = (),
    ptrn_map          = (),
    ptrn_tag_obj      = (),
    ptrn_any          = (),
    ptrn_symbol()     = (),
    ptrn_integer()    = (),
    ptrn_tuple(ps?)   = ptrn_tuple_wf_errors(ps, def_vars),
    ptrn_tag_obj()    = ptrn_wf_errors(ptrn.tag, def_vars) & ptrn_wf_errors(ptrn.obj, def_vars),
    ptrn_var()        = (already_def_var(ptrn.var) if already_def(ptrn.var, def_vars)) & ptrn_wf_errors(ptrn.ptrn, def_vars & [ptrn.var]),
    ptrn_type(t?)     = type_wf_errors(t, type_arity_map, true),
    ptrn_union(ps?)   = ptrn_union_wf_errors(ps, def_vars);


  ExprWFError* ptrn_tuple_wf_errors(SynPtrn+ ptrns, [DefVar] def_vars)
  {
    curr_vars = def_vars;
    for p <- ptrns:
      errs = ptrn_wf_errors(p, curr_vars);
      return errs if errs != ();
      curr_vars = curr_vars & syn_new_vars(p);
    ;
    return ();
  }


  ExprWFError* ptrn_union_wf_errors(SynPtrn+ ptrns, [DefVar] def_vars)
  {
    assert length(ptrns) > 1;
    errs = join((ptrn_wf_errors(p, def_vars) | p <- ptrns));
    return errs if errs != ();
    new_vars = (syn_new_vars(p) | p <- ptrns);
    vs0 = new_vars[0];
    for vs <- new_vars:
      return (diff_var_sets_in_ptrn_union(ptrns)) if vs != vs0;
    ;
    return ();
    //## CHECK THAT THE PATTERNS DO NOT OVERLAP?
  }
}

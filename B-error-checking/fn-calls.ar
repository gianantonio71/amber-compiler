implicit
{
  syn_prg                  : SynPrg,

  type_arity_map           : [BasicTypeSymbol -> [+Nat]],
  curr_function_named_args : [NamedArg -> Nat],
  global_functions         : [FnSymbol -> [Nat -> (Nat*, [+[NamedArg -> Nat]])]],
  local_functions          : [FnSymbol -> [Nat -> Nat*]],
  closures                 : [FnSymbol -> NzNat],
  procedures               : [ProcSymbol -> (Nat, Bool)],
  auto_vars                : [AnyAutoVar -> AutoSymbol],
  db_vars                  : [AnyDBVar -> DBSymbol],
  automata                 : [AutoSymbol -> SynAutoDef],
  actual_arg_arity         : Nat;


  ExprWFError* fn_call_local_wf_errors(SynFnCall expr, [Var] def_vars)
  {
    name = expr.name;
    args = expr.args;
    named_args = expr.named_args;
    actual_arity = length(args);

    dupl_named_args = dupl_elems((pn | pn, unused_var_1, unused_var_2 <- named_args)); //## UGLY UGLY UGLY
    return (duplicate_named_args(expr, dupl_named_args)) if dupl_named_args != [];

    // First we check if function call can actually be a lookup
    // or a membership test that targets a local variable
    if name :: <fn_symbol(Atom)>:
      bare_name = match (name) fn_symbol(n?) = n;
      if named_args == () and (actual_arity == 1 or actual_arity == 2) and already_def(bare_name, def_vars):
        // Since this is not actually a function call, it does not change
        // anything about what implicit closure arguments are accepted.
        // Therefore, the arguments are checked like ordinary expressions
        return join((expr_wf_errors(a, def_vars) | a <- args));
      ;
    ;

    // Closures have priority
    if has_key(closures, name):
      exp_arity = closures[name];
      return (
        wrong_cls_call_arity(expr, exp_arity) if actual_arity != exp_arity,
        named_args_not_allowed(expr)          if named_args != ()
      );
    ;

    if has_key(local_functions, name):
      arity_to_info = local_functions[name];
      return (wrong_fn_arity(expr, nonempty(keys(arity_to_info)))) if not has_key(arity_to_info, actual_arity);
      par_arities = arity_to_info[actual_arity];
      all_exp_named_args = [curr_function_named_args];

    elif has_key(global_functions, name):
      arity_to_info = global_functions[name];
      return (wrong_fn_arity(expr, nonempty(keys(arity_to_info)))) if not has_key(arity_to_info, actual_arity);
      par_arities, all_exp_named_args = arity_to_info[actual_arity];

    else
      return (calling_unknown_function(expr));
    ;

    pos_par_errs = join((actual_arg_wf_errors(p, par_arities[i], def_vars) | p @ i <- args));

    all_named_arg_errs = [named_args_wf_errors(named_args, enps, def_vars) | enps <- all_exp_named_args];
    named_arg_errs = if in((), all_named_arg_errs) then () else join(rand_sort(all_named_arg_errs));

    return pos_par_errs & named_arg_errs;


    ExprWFError* actual_arg_wf_errors(SynExpr actual_arg, Nat exp_arity, [Var] def_vars)
    {
      //## WHICH ONE?
      return expr_wf_errors(actual_arg, def_vars) if exp_arity == 0;
      // return expr_wf_errors(actual_arg, def_vars, actual_arg_arity=0) if exp_arity == 0;
      //## f(xs, g(ys, $a == $b))

      //  Here the function expects a closure. The parameter can be:
      //    1) A normal expression, implicitly defining a constant functions
      //    2) The name of a an existing closure
      //    3) The name of a function
      //    4) A closure expression

      //  Handling cases 1) and 4) above
      par_errs = expr_wf_errors(actual_arg, def_vars, actual_arg_arity=exp_arity);
      if par_errs != () and actual_arg :: ConstOrVar:
        cls_symb = fn_symbol(_obj_(actual_arg));

        if has_key(closures, cls_symb):
          cls_arity = closures[cls_symb];
          return (wrong_cls_arg_arity(actual_arg, exp_arity, [cls_arity]) if exp_arity != cls_arity);
        ;

        if has_key(local_functions, cls_symb):
          fns_info = local_functions[cls_symb];
          //## BUG BUG BUG: I MUST ALSO CHECK THAT IT HAS NO NAMED PARAMETERS
          return (wrong_cls_arg_arity(actual_arg, exp_arity, nonempty(keys(fns_info))) if not has_key(fns_info, exp_arity));
        ;

        if has_key(global_functions, cls_symb):
          fns_info = global_functions[cls_symb];
          //## BUG BUG BUG: I MUST ALSO CHECK THAT IT HAS NO NAMED PARAMETERS
          return (wrong_cls_arg_arity(actual_arg, exp_arity, nonempty(keys(fns_info))) if not has_key(fns_info, exp_arity));
        ;
      ;
      return par_errs;
    }


    ExprWFError* named_args_wf_errors((NamedArg, StdVar*, SynExpr)* redef_named_args, [+[NamedArg -> Nat]] all_exp_named_args, [Var] def_vars)
    {
      errs = [named_args_wf_errors(redef_named_args, enps, def_vars) | enps <- all_exp_named_args];
      return () if in((), errs);
      return an_elem(errs);
    }


    ExprWFError* named_args_wf_errors((NamedArg, StdVar*, SynExpr)* redef_named_args, [NamedArg -> Nat] exp_named_args, [Var] def_vars)
    {
      redef_named_args_arity_map = merge(set(([p -> length(vs)] | p, vs, unused_var <- redef_named_args)));
      errs = ();
      for p, a <- rand_sort_pairs(exp_named_args):
        if has_key(redef_named_args_arity_map, p):
          // Checking arguments explicitly passed arguments first
          actual_arity = redef_named_args_arity_map[p];
          errs = (errs || invalid_named_arg_arity(p, a, actual_arity)) if actual_arity != a;
        else
          errs = errs & exp_named_arg_errors(p, a, def_vars);
        ;
      ;
      for np, vs, e <- redef_named_args:
        errs = (errs || invalid_named_arg(np)) if not has_key(exp_named_args, np);
        errs = errs & expr_wf_errors(e, def_vars & set(vs));
      ;
      return errs;
    }
  }
}
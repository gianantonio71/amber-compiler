//## CHECK THAT TWO LOCAL FUNCTIONS CANNOT HAVE THE SAME NAME, EVEN IF THEY HAVE DIFFERENT ARITIES OR COMPATIBLE SIGNATURES
//## CHECK THAT A POSITIONAL PARAMETER CANNOT HAVE THE SAME NAME AS A NAMED PARAMETER

[WFError] prg_wf_errors(SynPrg prg)
{
  decls = set(_obj_(prg));

  tdefs         = {d : typedef()       d <- decls};
  par_tdefs     = {d : par_typedef()   d <- decls};
  fndefs        = {d : syn_fn_def()    d <- decls};
  proc_defs     = {d : syn_proc_def()  d <- decls};
  ublocks       = {d : using_block()   d <- decls};
  subtype_decls = {d : subtype_decl()  d <- decls};
  automata      = {d : syn_auto_def()  d <- decls};

  assert tdefs & par_tdefs & fndefs & proc_defs & ublocks & subtype_decls & automata == decls;

  type_arity_map = merge_values({(td.name => 0) : td <- tdefs} & {(td.name => arity(td)) : td <- par_tdefs});
  tdef_errs = typedefs_wf_errors(rand_sort(tdefs), rand_sort(par_tdefs), type_arity_map);
  return tdef_errs if tdef_errs != [];

  typedefs = create_type_map(tdefs, par_tdefs);

  params_errs = join([block_params_wf_errors(ub.signatures, type_arity_map) : ub <- rand_sort(ublocks)]);
  return params_errs if params_errs != [];

  full_fndefs = [(fd, []) : fd <- rand_sort(fndefs)] & join([[(fd, ub.signatures) : fd <- ub.fn_defs] : ub <- rand_sort(ublocks)]);

  sgn_errs = function_group_signature_wf_errors(full_fndefs, type_arity_map, typedefs);
  return sgn_errs if sgn_errs != [];

  global_fns_map = create_global_functions_map(full_fndefs);

  proc_sgn_errs = procedures_signature_wf_errors(proc_defs, type_arity_map);

  proc_map = (pd.name => (arity(pd), pd.res_type != nil) : pd <- proc_defs) & builtin_procs_map;
  auto_map = (ad.name => ad : ad <- automata);

  fndef_errs = [];
  for (fd : rand_sort(fndefs))
    errs = fndef_wf_errors(fd, [], type_arity_map, typedefs, global_fns_map, auto_map);
    fndef_errs = [fndef_errs | fndef_errors(fd, errs)] if errs != [];
  ;
  for (ub : rand_sort(ublocks))
    impl_ps = ub.signatures;
    for (fd : ub.fn_defs)
      errs = fndef_wf_errors(fd, impl_ps, type_arity_map, typedefs, global_fns_map, auto_map);
      fndef_errs = [fndef_errs | fndef_errors(fd, errs)] if errs != [];
    ;
  ;

  proc_def_errs = [];
  for (pd : rand_sort(proc_defs))
    errs = proc_def_wf_errors(pd, type_arity_map, typedefs, global_fns_map, proc_map, auto_map);
    proc_def_errs = [proc_def_errs | proc_def_errors(pd, errs)] if errs != [];
  ;

  return fndef_errs & proc_def_errs;
}


[WFError] typedefs_wf_errors([SynTypedef] tdefs, [SynParTypedef] par_tdefs, (BasicTypeSymbol => Nat+) type_arity_map)
{
  errs = [];
  for (td1 @ i1 : tdefs ; td2 : right_subseq(tdefs, i1+1)) //## BIT UGLY
    errs = [errs | dupl_typedef(td1, td2)] if td1.name == td2.name;
  ;
  for (td1 @ i1 : par_tdefs ; td2 : right_subseq(par_tdefs, i1+1)) //## BIT UGLY
    errs = [errs | dupl_typedef(td1, td2)] if td1.name == td2.name and arity(td1) == arity(td2);
  ;

  //## TODO: CHECK FOR CYCLES IN THE SUBSET GRAPH

  for (td : tdefs & par_tdefs)
    maybe_err = typedef_wf_errors(td, type_arity_map);
    errs = [errs | value(maybe_err)] if maybe_err != nil;
  ;
  return errs;
}


[WFError] block_params_wf_errors([SynSgn] signatures, (BasicTypeSymbol => Nat+) type_arity_map)
{
  errs = [];
  for (s1 @ i1 : signatures ; s2 : right_subseq(signatures, i1+1))
    errs = [errs | dupl_using_block_param(s1, s2)] if s1.name == s2.name;
  ;
  for (s : signatures)
    type_errs = join([type_wf_errors(t, type_arity_map, true) : t <- s.params]) & type_wf_errors(s.res_type, type_arity_map, true);
    errs = [errs | signature_errors(s, type_errs)] if type_errs != [];
  ;
  return errs;
}


[WFError] function_group_signature_wf_errors([(SynFnDef, [SynSgn])] full_fndefs, (BasicTypeSymbol => Nat+) type_arity_map, (TypeName => Type) typedefs)
{
  sgn_errs = values([fndef_signature_wf_errors(fd, nps, type_arity_map) : fd, nps <- full_fndefs]);
  return sgn_errs if sgn_errs != [];

  fndefs_by_name_and_arity = merge_values(set([((fd.name, arity(fd)) => (fd, ss)) : fd, ss <- full_fndefs]));
  fndef_incomp_errs = join(rand_sort({polymorphic_functions_errors(nonempty(rand_sort(fds)), typedefs) : fds @ _ <- fndefs_by_name_and_arity}));
  return fndef_incomp_errs;
}


Maybe[WFError] fndef_signature_wf_errors(SynFnDef fndef, [SynSgn] named_pars, (BasicTypeSymbol => Nat+) type_arity_map)
{
  errs = join([type_wf_errors(p.type, type_arity_map) : p <- fndef.params, p.type?]);
  errs = errs & type_wf_errors(fndef.res_type, type_arity_map) if fndef.res_type?;

  pos_args = [p.var_name : p <- fndef.params, p.var_name?];
  named_args = [match (p.name) named_par(n?) = n : p <- named_pars];

  dupl_pos_pars = dupl_elems(pos_args);
  dupl_named_pars = dupl_elems(pos_args & named_args) - dupl_pos_pars;
  errs = [errs | dupl_par_names(dupl_pos_pars, dupl_named_pars)] if dupl_pos_pars != {} or dupl_named_pars != {};

  direct_type_vars = seq_union([syn_type_vars(p.type) : p <- fndef.params, p.type :: SynType]);
  // indirect_type_vars = seq_union([syn_type_vars(p.type.out_type) : p <- fndef.params, p.type :: SynClsType]);

  indirect_type_vars = {};
  for (p @ i : fndef.params)
    if (p :: SynClsFnArg)
      in_type_vars = seq_union([syn_type_vars(t) : t <- p.type.in_types]);
      undef_type_vars = in_type_vars - direct_type_vars;
      errs = [errs | invalid_cls_type_vars(i, p.var_name, undef_type_vars)] if undef_type_vars != {};
      indirect_type_vars = indirect_type_vars & syn_type_vars(p.type.out_type);
    ;
  ;

  res_type_vars = syn_type_vars(fndef.res_type);
  undef_res_type_vars = res_type_vars - (direct_type_vars & indirect_type_vars);
  errs = [errs | invalid_res_type_vars(undef_res_type_vars)] if undef_res_type_vars != {};

  return if errs != [] then just(fndef_errors(fndef, errs)) else nil;
}


[WFError] polymorphic_functions_errors([(SynFnDef, [SynSgn])^] full_fndefs, (TypeName => Type) typedefs)
{
  for (fd1, ss1 @ i1 : full_fndefs ; fd2, ss2 : right_subseq(full_fndefs, i1+1))
    assert fd1.name == fd2.name and arity(fd1) == arity(fd2);
    arity_match = [fn_arg_arity(p1) == fn_arg_arity(p2) : p1, p2 <- zip(fd1.params, fd2.params)];
    if (not all(arity_match))
      return [incomp_pos_params(fd1, fd2, nonempty([i : b @ i <- arity_match, not b]))];
    ;
    // //## BAD BAD BAD. I SHOULD MAKE SURE THAT THE SIGNATURES ARE EQUIVALENT, NOT THAT THEY ARE SYNTACTICALLY THE SAME
    // return [incomp_named_params(fd1, ss1, fd2, ss2)] if set(ss1) != set(ss2);
    args_are_disjoint = [args_are_pseudotype_disjoint(p1, p2, typedefs) : p1, p2 <- zip(fd1.params, fd2.params)];
    return [overlapping_pos_params_types(fd1, fd2)] if not at_least_one(args_are_disjoint);
  ;
  return [];


  Bool args_are_pseudotype_disjoint(SynFnArg arg1, SynFnArg arg2, (TypeName => Type) typedefs)
  {
    return false if not arg1.type? or not arg2.type?;
    type1 = arg1.type;
    type2 = arg2.type;
    return type1 :: SynType and type2 :: SynType and are_disjoint(syn_pseudotype(type1, typedefs), syn_pseudotype(type2, typedefs));
  }

  Nat fn_arg_arity(SynFnArg arg) = if arg.type? then syn_type_arity(arg.type) else 0;
}


[WFError] procedures_signature_wf_errors(SynProcDef* proc_defs, (BasicTypeSymbol => Nat+) type_arity_map)
{
  def_errs = join([proc_signature_wf_errors(pd, type_arity_map) : pd <- rand_sort(proc_defs)]);
  procs_by_name = group_by(proc_defs, $.name);
  global_errs = rand_sort({same_name_proc_defs(rand_sort(pds)) : pds @ _ <- procs_by_name, size(pds) != 1});
  return def_errs & global_errs;
}


[WFError] proc_signature_wf_errors(SynProcDef proc_def, (BasicTypeSymbol => Nat+) type_arity_map)
{
  name = proc_def.name;
  bare_name = match (name) proc_symbol(n?) = n;
  arity = arity(proc_def);
  res_type = proc_def.res_type;

  dup_pars = dupl_elems([match (p.var) var(n?) = n : p <- proc_def.params]);

  errs = [
    builtin_proc_redef            if has_key(builtin_procs_map, name),
    wrong_main_proc_arity         if bare_name == :main and arity(proc_def) != 1,
    dupl_par_names(dup_pars, {})  if dup_pars != {}
  ];

  errs = errs & join([type_wf_errors(p.type, type_arity_map) : p <- proc_def.params]);
  errs = errs & type_wf_errors(value(res_type), type_arity_map) if res_type != nil;

  return [proc_def_errors(proc_def, errs) if errs != []];
}


[FnDefWFError] fndef_wf_errors(
  SynFnDef                                            fndef,
  [SynSgn]                                            named_params,
  (BasicTypeSymbol => Nat+)                           type_arity_map,
  (TypeName => Type)                                  typedefs,
  (FnSymbol => (Nat => ([Nat], (NamedPar => Nat)+)))  global_functions,
  (AutoSymbol => SynAutoDef)                          automata
)
{
  loc_fns_errs = function_group_signature_wf_errors([(fd, named_params) : fd <- fndef.local_fns], type_arity_map, typedefs);
  return [nested_functions_errors(loc_fns_errs)] if loc_fns_errs != [];

  loc_fns_by_name = group_by(fndef.local_fns, $.name);
  local_fns = (n => local_fn_untyped_sgns(fds) : fds @ n <- loc_fns_by_name);

  main_fn_errs = fndef_wf_errors(fndef, named_params, local_fns, type_arity_map, typedefs, global_functions, automata);

  nested_fns_errs = join([
      fndef_wf_errors(fd, named_params, local_fns, type_arity_map, typedefs, global_functions, automata)
      : fd <- fndef.local_fns
  ]);

  return main_fn_errs & nested_fns_errs;


  (Nat => [Nat]) local_fn_untyped_sgns(SynFnDef+ fds)
  {
    pars_arities_by_fn_arity = group_by(fds, arity($), [syn_type_arity(p.type) : p <- $.params]);
    return (fn_arity => only_element(param_arities) : param_arities @ fn_arity <- pars_arities_by_fn_arity);
  }
}


[FnDefWFError] fndef_wf_errors(
  SynFnDef                                            fndef,
  [SynSgn]                                            named_params,
  (FnSymbol => (Nat => [Nat]))                        local_fns,
  (BasicTypeSymbol => Nat+)                           type_arity_map,
  (TypeName => Type)                                  typedefs,
  (FnSymbol => (Nat => ([Nat], (NamedPar => Nat)+)))  global_functions,
  (AutoSymbol => SynAutoDef)                          automata
)
{
  args = seq_union([{fn_par(i), var(p.var_name) if p.var_name?} : p @ i <- fndef.params, p.type :: SynType]) &
         set([p.name : p <- named_params, p.params == []]);

  cls = (fn_symbol(p.var_name) => syn_type_arity(type) : p <- set(fndef.params), type = p.type, type :: SynClsType, p.var_name?) &
        (named_par_to_fn_symb(p.name) => a : p <- set(named_params), a = arity(p), a != 0);

  named_params_arities = merge(set([(p.name => arity(p)): p <- named_params]));

  return expr_wf_errors(
    fndef.expr,
    args,
    type_arity_map = type_arity_map,
    curr_function_named_params = named_params_arities,
    global_functions = global_functions,
    local_functions = local_fns,
    closures = cls,
    procedures = (),
    auto_vars = (),
    automata = automata,
    actual_param_arity = 0
  );
}


[ProcDefWFError] proc_def_wf_errors(
  SynProcDef                                          proc_def,
  (BasicTypeSymbol => Nat+)                           type_arity_map,
  (TypeName => Type)                                  typedefs,
  (FnSymbol => (Nat => ([Nat], (NamedPar => Nat)+)))  global_functions,
  (ProcSymbol => (Nat, Bool))                         procedures,
  (AutoSymbol => SynAutoDef)                          automata
)
{
  body = proc_def.body;
  return [] if body == [];

  return root_stmt_block_wf_errors(
    body,
    set([p.var : p <- proc_def.params]),
    proc_def.res_type != nil,
    true,
    type_arity_map = type_arity_map,
    curr_function_named_params = (),
    global_functions = global_functions,
    local_functions = (),
    closures = (),
    procedures = procedures,
    auto_vars = (v.var => auto_symbol(v.type) : v <- set(proc_def.auto_vars)),
    automata = automata,
    actual_param_arity = 0
  );
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

(FnSymbol => (Nat => ([Nat], (NamedPar => Nat)+))) create_global_functions_map([(SynFnDef, [SynSgn])] full_fndefs)
{
  fndefs_by_name = group_by(full_fndefs, left($).name);
  return (n => create_polymorphic_function_map(fds) : fds @ n <- fndefs_by_name);

  (Nat => ([Nat], (NamedPar => Nat)+)) create_polymorphic_function_map((SynFnDef, [SynSgn])+ full_fndefs)
  {
    fndefs_by_arity = group_by(full_fndefs, arity(left($)));
    // return (a => {fndef_sgn_info(left(fd), right(fd)) : fd <- fds} : fds @ a <- fndefs_by_arity);
    return (a => fndefs_sgn_info(fds) : fds @ a <- fndefs_by_arity);
  }


  ([Nat], (NamedPar => Nat)+) fndefs_sgn_info((SynFnDef, [SynSgn])+ full_fndefs)
  {
    sgn_infos = {fndef_sgn_info(left(fd), right(fd)) : fd <- full_fndefs};
    pos_pars_info = {left(si) : si <- sgn_infos};
    named_pars_info = {right(si) : si <- sgn_infos};
    return (only_element(pos_pars_info), named_pars_info);
  }


  ([Nat], (NamedPar => Nat)) fndef_sgn_info(SynFnDef fndef, [SynSgn] named_params)
  {
    pos_pars_info = [arity(p) : p <- fndef.params];
    named_pars_info = merge([(p.name => arity(p)) : p <- named_params]);
    return (pos_pars_info, named_pars_info);
  }
}


(ProcSymbol => (Nat, Bool)) builtin_procs_map = (
  proc_symbol(:file_read)    => (1, true),
  proc_symbol(:file_write)   => (3, false),
  proc_symbol(:print)        => (1, false),
  proc_symbol(:get_char)     => (0, true)
);

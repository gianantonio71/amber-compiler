
type TokenLineInfo  = token_line_info(token: PlainToken, offset: Nat, length: NzNat);

type LexerError = lexer_error(line: NzNat, col: NzNat);

type LexerResult      = Result[[AnnotatedToken], LexerError];
type ParseLineResult  = Result[[TokenLineInfo], Nat];
type ParseTokenResult = Result[TokenLineInfo, Nat];

////////////////////////////////////////////////////////////////////////////////

TokenLineInfo token_line_info(PlainToken token, Nat offset, NzNat length) = token_line_info(token: token, offset: offset, length: length);

AnnotatedToken annotated_token(TokenLineInfo token_info, NzNat line, Nat idx) = annotated_token(token_info.token, line, nz_nat(token_info.offset+1), idx);

LexerError lexer_error(NzNat line, NzNat col) = lexer_error(line: line, col: col);

////////////////////////////////////////////////////////////////////////////////

Atom symb([Nat] bytes) = _symb_(string(bytes)); //## THIS DOESN'T BELONG HERE

////////////////////////////////////////////////////////////////////////////////

Bool is_lower([Nat] bytes, Nat offset)           = is_lower(at(bytes, offset, 0));
Bool is_upper([Nat] bytes, Nat offset)           = is_upper(at(bytes, offset, 0));
Bool is_digit([Nat] bytes, Nat offset)           = is_digit(at(bytes, offset, 0));
Bool is_lower_or_digit([Nat] bytes, Nat offset)  = is_lower_or_digit(at(bytes, offset, 0));
Bool is_char([Nat] bytes, Nat offset, Nat ch)    = at(bytes, offset, nil) == ch;
Bool is_str([Nat] bytes, Nat offset, String str) = subseq(bytes, offset, min(length(bytes)-offset, length(str))) == _obj_(str);

Bool is_alphanum([Nat] bytes, Nat offset, <upper, lower, any> case) = is_alpha(bytes, offset, case) or is_digit(bytes, offset);
Bool is_alpha([Nat] bytes, Nat offset, <upper, lower, any> case)    = (case != :lower and is_upper(bytes, offset)) or
                                                                      (case != :upper and is_lower(bytes, offset));

//## THESE TWO FUNCTIONS DO NOT BELONG HERE
Bool is_alphanum(Nat ch, <upper, lower, any> case)  = is_alpha(ch, case) or is_digit(ch);
Bool is_alpha(Nat ch, <upper, lower, any> case)     = (case != :lower and is_upper(ch)) or (case != :upper and is_lower(ch));

////////////////////////////////////////////////////////////////////////////////

Bool looks_like_a_lowercase_id([Nat] bytes, Nat offset)           = is_lower(bytes, offset);
Bool looks_like_a_mixed_or_upper_case_id([Nat] bytes, Nat offset) = is_upper(bytes, offset);
Bool looks_like_a_qualified_symbol([Nat] bytes, Nat offset)       = is_char(bytes, offset, ascii_colon) and is_lower(bytes, nat(offset+1));
Bool looks_like_an_integer_or_float([Nat] bytes, Nat offset)      = is_digit(bytes, offset);
Bool looks_like_a_string([Nat] bytes, Nat offset)                 = is_char(bytes, offset, ascii_double_quotes);
Bool looks_like_a_char([Nat] bytes, Nat offset)                   = is_char(bytes, offset, ascii_single_quote);
Bool looks_like_a_builtin([Nat] bytes, Nat offset)                = is_char(bytes, offset, ascii_underscore) and is_lower(bytes, nat(offset+1));
Bool looks_like_a_cls_par([Nat] bytes, Nat offset)                = is_char(bytes, offset, ascii_dollar);
Bool looks_like_a_memb_copy_var([Nat] bytes, Nat offset)          = is_char(bytes, offset, ascii_hash) and is_lower(bytes, nat(offset+1));

////////////////////////////////////////////////////////////////////////////////

LexerResult lex_src_file([Nat] chars)
{
  lines = [remove_line_comment(l) : l <- split_lines(chars)];
  tokens = [];
  for (l @ i : lines)
    res = split_line_into_tokens(l);
    if (is_success(res))
      start_idx = length(tokens);
      tokens = tokens & [annotated_token(ti, nz_nat(i+1), nz_nat(start_idx+j+1)) : ti @ j <- get_result(res)];
    else
      return failure(lexer_error(nz_nat(i+1), nz_nat(get_error(res)+1)));
    ;
  ;
  return success(tokens);

  [Nat] remove_line_comment([Nat] line) =
    match (left_search(line, 2 * [ascii_slash]))
      just(idx?)  = subseq(line, 0, idx),
      nil         = line;
}


ParseLineResult split_line_into_tokens([Nat] bytes)
{
  len = length(bytes);
  idx = 0;
  tokens = [];
  loop
    while (idx < len and is_space(bytes[idx]))
      idx = nz_nat(idx + 1);
    ;
    break if idx >= len;
    res = if looks_like_a_lowercase_id(bytes, idx)           then read_lowercase_id(bytes, idx),
             looks_like_a_mixed_or_upper_case_id(bytes, idx) then read_mixed_or_upper_case_id(bytes, idx),
             looks_like_a_qualified_symbol(bytes, idx)       then read_qualified_symbol(bytes, idx),
             looks_like_an_integer_or_float(bytes, idx)      then read_integer_or_float(bytes, idx),
             looks_like_a_string(bytes, idx)                 then read_string(bytes, idx),
             //looks_like_a_char(bytes, idx)                   then read_char(bytes, idx),
             looks_like_a_builtin(bytes, idx)                then read_builtin(bytes, idx),
             looks_like_a_cls_par(bytes, idx)                then read_cls_par(bytes, idx),
             looks_like_a_memb_copy_var(bytes, idx)          then read_memb_copy_var(bytes, idx)
                                                             else read_symbolic_token(bytes, idx);
    return failure(get_error(res)) if not is_success(res); //## IT'S failure(get_error(res)) INSTEAD OF JUST res JUST TO SHUT UP THE TYPECHECKER
    info = get_result(res);
    tokens = tokens & [info];
    assert idx == info.offset;
    idx = nz_nat(idx + info.length);
  ;
  return success(tokens); //## SHOULD ALSO RETURN THE OFFSETS OF THE TOKENS
}

////////////////////////////////////////////////////////////////////////////////

ParseTokenResult read_lowercase_id([Nat] bytes, Nat offset)
{
  len = identifier_length(bytes, offset, :lower);
  fail if len == 0; //## SHUTTING UP THE TYPECHECKER. AN ASSERT WOULD BE NICER HERE
  next_idx = nat(offset + len);
  next_ch = at(bytes, next_idx, 0);
  return failure(next_idx) if is_upper(next_ch) or next_ch == ascii_underscore;
  id = symb(subseq(bytes, offset, len));
  return success(token_line_info(lowercase_id(id), offset, len));
}

ParseTokenResult read_mixed_or_upper_case_id([Nat] bytes, Nat offset)
{
  mixed_case_res = read_mixedcase_id(bytes, offset);
  return mixed_case_res if is_success(mixed_case_res);
  uppercase_res = read_uppercase_id(bytes, offset);
  return uppercase_res if is_success(uppercase_res);
  return failure(nat(max(get_error(mixed_case_res), get_error(uppercase_res))));
}

ParseTokenResult read_mixedcase_id([Nat] bytes, Nat offset)
{
  assert is_upper(bytes, offset);
  len = alphanum_length(bytes, offset);
  fail if len == 0; //## SHUTTING UP THE TYPECHECKER. AN ASSERT WOULD BE NICER
  return failure(nat(offset+len)) if is_char(bytes, nat(offset+len), ascii_underscore);
  return failure(offset) if none([is_lower(bytes, nat(offset+i)) : i < len]);
  symbol = symb(to_lower_with_underscores(nonempty(subseq(bytes, offset, len))));
  return success(token_line_info(mixedcase_id(symbol), offset, len));
}

ParseTokenResult read_uppercase_id([Nat] bytes, Nat offset)
{
  assert is_upper(bytes, offset);
  len = identifier_length(bytes, offset, :upper);
  fail if len == 0; //## SHUTTING UP THE TYPECHECKER. AN ASSERT WOULD BE NICER
  next_idx = offset + len;
  next_ch = at(bytes, next_idx, 0);
  return failure(nat(next_idx)) if is_lower(next_ch) or next_ch == ascii_underscore;
  symbol = symb([lower(ch) : ch <- subseq(bytes, offset, len)]);
  return success(token_line_info(uppercase_id(symbol), offset, len));
}

ParseTokenResult read_qualified_symbol([Nat] bytes, Nat offset)
{
  assert is_char(bytes, offset, ascii_colon) and is_lower(bytes, nat(offset+1));
  len = identifier_length(bytes, nat(offset+1), :lower);
  next_idx = nat(offset + 1 + len);
  next_ch = at(bytes, next_idx, 0);
  return failure(next_idx) if is_upper(next_ch) or next_ch == ascii_underscore;
  symbol = symb(subseq(bytes, offset+1, len));
  return success(token_line_info(qualified_symbol(symbol), offset, nz_nat(len+1)));
}


ParseTokenResult read_integer_or_float([Nat] bytes, Nat offset)
{
  assert is_digit(bytes, offset);
  len = digit_length(bytes, offset);
  fail if len == 0; //## SHUTTING UP THE COMPILER. AN ASSERTION WOULD BE NICER
  //## CHECK THAT THE INTEGER IS NOT TOO BIG (BUT THAT WOULD BE OK FOR A FLOATING POINT NUMBER)
  next_idx = nat(offset + len);
  return failure(nat(next_idx)) if is_alpha(bytes, next_idx, :any);
  value = to_int(string(subseq(bytes, offset, len)));
  return success(token_line_info(value, offset, len)) if not is_char(bytes, next_idx, ascii_dot) or is_char(bytes, nat(next_idx+1), ascii_dot);

  dec_len = digit_length(bytes, nat(next_idx+1));
  dec_chs = subseq(bytes, next_idx+1, dec_len);
  mantissa = value;
  exp = 0;
  for (ch : dec_chs)
    d = ch - ascii_0;
    assert d >= 0 and d <= 9;
    new_mantissa = 10 * mantissa + d;
    // If the mantissa overflows, we just ignore the least significant digits 
    break if new_mantissa < mantissa;
    mantissa = new_mantissa;
    exp = exp - 1;
  ;
  float_value = float_lit(mantissa, exp);
  return success(token_line_info(float_value, offset, nz_nat(len+dec_len+1)));
}


ParseTokenResult read_string([Nat] bytes, Nat offset)
{
  assert is_char(bytes, offset, ascii_double_quotes);

  len = length(bytes);
  chs = [];
  i = 1;
  loop
    idx = offset + i;
    return failure(len) if idx >= len; //## WOULD BE GOOD TO ADD MORE INFORMATION ABOUT THE FAILURE HERE
    ch = bytes[idx];
    i = i + 1;
    return success(token_line_info(string(chs), nat(offset), nz_nat(i))) if ch == ascii_double_quotes;
    if (ch == ascii_backslash)
      idx = offset + i;
      i = i + 1;
      return failure(len) if idx >= len; //## WOULD BE GOOD TO ADD MORE INFORMATION ABOUT THE FAILURE HERE
      ch = bytes[idx];
      if (ch == ascii_backslash or ch == ascii_double_quotes)
        chs = chs & [ch];
      elif (ch == ascii_lower_n)
        chs = chs & [ascii_newline];
      else
        return failure(nat(offset+i)); //## WOULD BE GOOD TO ADD MORE INFORMATION ABOUT THE FAILURE HERE
      ;
    else
      chs = chs & [ch];
    ;
  ;
}


ParseTokenResult read_char([Nat] bytes, Nat offset)
{
  fail;
}


ParseTokenResult read_builtin([Nat] bytes, Nat offset)
{
  assert is_char(bytes, offset, ascii_underscore);
  len = identifier_length(bytes, nat(offset+1), :lower);
  next_idx = nat(offset + 1 + len);
  return failure(next_idx) if not is_char(bytes, next_idx, ascii_underscore);
  symbol = symb(subseq(bytes, offset+1, len));
  return failure(offset) if not symbol :: BuiltIn; //## WOULD BE GOOD TO ADD MORE INFORMATION ABOUT THE FAILURE HERE
  return success(token_line_info(builtin(symbol), offset, nz_nat(len+2)));
}


ParseTokenResult read_cls_par([Nat] bytes, Nat offset)
{
  assert is_char(bytes, offset, ascii_dollar);
  return success(token_line_info(qual_var(0), offset, 1)) if not is_lower(bytes, nat(offset+1));
  return failure(nat(offset+2)) if is_lower(bytes, nat(offset+2));
  return success(token_line_info(qual_var(nat(bytes[offset+1]-ascii_lower_a)), offset, 2));
}


ParseTokenResult read_memb_copy_var([Nat] bytes, Nat offset)
{
  assert is_char(bytes, offset, ascii_hash) and is_lower(bytes, nat(offset+1));
  len = identifier_length(bytes, nat(offset+1), :lower);
  next_idx = nat(offset + 1 + len);
  next_ch = at(bytes, next_idx, 0);
  return failure(next_idx) if is_upper(next_ch) or next_ch == ascii_underscore;
  symbol = symb(subseq(bytes, offset+1, len));
  return success(token_line_info(hash_lowercase_id(symbol), offset, nz_nat(len+1)));
}


ParseTokenResult read_symbolic_token([Nat] bytes, Nat offset)
{
  return failure(offset) if offset >= length(bytes); //## MAYBE HERE I SHOULD CHANGE THE CALLER
  trie = string_to_symbol_trie;
  maybe_symb, len = trie_lookup(trie, nonempty(right_subseq(bytes, offset)));
  return failure(offset) if maybe_symb == nil;
  return success(token_line_info(value(maybe_symb), offset, nz_nat(len)));
}

////////////////////////////////////////////////////////////////////////////////

Nat identifier_length([Nat] bytes, Nat offset, <upper, lower> case)
{
  assert is_alpha(bytes, offset, case);
  return 0 if not is_alpha(bytes, offset, case);
  len = 1;
  loop
    idx = offset + len;
    ch = at(bytes, idx, 0);
    if (ch == ascii_underscore)
      return len if not is_alphanum(bytes, nat(idx+1), case);
    elif (not is_alphanum(ch, case))
      return len;
    ;
    len = nz_nat(len + 1);
  ;
 }

//## REENABLE THE COMMENTED OUT IMPLEMENTATION AS SOON AS POSSIBLE
// [Nat^] to_lower_with_underscores([Nat^] bytes) = join([[ascii_underscore if i > 0 and is_upper(b), lower(b)] : b @ i <- bytes]);
[Nat^] to_lower_with_underscores([Nat^] bytes) =
  nonempty(join([if i > 0 and is_upper(b) then [ascii_underscore, lower(b)] else [lower(b)] : b @ i <- bytes]));

//## THINK OF A BETTER WAY TO WRITE ALL THESE FUNCTIONS. THERE MUST BE ONE

Nat alphanum_length([Nat] bytes, Nat offset)
{
  len = 0;
  while (is_alphanum(bytes, nat(offset+len), :any))
    len = len + 1;
  ;
  return nat(len);
}

Nat digit_length([Nat] bytes, Nat offset)
{
  len = 0;
  while (is_digit(bytes, nat(offset+len)))
    len = len + 1;
  ;
  return nat(len);
}

////////////////////////////////////////////////////////////////////////////////


Trie[Nat, PlainToken] string_to_symbol_trie
{
  raw_str_to_symb = (nonempty(raw_str(str)) => symb : symb @ str <- string_to_symbol);
  return trie(raw_str_to_symb);
}


(String => PlainToken) string_to_symbol = (
  "("     =>  left_parenthesis,
  ")"     =>  right_parenthesis,
  "["     =>  left_bracket,
  "]"     =>  right_bracket,
  "{"     =>  left_brace,
  "}"     =>  right_brace,
  ","     =>  comma,
  ";"     =>  semicolon,

  "?"     =>  question_mark,
  "="     =>  equals,
  "|"     =>  pipe,
  ":"     =>  colon,
  "_"     =>  underscore,
  "^"     =>  circumflex,
  "."     =>  dot,
  "~"     =>  tilde,
  "@"     =>  at,
  "&"     =>  ampersand,
  "!"     =>  bang,
  "#"     =>  hash,
  "$"     =>  dollar,

  "<"     =>  lower,
  ">"     =>  greater,
  "+"     =>  plus,
  "-"     =>  minus,
  "*"     =>  asterisk,
  "/"     =>  slash,

  ".."    =>  double_dot,

  "=="    =>  double_equals,
  "!="    =>  not_equal,
  "<="    =>  lower_eq,
  ">="    =>  greater_eq,

  ":="    =>  assign,
  "::"    =>  double_colon,
  "->"    =>  right_arrow,
  "=>"    =>  double_right_arrow,
  "<-"    =>  left_arrow,
  //"<="    =>  double_left_arrow,
  "\\/"   =>  logical_or_operator,

  "..."   =>  triple_dot,

  "<<"    =>  double_lower,
  ">>"    =>  double_greater,

  "(-_)"    => operator(:minus),
  "(_+_)"   => operator(:plus),
  "(_-_)"   => operator(:minus),
  "(_*_)"   => operator(:star),     //## RENAME
  "(_/_)"   => operator(:slash),    //## RENAME
  "(_^_)"   => operator(:exp),      //## RENAME
  "(_&_)"   => operator(:amp),      //## RENAME
  "(_<_)"   => operator(:lower),
  "(_>_)"   => operator(:greater),
  "(_<=_)"  => operator(:lower_eq),
  "(_>=_)"  => operator(:greater_eq),
  "(_[_])"  => operator(:brackets)
);

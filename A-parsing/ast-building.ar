[PrgDecl] build_amber_file_ast(RuleMatch file, String filename, [[Nat]] lines) =
  [build_declaration_ast(m, filename=filename, lines=lines) : m <- rep_rule_nodes(file)];

using String filename, [[Nat]] lines
{
  PrgDecl build_declaration_ast(RuleMatch mtc)
  {
    inner_match = get_rule_match(mtc);
    decl = match (get_rule_name(mtc))
      typedef         = build_typedef_ast(inner_match),
      par_typedef     = build_par_typedef_ast(inner_match),
      fndef           = build_std_fndef_ast(inner_match),
      fndef_proc      = build_proc_fndef_ast(inner_match),
      fndef_switch    = build_switch_fndef_ast(inner_match),
      using_block_1   = build_using_block_1_ast(inner_match),
      using_block_2   = build_using_block_2_ast(inner_match),
      proc_def        = build_proc_def_ast(inner_match),
      auto_def        = build_auto_def_ast(inner_match);

    return attach_src_code_info(decl, filename, mtc);
  }

  ////////////////////////////////////////////////////////////////////////////////

  SynTypedef build_typedef_ast(RuleMatch typedef)
  {
    nodes = rule_seq_nodes(typedef);
    assert is_annotated_token(nodes[0], lowercase_id(:type));
    name = build_basic_type_symbol_ast(nodes[1]);
    assert is_annotated_token(nodes[2], equals);
    pretypes = [build_pretype_ast(n) : n <- rep_rule_nodes(nodes[3])];
    assert is_annotated_token(nodes[4], semicolon);
    return syn_typedef(name, syn_union_type(nonempty(pretypes)));
  }

  SynParTypedef build_par_typedef_ast(RuleMatch par_typedef)
  {
    nodes = rule_seq_nodes(par_typedef);
    assert is_annotated_token(nodes[0], lowercase_id(:type));
    name = build_basic_type_symbol_ast(nodes[1]);
    params = [build_type_var_ast(p) : p <- rep_rule_nodes(block_node(nodes[2]))];
    assert is_annotated_token(nodes[3], equals);
    pretypes = [build_pretype_ast(n) : n <- rep_rule_nodes(nodes[4])];
    assert is_annotated_token(nodes[5], semicolon);
    return syn_par_typedef(name, nonempty(params), syn_union_type(nonempty(pretypes)));
  }

  SynType build_pretype_ast(RuleMatch pretype) =
    match (get_rule_name(pretype))
      type              = build_type_ast(get_rule_match(pretype)),
      type_empty_set    = empty_set_type,
      type_empty_seq    = empty_seq_type,
      type_empty_map    = empty_map_type,
      type_tag_obj      = build_tag_obj_type_ast(get_rule_match(pretype)),
      type_tag_record   = build_tag_record_type_ast(get_rule_match(pretype)),
      type_symbol       = build_symbol_type(get_rule_match(pretype));

  SynType build_type_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    basic_type_node = nodes[0];
    submatch = get_rule_match(basic_type_node);
    res_type = match (get_rule_name(basic_type_node))
      type_name         = build_type_ref_ast(submatch),
      type_name_par     = build_par_type_ref_ast(submatch),
      type_var          = build_type_var_ast(submatch),
      type_union        = build_type_union_ast(submatch),
      type_any_symbol   = atom_type,
      type_integer      = build_integer_type_ast(submatch),
      type_float        = float_type,
      type_seq          = build_seq_type_ast(submatch),
      type_map          = build_map_type_ast(submatch),
      type_record       = build_record_type_ast(submatch),
      type_tuple        = build_tuple_type_ast(submatch),
      type_any_tag_obj  = build_any_tag_obj_type(submatch);
    for (s : rep_rule_nodes(nodes[1]))
      res_type = syn_set_type(res_type, get_rule_name(s) == :ne_set);
    ;
    return res_type;
  }

  SynType build_tag_obj_type_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 2;
    tag_type = symb_type(object(get_lowercase_id(nodes[0])));
    obj_type = build_pretype_ast(block_node(nodes[1]));
    return syn_tag_obj_type(tag_type, obj_type);
  }

  SynType build_tag_record_type_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 2;
    tag_type = symb_type(object(get_lowercase_id(nodes[0])));
    obj_type = build_record_type_ast(nodes[1]);
    return syn_tag_obj_type(tag_type, obj_type);
  }

  SymbType build_symbol_type(RuleMatch mtc) = symb_type(get_lowercase_id(mtc));

  SynType build_type_ref_ast(RuleMatch mtc) = syn_type_ref(type_symbol(get_lowercase_id(mtc)));

  SynType build_par_type_ref_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 2;
    ts = type_symbol(get_lowercase_id(nodes[0]));
    ps = [build_type_ast(n) : n <- rep_rule_nodes(block_node(nodes[1]))];
    return syn_type_ref(ts, nonempty(ps));
  }

  TypeVar build_type_var_ast(RuleMatch mtc) = type_var(get_lowercase_id(mtc));

  SynType build_type_union_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 3;
    types = [build_pretype_ast(n) : n <- rep_rule_nodes(nodes[1])];
    return syn_union_type(nonempty(types));
  }

  SynType build_integer_type_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 5;
    assert is_annotated_token(nodes[0], lower) and is_annotated_token(nodes[2], double_dot) and is_annotated_token(nodes[4], greater);
    min_node = nodes[1];
    max_node = nodes[3];
    min = bound(get_rule_name(min_node), get_rule_match(min_node));
    max = bound(get_rule_name(max_node), get_rule_match(max_node));
    return match (min, max)
             nil,   nil   = integer,
             nil,   *     = low_ints(max),
             *,     nil   = high_ints(min),
             *,     *     = syn_int_range(min, max);

    <Int, nil> bound(Atom bound_type, RuleMatch mtc):
      asterisk      = nil,
      integer       = get_integer(mtc),
      neg_integer   = -get_integer(mtc, 1),
      _             = {fail;};
  }

  SynType build_seq_type_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(block_node(mtc));
    assert length(nodes) == 2;
    elem_type = build_type_ast(nodes[0]);
    return syn_seq_type(elem_type, nodes[1] != null_match);
  }

  SynType build_map_type_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(block_node(mtc));
    assert length(nodes) == 3;
    key_type = build_type_ast(nodes[0]);
    value_type = build_type_ast(nodes[2]);
    return syn_map_type(key_type, value_type);
  }

  SynRecordType build_record_type_ast(RuleMatch mtc)
  {
    fields = [build_record_field_ast(n) : n <- rep_rule_nodes(block_node(mtc))];
    return syn_record_type(nonempty(fields));

    (label: SymbObj, type: SynType, optional: Bool) build_record_field_ast(RuleMatch mtc)
    {
      nodes = rule_seq_nodes(mtc);
      assert length(nodes) == 3;
      label = object(get_label(nodes[0]));
      type = build_pretype_ast(nodes[1]);
      optional = nodes[2] != null_match;
      return (label: label, type: type, optional: optional);
    }
  }

  SynTupleType build_tuple_type_ast(RuleMatch mtc) =
    syn_tuple_type(nonempty([build_type_ast(n) : n <- rep_rule_nodes(block_node(mtc))]));

  SynType build_any_tag_obj_type(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(block_node(mtc));
    assert length(nodes) == 3;
    obj_type = build_type_ast(nodes[2]);
    return syn_any_tag_obj_type(obj_type);
  }

  ////////////////////////////////////////////////////////////////////////////////

  Maybe[SynType] build_maybe_type_ast(RuleMatch mtc) = if mtc != null_match then just(build_type_ast(mtc)) else nil;

  ////////////////////////////////////////////////////////////////////////////////

  SynFnDef build_fndef_ast(RuleMatch mtc) =
    match (get_rule_name(mtc))
      std     = build_std_fndef_ast(get_rule_match(mtc)),
      proc    = build_proc_fndef_ast(get_rule_match(mtc)),
      switch  = build_switch_fndef_ast(get_rule_match(mtc));

  SynFnDef build_std_fndef_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 6;
    ret_type  = build_maybe_type_ast(nodes[0]);
    fail if ret_type == nil; //## BAD BAD BAD
    return syn_fn_def(
      name:       build_fn_symbol_ast(nodes[1]),
      args:       build_fn_args_ast(nodes[2]),
      res_type:   value(ret_type),
      expr:       build_expr_ast(nodes[4]),
      local_fns:  []
    );
  }

  SynFnDef build_proc_fndef_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 4;
    ret_type = build_maybe_type_ast(nodes[0]);
    fail if ret_type == nil; //## BAD BAD BAD

    lfds = [];
    rem_stmts = [];

    for (s : build_stmts_ast(block_node(nodes[3])))
      lfds, rem_stmts = match (s)
        fn_def_stmt(fd?)  = ([lfds | transfer_attached_data(fd, s)], rem_stmts),
        _                 = (lfds, [rem_stmts | s]);
    ;

    return syn_fn_def(
      name:       build_fn_symbol_ast(nodes[1]),
      args:       build_fn_args_ast(nodes[2]),
      res_type:   value(ret_type),
      expr:       syn_do_expr(nonempty(rem_stmts)),
      local_fns:  lfds
    );

    SynFnDef transfer_attached_data(SynFnDef target, SynFnDefStmt source)
    {
      attachments = _fetch_(source);
      return target if attachments == {};
      fail if not attachments :: ((NzNat, NzNat), (NzNat, NzNat))+;
      start_pos, end_pos = only_element(attachments);
      return attach(target, (filename, left(start_pos), left(end_pos)));
    }

    T attach(T obj, Any data) = _attach_(obj, data);  //## BAD BAD BAD: THIS IS A WORKAROUND FOR A BUG IN THE TYPECHECKER
  }

  SynFnDef build_switch_fndef_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 6;
    ret_type = build_maybe_type_ast(nodes[0]);
    fail if ret_type == nil; //## BAD BAD BAD
    args = build_fn_args_ast(nodes[2]);
    cases = [build_switch_case_ast(n) : n <- rep_rule_nodes(nodes[4])];
    arity = syn_case_arity(cases[0]);
    expr = syn_try_expr(nonempty([fn_par(i) : i < arity]), nonempty(cases));
    return syn_fn_def(
      name:       build_fn_symbol_ast(nodes[1]),
      args:       args,
      res_type:   value(ret_type),
      expr:       expr,
      local_fns:  []
    );
  }

  SynUsingBlock build_using_block_1_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 3;
    return build_using_block_ast(nodes[1], block_node(nodes[2]));
  }

  SynUsingBlock build_using_block_2_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    nodes = rule_seq_nodes(block_node(nodes[1]));
    assert length(nodes) == 3;
    return build_using_block_ast(nodes[0], nodes[2]);
  }

  SynUsingBlock build_using_block_ast(RuleMatch signatures, RuleMatch fndefs) =
    syn_using_block(
      nonempty([build_signature_ast(n) : n  <- rep_rule_nodes(signatures)]),
      nonempty([attach_src_code_info(build_fndef_ast(fd), filename, fd) : fd <- rep_rule_nodes(fndefs)])
    );

  SynSgn build_signature_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 3;
    return syn_sgn(
      named_arg(get_lowercase_id(nodes[1])),
      [build_type_ast(t) : t <- rep_rule_nodes(block_node_or_null(nodes[2]))],
      build_type_ast(nodes[0])
    );
  }

  SynProcDef build_proc_def_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 3;

    if (get_rule_name(nodes[0]) == :ret_val)
      ns = rule_seq_nodes(get_rule_match(nodes[0]));
      assert length(ns) == 2;
      res_type = just(build_type_ast(ns[0]));
      name = proc_symbol(get_lowercase_id(ns[1]));
    else
      res_type = nil;
      name = proc_symbol(get_lowercase_id(get_rule_match(nodes[0])));
    ;

    args = [(type: build_type_ast(rule_seq_node(ns, 0)), var: var(get_lowercase_id(rule_seq_node(ns, 1)))) : ns <- rep_rule_nodes(block_node(nodes[1]))];

    body_nodes = rule_seq_nodes(block_node(nodes[2]));
    auto_vars = [build_auto_var_decl(n) : n <- rep_rule_nodes(body_nodes[0])];
    body = [build_stmt_ast(n) : n <- rep_rule_nodes(body_nodes[1])];

    return syn_proc_def(
      name:       name,
      args:       args,
      res_type:   res_type,
      auto_vars:  auto_vars,
      body:       body
    );

    (var: AutoVar, type: Atom) build_auto_var_decl(RuleMatch mtc)
    {
      nodes = rule_seq_nodes(mtc);
      assert length(nodes) == 4;
      type = get_lowercase_id(nodes[1]);
      var = auto_var(get_lowercase_id(nodes[2]));
      return (var: var, type: type);
    }
  }

  FnSymbol build_fn_symbol_ast(RuleMatch mtc) =
    match (get_token(mtc))
      lowercase_id(a?)  = fn_symbol(a),
      operator(op?)     = op_symbol(op);

  [SynFnArg] build_fn_args_ast(RuleMatch mtc) = if mtc != null_match then [build_fn_arg_ast(m) : m <- rep_rule_nodes(block_node(mtc))] else []; //## MAYBE rep_rule_nodes (AND seq_rule_nodes) SHOULD RETURN THE EMPTY SEQUENCE WHEN INVOKED WITH A null_match PARAMETER

  SynFnArg build_fn_arg_ast(RuleMatch mtc) =
    match (get_rule_name(mtc))
      unknown   = {fail;}, //(),
      untyped   = {fail;}, //(var_name: get_lowercase_id(get_rule_match(mtc))),
      typed     = {
        nodes = rule_seq_nodes(get_rule_match(mtc));
        assert length(nodes) == 2;
        return (type: build_type_ast(nodes[0]), var_name: get_lowercase_id(nodes[1]) if nodes[1] != null_match);
      },
      cls       = {
        nodes = rule_seq_nodes(get_rule_match(mtc));
        assert length(nodes) == 2;
        return (type: build_cls_type_ast(nodes[0]), var_name: get_lowercase_id(nodes[1]));
      };

  SynClsType build_cls_type_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(block_node(mtc));
    assert length(nodes) == 3;
    in_types = [build_type_ast(n) : n <- rep_rule_nodes(nodes[0])];
    out_type = build_type_ast(nodes[2]);
    return syn_cls_type(nonempty(in_types), out_type);
  }

  ////////////////////////////////////////////////////////////////////////////////

  SynExpr build_expr_ast(RuleMatch mtc) = build_expr_10_ast(mtc);

  SynExpr build_expr_10_ast(RuleMatch mtc)
  {
    // ParsingRule rule_expr_10  = rule_seq([rule_expr_9, optional_rule(rule_seq([atomic_rule(at), rule_expr_9]))]);
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 2;
    expr = build_expr_9_ast(nodes[0]);
    return expr if nodes[1] == null_match;
    right_expr = build_expr_9_ast(rule_seq_node(nodes[1], 1));
    return attach_src_code_info(syn_tag_obj_expr(expr, right_expr), mtc);
  }

  SynExpr build_expr_9_ast(RuleMatch mtc)
  {
    // ParsingRule rule_expr_9   = rep_rule(rule_expr_8, ops_prec_log, true, true);
    nodes = rep_rule_nodes(mtc);
    expr = build_expr_8_ast(nodes[0]);
    i = 1;
    while (i < length(nodes)) //## WOULD BE NICE TO HAVE A C-STYLE FOR LOOP HERE: for (i=0 ; i < length(nodes) ; i = i + 2). BUT EVEN THAT WOULD NOT BE IDEAL, BECAUSE THE length(nodes) EXPRESSION IS RECALCULATED EVERY TIME
      right_expr = build_expr_8_ast(nodes[i+1]);
      op = get_lowercase_id(nodes[i]);
      if (op == :and)
        expr = syn_and(expr, right_expr);
      else
        assert op == :or;
        expr = syn_or(expr, right_expr);
      ;
      i = i + 2;
    ;
    return attach_src_code_info(expr, mtc);
  }

  SynExpr build_expr_8_ast(RuleMatch mtc)
  {
    // ParsingRule rule_expr_8   = rule_seq([rule_expr_7, optional_rule(rule_seq([ops_prec_eq, rule_expr_7]))]);
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 2;
    expr = build_expr_7_ast(nodes[0]);
    return expr if nodes[1] == null_match;
    nodes = rule_seq_nodes(nodes[1]);
    op = get_token(nodes[0]);
    right_expr = build_expr_7_ast(nodes[1]);
    if (op == :double_equals)
      expr = syn_eq(expr, right_expr);
    else
      assert op == :not_equal;
      expr = syn_neq(expr, right_expr);
    ;
    return attach_src_code_info(expr, mtc);
  }

  SynExpr build_expr_7_ast(RuleMatch mtc)
  {
    // ParsingRule rule_expr_7   = rule_seq([rule_expr_6, optional_rule(rule_seq([ops_prec_ord, rule_expr_6]))]);
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 2;
    expr = build_expr_6_ast(nodes[0]);
    return expr if nodes[1] == null_match;
    nodes = rule_seq_nodes(nodes[1]);
    op = op_symbol(token_to_operator(get_token(nodes[0])));
    right_expr = build_expr_6_ast(nodes[1]);
    return attach_src_code_info(syn_fn_call(op, [expr, right_expr]), mtc);
  }

  SynExpr build_expr_6_ast(RuleMatch mtc)
  {
    // ParsingRule rule_expr_6   = rep_rule(rule_expr_5, ops_prec_sum, true, true);
    nodes = rep_rule_nodes(mtc);
    expr = build_expr_5_ast(nodes[0]);
    i = 1;
    while (i < length(nodes)) //## WOULD BE NICE TO HAVE A C-STYLE FOR LOOP HERE: for (i=0 ; i < length(nodes) ; i = i + 2). BUT EVEN THAT WOULD NOT BE IDEAL, BECAUSE THE length(nodes) EXPRESSION IS RECALCULATED EVERY TIME
      op = op_symbol(token_to_operator(get_token(nodes[i])));
      right_expr = build_expr_5_ast(nodes[i+1]);
      expr = syn_fn_call(op, [expr, right_expr]);
      i = i + 2;
    ;
    return attach_src_code_info(expr, mtc);
  }

  SynExpr build_expr_5_ast(RuleMatch mtc)
  {
    // ParsingRule rule_expr_5   = rep_rule(rule_expr_4, ops_prec_prod, true, true);
    nodes = rep_rule_nodes(mtc);
    expr = build_expr_4_ast(nodes[0]);
    i = 1;
    while (i < length(nodes)) //## WOULD BE NICE TO HAVE A C-STYLE FOR LOOP HERE: for (i=0 ; i < length(nodes) ; i = i + 2). BUT EVEN THAT WOULD NOT BE IDEAL, BECAUSE THE length(nodes) EXPRESSION IS RECALCULATED EVERY TIME
      op = op_symbol(token_to_operator(get_token(nodes[i])));
      right_expr = build_expr_4_ast(nodes[i+1]);
      expr = syn_fn_call(op, [expr, right_expr]);
      i = i + 2;
    ;
    return attach_src_code_info(expr, mtc);
  }

  SynExpr build_expr_4_ast(RuleMatch mtc)
  {
    // ParsingRule rule_expr_4   = rule_seq([optional_rule(rule_anon_choice([atomic_rule(minus), keyword_not])), rule_expr_3]);
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 2;
    expr = build_expr_3_ast(nodes[1]);
    prefix = nodes[0];
    if (prefix != null_match)
      op = annotated_token(prefix).token;
      if (op == :minus)
        expr = syn_fn_call(op_symbol(:minus), [expr]);
      else
        assert op == lowercase_id(:not);
        expr = syn_not(expr);
      ;
    ;
    return attach_src_code_info(expr, mtc);
  }

  SynExpr build_expr_3_ast(RuleMatch mtc)
  {
    // ParsingRule rule_expr_3   = rep_rule(rule_expr_2, atomic_rule(circumflex), true, false);
    nodes = rep_rule_nodes(mtc);
    expr = build_expr_2_ast(last(nonempty(nodes)));
    i = length(nodes) - 2;
    while (i >= 0)
      left_expr = build_expr_2_ast(nodes[i]);
      expr = syn_fn_call(op_symbol(:exp), [left_expr, expr]);
      i = i - 1;
    ;
    return attach_src_code_info(expr, mtc);
  }

  SynExpr build_expr_2_ast(RuleMatch mtc)
  {
    // ParsingRule rule_expr_2   = rule_seq([rule_expr_1, optional_rule(rule_seq([atomic_rule(double_colon), rule_type]))]);
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 2;
    expr = build_expr_1_ast(nodes[0]);
    return expr if nodes[1] == null_match;
    type = build_type_ast(rule_seq_node(nodes[1], 1));
    return attach_src_code_info(syn_membership(expr, type), mtc);
  }

  SynExpr build_expr_1_ast(RuleMatch mtc)
  {
    // ParsingRule rule_expr_1   = rule_seq([rule_expr_0, rep_rule(rule_dot_or_sub), optional_rule(rule_dot_access(true))]);
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 3;
    expr = build_expr_0_ast(nodes[0]);
    for (r : rep_rule_nodes(nodes[1]))
      if (get_rule_name(r) == :dot)
        field = get_lowercase_id(get_rule_match(r), 1);
        expr = syn_accessor(expr, field);
      else
        assert get_rule_name(r) == :sub;
        idx_expr = build_expr_ast(block_node(get_rule_match(r)));
        expr = syn_fn_call(op_symbol(:brackets), [expr, idx_expr]);
      ;
    ;
    if (nodes[2] != null_match)
      field = get_lowercase_id(nodes[2], 1);
      expr = syn_accessor_test(expr, field);
    ;
    return attach_src_code_info(expr, mtc);
  }

  SynExpr build_expr_0_ast(RuleMatch mtc)
  {
    inner_match = get_rule_match(mtc);
    expr = match (get_rule_name(mtc))
      tag_obj       = build_tag_obj_expr_ast(inner_match),                  // rule_seq([atomic_rule(qualified_symbol), par_rule(rule_ref_expr)])
      memb_copy     = memb_copy_var(get_var_id(inner_match)),               // atomic_rule(prev_value_var)
      is_def        = is_def(memb_var(get_lowercase_id(inner_match, 0))),   // rule_seq([rule_id, atomic_rule(question_mark)]))
      integer       = object(get_integer(inner_match)),                     // atomic_rule(integer)
      symbol        = object(get_qualified_symbol(inner_match)),            // atomic_rule(qualified_symbol)
      string        = build_string_expr_ast(inner_match),                   // atomic_rule(string)
      float         = get_float_lit(inner_match),                           // atomic_rule(float)
      true          = object(true),                                         // atomic_rule(keyword(true))
      false         = object(false),                                        // atomic_rule(keyword(false))
      nil           = object(nil),                                          // atomic_rule(keyword(nil))
      set           = build_set_expr_ast(block_node(inner_match)),          // brace_rule(opt_comma_sep_seq(rule_subexpr))
      map           = build_map_expr_ast(inner_match),                      // par_rule(opt_comma_sep_seq(rule_map_entry))
      record        = build_record_expr_ast(inner_match),                   // rule_record_expr
      seq           = build_seq_expr_ast(inner_match),                      // rule_seq_expr
      seq_tail      = build_seq_tail_expr_ast(inner_match),                 // rule_seq_tail_expr
      tag_record    = build_tag_record_expr_ast(inner_match),               // rule_tag_record_expr
      builtin_call  = build_builtin_call_expr_ast(inner_match),             // rule_seq([atomic_rule(builtin), par_rule(comma_sep_seq(rule_ref_expr))])
      par_exprs     = build_tuple_or_par_expr_ast(block_node(inner_match)), // par_rule(comma_sep_seq(rule_ref_expr))
      ex_qual       = build_ex_qual_expr_ast(inner_match),                  // rule_ex_qual_expr
      set_cp        = build_set_cp_expr_ast(block_node(inner_match)),       // rule_set_cp_expr
      map_cp        = build_map_cp_expr_ast(inner_match),                   // rule_map_cp_expr
      seq_cp        = build_seq_cp_expr_ast(inner_match),                   // rule_seq_cp_expr
      // alt_cp        = build_alt_cp_expr_ast(inner_match),                   // rule_alt_cp_expr
      if_else       = build_if_else_expr_ast(inner_match),                  // rule_if_expr
      match_expr    = build_match_expr_ast(inner_match),                    // rule_match_expr
      proc          = build_proc_expr_ast(block_node(inner_match)),         // brace_rule(rep_rule(rule_ref_stmt, true))
      fn_call       = build_fn_call_expr_ast(inner_match),                  // rule_fn_call_expr
      const_or_var  = const_or_var(get_lowercase_id(inner_match)),          // rule_id
      cls_par       = cls_par(get_cls_par_idx(inner_match));                // atomic_rule(qual_var))

    return attach_src_code_info(expr, mtc);
  }

  SynTagObjExpr build_tag_obj_expr_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 2;
    return syn_tag_obj_expr(object(get_qualified_symbol(nodes[0])), build_expr_ast(block_node(nodes[1])));
  }

  SynSetExpr build_set_expr_ast(RuleMatch mtc) = syn_set_expr([build_subexpr_ast(n) : n <- rep_rule_nodes(mtc)]);

  SynSeqExpr build_seq_expr_ast(RuleMatch mtc) = syn_seq_expr([build_subexpr_ast(n) : n <- rep_rule_nodes(block_node(mtc))]);

  SynSeqExpr build_seq_tail_expr_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(block_node(mtc));
    assert length(nodes) == 2;
    seq_expr = build_expr_ast(nodes[0]);
    tail_exprs = [build_expr_ast(n) : n <- rep_rule_nodes(rule_seq_node(nodes[1], 1))];
    return syn_seq_tail_expr(seq_expr, nonempty(tail_exprs));
  }

  SynExpr build_tuple_or_par_expr_ast(RuleMatch mtc)
  {
    exprs = nonempty([build_expr_ast(n) : n <- rep_rule_nodes(mtc)]);
    return if length(exprs) == 1 then exprs[0] else syn_tuple_expr(exprs);
  }

  SynMapExpr build_map_expr_ast(RuleMatch mtc) = syn_map_expr([build_map_entry_ast(n) : n <- rep_rule_nodes(block_node(mtc))]);

  SynMapExpr build_record_expr_ast(RuleMatch mtc) = syn_map_expr([build_record_field_ast(n) : n <- rep_rule_nodes(block_node(mtc))]);

  SynTagObjExpr build_tag_record_expr_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 2;
    tag = object(get_lowercase_id(nodes[0]));
    obj = build_record_expr_ast(nodes[1]);
    return syn_tag_obj_expr(tag, obj);
  }

  SynExpr build_string_expr_ast(RuleMatch mtc) = syn_tag_obj_expr(object(:string), syn_seq_expr([object(ch) : ch <- _obj_(get_string(mtc))]));

  SynExpr build_builtin_call_expr_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 2;
    builtin = get_builtin(nodes[0]);
    args = [build_expr_ast(n) : n <- rep_rule_nodes(block_node(nodes[1]))];
    return syn_builtin_call(builtin, nonempty(args));
  }

  SynExpr build_ex_qual_expr_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(block_node(mtc));
    assert length(nodes) == 4;
    clauses = [build_clause_ast(n) : n <- rep_rule_nodes(nodes[1])];
    expr = build_expr_ast(nodes[3]);
    return syn_ex_qual(nonempty(clauses), expr);
  }

  SynExpr build_set_cp_expr_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 3;
    expr = build_expr_ast(nodes[0]);
    clauses = [build_clause_ast(n) : n <- rep_rule_nodes(nodes[2])];
    return syn_set_comp(expr, nonempty(clauses));
  }

  SynExpr build_map_cp_expr_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(block_node(mtc));
    assert length(nodes) == 5;
    key_expr = build_expr_ast(nodes[0]);
    value_expr = build_expr_ast(nodes[2]);
    clauses = [build_clause_ast(n) : n <- rep_rule_nodes(nodes[4])];
    return syn_map_comp(key_expr, value_expr, nonempty(clauses));
  }

  <SynLCExpr, SynRCExpr> build_seq_cp_expr_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(block_node(mtc));
    assert length(nodes) == 5;

    expr     = build_expr_ast(nodes[0]);

    src_expr = build_expr_ast(nodes[3]);

    if (nodes[4] != null_match)
      ns = rule_seq_nodes(nodes[4]);
      sel_expr = just(build_expr_ast(ns[1]));
    else
      sel_expr = nil;
    ;

    var_and_type_node = nodes[2];
    if (get_rule_name(var_and_type_node) == :seq)
      ns = rule_seq_nodes(get_rule_match(var_and_type_node));
      vars = [var(get_lowercase_id(n)) : n <- rep_rule_nodes(ns[0])];
      if (ns[1] != null_match)
        sub_ns = rule_seq_nodes(ns[1]);
        idx_var = just(var(get_lowercase_id(sub_ns[1])));
      else
        idx_var = nil;
      ;
      return seq_comp(
        expr:       expr,
        vars:       nonempty(vars),
        idx_var:    value(idx_var) if idx_var != nil,
        src_expr:   src_expr,
        sel_expr:   value(sel_expr) if sel_expr != nil
      );

    else
      assert get_rule_name(var_and_type_node) == :range;
      ns = rule_seq_nodes(get_rule_match(var_and_type_node));
      var = var(get_lowercase_id(ns[0]));
      op = get_token(ns[1]);
      assert op == lower or op == lower_eq;
      inclusive = op == lower_eq;
      return range_comp(expr: expr, var: var, bound_expr: src_expr, inclusive: inclusive, sel_expr: value(sel_expr) if sel_expr != nil);
    ;
  }


  SynExpr build_if_else_expr_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 4;
    branches = [build_if_then_branch_ast(n) : n <- rep_rule_nodes(nodes[1])];
    else_expr = build_expr_ast(nodes[3]);
    return syn_if_expr(nonempty(branches), else_expr);

    (cond: SynExpr, expr: SynExpr) build_if_then_branch_ast(RuleMatch mtc)
    {
      nodes = rule_seq_nodes(mtc);
      assert length(nodes) == 3;
      cond = build_expr_ast(nodes[0]);
      expr = build_expr_ast(nodes[2]);
      return (expr: expr, cond: cond);
    }
  }

  SynExpr build_match_expr_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 3;
    exprs = [build_expr_ast(n) : n <- rep_rule_nodes(block_node(nodes[1]))];
    cases = [build_switch_case_ast(n) : n <- rep_rule_nodes(nodes[2])];
    return syn_try_expr(nonempty(exprs), nonempty(cases));
  }

  SynExpr build_proc_expr_ast(RuleMatch mtc) = syn_do_expr(build_stmts_ast(mtc));

  SynExpr build_fn_call_expr_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 2;
    fn_name = build_fn_symbol_ast(nodes[0]);

    nodes = rule_seq_nodes(block_node(nodes[1]));
    assert length(nodes) == 2;

    args = [build_expr_ast(rule_seq_nodes(n)[1]) : n <- rep_rule_nodes(nodes[0])];
    named_args = [build_actual_named_arg_ast(rule_seq_nodes(n)[1]) : n <- rep_rule_nodes(nodes[1])];

    return syn_fn_call(fn_name, nonempty(args), named_args);

    (NamedArg, [<var(Atom)>], SynExpr) build_actual_named_arg_ast(RuleMatch mtc)
    {
      nodes = rule_seq_nodes(mtc);
      assert length(nodes) == 4;

      name = named_arg(get_lowercase_id(nodes[0]));
      args = [var(get_lowercase_id(n)) : n <- rep_rule_nodes(block_node_or_null(nodes[1]))];
      expr = build_expr_ast(nodes[3]);

      return (name, args, expr);
    }
  }

  ////////////////////////////////////////////////////////////////////////////////

  SynSubExpr build_subexpr_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 2;
    expr = build_expr_ast(nodes[0]);
    return expr if nodes[1] == null_match;
    nodes = rule_seq_nodes(nodes[1]);
    assert length(nodes) == 2;
    assert get_lowercase_id(nodes[0]) == :if;
    cond = build_expr_ast(nodes[1]);
    return syn_cond_expr(expr, cond);
  }

  SynMapExprEntry build_map_entry_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 4;
    key = build_expr_ast(nodes[0]);
    value = build_expr_ast(nodes[2]);
    // return (key: key, value: value, cond: build_expr_ast(rule_seq_nodes(nodes[3])[1]) if nodes[3] != null_match); //## REENABLE
    return (key: key, value: value) if nodes[3] == null_match;
    cond_nodes = rule_seq_nodes(nodes[3]);
    cond = build_expr_ast(cond_nodes[1]);
    return (key: key, value: value, cond: cond);
  }

  SynMapExprEntry build_record_field_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 3;
    label = object(get_label(nodes[0]));
    expr = build_expr_ast(nodes[1]);
    return (key: label, value: expr) if nodes[2] == null_match;
    nodes = rule_seq_nodes(nodes[2]);
    assert get_lowercase_id(nodes[0]) == :if;
    cond = build_expr_ast(nodes[1]);
    return (key: label, value: expr, cond: cond);
  }

  ////////////////////////////////////////////////////////////////////////////////

  [SynStmt^] build_stmts_ast(RuleMatch mtc) = [build_stmt_ast(n) : n <- nonempty(rep_rule_nodes(mtc))];

  SynStmt build_stmt_ast(RuleMatch mtc)
  {
    inner_match = get_rule_match(mtc);
    stmt = match (get_rule_name(mtc))
      asgnm             = build_asgnm_stmt_ast(inner_match),
      ret               = build_ret_stmt_ast(inner_match),
      if_stmt           = build_if_stmt_ast(inner_match),
      loop_stmt         = build_loop_stmt_ast(inner_match),
      while_stmt        = build_while_stmt_ast(inner_match),
      let_stmt          = build_let_stmt_ast(inner_match),
      break_stmt        = build_break_stmt_ast(inner_match),
      for_stmt          = build_for_stmt_ast(inner_match),
      fail_stmt         = build_fail_stmt_ast(inner_match),
      assert_stmt       = build_assert_stmt_ast(inner_match),
      print_stmt        = build_print_stmt_ast(inner_match),
      imp_update        = build_imp_update_stmt(inner_match),
      fn                = syn_fn_def_stmt(build_std_fndef_ast(inner_match)),
      fn_proc           = syn_fn_def_stmt(build_proc_fndef_ast(inner_match)),
      fn_case           = syn_fn_def_stmt(build_switch_fndef_ast(inner_match)),
      no_val_ret        = build_no_val_ret_stmt_ast(inner_match),
      proc_call         = build_proc_call_stmt_ast(inner_match),
      auto_input_update = build_auto_input_update_stmt(inner_match);

    return attach_src_code_info(stmt, mtc);
  }

  SynStmt build_asgnm_stmt_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 6;
    assert nodes[0] == null_match;
    vars = [var(get_lowercase_id(n)) : n <- rep_rule_nodes(nodes[1])];
    assert vars != [];
    expr = build_expr_ast(nodes[3]);
    stmt = syn_asgnm_stmt(nonempty(vars), expr);
    return stmt if nodes[4] == null_match;
    cond = build_expr_ast(rule_seq_node(nodes[4], 1));
    return syn_if_stmt(cond, [stmt]);
  }

  SynStmt build_ret_stmt_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 4;
    expr = build_expr_ast(nodes[1]);
    stmt = syn_ret_stmt(expr);
    return stmt if nodes[2] == null_match;
    cond = build_expr_ast(rule_seq_node(nodes[2], 1));
    return syn_if_stmt(cond, [stmt]);
  }

  SynStmt build_if_stmt_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 6;
    cond = build_expr_ast(block_node(nodes[1]));
    stmts = build_stmts_ast(nodes[2]);
    branches = [(cond: cond, body: stmts)];
    for (n : rep_rule_nodes(nodes[3]))
      cond = build_expr_ast(block_node(rule_seq_node(n, 1)));
      stmts = build_stmts_ast(rule_seq_node(n, 2));
      branches = branches & [(cond: cond, body: stmts)];
    ;
    else_stmts = if nodes[4] != null_match then build_stmts_ast(rule_seq_node(nodes[4], 1)) else [];
    return syn_if_stmt(nonempty(branches), else_stmts);
  }

  SynStmt build_loop_stmt_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    stmts = build_stmts_ast(nodes[1]);
    return syn_inf_loop_stmt(stmts) if nodes[2] == null_match;
    cond = build_expr_ast(rule_seq_node(block_node(nodes[2]), 1));
    return syn_loop_stmt(cond, stmts, true);
  }

  SynStmt build_while_stmt_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    cond = build_expr_ast(block_node(nodes[1]));
    stmts = build_stmts_ast(nodes[2]);
    return syn_loop_stmt(cond, stmts);
  }

  SynStmt build_let_stmt_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    asgnms = [build_let_asgnm_ast(n) : n <- rep_rule_nodes(block_node(nodes[1]))];
    stmts = build_stmts_ast(nodes[2]);
    return syn_let_stmt(nonempty(asgnms), stmts);

    (NamedArg, SynExpr) build_let_asgnm_ast(RuleMatch mtc)
    {
      name = named_arg(get_lowercase_id(mtc, 0));
      expr = build_expr_ast(rule_seq_node(mtc, 2));
      return (name, expr);
    }
  }

  SynStmt build_break_stmt_ast(RuleMatch mtc)
  {
    if_node = rule_seq_node(mtc, 1);
    return break_stmt if if_node == null_match;
    cond = build_expr_ast(rule_seq_node(if_node, 1));
    return syn_if_stmt(cond, [break_stmt]);
  }

  SynStmt build_for_stmt_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    iters = [build_iter_ast(n) : n <- rep_rule_nodes(block_node(nodes[1]))];
    stmts = build_stmts_ast(nodes[2]);
    return syn_for_stmt(nonempty(iters), stmts);

    SynIter build_iter_ast(RuleMatch mtc)
    {
      if (get_rule_name(mtc) == :repeat)
        expr = build_expr_ast(get_rule_match(mtc));
        return range_iter(start_val: object(0), end_val: expr, end_val_incl: false);
      ;

      nodes = rule_seq_nodes(get_rule_match(mtc));

      if (get_rule_name(mtc) == :foreach)
        vars = [var(get_lowercase_id(n)) : n <- rep_rule_nodes(nodes[0])];
        expr = build_expr_ast(nodes[2]);
        return syn_seq_iter(nonempty(vars), expr);
      ;

      if (get_rule_name(mtc) == :foreach_idx)
        vars = [var(get_lowercase_id(n)) : n <- rep_rule_nodes(nodes[0])];
        idx_var = var(get_lowercase_id(nodes[2]));
        expr = build_expr_ast(nodes[4]);
        return syn_seq_iter(nonempty(vars), idx_var, expr);
      ;

      if (get_rule_name(mtc) == :for_upper)
        var = var(get_lowercase_id(nodes[0]));
        op = get_token(nodes[1]);
        assert op == lower or op == lower_eq;
        expr = build_expr_ast(nodes[2]);
        return range_iter(var: var, start_val: object(0), end_val: expr, end_val_incl: op == lower_eq);
      ;

      assert get_rule_name(mtc) == :for_range;
      var = var(get_lowercase_id(nodes[0]));
      start_expr = build_expr_ast(nodes[2]);
      range_type = get_token(nodes[3]);
      assert range_type == double_dot or range_type == triple_dot;
      end_expr = build_expr_ast(nodes[4]);
      return range_iter(var: var, start_val: start_expr, end_val: end_expr, end_val_incl: range_type == triple_dot);
    }
  }

  SynStmt build_fail_stmt_ast(RuleMatch mtc)
  {
    if_node = rule_seq_node(mtc, 1);
    return fail_stmt if if_node == null_match;
    cond = build_expr_ast(rule_seq_node(if_node, 1));
    return syn_if_stmt(cond, [fail_stmt]);
  }

  SynStmt build_assert_stmt_ast(RuleMatch mtc)
  {
    cond_node = rule_seq_node(mtc, 1);
    cond = build_expr_ast(cond_node);
    start_loc, end_loc = try_value(source_file_location(cond_node));
    start_line, start_col = start_loc;
    end_line, end_col = end_loc;
    if (start_line == end_line)
      cond_line = lines[start_line-1];
      cond_text = just(string(subseq(cond_line, start_col-1, end_col-start_col+1)));
    else
      cond_text = nil;
    ;
    return syn_assert_stmt(cond, filename, start_line, cond_text);
  }

  SynStmt build_print_stmt_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    expr = build_expr_ast(nodes[1]);
    stmt = syn_print_stmt(expr);
    return stmt if nodes[2] == null_match;
    cond = build_expr_ast(rule_seq_node(nodes[2], 1));
    return syn_if_stmt(cond, [stmt]);
  }

  SynStmt build_imp_update_stmt(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 5;
    var = var(get_lowercase_id(nodes[0]));
    idx_expr = build_expr_ast(block_node(nodes[1]));
    value_expr = build_expr_ast(nodes[3]);
    return syn_imp_update_stmt(var, idx_expr, value_expr);
  }

  SynStmt build_no_val_ret_stmt_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 3;

    if (nodes[1] == null_match)
      return return_stmt;
    else
      cond = build_expr_ast(rule_seq_node(nodes[1], 1));
      return syn_if_stmt(cond, [return_stmt]);
    ;
  }

  SynStmt build_proc_call_stmt_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 4;
    proc_name = proc_symbol(get_lowercase_id(nodes[1]));
    args = [build_expr_ast(n) : n <- rep_rule_nodes(block_node(nodes[2]))];
    return syn_proc_call(proc_name, args) if nodes[0] == null_match;
    var = var(get_lowercase_id(rule_seq_node(nodes[0], 0)));
    return syn_proc_call(var, proc_name, args);
  }

  SynStmt build_auto_input_update_stmt(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 4;
    auto_var = auto_var(get_lowercase_id(nodes[1]));
    inputs = [build_input_update(n) : n <- rep_rule_nodes(nodes[2])];
    return syn_auto_input_update_stmt(auto_var, nonempty(inputs));

    (input: Atom, value: SynExpr, cond: SynExpr?) build_input_update(RuleMatch mtc)
    {
      nodes = rule_seq_nodes(mtc);
      assert length(nodes) == 4;
      input = get_lowercase_id(nodes[0]);
      value = build_expr_ast(nodes[2]);
      cond_node = nodes[3];
      return (input: input, value: value) if cond_node == null_match;
      cond = build_expr_ast(rule_seq_nodes(cond_node)[1]);
      return (input: input, value: value, cond: cond);
    }
  }

  ////////////////////////////////////////////////////////////////////////////////

  SynClause build_clause_ast(RuleMatch mtc)
  {
    inner_mtc = get_rule_match(mtc);
    clause = match (get_rule_name(mtc))
      in      = build_set_elem_or_map_entry_clause_ast(inner_mtc),
      asgnm   = build_asgnm_clause_ast(inner_mtc),
      match   = build_match_clause_ast(inner_mtc),
      filter  = syn_filter_clause(build_expr_ast(inner_mtc));
    return attach_src_code_info(clause, mtc);
  }


  SynClause build_set_elem_or_map_entry_clause_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 4;
    var = var(get_lowercase_id(nodes[0]));
    expr = build_expr_ast(nodes[3]);
    return syn_set_elem_clause(var, expr) if nodes[1] == null_match;
    other_var = var(get_lowercase_id(rule_seq_node(nodes[1], 1)));
    return syn_map_entry_clause(other_var, var, expr);
  }

  SynClause build_asgnm_clause_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 3;
    var = var(get_lowercase_id(nodes[0]));
    expr = build_expr_ast(nodes[2]);
    return syn_asgnm_clause(var, expr);
  }

  SynClause build_match_clause_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 3;
    ptrn = build_ptrn_ast(nodes[0]);
    expr = build_expr_ast(nodes[2]);
    return syn_match_clause(ptrn, expr);
  }

  ////////////////////////////////////////////////////////////////////////////////

  SynPtrn build_ptrn_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    ptrn_match = nodes[0];
    var_match = nodes[1];
    ptrn = build_ptrn_ast(get_rule_name(ptrn_match), get_rule_match(ptrn_match));
    ptrn = syn_ptrn_var(var(get_lowercase_id(var_match, 0)), ptrn) if var_match != null_match;
    return attach_src_code_info(ptrn, mtc);
  }

  SynPtrn build_ptrn_ast(Atom name, RuleMatch mtc):
    type          = syn_ptrn_type(build_type_ast(mtc)),                     //rule_type
    tag_only      = syn_ptrn_tag_obj(get_lowercase_id(mtc, 0)),             //rule_seq([atomic_rule(lowercase_id), empty_block_rule(parenthesis)])
    tag_obj       = build_ptrn_tag_obj_ast(mtc),                            //rule_seq([atomic_rule(lowercase_id), par_rule(rule_ref_ptrn)])
    tag_obj_any   = build_ptrn_tag_obj_any_ast(mtc),                        //rule_seq([atomic_rule(lowercase_id), atomic_rule(at), atomic_rule(lowercase_id)])
    var           = syn_ptrn_var(var(get_lowercase_id(mtc, 0)), ptrn_any),  //rule_seq([atomic_rule(lowercase_id), atomic_rule(question_mark)])
    atom          = ptrn_symbol(get_lowercase_id(mtc)),                     //atomic_rule(lowercase_id)
    integer       = syn_ptrn_integer(get_integer(mtc, 1)),                  //rule_seq([optional_rule(atomic_rule(minus)), atomic_rule(integer)])
    float         = ptrn_float,                                             //atomic_rule(circumflex)
    atom_any      = ptrn_symbol,                                            //atomic_rule(plus)
    integer_any   = syn_ptrn_integer,                                       //atomic_rule(asterisk)
    any           = ptrn_any,                                               //atomic_rule(underscore)
    seq           = syn_ptrn_seq,                                           //bracket_rule(atomic_rule(triple_dot))
    set           = syn_ptrn_set,                                           //brace_rule(atomic_rule(triple_dot))
    map           = syn_ptrn_map;                                           //par_rule(atomic_rule(triple_dot))

  SynPtrn build_ptrn_tag_obj_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 2;
    tag_ptrn = ptrn_symbol(get_lowercase_id(nodes[0]));
    return syn_ptrn_tag_obj(tag_ptrn, build_ptrn_ast(block_node(nodes[1])));
  }

  SynPtrn build_ptrn_tag_obj_any_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 3;
    // tag_ptrn = ptrn_var(var(get_lowercase_id(nodes[0])), ptrn_symbol);
    tag_ptrn = ptrn_var(var: var(get_lowercase_id(nodes[0])), ptrn: :ptrn_symbol); //## BAD: REENABLE THE ABOVE VERSION ONE SUBSIGNATURES ARE IMPLEMENTED
    obj_ptrn = syn_ptrn_var(var(get_lowercase_id(nodes[2])), ptrn_any);
    return syn_ptrn_tag_obj(tag_ptrn, obj_ptrn);
  }

  ////////////////////////////////////////////////////////////////////////////////

  SynCase build_switch_case_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 3;
    ptrns = [build_ptrn_ast(n) : n <- rep_rule_nodes(nodes[0])];
    expr = build_expr_ast(nodes[2]);
    return syn_case(nonempty(ptrns), expr);
  }
  ////////////////////////////////////////////////////////////////////////////////

  [SynInputDecl] build_input_decl_asts(RuleMatch mtc)
  {
    nodes = rep_rule_nodes(rule_seq_nodes(mtc)[1]);
    return [build_input_decl_ast(n) : n <- nodes];

    SynInputDecl build_input_decl_ast(RuleMatch mtc)
    {
      nodes = rule_seq_nodes(mtc);
      assert length(nodes) == 2;
      type = build_type_ast(nodes[0]);
      name = get_lowercase_id(nodes[1]);
      return syn_input(name, type, false);
    }
  }

  [SynOutputDecl] build_output_decl_asts(RuleMatch mtc)
  {
    nodes = rep_rule_nodes(rule_seq_nodes(mtc)[1]);
    return [build_output_decl_ast(n) : n <- nodes];

    SynOutputDecl build_output_decl_ast(RuleMatch mtc)
    {
      nodes = rule_seq_nodes(mtc);
      assert length(nodes) == 2;
      type = build_type_ast(nodes[0]);
      name = get_lowercase_id(nodes[1]);
      return syn_output(name, type, false);
    }
  }

  [SynStateDecl] build_state_decl_asts(RuleMatch mtc)
  {
    nodes = rep_rule_nodes(rule_seq_nodes(mtc)[1]);
    return [build_state_decl_ast(n) : n <- nodes];

    SynStateDecl build_state_decl_ast(RuleMatch mtc)
    {
      nodes = rule_seq_nodes(mtc);
      assert length(nodes) == 4;
      type = build_type_ast(nodes[0]);
      name = get_lowercase_id(nodes[1]);
      default = build_expr_ast(nodes[3]);
      return syn_state(name, type, default);
    }
  }

  SynPlainRule build_plain_rule_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 4;
    name = get_lowercase_id(nodes[0]);
    expr = build_expr_ast(nodes[2]);
    return syn_plain_rule(name, expr);
  }

  SynCondRule build_cond_rule_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 4;
    name = get_lowercase_id(nodes[0]);
    branches = [build_branch_ast(n) : n <- rep_rule_nodes(nodes[2])];
    return syn_cond_rule(name, nonempty(branches));

    (expr: SynExpr, cond: SynExpr) build_branch_ast(RuleMatch mtc)
    {
      nodes = rule_seq_nodes(mtc);
      assert length(nodes) == 3;
      expr = build_expr_ast(nodes[0]);
      cond = build_expr_ast(nodes[2]);
      return (expr: expr, cond: cond);
    }
  }

  ////////////////////////////////////////////////////////////////////////////////

  [AutoDecl] build_auto_decls_ast(RuleMatch mtc)
  {
    inner_match = get_rule_match(mtc);
    decls = match (get_rule_name(mtc))
      input       = build_input_decl_asts(inner_match),
      output      = build_output_decl_asts(inner_match),
      state       = build_state_decl_asts(inner_match),
      plain_rule  = [build_plain_rule_ast(inner_match)],
      cond_rule   = [build_cond_rule_ast(inner_match)];
    return decls;
  }

  ////////////////////////////////////////////////////////////////////////////////

  SynAutoDef build_auto_def_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 4;
    name = get_lowercase_id(nodes[1]);
    pos_pars = if nodes[2] != null_match then [get_lowercase_id(n) : n <- rep_rule_nodes(block_node(nodes[2]))] else [];
    decls = join([build_auto_decls_ast(n) : n <- rep_rule_nodes(block_node(nodes[3]))]);
    return syn_auto_def(name, pos_pars, decls);
  }
}

////////////////////////////////////////////////////////////////////////////////

BasicTypeSymbol build_basic_type_symbol_ast(RuleMatch mtc) = type_symbol(get_lowercase_id(mtc));

////////////////////////////////////////////////////////////////////////////////

Operator token_to_operator(PlainToken):
  asterisk    = :star,
  slash       = :slash,
  plus        = :plus,
  minus       = :minus,
  ampersand   = :amp,
  lower       = :lower,
  greater     = :greater,
  lower_eq    = :lower_eq,
  greater_eq  = :greater_eq;

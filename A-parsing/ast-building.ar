[(PrgDecl, RuleMatch)] build_amber_file_ast(RuleMatch file) = [(build_declaration_ast(m), m) : m <- rep_rule_nodes(file)];

PrgDecl build_declaration_ast(RuleMatch decl) =
  match (get_rule_name(decl))
    typedef         = build_typedef_ast(get_rule_match(decl)),
    par_typedef     = build_par_typedef_ast(get_rule_match(decl)),
    fndef           = build_std_fndef_ast(get_rule_match(decl)),
    fndef_proc      = build_proc_fndef_ast(get_rule_match(decl)),
    fndef_switch    = build_switch_fndef_ast(get_rule_match(decl)),
    using_block_1   = build_using_block_1_ast(get_rule_match(decl)),
    using_block_2   = build_using_block_2_ast(get_rule_match(decl)),
    proc_def        = build_proc_def_ast(get_rule_match(decl));
  ;

////////////////////////////////////////////////////////////////////////////////

SynTypedef build_typedef_ast(RuleMatch typedef)
{
  nodes = rule_seq_nodes(typedef);
  assert is_annotated_token(nodes[0], lowercase_id(:type));
  name = build_basic_type_symbol_ast(nodes[1]);
  assert is_annotated_token(nodes[2], equals);
  pretypes = [build_pretype_ast(n) : n <- rep_rule_nodes(nodes[3])];
  assert is_annotated_token(nodes[4], semicolon);
  return syn_typedef(name, syn_union_type(nonempty(pretypes)));
}

SynParTypedef build_par_typedef_ast(RuleMatch par_typedef)
{
  nodes = rule_seq_nodes(par_typedef);
  assert is_annotated_token(nodes[0], lowercase_id(:type));
  name = build_basic_type_symbol_ast(nodes[1]);
  params = [build_type_var_ast(p) : p <- rep_rule_nodes(block_node(nodes[2]))];
  assert is_annotated_token(nodes[3], equals);
  pretypes = [build_pretype_ast(n) : n <- rep_rule_nodes(nodes[4])];
  assert is_annotated_token(nodes[5], semicolon);
  return syn_par_typedef(name, nonempty(params), syn_union_type(nonempty(pretypes)));
}

SynType build_pretype_ast(RuleMatch pretype) =
  match (get_rule_name(pretype))
    type              = build_type_ast(get_rule_match(pretype)),
    type_empty_set    = empty_set_type,
    type_empty_seq    = empty_seq_type,
    type_empty_map    = empty_map_type,
    type_tag_obj      = build_tag_obj_type_ast(get_rule_match(pretype)),
    type_tag_record   = build_tag_record_type_ast(get_rule_match(pretype)),
    type_symbol       = build_symbol_type(get_rule_match(pretype));
  ;

SynType build_type_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  basic_type_node = nodes[0];
  submatch = get_rule_match(basic_type_node);
  res_type = match (get_rule_name(basic_type_node))
                type_name         = build_type_ref_ast(submatch),
                type_name_par     = build_par_type_ref_ast(submatch),
                type_var          = build_type_var_ast(submatch),
                type_union        = build_type_union_ast(submatch),
                type_any_symbol   = atom_type,
                type_integer      = build_integer_type_ast(submatch),
                type_float        = float_type,
                type_seq          = build_seq_type_ast(submatch),
                type_map          = build_map_type_ast(submatch),
                type_record       = build_record_type_ast(submatch),
                type_tuple        = build_tuple_type_ast(submatch),
                type_any_tag_obj  = build_any_tag_obj_type(submatch);
              ;
  for (s : rep_rule_nodes(nodes[1]))
    res_type = syn_set_type(res_type, get_rule_name(s) == :ne_set);
  ;
  return res_type;
}

SynType build_tag_obj_type_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 2;
  tag_type = symb_type(object(get_lowercase_id(nodes[0])));
  obj_type = build_pretype_ast(block_node(nodes[1]));
  return syn_tag_obj_type(tag_type, obj_type);
}

SynType build_tag_record_type_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 2;
  tag_type = symb_type(object(get_lowercase_id(nodes[0])));
  obj_type = build_record_type_ast(nodes[1]);
  return syn_tag_obj_type(tag_type, obj_type);
}

SymbType build_symbol_type(RuleMatch mtc) = symb_type(get_lowercase_id(mtc));

SynType build_type_ref_ast(RuleMatch mtc) = syn_type_ref(type_symbol(get_lowercase_id(mtc)));

SynType build_par_type_ref_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 2;
  ts = type_symbol(get_lowercase_id(nodes[0]));
  ps = [build_type_ast(n) : n <- rep_rule_nodes(block_node(nodes[1]))];
  return syn_type_ref(ts, nonempty(ps));
}

TypeVar build_type_var_ast(RuleMatch mtc) = type_var(get_lowercase_id(mtc));

SynType build_type_union_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 3;
  types = [build_pretype_ast(n) : n <- rep_rule_nodes(nodes[1])];
  return syn_union_type(nonempty(types));
}

SynType build_integer_type_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(block_node(mtc));
  assert length(nodes) == 3;
  assert is_annotated_token(nodes[1], double_dot);
  min_node = nodes[0];
  max_node = nodes[2];
  min = bound(get_rule_name(min_node), get_rule_match(min_node));
  max = bound(get_rule_name(max_node), get_rule_match(max_node));
  return match (min, max)
           nil,   nil   = integer,
           nil,   *     = low_ints(max),
           *,     nil   = high_ints(min),
           *,     *     = syn_int_range(min, max);
         ;

  <Int, nil> bound(Atom bound_type, RuleMatch mtc):
    asterisk      = nil,
    integer       = get_integer(mtc),
    neg_integer   = -get_integer(mtc, 1),
    _             = {fail;};
}

SynType build_seq_type_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(block_node(mtc));
  assert length(nodes) == 2;
  elem_type = build_type_ast(nodes[0]);
  return syn_seq_type(elem_type, nodes[1] /= null_match);
}

SynType build_map_type_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(block_node(mtc));
  assert length(nodes) == 3;
  key_type = build_type_ast(nodes[0]);
  value_type = build_type_ast(nodes[2]);
  return syn_map_type(key_type, value_type);
}

SynRecordType build_record_type_ast(RuleMatch mtc)
{
  fields = [build_record_field_ast(n) : n <- rep_rule_nodes(block_node(mtc))];
  return syn_record_type(nonempty(fields));

  (label: SymbObj, type: SynType, optional: Bool) build_record_field_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 3;
    label = object(get_label(nodes[0]));
    type = build_pretype_ast(nodes[1]);
    optional = nodes[2] /= null_match;
    return (label: label, type: type, optional: optional);
  }
}

SynTupleType build_tuple_type_ast(RuleMatch mtc) =
  syn_tuple_type(nonempty([build_type_ast(n) : n <- rep_rule_nodes(block_node(mtc))]));

SynType build_any_tag_obj_type(RuleMatch mtc)
{
  nodes = rule_seq_nodes(block_node(mtc));
  assert length(nodes) == 3;
  obj_type = build_type_ast(nodes[2]);
  return syn_any_tag_obj_type(obj_type);
}

////////////////////////////////////////////////////////////////////////////////

Maybe[SynType] build_maybe_type_ast(RuleMatch mtc) = if mtc /= null_match then just(build_type_ast(mtc)) else nil;

////////////////////////////////////////////////////////////////////////////////

SynFnDef build_fndef_ast(RuleMatch mtc) =
  match (get_rule_name(mtc))
    std     = build_std_fndef_ast(get_rule_match(mtc)),
    proc    = build_proc_fndef_ast(get_rule_match(mtc)),
    switch  = build_switch_fndef_ast(get_rule_match(mtc));
  ;

SynFnDef build_std_fndef_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 6;
  ret_type  = build_maybe_type_ast(nodes[0]);
  fail if ret_type == nil; //## BAD BAD BAD
  return syn_fn_def(
    name:       build_fn_symbol_ast(nodes[1]),
    params:     build_fn_params_ast(nodes[2]),
    res_type:   value(ret_type),
    expr:       build_expr_ast(nodes[4]),
    local_fns:  []
  );
}

SynFnDef build_proc_fndef_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 4;
  ret_type = build_maybe_type_ast(nodes[0]);
  fail if ret_type == nil; //## BAD BAD BAD
  return syn_fn_def(
    name:       build_fn_symbol_ast(nodes[1]),
    params:     build_fn_params_ast(nodes[2]),
    res_type:   value(ret_type),
    expr:       build_proc_expr_ast(block_node(nodes[3])),
    local_fns:  []
  );
}

SynFnDef build_switch_fndef_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 6;
  ret_type = build_maybe_type_ast(nodes[0]);
  fail if ret_type == nil; //## BAD BAD BAD
  params = build_fn_params_ast(nodes[2]);
  cases = [build_switch_case_ast(n) : n <- rep_rule_nodes(nodes[4])];
  arity = syn_case_arity(cases[0]);
  expr = syn_try_expr(nonempty([fn_par(i) : i < arity]), nonempty(cases));
  return syn_fn_def(
    name:       build_fn_symbol_ast(nodes[1]),
    params:     params,
    res_type:   value(ret_type),
    expr:       expr,
    local_fns:  []
  );
}

SynUsingBlock build_using_block_1_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 3;
  return build_using_block_ast(nodes[1], block_node(nodes[2]));
}

SynUsingBlock build_using_block_2_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  nodes = rule_seq_nodes(block_node(nodes[1]));
  assert length(nodes) == 3;
  return build_using_block_ast(nodes[0], nodes[2]);
}

SynUsingBlock build_using_block_ast(RuleMatch signatures, RuleMatch fndefs) =
  syn_using_block(
    nonempty([build_signature_ast(n) : n  <- rep_rule_nodes(signatures)]),
    nonempty([build_fndef_ast(fd)    : fd <- rep_rule_nodes(fndefs)])
  );

SynSgn build_signature_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 3;
  return syn_sgn(
    named_par(get_lowercase_id(nodes[1])),
    [build_type_ast(t) : t <- rep_rule_nodes(block_node_or_null(nodes[2]))],
    build_type_ast(nodes[0])
  );
}

SynProcDef build_proc_def_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 3;

  if (get_rule_name(nodes[0]) == :ret_val)
    ns = rule_seq_nodes(get_rule_match(nodes[0]));
    assert length(ns) == 2;
    res_type = just(build_type_ast(ns[0]));
    name = proc_symbol(get_lowercase_id(ns[1]));
  else
    res_type = nil;
    name = proc_symbol(get_lowercase_id(get_rule_match(nodes[0])));
  ;

  params = [(type: build_type_ast(rule_seq_node(ns, 0)), var: var(get_lowercase_id(rule_seq_node(ns, 1)))) : ns <- rep_rule_nodes(block_node(nodes[1]))];
  body = [build_stmt_ast(n) : n <- rep_rule_nodes(block_node(nodes[2]))];

  return syn_proc_def(
    name:     name,
    params:   params,
    res_type: res_type,
    body:     body
  );
}

FnSymbol build_fn_symbol_ast(RuleMatch mtc) =
  match (get_token(mtc))
    lowercase_id(a?)  = fn_symbol(a),
    operator(op?)     = op_symbol(op);
  ;

[SynFnArg] build_fn_params_ast(RuleMatch mtc) = if mtc /= null_match then [build_fn_arg_ast(m) : m <- rep_rule_nodes(block_node(mtc))] else []; //## MAYBE rep_rule_nodes (AND seq_rule_nodes) SHOULD RETURN THE EMPTY SEQUENCE WHEN INVOKED WITH A null_match PARAMETER

SynFnArg build_fn_arg_ast(RuleMatch mtc) =
  match (get_rule_name(mtc))
    unknown   = {fail;}, //(),
    untyped   = {fail;}, //(var_name: get_lowercase_id(get_rule_match(mtc))),
    typed     = {
      nodes = rule_seq_nodes(get_rule_match(mtc));
      assert length(nodes) == 2;
      return (type: build_type_ast(nodes[0]), var_name: get_lowercase_id(nodes[1]) if nodes[1] /= null_match);
    },
    cls       = {
      nodes = rule_seq_nodes(get_rule_match(mtc));
      assert length(nodes) == 2;
      return (type: build_cls_type_ast(nodes[0]), var_name: get_lowercase_id(nodes[1]));
    };
  ;

SynClsType build_cls_type_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(block_node(mtc));
  assert length(nodes) == 3;
  in_types = [build_type_ast(n) : n <- rep_rule_nodes(nodes[0])];
  out_type = build_type_ast(nodes[2]);
  return syn_cls_type(nonempty(in_types), out_type);
}

////////////////////////////////////////////////////////////////////////////////

SynExpr build_expr_ast(RuleMatch mtc) = build_expr_10_ast(mtc);

SynExpr build_expr_10_ast(RuleMatch mtc)
{
  // ParsingRule rule_expr_10  = rule_seq([rule_expr_9, optional_rule(rule_seq([atomic_rule(at), rule_expr_9]))]);
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 2;
  expr = build_expr_9_ast(nodes[0]);
  return expr if nodes[1] == null_match;
  right_expr = build_expr_9_ast(rule_seq_node(nodes[1], 1));
  return attach_src_code_info(syn_tag_obj_expr(expr, right_expr), mtc);
}

SynExpr build_expr_9_ast(RuleMatch mtc)
{
  // ParsingRule rule_expr_9   = rep_rule(rule_expr_8, ops_prec_log, true, true);
  nodes = rep_rule_nodes(mtc);
  expr = build_expr_8_ast(nodes[0]);
  i = 1;
  while (i < length(nodes)) //## WOULD BE NICE TO HAVE A C-STYLE FOR LOOP HERE: for (i=0 ; i < length(nodes) ; i = i + 2). BUT EVEN THAT WOULD NOT BE IDEAL, BECAUSE THE length(nodes) EXPRESSION IS RECALCULATED EVERY TIME
    right_expr = build_expr_8_ast(nodes[i+1]);
    op = get_lowercase_id(nodes[i]);
    if (op == :and)
      expr = syn_and(expr, right_expr);
    else
      assert op == :or;
      expr = syn_or(expr, right_expr);
    ;
    i = i + 2;
  ;
  return attach_src_code_info(expr, mtc);
}

SynExpr build_expr_8_ast(RuleMatch mtc)
{
  // ParsingRule rule_expr_8   = rule_seq([rule_expr_7, optional_rule(rule_seq([ops_prec_eq, rule_expr_7]))]);
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 2;
  expr = build_expr_7_ast(nodes[0]);
  return expr if nodes[1] == null_match;
  nodes = rule_seq_nodes(nodes[1]);
  op = get_token(nodes[0]);
  right_expr = build_expr_7_ast(nodes[1]);
  if (op == :double_equals)
    expr = syn_eq(expr, right_expr);
  else
    assert op == :not_equal;
    expr = syn_neq(expr, right_expr);
  ;
  return attach_src_code_info(expr, mtc);
}

SynExpr build_expr_7_ast(RuleMatch mtc)
{
  // ParsingRule rule_expr_7   = rule_seq([rule_expr_6, optional_rule(rule_seq([ops_prec_ord, rule_expr_6]))]);
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 2;
  expr = build_expr_6_ast(nodes[0]);
  return expr if nodes[1] == null_match;
  nodes = rule_seq_nodes(nodes[1]);
  op = op_symbol(token_to_operator(get_token(nodes[0])));
  right_expr = build_expr_6_ast(nodes[1]);
  return attach_src_code_info(syn_fn_call(op, [expr, right_expr]), mtc);
}

SynExpr build_expr_6_ast(RuleMatch mtc)
{
  // ParsingRule rule_expr_6   = rep_rule(rule_expr_5, ops_prec_sum, true, true);
  nodes = rep_rule_nodes(mtc);
  expr = build_expr_5_ast(nodes[0]);
  i = 1;
  while (i < length(nodes)) //## WOULD BE NICE TO HAVE A C-STYLE FOR LOOP HERE: for (i=0 ; i < length(nodes) ; i = i + 2). BUT EVEN THAT WOULD NOT BE IDEAL, BECAUSE THE length(nodes) EXPRESSION IS RECALCULATED EVERY TIME
    op = op_symbol(token_to_operator(get_token(nodes[i])));
    right_expr = build_expr_5_ast(nodes[i+1]);
    expr = syn_fn_call(op, [expr, right_expr]);
    i = i + 2;
  ;
  return attach_src_code_info(expr, mtc);
}

SynExpr build_expr_5_ast(RuleMatch mtc)
{
  // ParsingRule rule_expr_5   = rep_rule(rule_expr_4, ops_prec_prod, true, true);
  nodes = rep_rule_nodes(mtc);
  expr = build_expr_4_ast(nodes[0]);
  i = 1;
  while (i < length(nodes)) //## WOULD BE NICE TO HAVE A C-STYLE FOR LOOP HERE: for (i=0 ; i < length(nodes) ; i = i + 2). BUT EVEN THAT WOULD NOT BE IDEAL, BECAUSE THE length(nodes) EXPRESSION IS RECALCULATED EVERY TIME
    op = op_symbol(token_to_operator(get_token(nodes[i])));
    right_expr = build_expr_4_ast(nodes[i+1]);
    expr = syn_fn_call(op, [expr, right_expr]);
    i = i + 2;
  ;
  return attach_src_code_info(expr, mtc);
}

SynExpr build_expr_4_ast(RuleMatch mtc)
{
  // ParsingRule rule_expr_4   = rule_seq([optional_rule(rule_anon_choice([atomic_rule(minus), keyword_not])), rule_expr_3]);
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 2;
  expr = build_expr_3_ast(nodes[1]);
  prefix = nodes[0];
  if (prefix /= null_match)
    op = annotated_token(prefix).token;
    if (op == :minus)
      expr = syn_fn_call(op_symbol(:minus), [expr]);
    else
      assert op == lowercase_id(:not);
      expr = syn_not(expr);
    ;
  ;
  return attach_src_code_info(expr, mtc);
}

SynExpr build_expr_3_ast(RuleMatch mtc)
{
  // ParsingRule rule_expr_3   = rep_rule(rule_expr_2, atomic_rule(circumflex), true, false);
  nodes = rep_rule_nodes(mtc);
  expr = build_expr_2_ast(last(nonempty(nodes)));
  i = length(nodes) - 2;
  while (i >= 0)
    left_expr = build_expr_2_ast(nodes[i]);
    expr = syn_fn_call(op_symbol(:exp), [left_expr, expr]);
    i = i - 1;
  ;
  return attach_src_code_info(expr, mtc);
}

SynExpr build_expr_2_ast(RuleMatch mtc)
{
  // ParsingRule rule_expr_2   = rule_seq([rule_expr_1, optional_rule(rule_seq([atomic_rule(double_colon), rule_type]))]);
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 2;
  expr = build_expr_1_ast(nodes[0]);
  return expr if nodes[1] == null_match;
  type = build_type_ast(rule_seq_node(nodes[1], 1));
  return attach_src_code_info(syn_membership(expr, type), mtc);
}

SynExpr build_expr_1_ast(RuleMatch mtc)
{
  // ParsingRule rule_expr_1   = rule_seq([rule_expr_0, rep_rule(rule_dot_or_sub), optional_rule(rule_dot_access(true))]);
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 3;
  expr = build_expr_0_ast(nodes[0]);
  for (r : rep_rule_nodes(nodes[1]))
    if (get_rule_name(r) == :dot)
      field = get_lowercase_id(get_rule_match(r), 1);
      expr = syn_accessor(expr, field);
    else
      assert get_rule_name(r) == :sub;
      idx_expr = build_expr_ast(block_node(get_rule_match(r)));
      expr = syn_fn_call(op_symbol(:brackets), [expr, idx_expr]);
    ;
  ;
  if (nodes[2] /= null_match)
    field = get_lowercase_id(nodes[2], 1);
    expr = syn_accessor_test(expr, field);
  ;
  return attach_src_code_info(expr, mtc);
}

SynExpr build_expr_0_ast(RuleMatch mtc)
{
  expr = match (get_rule_name(mtc))
    tag_obj       = build_tag_obj_expr_ast(get_rule_match(mtc)),                  // rule_seq([atomic_rule(qualified_symbol), par_rule(rule_ref_expr)])
    integer       = object(get_integer(get_rule_match(mtc))),                     // atomic_rule(integer)
    symbol        = object(get_qualified_symbol(get_rule_match(mtc))),            // atomic_rule(qualified_symbol)
    string        = build_string_expr_ast(get_rule_match(mtc)),                   // atomic_rule(string)
    float         = get_float_lit(get_rule_match(mtc)),                           // atomic_rule(float)
    true          = object(true),                                                 // atomic_rule(keyword(true))
    false         = object(false),                                                // atomic_rule(keyword(false))
    nil           = object(nil),                                                  // atomic_rule(keyword(nil))
    set           = build_set_expr_ast(block_node(get_rule_match(mtc))),          // brace_rule(opt_comma_sep_seq(rule_subexpr))
    map           = build_map_expr_ast(get_rule_match(mtc)),                      // par_rule(opt_comma_sep_seq(rule_map_entry))
    record        = build_record_expr_ast(get_rule_match(mtc)),                   // rule_record_expr
    seq           = build_seq_expr_ast(get_rule_match(mtc)),                      // rule_seq_expr
    seq_tail      = build_seq_tail_expr_ast(get_rule_match(mtc)),                 // rule_seq_tail_expr
    tag_record    = build_tag_record_expr_ast(get_rule_match(mtc)),               // rule_tag_record_expr
    builtin_call  = build_builtin_call_expr_ast(get_rule_match(mtc)),             // rule_seq([atomic_rule(builtin), par_rule(comma_sep_seq(rule_ref_expr))])
    par_exprs     = build_tuple_or_par_expr_ast(block_node(get_rule_match(mtc))), // par_rule(comma_sep_seq(rule_ref_expr))
    ex_qual       = build_ex_qual_expr_ast(get_rule_match(mtc)),                  // rule_ex_qual_expr
    set_cp        = build_set_cp_expr_ast(block_node(get_rule_match(mtc))),       // rule_set_cp_expr
    map_cp        = build_map_cp_expr_ast(get_rule_match(mtc)),                   // rule_map_cp_expr
    seq_cp        = build_seq_cp_expr_ast(get_rule_match(mtc)),                   // rule_seq_cp_expr
    alt_cp        = build_alt_cp_expr_ast(get_rule_match(mtc)),                   // rule_alt_cp_expr
    if_else       = build_if_else_expr_ast(get_rule_match(mtc)),                  // rule_if_expr
    match_expr    = build_match_expr_ast(get_rule_match(mtc)),                    // rule_match_expr
    proc          = build_proc_expr_ast(block_node(get_rule_match(mtc))),         // brace_rule(rep_rule(rule_ref_stmt, true))
    fn_call       = build_fn_call_expr_ast(get_rule_match(mtc)),                  // rule_fn_call_expr
    const_or_var  = const_or_var(get_lowercase_id(get_rule_match(mtc))),          // rule_id
    cls_par       = cls_par(get_cls_par_idx(get_rule_match(mtc)));                // atomic_rule(qual_var))
  ;
  return attach_src_code_info(expr, mtc);
}

SynTagObjExpr build_tag_obj_expr_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 2;
  return syn_tag_obj_expr(object(get_qualified_symbol(nodes[0])), build_expr_ast(block_node(nodes[1])));
}

SynSetExpr build_set_expr_ast(RuleMatch mtc) = syn_set_expr([build_subexpr_ast(n) : n <- rep_rule_nodes(mtc)]);

SynSeqExpr build_seq_expr_ast(RuleMatch mtc) = syn_seq_expr([build_subexpr_ast(n) : n <- rep_rule_nodes(block_node(mtc))]);

SynSeqExpr build_seq_tail_expr_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(block_node(mtc));
  assert length(nodes) == 2;
  seq_expr = build_expr_ast(nodes[0]);
  tail_exprs = [build_expr_ast(n) : n <- rep_rule_nodes(rule_seq_node(nodes[1], 1))];
  return syn_seq_tail_expr(seq_expr, nonempty(tail_exprs));
}

SynExpr build_tuple_or_par_expr_ast(RuleMatch mtc)
{
  exprs = nonempty([build_expr_ast(n) : n <- rep_rule_nodes(mtc)]);
  return if length(exprs) == 1 then exprs[0] else syn_tuple_expr(exprs);
}

SynMapExpr build_map_expr_ast(RuleMatch mtc) = syn_map_expr([build_map_entry_ast(n) : n <- rep_rule_nodes(block_node(mtc))]);

SynMapExpr build_record_expr_ast(RuleMatch mtc) = syn_map_expr([build_record_field_ast(n) : n <- rep_rule_nodes(block_node(mtc))]);

SynTagObjExpr build_tag_record_expr_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 2;
  tag = object(get_lowercase_id(nodes[0]));
  obj = build_record_expr_ast(nodes[1]);
  return syn_tag_obj_expr(tag, obj);
}

SynExpr build_string_expr_ast(RuleMatch mtc) = syn_tag_obj_expr(object(:string), syn_seq_expr([object(ch) : ch <- _obj_(get_string(mtc))]));

SynExpr build_builtin_call_expr_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 2;
  builtin = get_builtin(nodes[0]);
  params = [build_expr_ast(n) : n <- rep_rule_nodes(block_node(nodes[1]))];
  return syn_builtin_call(builtin, nonempty(params));
}

SynExpr build_ex_qual_expr_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(block_node(mtc));
  assert length(nodes) == 3;
  clauses = [build_clause_ast(n) : n <- rep_rule_nodes(nodes[1])];
  exprs = build_sel_expr_asts(nodes[2]);
  return syn_ex_qual(nonempty(clauses), exprs);
}

SynExpr build_set_cp_expr_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 4;
  expr = build_expr_ast(nodes[0]);
  clauses = [build_clause_ast(n) : n <- rep_rule_nodes(nodes[2])];
  exprs = build_sel_expr_asts(nodes[3]);
  return syn_set_comp(expr, nonempty(clauses), exprs);
}

SynExpr build_map_cp_expr_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(block_node(mtc));
  assert length(nodes) == 6;
  key_expr = build_expr_ast(nodes[0]);
  value_expr = build_expr_ast(nodes[2]);
  clauses = [build_clause_ast(n) : n <- rep_rule_nodes(nodes[4])];
  exprs = build_sel_expr_asts(nodes[5]);
  return syn_map_comp(key_expr, value_expr, nonempty(clauses), exprs);
}

<SynLCExpr, SynRCExpr> build_seq_cp_expr_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(block_node(mtc));
  assert length(nodes) == 5;

  expr     = build_expr_ast(nodes[0]);

  src_expr = build_expr_ast(nodes[3]);

  if (nodes[4] /= null_match)
    ns = rule_seq_nodes(nodes[4]);
    sel_expr = just(build_expr_ast(ns[1]));
  else
    sel_expr = nil;
  ;

  var_and_type_node = nodes[2];
  if (get_rule_name(var_and_type_node) == :seq)
    ns = rule_seq_nodes(get_rule_match(var_and_type_node));
    vars = [var(get_lowercase_id(n)) : n <- rep_rule_nodes(ns[0])];
    if (ns[1] /= null_match)
      sub_ns = rule_seq_nodes(ns[1]);
      idx_var = just(var(get_lowercase_id(sub_ns[1])));
    else
      idx_var = nil;
    ;
    return seq_comp(
      expr:       expr,
      vars:       nonempty(vars),
      idx_var:    value(idx_var) if idx_var /= nil,
      src_expr:   src_expr,
      sel_expr:   value(sel_expr) if sel_expr /= nil
    );

  else
    assert get_rule_name(var_and_type_node) == :range;
    ns = rule_seq_nodes(get_rule_match(var_and_type_node));
    var = var(get_lowercase_id(ns[0]));
    op = get_token(ns[1]);
    assert op == lower or op == lower_eq;
    inclusive = op == lower_eq;
    return range_comp(expr: expr, var: var, bound_expr: src_expr, inclusive: inclusive, sel_expr: value(sel_expr) if sel_expr /= nil);
  ;
}

SynExpr build_alt_cp_expr_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 4;
  clauses = [build_clause_ast(n) : n <- rep_rule_nodes(block_node(nodes[1]))];
  if (nodes[2] == null_match)
    exprs = [];
  else
    ns = rule_seq_nodes(nodes[2]);
    exprs = [build_expr_ast(n) : n <- rep_rule_nodes(block_node(ns[1]))];
  ;
  expr_match = block_node(get_rule_match(nodes[3]));
  if (get_rule_name(nodes[3]) == :set)
    return syn_set_comp(build_expr_ast(expr_match), nonempty(clauses), exprs);
  else
    key_expr = build_expr_ast(rule_seq_node(expr_match, 0));
    value_expr = build_expr_ast(rule_seq_node(expr_match, 2));
    return syn_map_comp(key_expr, value_expr, nonempty(clauses), exprs);
  ;
}

SynExpr build_if_else_expr_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 4;
  branches = [build_if_then_branch_ast(n) : n <- rep_rule_nodes(nodes[1])];
  else_expr = build_expr_ast(nodes[3]);
  return syn_if_expr(nonempty(branches), else_expr);

  (cond: SynExpr, expr: SynExpr) build_if_then_branch_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 3;
    cond = build_expr_ast(nodes[0]);
    expr = build_expr_ast(nodes[2]);
    return (expr: expr, cond: cond);
  }
}

SynExpr build_match_expr_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 4;
  exprs = [build_expr_ast(n) : n <- rep_rule_nodes(block_node(nodes[1]))];
  cases = [build_switch_case_ast(n) : n <- rep_rule_nodes(nodes[2])];
  return syn_try_expr(nonempty(exprs), nonempty(cases));
}

SynExpr build_proc_expr_ast(RuleMatch mtc) = syn_do_expr(build_stmts_ast(mtc));

SynExpr build_fn_call_expr_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 2;
  fn_name = build_fn_symbol_ast(nodes[0]);

  nodes = rule_seq_nodes(block_node(nodes[1]));
  assert length(nodes) == 2;

  params = [build_expr_ast(rule_seq_nodes(n)[1]) : n <- rep_rule_nodes(nodes[0])];
  named_pars = [build_actual_named_par_ast(rule_seq_nodes(n)[1]) : n <- rep_rule_nodes(nodes[1])];

  return syn_fn_call(fn_name, nonempty(params), named_pars);

  (NamedPar, [<var(Atom)>], SynExpr) build_actual_named_par_ast(RuleMatch mtc)
  {
    nodes = rule_seq_nodes(mtc);
    assert length(nodes) == 4;

    name = named_par(get_lowercase_id(nodes[0]));
    params = [var(get_lowercase_id(n)) : n <- rep_rule_nodes(block_node_or_null(nodes[1]))];
    expr = build_expr_ast(nodes[3]);

    return (name, params, expr);
  }
}

////////////////////////////////////////////////////////////////////////////////

SynSubExpr build_subexpr_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 2;
  expr = build_expr_ast(nodes[0]);
  return expr if nodes[1] == null_match;
  nodes = rule_seq_nodes(nodes[1]);
  assert length(nodes) == 2;
  assert get_lowercase_id(nodes[0]) == :if;
  cond = build_expr_ast(nodes[1]);
  return syn_cond_expr(expr, cond);
}

SynMapExprEntry build_map_entry_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 4;
  key = build_expr_ast(nodes[0]);
  value = build_expr_ast(nodes[2]);
  // return (key: key, value: value, cond: build_expr_ast(rule_seq_nodes(nodes[3])[1]) if nodes[3] /= null_match); //## REENABLE
  return (key: key, value: value) if nodes[3] == null_match;
  cond_nodes = rule_seq_nodes(nodes[3]);
  cond = build_expr_ast(cond_nodes[1]);
  return (key: key, value: value, cond: cond);
}

SynMapExprEntry build_record_field_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 3;
  label = object(get_label(nodes[0]));
  expr = build_expr_ast(nodes[1]);
  return (key: label, value: expr) if nodes[2] == null_match;
  nodes = rule_seq_nodes(nodes[2]);
  assert get_lowercase_id(nodes[0]) == :if;
  cond = build_expr_ast(nodes[1]);
  return (key: label, value: expr, cond: cond);
}

//## THIS FUNCTION IS EXTREMELY SPECIAL-PURPOSE, THINK OF A MORE SPECIFIC NAME.
[SynExpr] build_sel_expr_asts(RuleMatch mtc)
{
  return [] if mtc == null_match;
  nodes = rule_seq_nodes(mtc);
  return [build_expr_ast(n) : n <- rep_rule_nodes(nodes[1])];
}

////////////////////////////////////////////////////////////////////////////////

[SynStmt^] build_stmts_ast(RuleMatch mtc) = [build_stmt_ast(n) : n <- rep_rule_nodes(mtc)];

SynStmt build_stmt_ast(RuleMatch mtc)
{
  stmt = match (get_rule_name(mtc))
    asgnm       = build_asgnm_stmt_ast(get_rule_match(mtc)),
    ret         = build_ret_stmt_ast(get_rule_match(mtc)),
    if_stmt     = build_if_stmt_ast(get_rule_match(mtc)),
    loop_stmt   = build_loop_stmt_ast(get_rule_match(mtc)),
    while_stmt  = build_while_stmt_ast(get_rule_match(mtc)),
    let_stmt    = build_let_stmt_ast(get_rule_match(mtc)),
    break_stmt  = build_break_stmt_ast(get_rule_match(mtc)),
    for_stmt    = build_for_stmt_ast(get_rule_match(mtc)),
    fail_stmt   = build_fail_stmt_ast(get_rule_match(mtc)),
    assert_stmt = build_assert_stmt_ast(get_rule_match(mtc)),
    print_stmt  = build_print_stmt_ast(get_rule_match(mtc)),
    imp_update  = build_imp_update_stmt(get_rule_match(mtc)),
    fn          = syn_fn_def_stmt(build_std_fndef_ast(get_rule_match(mtc))),
    fn_proc     = syn_fn_def_stmt(build_proc_fndef_ast(get_rule_match(mtc))),
    fn_case     = syn_fn_def_stmt(build_switch_fndef_ast(get_rule_match(mtc))),
    no_val_ret  = build_no_val_ret_stmt_ast(get_rule_match(mtc)),
    proc_call   = build_proc_call_stmt_ast(get_rule_match(mtc));
  ;
  return attach_src_code_info(stmt, mtc);
}

SynStmt build_asgnm_stmt_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 6;
  assert nodes[0] == null_match;
  vars = [var(get_lowercase_id(n)) : n <- rep_rule_nodes(nodes[1])];
  assert vars /= [];
  expr = build_expr_ast(nodes[3]);
  stmt = syn_asgnm_stmt(nonempty(vars), expr);
  return stmt if nodes[4] == null_match;
  cond = build_expr_ast(rule_seq_node(nodes[4], 1));
  return syn_if_stmt(cond, [stmt]);
}

SynStmt build_ret_stmt_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 4;
  expr = build_expr_ast(nodes[1]);
  stmt = syn_ret_stmt(expr);
  return stmt if nodes[2] == null_match;
  cond = build_expr_ast(rule_seq_node(nodes[2], 1));
  return syn_if_stmt(cond, [stmt]);
}

SynStmt build_if_stmt_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 6;
  cond = build_expr_ast(block_node(nodes[1]));
  stmts = build_stmts_ast(nodes[2]);
  branches = [(cond: cond, body: stmts)];
  for (n : rep_rule_nodes(nodes[3]))
    cond = build_expr_ast(block_node(rule_seq_node(n, 1)));
    stmts = build_stmts_ast(rule_seq_node(n, 2));
    branches = branches & [(cond: cond, body: stmts)];
  ;
  else_stmts = if nodes[4] /= null_match then build_stmts_ast(rule_seq_node(nodes[4], 1)) else [];
  return syn_if_stmt(nonempty(branches), else_stmts);
}

SynStmt build_loop_stmt_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  stmts = build_stmts_ast(nodes[1]);
  return syn_inf_loop_stmt(stmts) if nodes[2] == null_match;
  cond = build_expr_ast(rule_seq_node(block_node(nodes[2]), 1));
  return syn_loop_stmt(cond, stmts, true);
}

SynStmt build_while_stmt_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  cond = build_expr_ast(block_node(nodes[1]));
  stmts = build_stmts_ast(nodes[2]);
  return syn_loop_stmt(cond, stmts);
}

SynStmt build_let_stmt_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  asgnms = [build_let_asgnm_ast(n) : n <- rep_rule_nodes(block_node(nodes[1]))];
  stmts = build_stmts_ast(nodes[2]);
  return syn_let_stmt(nonempty(asgnms), stmts);

  (NamedPar, SynExpr) build_let_asgnm_ast(RuleMatch mtc)
  {
    name = named_par(get_lowercase_id(mtc, 0));
    expr = build_expr_ast(rule_seq_node(mtc, 2));
    return (name, expr);
  }
}

SynStmt build_break_stmt_ast(RuleMatch mtc)
{
  if_node = rule_seq_node(mtc, 1);
  return break_stmt if if_node == null_match;
  cond = build_expr_ast(rule_seq_node(if_node, 1));
  return syn_if_stmt(cond, [break_stmt]);
}

SynStmt build_for_stmt_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  iters = [build_iter_ast(n) : n <- rep_rule_nodes(block_node(nodes[1]))];
  stmts = build_stmts_ast(nodes[2]);
  return syn_for_stmt(nonempty(iters), stmts);

  SynIter build_iter_ast(RuleMatch mtc)
  {
    if (get_rule_name(mtc) == :repeat)
      expr = build_expr_ast(get_rule_match(mtc));
      return range_iter(start_val: object(0), end_val: expr, end_val_incl: false);
    ;

    nodes = rule_seq_nodes(get_rule_match(mtc));

    if (get_rule_name(mtc) == :foreach)
      vars = [var(get_lowercase_id(n)) : n <- rep_rule_nodes(nodes[0])];
      expr = build_expr_ast(nodes[2]);
      return syn_seq_iter(nonempty(vars), expr);
    ;

    if (get_rule_name(mtc) == :foreach_idx)
      vars = [var(get_lowercase_id(n)) : n <- rep_rule_nodes(nodes[0])];
      idx_var = var(get_lowercase_id(nodes[2]));
      expr = build_expr_ast(nodes[4]);
      return syn_seq_iter(nonempty(vars), idx_var, expr);
    ;

    if (get_rule_name(mtc) == :for_upper)
      var = var(get_lowercase_id(nodes[0]));
      op = get_token(nodes[1]);
      assert op == lower or op == lower_eq;
      expr = build_expr_ast(nodes[2]);
      return range_iter(var: var, start_val: object(0), end_val: expr, end_val_incl: op == lower_eq);
    ;

    assert get_rule_name(mtc) == :for_range;
    var = var(get_lowercase_id(nodes[0]));
    start_expr = build_expr_ast(nodes[2]);
    range_type = get_token(nodes[3]);
    assert range_type == double_dot or range_type == triple_dot;
    end_expr = build_expr_ast(nodes[4]);
    return range_iter(var: var, start_val: start_expr, end_val: end_expr, end_val_incl: range_type == triple_dot);
  }
}

SynStmt build_fail_stmt_ast(RuleMatch mtc)
{
  if_node = rule_seq_node(mtc, 1);
  return fail_stmt if if_node == null_match;
  cond = build_expr_ast(rule_seq_node(if_node, 1));
  return syn_if_stmt(cond, [fail_stmt]);
}

SynStmt build_assert_stmt_ast(RuleMatch mtc) = syn_assert_stmt(build_expr_ast(rule_seq_node(mtc, 1)));

SynStmt build_print_stmt_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  expr = build_expr_ast(nodes[1]);
  stmt = syn_print_stmt(expr);
  return stmt if nodes[2] == null_match;
  cond = build_expr_ast(rule_seq_node(nodes[2], 1));
  return syn_if_stmt(cond, [stmt]);
}

SynStmt build_imp_update_stmt(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 5;
  var = var(get_lowercase_id(nodes[0]));
  idx_expr = build_expr_ast(block_node(nodes[1]));
  value_expr = build_expr_ast(nodes[3]);
  return syn_imp_update_stmt(var, idx_expr, value_expr);
}

SynStmt build_no_val_ret_stmt_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 3;

  if (nodes[1] == null_match)
    return return_stmt;
  else
    cond = build_expr_ast(rule_seq_node(nodes[1], 1));
    return syn_if_stmt(cond, [return_stmt]);
  ;
}

SynStmt build_proc_call_stmt_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 4;
  proc_name = proc_symbol(get_lowercase_id(nodes[1]));
  params = [build_expr_ast(n) : n <- rep_rule_nodes(block_node(nodes[2]))];
  return syn_proc_call(proc_name, params) if nodes[0] == null_match;
  var = var(get_lowercase_id(rule_seq_node(nodes[0], 0)));
  return syn_proc_call(var, proc_name, params);
}

////////////////////////////////////////////////////////////////////////////////

SynClause build_clause_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(get_rule_match(mtc));
  if (get_rule_name(mtc) == :eq)
    var  = var(get_lowercase_id(get_rule_match(mtc), 0));
    expr = build_expr_ast(rule_seq_node(get_rule_match(mtc), 2));
    return attach_src_code_info(syn_eq_clause(var, expr), mtc);
  ;
  assert get_rule_name(mtc) == :in;
  ptrn = build_clause_ptrn_ast(nodes[0]);
  expr = build_expr_ast(nodes[3]);
  return attach_src_code_info(syn_in_clause(ptrn, expr), mtc) if nodes[1] == null_match;
  nodes = rule_seq_nodes(nodes[1]);
  value_ptrn = build_clause_ptrn_ast(nodes[1]);
  return attach_src_code_info(syn_map_in_clause(ptrn, value_ptrn, expr), mtc);
}

////////////////////////////////////////////////////////////////////////////////

SynPtrn build_clause_ptrn_ast(RuleMatch mtc)
{
  ptrn = match (get_rule_name(mtc))
    // atomic_rule(underscore)
    any       = ptrn_any,
    // rule_seq([atomic_rule(lowercase_id), empty_block_rule(parenthesis), atomic_rule(lowercase_id)])
    tag_var   = syn_ptrn_var(var(get_lowercase_id(get_rule_match(mtc), 2)), syn_ptrn_tag_obj(get_lowercase_id(get_rule_match(mtc), 0))),
    // rule_seq([atomic_rule(lowercase_id), empty_block_rule(parenthesis)])
    tag_only  = syn_ptrn_tag_obj(get_lowercase_id(get_rule_match(mtc), 0)),
    // rule_seq([atomic_rule(lowercase_id), par_rule(atomic_rule(lowercase_id))])
    tag_obj   = build_tag_obj_clause_ptrn_ast(get_rule_match(mtc)),
    // atomic_rule(lowercase_id)
    var       = syn_ptrn_var(var(get_lowercase_id(get_rule_match(mtc))), ptrn_any);
  ;
  return attach_src_code_info(ptrn, mtc);
}

SynPtrn build_tag_obj_clause_ptrn_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  tag_symb = get_lowercase_id(nodes[0]);
  var_symb = get_lowercase_id(block_node(nodes[1]));
  return syn_ptrn_tag_obj(ptrn_symbol(tag_symb), syn_ptrn_var(var(var_symb), ptrn_any));
}

////////////////////////////////////////////////////////////////////////////////

SynPtrn build_switch_ptrn_ast(RuleMatch mtc)  //## build_try_ptrn_ast? build_match_ptrn_ast?
{
  nodes = rule_seq_nodes(mtc);
  ptrn_match = nodes[0];
  var_match = nodes[1];
  ptrn = build_switch_ptrn_ast(get_rule_name(ptrn_match), get_rule_match(ptrn_match));
  ptrn = syn_ptrn_var(var(get_lowercase_id(var_match, 0)), ptrn) if var_match /= null_match;
  return attach_src_code_info(ptrn, mtc);
}

SynPtrn build_switch_ptrn_ast(Atom name, RuleMatch mtc):  //## build_try_ptrn_ast? build_match_ptrn_ast?
  type          = syn_ptrn_type(build_type_ast(mtc)),                     //rule_type
  tag_only      = syn_ptrn_tag_obj(get_lowercase_id(mtc, 0)),             //rule_seq([atomic_rule(lowercase_id), empty_block_rule(parenthesis)])
  tag_obj       = build_switch_ptrn_tag_obj_ast(mtc),                     //rule_seq([atomic_rule(lowercase_id), par_rule(rule_ref_ptrn)])
  tag_obj_any   = build_switch_ptrn_tag_obj_any_ast(mtc),                 //rule_seq([atomic_rule(lowercase_id), atomic_rule(at), atomic_rule(lowercase_id)])
  var           = syn_ptrn_var(var(get_lowercase_id(mtc, 0)), ptrn_any),  //rule_seq([atomic_rule(lowercase_id), atomic_rule(question_mark)])
  atom          = ptrn_symbol(get_lowercase_id(mtc)),                     //atomic_rule(lowercase_id)
  integer       = syn_ptrn_integer(get_integer(mtc, 1)),                  //rule_seq([optional_rule(atomic_rule(minus)), atomic_rule(integer)])
  float         = ptrn_float,                                             //atomic_rule(circumflex)
  atom_any      = ptrn_symbol,                                            //atomic_rule(plus)
  integer_any   = syn_ptrn_integer,                                       //atomic_rule(asterisk)
  any           = ptrn_any,                                               //atomic_rule(underscore)
  seq           = syn_ptrn_seq,                                           //bracket_rule(atomic_rule(triple_dot))
  set           = syn_ptrn_set,                                           //brace_rule(atomic_rule(triple_dot))
  map           = syn_ptrn_map;                                           //par_rule(atomic_rule(triple_dot))

SynPtrn build_switch_ptrn_tag_obj_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 2;
  tag_ptrn = ptrn_symbol(get_lowercase_id(nodes[0]));
  return syn_ptrn_tag_obj(tag_ptrn, build_switch_ptrn_ast(block_node(nodes[1])));
}

SynPtrn build_switch_ptrn_tag_obj_any_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 3;
  // tag_ptrn = ptrn_var(var(get_lowercase_id(nodes[0])), ptrn_symbol);
  tag_ptrn = ptrn_var(var: var(get_lowercase_id(nodes[0])), ptrn: :ptrn_symbol); //## BAD: REENABLE THE ABOVE VERSION ONE SUBSIGNATURES ARE IMPLEMENTED
  obj_ptrn = syn_ptrn_var(var(get_lowercase_id(nodes[2])), ptrn_any);
  return syn_ptrn_tag_obj(tag_ptrn, obj_ptrn);
}

////////////////////////////////////////////////////////////////////////////////

SynCase build_switch_case_ast(RuleMatch mtc)
{
  nodes = rule_seq_nodes(mtc);
  assert length(nodes) == 3;
  ptrns = [build_switch_ptrn_ast(n) : n <- rep_rule_nodes(nodes[0])];
  expr = build_expr_ast(nodes[2]);
  return syn_case(nonempty(ptrns), expr);
}

////////////////////////////////////////////////////////////////////////////////

BasicTypeSymbol build_basic_type_symbol_ast(RuleMatch mtc) = type_symbol(get_lowercase_id(mtc));

////////////////////////////////////////////////////////////////////////////////

Operator token_to_operator(PlainToken):
  asterisk    = :star,
  slash       = :slash,
  plus        = :plus,
  minus       = :minus,
  ampersand   = :amp,
  lower       = :lower,
  greater     = :greater,
  lower_eq    = :lower_eq,
  greater_eq  = :greater_eq;

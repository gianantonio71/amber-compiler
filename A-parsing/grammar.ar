ParsingRule rule_lc_id            = atomic_rule(lowercase_id);
ParsingRule rule_plus             = atomic_rule(plus);
ParsingRule rule_dot              = atomic_rule(dot);
ParsingRule rule_question_mark    = atomic_rule(question_mark);
ParsingRule rule_equals           = atomic_rule(equals);
ParsingRule rule_semicolon        = atomic_rule(semicolon);
ParsingRule rule_colon            = atomic_rule(colon);
ParsingRule rule_assign           = atomic_rule(assign);
ParsingRule rule_left_arrow       = atomic_rule(left_arrow);
ParsingRule rule_right_arrow      = atomic_rule(right_arrow);

ParsingRule rule_id = rule_lc_id; //## I SHOULD EXCLUDE ALL THE KEYWORDS HERE...

ParsingRule rule_keyword(Atom kw) = atomic_rule(keyword(kw));

ParsingRule keyword_after     = rule_keyword(:after);
ParsingRule keyword_and       = rule_keyword(:and);
ParsingRule keyword_assert    = rule_keyword(:assert);
ParsingRule keyword_auto      = rule_keyword(:auto);
ParsingRule keyword_break     = rule_keyword(:break);
ParsingRule keyword_discrete  = rule_keyword(:discrete);
ParsingRule keyword_elapsed   = rule_keyword(:elapsed);
ParsingRule keyword_elif      = rule_keyword(:elif);
ParsingRule keyword_else      = rule_keyword(:else);
ParsingRule keyword_every     = rule_keyword(:every);
ParsingRule keyword_fail      = rule_keyword(:fail);
ParsingRule keyword_false     = rule_keyword(:false);
ParsingRule keyword_for       = rule_keyword(:for);
ParsingRule keyword_if        = rule_keyword(:if);
ParsingRule keyword_in        = rule_keyword(:in);
ParsingRule keyword_input     = rule_keyword(:input);
ParsingRule keyword_let       = rule_keyword(:let);
ParsingRule keyword_loop      = rule_keyword(:loop);
ParsingRule keyword_match     = rule_keyword(:match);
ParsingRule keyword_nil       = rule_keyword(:nil);
ParsingRule keyword_not       = rule_keyword(:not);
ParsingRule keyword_or        = rule_keyword(:or);
ParsingRule keyword_output    = rule_keyword(:output);
ParsingRule keyword_print     = rule_keyword(:print);
ParsingRule keyword_return    = rule_keyword(:return);
ParsingRule keyword_state     = rule_keyword(:state);
ParsingRule keyword_then      = rule_keyword(:then);
ParsingRule keyword_true      = rule_keyword(:true);
ParsingRule keyword_type      = rule_keyword(:type);
ParsingRule keyword_update    = rule_keyword(:update);
ParsingRule keyword_using     = rule_keyword(:using);
ParsingRule keyword_while     = rule_keyword(:while);
ParsingRule keyword_with      = rule_keyword(:with);

ParsingRule rule_ops(TokenMatchingRule+ ops) = rule_anon_choice((atomic_rule(op) : op <- ops));

ParsingRule ops_prec_log      = rule_anon_choice((keyword_and, keyword_or));
ParsingRule ops_prec_eq       = rule_ops((double_equals, not_equal));
ParsingRule ops_prec_ord      = rule_ops((lower, greater, lower_eq, greater_eq));
ParsingRule ops_prec_sum      = rule_ops((plus, minus, ampersand));
ParsingRule ops_prec_prod     = rule_ops((asterisk, slash));

ParsingRule rule_ref_type                       = rule_ref(:type);
ParsingRule rule_ref_pretype                    = rule_ref(:pretype);
ParsingRule rule_ref_expr                       = rule_ref(:expr);
ParsingRule rule_ref_ptrn                       = rule_ref(:ptrn);
ParsingRule rule_ref_fndef                      = rule_ref(:fndef);
ParsingRule rule_ref_fndef_proc                 = rule_ref(:fndef_proc);
ParsingRule rule_ref_fndef_switch               = rule_ref(:fndef_switch);
ParsingRule rule_ref_basic_time_expr            = rule_ref(:basic_time_expr);

ParsingRule rule_ref_stmt(<fn, proc, meth> ctx):
  fn    = rule_ref(:stmt),
  proc  = rule_ref(:proc_stmt),
  meth  = rule_ref(:meth_stmt);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_amber_file = rep_rule(rule_declaration, true);

ParsingRule rule_declaration =
  rule_choice((
    (:typedef,                  rule_typedef),
    (:par_typedef,              rule_par_typedef),
    (:fndef,                    rule_std_fndef(true)),
    (:fndef_proc,               rule_proc_fndef(true)),
    (:fndef_switch,             rule_switch_fndef),
    (:using_block_1,            rule_using_block_1),
    (:using_block_2,            rule_using_block_2),
    (:proc_def,                 rule_proc_def),
    (:auto_def,                 rule_auto_def),
    (:std_read_only_method,     rule_std_read_only_method_def),
    (:proc_read_only_method,    rule_proc_read_only_method_def),
    (:switch_read_only_method,  rule_switch_read_only_method_def),
    (:update_method,            rule_update_method_def)
  ));

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_proc_def =
  rule_seq((
    rule_choice((
      (:ret_val,      rule_seq((rule_type, atomic_rule(mixedcase_id)))),
      (:no_ret_val,   atomic_rule(mixedcase_id))
    )),
    par_rule(opt_comma_sep_seq(rule_seq((rule_type, optional_rule(rule_id))))),
    brace_rule(rule_seq((rep_rule(rule_auto_var_decl), rep_rule(rule_stmt(:proc)))))
  ));

ParsingRule rule_auto_var_decl =
  rule_seq((
    keyword_auto,
    rule_lc_id,
    rule_lc_id,
    rule_semicolon
  ));

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_using_block_1 =
  rule_seq((
    keyword_using,
    comma_sep_seq(rule_signature),
    brace_rule(rep_rule(rule_fndef, true))
  ));

ParsingRule rule_using_block_2 =
  rule_seq((
    keyword_using,
    brace_rule(
      rule_seq((
        comma_sep_seq(rule_signature),
        rule_semicolon,
        rep_rule(rule_fndef, true)
      ))
    )
  ));

ParsingRule rule_signature = rule_seq((rule_type, rule_id, optional_rule(par_rule(comma_sep_seq(rule_type)))));

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_typedef =
  rule_seq((
    keyword_type,
    atomic_rule(mixedcase_id),
    rule_equals,
    comma_sep_seq(rule_pretype),
    rule_semicolon
  ));

ParsingRule rule_par_typedef =
  rule_seq((
    keyword_type,
    atomic_rule(mixedcase_id),
    bracket_rule(comma_sep_seq(rule_type_var)),
    rule_equals,
    comma_sep_seq(rule_pretype),
    rule_semicolon
  ));

////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_type =
  rule_seq((
    rule_choice((
      (:type_name_par,    rule_type_name_par),
      (:type_name,        rule_type_name),
      (:type_var,         rule_type_var),
      (:type_union,       rule_type_union),
      (:type_any_symbol,  rule_type_any_symbol),
      (:type_integer,     rule_type_integer),
      (:type_float,       rule_type_float),
      (:type_empty_set,   rule_type_empty_set),
      (:type_set,         rule_type_set),
      (:type_empty_map,   rule_type_empty_map),
      (:type_map,         rule_type_map),
      (:type_record,      rule_type_record),
      (:type_empty_seq,   rule_type_empty_seq),
      (:type_tuple,       rule_type_tuple),
      (:type_any_tag_obj, rule_type_any_tag_obj)
    )),
    rep_rule(
      rule_choice((
        (:seq,    atomic_rule(asterisk)),
        (:ne_seq, rule_plus)
      ))
    )
  ));

ParsingRule rule_pretype =
  rule_choice((
    (:type,             rule_ref_type),
    (:type_tag_obj,     rule_type_tag_obj),
    (:type_tag_record,  rule_type_tag_record),
    (:type_symbol,      rule_type_symbol)
  ));

ParsingRule rule_type_name        = atomic_rule(mixedcase_id);
ParsingRule rule_type_var         = atomic_rule(uppercase_id);
ParsingRule rule_type_name_par    = rule_seq((rule_type_name, bracket_rule(comma_sep_seq(rule_ref_type))));
ParsingRule rule_type_union       = rule_seq((atomic_rule(lower), comma_sep_seq(rule_ref_pretype), atomic_rule(greater)));
ParsingRule rule_type_any_symbol  = rule_seq((atomic_rule(lower), rule_plus, atomic_rule(greater)));
ParsingRule rule_type_integer     = rule_seq((atomic_rule(lower), int_type_bound, atomic_rule(double_dot), int_type_bound, atomic_rule(greater)));
ParsingRule rule_type_float       = rule_seq((atomic_rule(lower), atomic_rule(circumflex), atomic_rule(greater)));
ParsingRule rule_type_set         = bracket_rule(rule_seq((optional_rule(rule_plus), rule_ref_type)));
ParsingRule rule_type_map         = bracket_rule(rule_seq((optional_rule(rule_plus), rule_ref_type, rule_right_arrow, rule_ref_type)));

ParsingRule rule_type_record      = bracket_rule(comma_sep_seq(record_field));

ParsingRule rule_type_tuple       = par_rule(comma_sep_seq(rule_ref_type));

ParsingRule rule_type_any_tag_obj = par_rule(rule_seq((rule_type_any_symbol, atomic_rule(at), rule_ref_type)));

ParsingRule rule_type_empty_set   = empty_block_rule(bracket);
ParsingRule rule_type_empty_seq   = empty_block_rule(parenthesis);
ParsingRule rule_type_empty_map   = bracket_rule(rule_colon);

ParsingRule rule_type_symbol      = rule_lc_id;
ParsingRule rule_type_tag_obj     = rule_seq((rule_type_symbol, par_rule(comma_sep_seq(rule_ref_pretype))));
ParsingRule rule_type_tag_record  = rule_seq((rule_type_symbol, par_rule(comma_sep_seq(record_field))));

////////////////////////////////////////////////////////////////////////////////

ParsingRule record_field =
  rule_seq((
    rule_lc_id,
    rule_colon,
    rule_ref_pretype,
    optional_rule(rule_question_mark)
  ));

ParsingRule int_type_bound =
  rule_choice((
    (:asterisk,     atomic_rule(asterisk)),
    (:integer,      atomic_rule(integer)),
    (:neg_integer,  rule_seq((atomic_rule(minus), atomic_rule(integer))))
  ));

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_fndef =
  rule_choice((
    (:std,    rule_std_fndef(true)),
    (:proc,   rule_proc_fndef(true)),
    (:switch, rule_switch_fndef)
  ));

ParsingRule rule_std_fndef(Bool arity_0_allowed) =
  rule_seq((
    optional_rule(rule_type),
    rule_anon_choice((rule_id, atomic_rule(operator))),
    maybe_optional_rule(par_rule(comma_sep_seq(rule_fn_arg)), arity_0_allowed),
    rule_equals,
    rule_expr,
    // optional_rule_seq([keyword_let, rep_rule(rule_asgnm_stmt, true)]),
    rule_semicolon
  ));

ParsingRule rule_proc_fndef(Bool arity_0_allowed) =
  rule_seq((
    optional_rule(rule_type),
    rule_anon_choice((rule_id, atomic_rule(operator))),
    maybe_optional_rule(par_rule(comma_sep_seq(rule_fn_arg)), arity_0_allowed),
    brace_rule(rep_rule(rule_stmt(:fn), true))
  ));

ParsingRule rule_switch_fndef = //## rule_try_fndef? rule_match_fndef?
  rule_seq((
    optional_rule(rule_type),
    rule_anon_choice((rule_id, atomic_rule(operator))),
    par_rule(comma_sep_seq(rule_fn_arg)),
    rule_colon,
    comma_sep_seq(rule_switch_case),
    rule_semicolon
  ));

ParsingRule rule_fn_arg =
  rule_choice((
    (:unknown,  atomic_rule(underscore)),
    (:untyped,  rule_id),
    (:typed,    rule_seq((rule_type, optional_rule(rule_id)))),
    (:cls,      rule_seq((rule_cls_type, rule_id)))
  ));

ParsingRule rule_cls_type =
  par_rule(
    rule_seq((
      comma_sep_seq(rule_type),
      rule_right_arrow,
      rule_type
    ))
  );

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_ptrn =
  rule_seq((
    rule_choice((
      (:type,         rule_type),
      //## THIS WOULDN'T MAKE MUCH SENSE AT THE ROOT, AND THERE'S NO POINT IN ALLOWING IT TO BE FOLLOWED BY ANOTHER
      //## PATTERN VARIABLE, BUT ON THE OTHER HAND LEAVING IT LIKE THAT IS SIMPLER AND DOESN'T DO ANY REAL HARM
      (:tag_only,     rule_seq((rule_lc_id, empty_block_rule(parenthesis)))),
      (:tag_obj,      rule_seq((rule_lc_id, par_rule(rule_ref_ptrn)))),
      (:tag_obj_any,  rule_seq((rule_lc_id, atomic_rule(at), rule_lc_id))),
      (:var,          rule_seq((rule_lc_id, rule_question_mark))),
      (:atom,         rule_lc_id),
      (:integer,      rule_seq((optional_rule(atomic_rule(minus)), atomic_rule(integer)))),
      (:atom_any,     rule_plus),
      (:integer_any,  atomic_rule(asterisk)),
      (:float,        atomic_rule(circumflex)),
      (:any,          atomic_rule(underscore)),
      // (:empty_seq,    empty_block_rule(bracket)),
      (:seq,          par_rule(atomic_rule(double_dot))),
      // (:empty_set,    empty_block_rule(brace)),
      (:set,          bracket_rule(atomic_rule(double_dot))),
      // (:empty_map,    empty_block_rule(parenthesis)),
      (:map,          bracket_rule(rule_right_arrow))
    )),
    optional_rule_seq((rule_lc_id, rule_question_mark))
  ));

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_stmt(<fn, proc, meth> ctx) =
  rule_choice((
    (:asgnm,              rule_asgnm_stmt),
    (:ret,                rule_ret_stmt)              if ctx == :fn or ctx == :proc,
    (:if_stmt,            rule_if_stmt(ctx)),
    (:loop_stmt,          rule_loop_stmt(ctx)),
    (:while_stmt,         rule_while_stmt(ctx)),
    (:let_stmt,           rule_let_stmt(ctx)),
    (:break_stmt,         rule_break_stmt),
    (:for_stmt,           rule_for_stmt(ctx)),
    (:fail_stmt,          rule_fail_stmt),
    (:assert_stmt,        rule_assert_stmt),
    (:print_stmt,         rule_print_stmt),
    (:imp_update,         rule_imp_update_stmt),
    (:fn,                 rule_ref_fndef)             if ctx == :fn,
    (:fn_proc,            rule_ref_fndef_proc)        if ctx == :fn,
    (:fn_case,            rule_ref_fndef_switch)      if ctx == :fn,
    (:no_val_ret,         rule_no_val_ret_stmt)       if ctx == :proc or ctx == :meth,
    (:proc_call,          rule_proc_call_stmt)        if ctx == :proc,
    (:auto_set_input,     rule_auto_set_input_stmt)   if ctx == :proc,
    (:auto_update,        rule_auto_update_stmt)      if ctx == :proc,
    (:set_memb_var,       rule_set_memb_var_stmt)     if ctx == :meth,
    (:method_call,        rule_method_call_stmt)      if ctx == :proc or ctx == :meth
  ));

ParsingRule rule_asgnm_stmt =
  rule_seq((
    optional_rule(rule_type),
    comma_sep_seq(rule_id),
    rule_equals,
    rule_ref_expr,
    optional_rule_seq((keyword_if, rule_ref_expr)),
    rule_semicolon
  ));

ParsingRule rule_ret_stmt =
  rule_seq((
    keyword_return,
    rule_ref_expr,
    optional_rule_seq((keyword_if, rule_ref_expr)),
    rule_semicolon
  ));

ParsingRule rule_if_stmt(<fn, proc, meth> ctx) =
  rule_seq((
    keyword_if,
    rule_ref_expr,
    rule_colon,
    rep_rule(rule_ref_stmt(ctx), true),
    rep_rule(
      rule_seq((
        keyword_elif,
        rule_ref_expr,
        rule_colon,
        rep_rule(rule_ref_stmt(ctx), true)
      ))
    ),
    optional_rule(
      rule_seq((
        keyword_else,
        rep_rule(rule_ref_stmt(ctx), true)
      ))
    ),
    rule_semicolon
  ));

ParsingRule rule_loop_stmt(<fn, proc, meth> ctx) =
  rule_seq((
    keyword_loop,
    rep_rule(rule_ref_stmt(ctx), true),
    optional_rule_seq((keyword_while, rule_ref_expr)),
    rule_semicolon
  ));

ParsingRule rule_while_stmt(<fn, proc, meth> ctx) =
  rule_seq((
    keyword_while,
    rule_ref_expr,
    rule_colon,
    rep_rule(rule_ref_stmt(ctx), true),
    rule_semicolon
  ));

ParsingRule rule_for_stmt(<fn, proc, meth> ctx) =
  rule_seq((
    keyword_for,
    rep_rule(rule_for_range, rule_semicolon, true, false),
    rule_colon,
    rep_rule(rule_ref_stmt(ctx), true),
    rule_semicolon
  ));

ParsingRule rule_for_range =
  rule_choice((
    (:foreach,      rule_seq((comma_sep_seq(rule_id), rule_left_arrow, rule_ref_expr))),
    (:foreach_idx,  rule_seq((comma_sep_seq(rule_id), atomic_rule(at), rule_id, rule_left_arrow, rule_ref_expr))),
    (:for_upper,    rule_seq((rule_id, rule_ops((lower, lower_eq)), rule_ref_expr))),
    (:for_range,    rule_seq((rule_id, rule_equals, rule_ref_expr, rule_ops((double_dot, triple_dot)), rule_ref_expr))),
    (:repeat,       rule_ref_expr)
  ));

ParsingRule rule_let_stmt(<fn, proc, meth> ctx) =
  rule_seq((
    keyword_let,
    comma_sep_seq(rule_seq((rule_id, rule_equals, rule_ref_expr))),
    rule_colon,
    rep_rule(rule_ref_stmt(ctx), true),
    rule_semicolon
  ));

ParsingRule rule_break_stmt =
  rule_seq((
    keyword_break,
    optional_rule_seq((keyword_if, rule_ref_expr)),
    rule_semicolon
  ));

ParsingRule rule_fail_stmt =
  rule_seq((
    keyword_fail,
    optional_rule_seq((keyword_if, rule_ref_expr)),
    rule_semicolon
  ));

ParsingRule rule_assert_stmt = rule_seq((keyword_assert, rule_ref_expr, rule_semicolon));

ParsingRule rule_print_stmt =
  rule_seq((
    keyword_print,
    rule_ref_expr,
    optional_rule_seq((keyword_if, rule_ref_expr)),
    rule_semicolon
  ));

ParsingRule rule_imp_update_stmt =
  rule_seq((
    rule_id,
    bracket_rule(rule_ref_expr),
    rule_assign,
    rule_ref_expr,
    rule_semicolon
  ));

ParsingRule rule_no_val_ret_stmt =
  rule_seq((
    keyword_return,
    optional_rule_seq((keyword_if, rule_ref_expr)),
    rule_semicolon
  ));

ParsingRule rule_proc_call_stmt =
  rule_seq((
    optional_rule_seq((rule_id, rule_equals)),
    atomic_rule(mixedcase_id),
    par_rule(opt_comma_sep_seq(rule_ref_expr)),
    rule_semicolon
  ));

ParsingRule rule_auto_set_input_stmt =
  rule_seq((
    rule_lc_id,
    rule_dot,
    rule_lc_id,
    rule_equals,
    rule_expr,
    rule_semicolon
  ));

ParsingRule rule_auto_update_stmt =
  rule_seq((
    keyword_update,
    rule_lc_id,
    optional_rule_seq((
      keyword_elapsed,
      rule_expr
    )),
    rule_semicolon
  ));

ParsingRule rule_set_memb_var_stmt =
  rule_seq((
    rule_lc_id,
    rule_assign,
    rule_expr,
    optional_rule_seq((keyword_if, rule_expr)),
    rule_semicolon
  ));

ParsingRule rule_method_call_stmt =
  rule_seq((
    rule_lc_id,
    rule_dot,
    rule_lc_id,
    par_rule(opt_comma_sep_seq(rule_expr)),
    optional_rule_seq((keyword_if, rule_expr)),
    rule_semicolon
  ));

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_clause =
  rule_choice((
    (:in,       rule_set_elem_or_map_entry_clause),
    (:asgnm,    rule_seq((rule_id, rule_equals, rule_ref_expr))),
    (:match,    rule_seq((rule_ptrn, atomic_rule(double_lower), rule_ref_expr))),
    (:filter,   rule_ref_expr)
  ));

ParsingRule rule_set_elem_or_map_entry_clause =
  rule_seq((
    rule_id,
    optional_rule_seq((atomic_rule(at), rule_id)),
    rule_left_arrow,
    rule_ref_expr
  ));

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_expr = rule_expr_10;

ParsingRule rule_expr_10  = rule_seq((rule_expr_9, optional_rule_seq((atomic_rule(at), rule_expr_9))));
ParsingRule rule_expr_9   = rep_rule(rule_expr_8, ops_prec_log, true, true);
ParsingRule rule_expr_8   = rule_seq((rule_expr_7, optional_rule_seq((ops_prec_eq, rule_expr_7))));
ParsingRule rule_expr_7   = rule_seq((rule_expr_6, optional_rule_seq((ops_prec_ord, rule_expr_6))));
ParsingRule rule_expr_6   = rep_rule(rule_expr_5, ops_prec_sum, true, true);
ParsingRule rule_expr_5   = rep_rule(rule_expr_4, ops_prec_prod, true, true);
ParsingRule rule_expr_4   = rule_seq((optional_rule(rule_anon_choice((atomic_rule(minus), keyword_not))), rule_expr_3));
ParsingRule rule_expr_3   = rep_rule(rule_expr_2, atomic_rule(circumflex), true, false);
ParsingRule rule_expr_2   = rule_seq((rule_expr_1, optional_rule_seq((atomic_rule(double_colon), rule_type))));
ParsingRule rule_expr_1   =
  rule_choice((
    (:def_test,     rule_seq((rule_lc_id, rule_dot, rule_lc_id , rule_question_mark, rule_question_mark))),
    (:sub_dot_seq,  rule_seq((rule_expr_0, rep_rule(rule_dot_or_sub), optional_rule(rule_dot_access(true)))))
  ));

ParsingRule rule_dot_or_sub     = rule_choice(((:dot, rule_dot_access(false)), (:sub, rule_subscript_op)));
ParsingRule rule_subscript_op   = bracket_rule(rule_ref_expr);

ParsingRule rule_dot_access(Bool test)
{
  lr = rule_question_mark;
  lr = rule_neg(lr) if not test;
  return rule_seq((rule_dot, rule_lc_id, lr));
}


ParsingRule rule_expr_0 =
  rule_choice((
    (:tag_obj,      rule_seq((atomic_rule(qualified_symbol), par_rule(comma_sep_seq(rule_ref_expr))))),

    (:memb_copy,    atomic_rule(hash_lowercase_id)),
    (:is_set,       rule_seq((rule_id, rule_question_mark))),

    (:integer,      atomic_rule(integer)),
    (:symbol,       atomic_rule(qualified_symbol)),
    (:string,       atomic_rule(string)),
    (:float,        atomic_rule(float)),

    (true,          atomic_rule(keyword(true))),
    (false,         atomic_rule(keyword(false))),
    (nil,           atomic_rule(keyword(nil))),

    (:set,          bracket_rule(opt_comma_sep_seq(rule_subexpr))),
    (:empty_map,    bracket_rule(rule_colon)),
    (:map,          bracket_rule(comma_sep_seq(rule_map_entry))),
    (:record,       rule_record_expr),
    (:seq,          rule_seq_expr),
    (:seq_tail,     rule_seq_tail_expr),

    (:tag_record,   rule_tag_record_expr),

    (:builtin_call, rule_seq((atomic_rule(builtin), par_rule(comma_sep_seq(rule_ref_expr))))),

    (:par_expr,     brace_rule(rule_ref_expr)),

    (:ex_qual,      rule_ex_qual_expr),
    (:set_cp,       rule_set_cp_expr),
    (:map_cp,       rule_map_cp_expr),
    (:seq_cp,       rule_seq_cp_expr),

    // (:alt_cp,       rule_alt_cp_expr),

    (:if_else,      rule_if_expr),
    (:match_expr,   rule_match_expr),
    (:proc,         brace_rule(rep_rule(rule_ref_stmt(:fn), true))),

    (:method_call,  rule_seq((rule_id, rule_dot, rule_id, par_rule(opt_comma_sep_seq(rule_ref_expr))))),
    (:fn_call,      rule_fn_call_expr),
    (:const_or_var, rule_id),
    (:cls_par,      atomic_rule(qual_var))
  ));

ParsingRule rule_subexpr = rule_seq((rule_ref_expr, optional_rule_seq((keyword_if, rule_ref_expr))));

ParsingRule rule_map_entry =
  rule_seq((
    rule_ref_expr,
    rule_right_arrow,
    rule_ref_expr,
    optional_rule(
      rule_seq((
        keyword_if,
        rule_ref_expr
      ))
    )
  ));

ParsingRule rule_record_expr = bracket_rule(comma_sep_seq(rule_record_entry));

ParsingRule rule_record_entry =
  rule_seq((
    rule_lc_id,
    rule_colon,
    rule_ref_expr,
    optional_rule_seq((keyword_if, rule_ref_expr))
  ));

ParsingRule rule_seq_expr = par_rule(opt_comma_sep_seq(rule_subexpr));

ParsingRule rule_seq_tail_expr =
  par_rule(
    rule_seq((
      rule_ref_expr,
      rule_seq((atomic_rule(pipe), comma_sep_seq(rule_ref_expr))) //## MAYBE HERE I SHOULD ALLOW ALSO A CONDITIONAL EXPRESSION
    ))
  );

//## MAYBE I SHOULD ALLOW ALSO SYMBOLS FOR THE FIRST TOKEN, IN CASE THE SYMBOL NAME CONFLICTS WITH A KEYWORD
ParsingRule rule_tag_record_expr = rule_seq((rule_lc_id, par_rule(comma_sep_seq(rule_record_entry))));

ParsingRule rule_fn_call_expr =
  rule_seq((
    rule_anon_choice((rule_id, atomic_rule(operator))),
    par_rule(
      rule_seq((
        comma_sep_seq(
          rule_seq((
            rule_neg(rule_actual_named_arg),
            rule_ref_expr
          ))
        ),
        rep_rule(
          rule_seq((
            atomic_rule(comma),
            rule_actual_named_arg
          ))
        )
      ))
    )
  ));

ParsingRule rule_actual_named_arg =
  rule_seq((
    rule_id,
    optional_rule(par_rule(comma_sep_seq(rule_id))),
    rule_equals,
    rule_ref_expr
  ));

ParsingRule rule_ex_qual_expr =
  par_rule(
    rule_seq((
      rule_question_mark,
      comma_sep_seq(rule_clause),
      rule_colon,
      rule_ref_expr
    ))
  );

ParsingRule rule_set_cp_expr =
  bracket_rule(
    rule_seq((
      rule_ref_expr,
      rule_colon,
      comma_sep_seq(rule_clause)
    ))
  );

ParsingRule rule_map_cp_expr =
  bracket_rule(
    rule_seq((
      rule_ref_expr,
      rule_right_arrow,
      rule_ref_expr,
      rule_colon,
      comma_sep_seq(rule_clause)
    ))
  );

// ParsingRule rule_alt_cp_expr =
//   rule_seq([
//     keyword_for,
//     par_rule(comma_sep_seq(rule_clause)),
//     optional_rule(
//       rule_seq([
//         keyword_if,
//         par_rule(comma_sep_seq(rule_ref_expr))
//       ])
//     ),
//     rule_choice([
//       (:set,  brace_rule(rule_ref_expr)),
//       (:map,  par_rule(rule_seq([rule_ref_expr, atomic_rule(double_right_arrow), rule_ref_expr])))
//     ])
//   ]);

ParsingRule rule_seq_cp_expr =
  par_rule(
    rule_seq((
      rule_ref_expr,
      rule_colon,
      rule_choice((
        ( :seq,
          rule_seq((
            comma_sep_seq(rule_id),
            optional_rule_seq((atomic_rule(at), rule_id)),
            rule_left_arrow
          ))
        ),
        (:range, rule_seq((rule_id, rule_ops((lower, lower_eq)))))
      )),
      rule_ref_expr,
      optional_rule_seq((atomic_rule(comma), rule_ref_expr))
    ))
  );

ParsingRule rule_if_expr =
  rule_seq((
    keyword_if,
    comma_sep_seq(
      rule_seq((
        rule_ref_expr,
        keyword_then,
        rule_ref_expr
      ))
    ),
    keyword_else,
    rule_ref_expr
  ));

ParsingRule rule_match_expr =
  rule_seq((
    keyword_match,
    par_rule(comma_sep_seq(rule_ref_expr)),
    comma_sep_seq(rule_switch_case)
  ));

ParsingRule rule_switch_case =
  rule_seq((
    comma_sep_seq(rule_ptrn),
    rule_equals,
    rule_ref_expr
  ));


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_auto_def =
  rule_seq((
    keyword_auto,
    rule_lc_id,
    optional_rule(par_rule(comma_sep_seq(rule_lc_id))),
    brace_rule(rep_rule(rule_auto_decl))
  ));

ParsingRule rule_auto_decl =
  rule_choice((
    (:input,              rule_input_decl),
    (:output,             rule_output_decl),
    (:state,              rule_state_decl),
    (:plain_rule,         rule_plain_rule),
    (:cond_rule,          rule_cond_rule),
    (:foreach_rule,       rule_foreach_rule),
    (:time_varying_rule,  rule_time_varying_rule),
    (:nested_auto,        rule_nested_auto),
    (:method_call,        rule_method_call)
  ));

ParsingRule rule_input_decl =
  rule_seq((
    optional_rule(keyword_discrete),
    keyword_input,
    comma_sep_seq(rule_seq((rule_type, rule_lc_id))),
    rule_semicolon
  ));

ParsingRule rule_output_decl =
  rule_seq((
    optional_rule(keyword_discrete),
    keyword_output,
    comma_sep_seq(rule_seq((rule_type, rule_lc_id))),
    rule_semicolon
  ));

ParsingRule rule_state_decl =
  rule_seq((
    keyword_state,
    comma_sep_seq(
      rule_seq((
        rule_type,
        rule_lc_id,
        rule_equals,
        rule_expr
      ))
    ),
    rule_semicolon
  ));

ParsingRule rule_plain_rule =
  rule_seq((
    rule_lc_id,
    rule_anon_choice((rule_equals, rule_assign)),
    rule_expr,
    rule_semicolon
  ));

ParsingRule rule_cond_rule =
  rule_seq((
    rule_lc_id,
    rule_anon_choice((rule_equals, rule_assign)),
    comma_sep_seq(rule_seq((rule_expr, keyword_if, rule_expr))),
    rule_semicolon
  ));

ParsingRule rule_foreach_rule =
  rule_seq((
    rule_lc_id,
    rule_anon_choice((rule_equals, rule_assign)),
    rule_expr,
    optional_rule(rule_seq((keyword_if, rule_expr))),
    rule_colon,
    comma_sep_seq(rule_lc_id),
    rule_semicolon
  ));

ParsingRule rule_time_varying_rule =
  rule_seq((
    rule_lc_id,
    rule_equals,
    rule_expr,
    rule_anon_choice((keyword_for, keyword_after)),
    rule_time_expr,
    rule_semicolon
  ));

ParsingRule rule_time_span = atomic_rule(time_span);

ParsingRule rule_time_expr = rule_seq((rule_basic_time_expr, optional_rule_seq((keyword_every, rule_time_span))));

ParsingRule rule_basic_time_expr = rep_rule(rule_basic_time_expr_1, ops_prec_log, true, true);

ParsingRule rule_basic_time_expr_1 = rule_seq((optional_rule(keyword_not), rule_basic_time_expr_0));

ParsingRule rule_basic_time_expr_0 =
  rule_choice((
    (:at_least,     rule_time_span),
    (:par,          par_rule(rule_ref_basic_time_expr))
  ));

ParsingRule rule_nested_auto =
  rule_seq((
    rule_lc_id,
    rule_equals,
    rule_lc_id,
    par_rule(opt_comma_sep_seq(rule_seq((rule_lc_id, rule_equals, rule_expr)))),
    rule_semicolon
  ));

ParsingRule rule_method_call =
  rule_seq((
    rule_lc_id,
    rule_dot,
    rule_lc_id,
    par_rule(rule_expr),
    optional_rule_seq((keyword_if, rule_expr)),
    optional_rule_seq((rule_colon, comma_sep_seq(rule_lc_id))),
    rule_semicolon
  ));

ParsingRule rule_update_method_def =
  rule_seq((
    rule_lc_id,
    rule_dot,
    rule_lc_id,
    par_rule(opt_comma_sep_seq(rule_seq((rule_type, rule_lc_id)))),
    brace_rule(rep_rule(rule_stmt(:meth)))
  ));

ParsingRule rule_std_read_only_method_def =
  rule_seq((
    rule_type,
    rule_id,
    rule_dot,
    rule_id,
    par_rule(opt_comma_sep_seq(rule_seq((rule_type, rule_id)))),
    rule_equals,
    rule_expr,
    rule_semicolon
  ));

ParsingRule rule_proc_read_only_method_def =
  rule_seq((
    rule_type,
    rule_id,
    rule_dot,
    rule_id,
    par_rule(opt_comma_sep_seq(rule_seq((rule_type, rule_id)))),
    brace_rule(rep_rule(rule_stmt(:fn), true))
  ));

ParsingRule rule_switch_read_only_method_def =
  rule_seq((
    rule_type,
    rule_id,
    rule_dot,
    rule_id,
    par_rule(comma_sep_seq(rule_seq((rule_type, rule_id)))),
    rule_colon,
    comma_sep_seq(rule_switch_case),
    rule_semicolon
  ));

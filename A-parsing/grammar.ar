ParsingRule rule_id = atomic_rule(lowercase_id); //## I SHOULD EXCLUDE ALL THE KEYWORDS HERE...

ParsingRule rule_keyword(Atom kw) = atomic_rule(keyword(kw));

ParsingRule keyword_and       = rule_keyword(:and);
ParsingRule keyword_assert    = rule_keyword(:assert);
ParsingRule keyword_auto      = rule_keyword(:auto);
ParsingRule keyword_break     = rule_keyword(:break);
ParsingRule keyword_elif      = rule_keyword(:elif);
ParsingRule keyword_else      = rule_keyword(:else);
ParsingRule keyword_fail      = rule_keyword(:fail);
ParsingRule keyword_false     = rule_keyword(:false);
ParsingRule keyword_for       = rule_keyword(:for);
ParsingRule keyword_if        = rule_keyword(:if);
ParsingRule keyword_in        = rule_keyword(:in);
ParsingRule keyword_input     = rule_keyword(:input);
ParsingRule keyword_let       = rule_keyword(:let);
ParsingRule keyword_loop      = rule_keyword(:loop);
ParsingRule keyword_match     = rule_keyword(:match);
ParsingRule keyword_nil       = rule_keyword(:nil);
ParsingRule keyword_not       = rule_keyword(:not);
ParsingRule keyword_or        = rule_keyword(:or);
ParsingRule keyword_output    = rule_keyword(:output);
ParsingRule keyword_print     = rule_keyword(:print);
ParsingRule keyword_return    = rule_keyword(:return);
ParsingRule keyword_state     = rule_keyword(:state);
ParsingRule keyword_then      = rule_keyword(:then);
ParsingRule keyword_true      = rule_keyword(:true);
ParsingRule keyword_type      = rule_keyword(:type);
ParsingRule keyword_update    = rule_keyword(:update);
ParsingRule keyword_using     = rule_keyword(:using);
ParsingRule keyword_while     = rule_keyword(:while);
ParsingRule keyword_with      = rule_keyword(:with);

ParsingRule rule_ops([TokenMatchingRule^] ops) = rule_anon_choice([atomic_rule(op) : op <- ops]);

ParsingRule ops_prec_log      = rule_anon_choice([keyword_and, keyword_or]);
ParsingRule ops_prec_eq       = rule_ops([double_equals, not_equal]);
ParsingRule ops_prec_ord      = rule_ops([lower, greater, lower_eq, greater_eq]);
ParsingRule ops_prec_sum      = rule_ops([plus, minus, ampersand]);
ParsingRule ops_prec_prod     = rule_ops([asterisk, slash]);

ParsingRule rule_ref_type         = rule_ref(:type);
ParsingRule rule_ref_pretype      = rule_ref(:pretype);
ParsingRule rule_ref_expr         = rule_ref(:expr);
ParsingRule rule_ref_stmt(<fn, proc> ctx) = if ctx == :fn then rule_ref(:stmt) else rule_ref(:proc_stmt);
ParsingRule rule_ref_ptrn         = rule_ref(:ptrn);
ParsingRule rule_ref_fndef        = rule_ref(:fndef);
ParsingRule rule_ref_fndef_proc   = rule_ref(:fndef_proc);
ParsingRule rule_ref_fndef_switch = rule_ref(:fndef_switch);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_amber_file = rep_rule(rule_declaration, true);

ParsingRule rule_declaration =
  rule_choice([
    (:typedef,        rule_typedef),
    (:par_typedef,    rule_par_typedef),
    (:fndef,          rule_std_fndef(true)),
    (:fndef_proc,     rule_proc_fndef(true)),
    (:fndef_switch,   rule_switch_fndef),
    (:using_block_1,  rule_using_block_1),
    (:using_block_2,  rule_using_block_2),
    (:proc_def,       rule_proc_def),
    (:auto_def,       rule_auto_def)
  ]);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_proc_def =
  rule_seq([
    rule_choice([
      (:ret_val,      rule_seq([rule_type, atomic_rule(mixedcase_id)])),
      (:no_ret_val,   atomic_rule(mixedcase_id))
    ]),
    par_rule(opt_comma_sep_seq(rule_seq([rule_type, optional_rule(rule_id)]))),
    brace_rule(rule_seq([rep_rule(rule_auto_var_decl), rep_rule(rule_stmt(:proc))]))
  ]);

ParsingRule rule_auto_var_decl =
  rule_seq([
    keyword_auto,
    atomic_rule(lowercase_id),
    atomic_rule(lowercase_id),
    atomic_rule(semicolon)
  ]);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_using_block_1 =
  rule_seq([
    keyword_using,
    comma_sep_seq(rule_signature),
    brace_rule(rep_rule(rule_fndef, true))
  ]);

ParsingRule rule_using_block_2 =
  rule_seq([
    keyword_using,
    brace_rule(
      rule_seq([
        comma_sep_seq(rule_signature),
        atomic_rule(semicolon),
        rep_rule(rule_fndef, true)
      ])
    )
  ]);

ParsingRule rule_signature = rule_seq([rule_type, rule_id, optional_rule(par_rule(comma_sep_seq(rule_type)))]);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_typedef =
  rule_seq([
    keyword_type,
    atomic_rule(mixedcase_id),
    atomic_rule(equals),
    comma_sep_seq(rule_pretype),
    atomic_rule(semicolon)
  ]);

ParsingRule rule_par_typedef =
  rule_seq([
    keyword_type,
    atomic_rule(mixedcase_id),
    bracket_rule(comma_sep_seq(rule_type_var)),
    atomic_rule(equals),
    comma_sep_seq(rule_pretype),
    atomic_rule(semicolon)
  ]);

////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_type =
  rule_seq([
    rule_choice([
      (:type_name_par,    rule_type_name_par),
      (:type_name,        rule_type_name),
      (:type_var,         rule_type_var),
      (:type_union,       rule_type_union),
      (:type_any_symbol,  rule_type_any_symbol),
      (:type_integer,     rule_type_integer),
      (:type_float,       rule_type_float),
      (:type_seq,         rule_type_seq),
      (:type_map,         rule_type_map),
      (:type_record,      rule_type_record),
      (:type_tuple,       rule_type_tuple),
      (:type_any_tag_obj, rule_type_any_tag_obj)
    ]),
    rep_rule(
      rule_choice([
        (:set,    atomic_rule(asterisk)),
        (:ne_set, atomic_rule(plus))
      ])
    )
  ]);

ParsingRule rule_pretype =
  rule_choice([
    (:type,             rule_ref_type),
    (:type_empty_set,   rule_type_empty_set),
    (:type_empty_seq,   rule_type_empty_seq),
    (:type_empty_map,   rule_type_empty_map),
    (:type_tag_obj,     rule_type_tag_obj),
    (:type_tag_record,  rule_type_tag_record),
    (:type_symbol,      rule_type_symbol)
  ]);

ParsingRule rule_type_name        = atomic_rule(mixedcase_id);
ParsingRule rule_type_var         = atomic_rule(uppercase_id);
ParsingRule rule_type_name_par    = rule_seq([rule_type_name, bracket_rule(comma_sep_seq(rule_ref_type))]);
ParsingRule rule_type_union       = rule_seq([atomic_rule(lower), comma_sep_seq(rule_ref_pretype), atomic_rule(greater)]);
ParsingRule rule_type_any_symbol  = rule_seq([atomic_rule(lower), atomic_rule(plus), atomic_rule(greater)]);
ParsingRule rule_type_integer     = rule_seq([atomic_rule(lower), int_type_bound, atomic_rule(double_dot), int_type_bound, atomic_rule(greater)]);
ParsingRule rule_type_float       = rule_seq([atomic_rule(lower), atomic_rule(circumflex), atomic_rule(greater)]);
ParsingRule rule_type_seq         = bracket_rule(rule_seq([rule_ref_type, optional_rule(atomic_rule(circumflex))]));
ParsingRule rule_type_map         = par_rule(rule_seq([rule_ref_type, atomic_rule(double_right_arrow), rule_ref_type]));

ParsingRule rule_type_record      = par_rule(comma_sep_seq(record_field));

ParsingRule rule_type_tuple       = par_rule(comma_sep_seq(rule_ref_type, 2));

ParsingRule rule_type_any_tag_obj = par_rule(rule_seq([rule_type_any_symbol, atomic_rule(at), rule_ref_type]));

ParsingRule rule_type_empty_set   = empty_block_rule(brace);
ParsingRule rule_type_empty_seq   = empty_block_rule(bracket);
ParsingRule rule_type_empty_map   = empty_block_rule(parenthesis);

ParsingRule rule_type_symbol      = atomic_rule(lowercase_id);
ParsingRule rule_type_tag_obj     = rule_seq([rule_type_symbol, par_rule(rule_ref_pretype)]);
ParsingRule rule_type_tag_record  = rule_seq([rule_type_symbol, rule_type_record]);

////////////////////////////////////////////////////////////////////////////////

ParsingRule record_field = rule_seq([atomic_rule(label), rule_ref_pretype, optional_rule(atomic_rule(question_mark))]);

ParsingRule int_type_bound =
  rule_choice([
    (:asterisk,     atomic_rule(asterisk)),
    (:integer,      atomic_rule(integer)),
    (:neg_integer,  rule_seq([atomic_rule(minus), atomic_rule(integer)]))
  ]);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_fndef =
  rule_choice([
    (:std,    rule_std_fndef(true)),
    (:proc,   rule_proc_fndef(true)),
    (:switch, rule_switch_fndef)
  ]);

ParsingRule rule_std_fndef(Bool arity_0_allowed) =
  rule_seq([
    optional_rule(rule_type),
    rule_anon_choice([rule_id, atomic_rule(operator)]),
    maybe_optional_rule(par_rule(comma_sep_seq(rule_fn_arg)), arity_0_allowed),
    atomic_rule(equals),
    rule_expr,
    // optional_rule_seq([keyword_let, rep_rule(rule_asgnm_stmt, true)]),
    atomic_rule(semicolon)
  ]);

ParsingRule rule_proc_fndef(Bool arity_0_allowed) =
  rule_seq([
    optional_rule(rule_type),
    rule_anon_choice([rule_id, atomic_rule(operator)]),
    maybe_optional_rule(par_rule(comma_sep_seq(rule_fn_arg)), arity_0_allowed),
    brace_rule(rep_rule(rule_stmt(:fn), true))
  ]);

ParsingRule rule_switch_fndef = //## rule_try_fndef? rule_match_fndef?
  rule_seq([
    optional_rule(rule_type),
    rule_anon_choice([rule_id, atomic_rule(operator)]),
    par_rule(comma_sep_seq(rule_fn_arg)),
    atomic_rule(colon),
    comma_sep_seq(rule_switch_case),
    atomic_rule(semicolon)
  ]);

ParsingRule rule_fn_arg =
  rule_choice([
    (:unknown,  atomic_rule(underscore)),
    (:untyped,  rule_id),
    (:typed,    rule_seq([rule_type, optional_rule(rule_id)])),
    (:cls,      rule_seq([rule_cls_type, rule_id]))
  ]);

ParsingRule rule_cls_type =
  par_rule(
    rule_seq([
      comma_sep_seq(rule_type),
      atomic_rule(right_arrow),
      rule_type
    ])
  );

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_switch_ptrn = //## rule_try_ptrn? rule_match_ptrn?
  rule_seq([
    rule_choice([
      (:type,         rule_type),
      //## THIS WOULDN'T MAKE MUCH SENSE AT THE ROOT, AND THERE'S NO POINT IN ALLOWING IT TO BE FOLLOWED BY ANOTHER
      //## PATTERN VARIABLE, BUT ON THE OTHER HAND LEAVING IT LIKE THAT IS SIMPLER AND DOESN'T DO ANY REAL HARM
      (:tag_only,     rule_seq([atomic_rule(lowercase_id), empty_block_rule(parenthesis)])),
      (:tag_obj,      rule_seq([atomic_rule(lowercase_id), par_rule(rule_ref_ptrn)])),
      (:tag_obj_any,  rule_seq([atomic_rule(lowercase_id), atomic_rule(at), atomic_rule(lowercase_id)])),
      (:var,          rule_seq([atomic_rule(lowercase_id), atomic_rule(question_mark)])),
      (:atom,         atomic_rule(lowercase_id)),
      (:integer,      rule_seq([optional_rule(atomic_rule(minus)), atomic_rule(integer)])),
      (:atom_any,     atomic_rule(plus)),
      (:integer_any,  atomic_rule(asterisk)),
      (:float,        atomic_rule(circumflex)),
      (:any,          atomic_rule(underscore)),
      // (:empty_seq,    empty_block_rule(bracket)),
      (:seq,          bracket_rule(atomic_rule(triple_dot))),
      // (:empty_set,    empty_block_rule(brace)),
      (:set,          brace_rule(atomic_rule(triple_dot))),
      // (:empty_map,    empty_block_rule(parenthesis)),
      (:map,          par_rule(atomic_rule(triple_dot)))
    ]),
    optional_rule_seq([atomic_rule(lowercase_id), atomic_rule(question_mark)])
  ]);

ParsingRule rule_clause_ptrn =
  rule_choice([
    (:any,      atomic_rule(underscore)),
    (:tag_var,  rule_seq([atomic_rule(lowercase_id), empty_block_rule(parenthesis), atomic_rule(lowercase_id)])),
    (:tag_only, rule_seq([atomic_rule(lowercase_id), empty_block_rule(parenthesis)])),
    (:tag_obj,  rule_seq([atomic_rule(lowercase_id), par_rule(atomic_rule(lowercase_id))])),
    // (:tag_var,  rule_seq([atomic_rule(lowercase_id), empty_block_rule(parenthesis), atomic_rule(lowercase_id)])),
    (:var,      atomic_rule(lowercase_id))
  ]);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_stmt(<fn, proc> ctx) =
  rule_choice([
    (:asgnm,              rule_asgnm_stmt),
    (:ret,                rule_ret_stmt),
    (:if_stmt,            rule_if_stmt(ctx)),
    (:loop_stmt,          rule_loop_stmt(ctx)),
    (:while_stmt,         rule_while_stmt(ctx)),
    (:let_stmt,           rule_let_stmt(ctx)),
    (:break_stmt,         rule_break_stmt),
    (:for_stmt,           rule_for_stmt(ctx)),
    (:fail_stmt,          rule_fail_stmt),
    (:assert_stmt,        rule_assert_stmt),
    (:print_stmt,         rule_print_stmt),
    (:imp_update,         rule_imp_update_stmt),
    (:fn,                 rule_ref_fndef) if ctx == :fn,
    (:fn_proc,            rule_ref_fndef_proc) if ctx == :fn,
    (:fn_case,            rule_ref_fndef_switch) if ctx == :fn,
    (:no_val_ret,         rule_no_val_ret_stmt) if ctx == :proc,
    (:proc_call,          rule_proc_call_stmt) if ctx == :proc,
    (:auto_input_update,  rule_auto_input_update_stmt) if ctx == :proc
  ]);

ParsingRule rule_asgnm_stmt =
  rule_seq([
    optional_rule(rule_type),
    comma_sep_seq(rule_id),
    atomic_rule(equals),
    rule_ref_expr,
    optional_rule_seq([keyword_if, rule_ref_expr]),
    atomic_rule(semicolon)
  ]);

ParsingRule rule_ret_stmt =
  rule_seq([
    keyword_return,
    rule_ref_expr,
    optional_rule_seq([keyword_if, rule_ref_expr]),
    atomic_rule(semicolon)
  ]);

ParsingRule rule_if_stmt(<fn, proc> ctx) =
  rule_seq([
    keyword_if,
    par_rule(rule_ref_expr),
    rep_rule(rule_ref_stmt(ctx), true),
    rep_rule(
      rule_seq([
        keyword_elif,
        par_rule(rule_ref_expr),
        rep_rule(rule_ref_stmt(ctx), true)
      ])
    ),
    optional_rule(
      rule_seq([
        keyword_else,
        rep_rule(rule_ref_stmt(ctx), true)
      ])
    ),
    atomic_rule(semicolon)
  ]);

ParsingRule rule_loop_stmt(<fn, proc> ctx) =
  rule_seq([
    keyword_loop,
    rep_rule(rule_ref_stmt(ctx), true),
    optional_rule_seq([keyword_while, par_rule(rule_ref_expr)]),
    atomic_rule(semicolon)
  ]);

ParsingRule rule_while_stmt(<fn, proc> ctx) =
  rule_seq([
    keyword_while,
    par_rule(rule_ref_expr),
    rep_rule(rule_ref_stmt(ctx), true),
    atomic_rule(semicolon)
  ]);

ParsingRule rule_for_stmt(<fn, proc> ctx) =
  rule_seq([
    keyword_for,
    par_rule(rep_rule(rule_for_range, atomic_rule(semicolon), true, false)),
    rep_rule(rule_ref_stmt(ctx), true),
    atomic_rule(semicolon)
  ]);

ParsingRule rule_for_range =
  rule_choice([
    (:foreach,      rule_seq([comma_sep_seq(rule_id), atomic_rule(colon), rule_ref_expr])),
    (:foreach_idx,  rule_seq([comma_sep_seq(rule_id), atomic_rule(at), rule_id, atomic_rule(colon), rule_ref_expr])),
    (:for_upper,    rule_seq([rule_id, rule_ops([lower, lower_eq]), rule_ref_expr])),
    (:for_range,    rule_seq([rule_id, atomic_rule(equals), rule_ref_expr, rule_ops([double_dot, triple_dot]), rule_ref_expr])),
    (:repeat,       rule_ref_expr)
  ]);

ParsingRule rule_let_stmt(<fn, proc> ctx) =
  rule_seq([
    keyword_let,
    par_rule(comma_sep_seq(rule_seq([rule_id, atomic_rule(equals), rule_ref_expr]))),
    rep_rule(rule_ref_stmt(ctx), true),
    atomic_rule(semicolon)
  ]);

ParsingRule rule_break_stmt =
  rule_seq([
    keyword_break,
    optional_rule_seq([keyword_if, rule_ref_expr]),
    atomic_rule(semicolon)
  ]);

ParsingRule rule_fail_stmt =
  rule_seq([
    keyword_fail,
    optional_rule_seq([keyword_if, rule_ref_expr]),
    atomic_rule(semicolon)
  ]);

ParsingRule rule_assert_stmt = rule_seq([keyword_assert, rule_ref_expr, atomic_rule(semicolon)]);

ParsingRule rule_print_stmt =
  rule_seq([
    keyword_print,
    rule_ref_expr,
    optional_rule_seq([keyword_if, rule_ref_expr]),
    atomic_rule(semicolon)
  ]);

ParsingRule rule_imp_update_stmt =
  rule_seq([
    rule_id,
    bracket_rule(rule_ref_expr),
    atomic_rule(assign),
    rule_ref_expr,
    atomic_rule(semicolon)
  ]);

ParsingRule rule_no_val_ret_stmt =
  rule_seq([
    keyword_return,
    optional_rule_seq([keyword_if, rule_ref_expr]),
    atomic_rule(semicolon)
  ]);

ParsingRule rule_proc_call_stmt =
  rule_seq([
    optional_rule_seq([rule_id, atomic_rule(equals)]),
    atomic_rule(mixedcase_id),
    par_rule(opt_comma_sep_seq(rule_ref_expr)),
    atomic_rule(semicolon)
  ]);

ParsingRule rule_auto_input_update_stmt =
  rule_seq([
    keyword_update,
    atomic_rule(lowercase_id),
    comma_sep_seq(rule_seq([atomic_rule(lowercase_id), atomic_rule(equals), rule_expr])),
    atomic_rule(semicolon)
  ]);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_clause =
  rule_choice([
    (:in,   rule_in_clause),
    (:eq,   rule_seq([rule_id, atomic_rule(equals), rule_ref_expr]))
  ]);

ParsingRule rule_in_clause =
  rule_seq([
    rule_clause_ptrn,
    optional_rule_seq([atomic_rule(at), rule_clause_ptrn]),
    atomic_rule(left_arrow),
    rule_ref_expr
  ]);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_expr = rule_expr_10;

ParsingRule rule_expr_10  = rule_seq([rule_expr_9, optional_rule_seq([atomic_rule(at), rule_expr_9])]);
ParsingRule rule_expr_9   = rep_rule(rule_expr_8, ops_prec_log, true, true);
ParsingRule rule_expr_8   = rule_seq([rule_expr_7, optional_rule_seq([ops_prec_eq, rule_expr_7])]);
ParsingRule rule_expr_7   = rule_seq([rule_expr_6, optional_rule_seq([ops_prec_ord, rule_expr_6])]);
ParsingRule rule_expr_6   = rep_rule(rule_expr_5, ops_prec_sum, true, true);
ParsingRule rule_expr_5   = rep_rule(rule_expr_4, ops_prec_prod, true, true);
ParsingRule rule_expr_4   = rule_seq([optional_rule(rule_anon_choice([atomic_rule(minus), keyword_not])), rule_expr_3]);
ParsingRule rule_expr_3   = rep_rule(rule_expr_2, atomic_rule(circumflex), true, false);
ParsingRule rule_expr_2   = rule_seq([rule_expr_1, optional_rule_seq([atomic_rule(double_colon), rule_type])]);
ParsingRule rule_expr_1   = rule_seq([rule_expr_0, rep_rule(rule_dot_or_sub), optional_rule(rule_dot_access(true))]);

ParsingRule rule_dot_or_sub             = rule_choice([(:dot, rule_dot_access(false)), (:sub, rule_subscript_op)]);
ParsingRule rule_subscript_op           = bracket_rule(rule_ref_expr);

ParsingRule rule_dot_access(Bool test)
{
  lr = atomic_rule(question_mark);
  lr = rule_neg(lr) if not test;
  return rule_seq([atomic_rule(dot), atomic_rule(lowercase_id), lr]);
}


ParsingRule rule_expr_0 =
  rule_choice([
    (:tag_obj,      rule_seq([atomic_rule(qualified_symbol), par_rule(rule_ref_expr)])),

    (:integer,      atomic_rule(integer)),
    (:symbol,       atomic_rule(qualified_symbol)),
    (:string,       atomic_rule(string)),
    (:float,        atomic_rule(float)),

    (true,          atomic_rule(keyword(true))),
    (false,         atomic_rule(keyword(false))),
    (nil,           atomic_rule(keyword(nil))),

    (:set,          brace_rule(opt_comma_sep_seq(rule_subexpr))),
    (:map,          par_rule(opt_comma_sep_seq(rule_map_entry))),
    (:record,       rule_record_expr),
    (:seq,          rule_seq_expr),
    (:seq_tail,     rule_seq_tail_expr),

    (:tag_record,   rule_tag_record_expr),

    (:builtin_call, rule_seq([atomic_rule(builtin), par_rule(comma_sep_seq(rule_ref_expr))])),

    (:par_exprs,    par_rule(comma_sep_seq(rule_ref_expr))),

    (:ex_qual,      rule_ex_qual_expr),
    (:set_cp,       rule_set_cp_expr),
    (:map_cp,       rule_map_cp_expr),
    (:seq_cp,       rule_seq_cp_expr),

    (:alt_cp,       rule_alt_cp_expr),


    (:if_else,      rule_if_expr),
    (:match_expr,   rule_match_expr),
    (:proc,         brace_rule(rep_rule(rule_ref_stmt(:fn), true))),

    (:fn_call,      rule_fn_call_expr),
    (:const_or_var, rule_id),
    (:cls_par,      atomic_rule(qual_var))
  ]);

ParsingRule rule_subexpr = rule_seq([rule_ref_expr, optional_rule_seq([keyword_if, rule_ref_expr])]);

ParsingRule rule_map_entry =
  rule_seq([
    rule_ref_expr,
    atomic_rule(double_right_arrow),
    rule_ref_expr,
    optional_rule(
      rule_seq([
        keyword_if,
        rule_ref_expr
      ])
    )
  ]);

ParsingRule rule_record_expr =
  par_rule(
    comma_sep_seq(
      rule_seq([
        atomic_rule(label),
        rule_ref_expr,
        optional_rule_seq([keyword_if, rule_ref_expr])
      ])
    )
  );

ParsingRule rule_seq_expr = bracket_rule(opt_comma_sep_seq(rule_subexpr));

ParsingRule rule_seq_tail_expr =
  bracket_rule(
    rule_seq([
      rule_ref_expr,
      rule_seq([atomic_rule(pipe), comma_sep_seq(rule_ref_expr)]) //## MAYBE HERE I SHOULD ALLOW ALSO A CONDITIONAL EXPRESSION
    ])
  );

//## MAYBE I SHOULD ALLOW ALSO SYMBOLS FOR THE FIRST TOKEN, IN CASE THE SYMBOL NAME CONFLICTS WITH A KEYWORD
ParsingRule rule_tag_record_expr = rule_seq([atomic_rule(lowercase_id), rule_record_expr]);

ParsingRule rule_fn_call_expr =
  rule_seq([
    rule_anon_choice([rule_id, atomic_rule(operator)]),
    par_rule(
      rule_seq([
        comma_sep_seq(
          rule_seq([
            rule_neg(rule_actual_named_arg),
            rule_ref_expr
          ])
        ),
        rep_rule(
          rule_seq([
            atomic_rule(comma),
            rule_actual_named_arg
          ])
        )
      ])
    )
  ]);

ParsingRule rule_actual_named_arg =
  rule_seq([
    rule_id,
    optional_rule(par_rule(comma_sep_seq(rule_id))),
    atomic_rule(equals),
    rule_ref_expr
  ]);

ParsingRule rule_ex_qual_expr =
  par_rule(
    rule_seq([
      atomic_rule(question_mark),
      comma_sep_seq(rule_clause),
      optional_rule(
        rule_seq([
          atomic_rule(colon),
          comma_sep_seq(rule_ref_expr)
        ])
      )
    ])
  );

ParsingRule rule_set_cp_expr =
  brace_rule(
    rule_seq([
      rule_ref_expr,
      atomic_rule(colon),
      comma_sep_seq(rule_clause),
      optional_rule(
        rule_seq([
          atomic_rule(comma),
          comma_sep_seq(rule_ref_expr)
        ])
      )
    ])
  );

ParsingRule rule_map_cp_expr =
  par_rule(
    rule_seq([
      rule_ref_expr,
      atomic_rule(double_right_arrow),
      rule_ref_expr,
      atomic_rule(colon),
      comma_sep_seq(rule_clause),
      optional_rule_seq([atomic_rule(comma), comma_sep_seq(rule_ref_expr)])
    ])
  );

ParsingRule rule_alt_cp_expr =
  rule_seq([
    keyword_for,
    par_rule(comma_sep_seq(rule_clause)),
    optional_rule(
      rule_seq([
        keyword_if,
        par_rule(comma_sep_seq(rule_ref_expr))
      ])
    ),
    rule_choice([
      (:set,  brace_rule(rule_ref_expr)),
      (:map,  par_rule(rule_seq([rule_ref_expr, atomic_rule(double_right_arrow), rule_ref_expr])))
    ])
  ]);

ParsingRule rule_seq_cp_expr =
  bracket_rule(
    rule_seq([
      rule_ref_expr,
      atomic_rule(colon),
      rule_choice([
        ( :seq,
          rule_seq([
            comma_sep_seq(rule_id),
            optional_rule_seq([atomic_rule(at), rule_id]),
            atomic_rule(left_arrow)
          ])
        ),
        (:range, rule_seq([rule_id, rule_ops([lower, lower_eq])]))
      ]),
      rule_ref_expr,
      optional_rule_seq([atomic_rule(comma), rule_ref_expr])
    ])
  );

ParsingRule rule_if_expr =
  rule_seq([
    keyword_if,
    comma_sep_seq(
      rule_seq([
        rule_ref_expr,
        keyword_then,
        rule_ref_expr
      ])
    ),
    keyword_else,
    rule_ref_expr
  ]);

ParsingRule rule_match_expr =
  rule_seq([
    keyword_match,
    par_rule(comma_sep_seq(rule_ref_expr)),
    comma_sep_seq(rule_switch_case)
  ]);

ParsingRule rule_switch_case =
  rule_seq([
    comma_sep_seq(rule_switch_ptrn),
    atomic_rule(equals),
    rule_ref_expr
  ]);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ParsingRule rule_auto_def =
  rule_seq([
    keyword_auto,
    atomic_rule(lowercase_id),
    optional_rule(par_rule(comma_sep_seq(atomic_rule(lowercase_id)))),
    brace_rule(rep_rule(rule_auto_decl))
  ]);

ParsingRule rule_auto_decl =
  rule_choice([
    (:input,      rule_input_decl),
    (:output,     rule_output_decl),
    (:state,      rule_state_decl),
    (:plain_rule, rule_plain_rule),
    (:cond_rule,  rule_cond_rule)
  ]);

ParsingRule rule_input_decl =
  rule_seq([
    keyword_input,
    comma_sep_seq(rule_seq([rule_type, atomic_rule(lowercase_id)])),
    atomic_rule(semicolon)
  ]);

ParsingRule rule_output_decl =
  rule_seq([
    keyword_output,
    comma_sep_seq(rule_seq([rule_type, atomic_rule(lowercase_id)])),
    atomic_rule(semicolon)
  ]);

ParsingRule rule_state_decl =
  rule_seq([
    keyword_state,
    comma_sep_seq(
      rule_seq([
        rule_type,
        atomic_rule(lowercase_id),
        atomic_rule(equals),
        rule_expr
      ])
    ),
    atomic_rule(semicolon)
  ]);

ParsingRule rule_plain_rule =
  rule_seq([
    atomic_rule(lowercase_id),
    atomic_rule(equals),
    rule_expr,
    atomic_rule(semicolon)
  ]);

ParsingRule rule_cond_rule =
  rule_seq([
    atomic_rule(lowercase_id),
    atomic_rule(equals),
    comma_sep_seq(rule_seq([rule_expr, keyword_if, rule_expr])),
    atomic_rule(semicolon)
  ]);

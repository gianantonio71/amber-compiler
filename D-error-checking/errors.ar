type SgnDecl = Function, Method, Update, Handler;

type AnyAuto = Database, Automaton;

type AnyReactAutoVar = AutoMembVar, AutoMembVarCopy, QualDBMembVar, QualAutoMembVar;

type CoreWFError  = error_cluster(AnyAuto, [+CoreWFError]),
                    recursively_defined_auto_or_db(AnyAuto),
                    overlapping_signatures(SgnDecl, SgnDecl),
                    dependency_loop(signal: AnyReactAutoVar, deps: [AnyReactAutoVar]),
                    invalid_auto_var(var: Var, signal: Atom, expr: <Expr, TimeVaryingCond>),
                    invalid_nested_auto_input_var(var: Var, auto_id: Atom, input_id: Atom, expr: Expr);

////////////////////////////////////////////////////////////////////////////////

CoreWFError error_cluster(AnyAuto db, [+CoreWFError] es)    = :error_cluster(db, es);
CoreWFError recursively_defined_auto_or_db(AnyAuto db)      = :recursively_defined_auto_or_db(db);
CoreWFError overlapping_signatures(SgnDecl f1, SgnDecl f2)  = :overlapping_signatures(f1, f2);
CoreWFError invalid_auto_var(Var v, Atom s, <Expr, TimeVaryingCond> e)  = invalid_auto_var(var: v, signal: s, expr: e);
CoreWFError dependency_loop(AnyReactAutoVar s, [+AnyReactAutoVar] ds)   = dependency_loop(signal: s, deps: ds);
CoreWFError invalid_nested_auto_input_var(Var v, Atom a, Atom i, Expr e) =
  invalid_nested_auto_input_var(var: v, auto_id: a, input_id: i, expr: e);

////////////////////////////////////////////////////////////////////////////////

String* error_message(CoreWFError err) =
  error_cluster(db?, es?)             = error_cluster_error_message(db, es),
  recursively_defined_auto_or_db(db?) = recursively_defined_auto_or_db_error_message(db),
  overlapping_signatures(f1?, f2?)    = overlapping_signatures_error_message(f1, f2),
  dependency_loop()                   = dependency_loop_error_message(err.signal, err.deps),
  invalid_auto_var()                  = invalid_auto_var_error_message(err.var, err.signal, err.expr),
  invalid_nested_auto_input_var()     = invalid_nested_auto_input_var_error_message(err.var, err.auto_id, err.input_id, err.expr);

////////////////////////////////////////////////////////////////////////////////

String* overlapping_signatures_error_message(SgnDecl d1, SgnDecl d2) = (
  "Overlapping argument types in polymorphic " & artifact_type_name(d1) & ": " & artifact_name(d1),
  "    " & source_code_location_string(source_code_location(d1)),
  "    " & source_code_location_string(source_code_location(d2))
);


String* recursively_defined_auto_or_db_error_message(AnyAuto auto_or_db) {
  auto_type_str = match (auto_or_db)
    data_base() = "Transactional",
    automaton() = "Reactive";

  return (
    auto_type_str & " automata cannot contain themselves: " & user_repr(auto_or_db.name),
    "    " & source_code_location_string(source_code_location(auto_or_db))
  );
}


String* error_cluster_error_message(AnyAuto decl, [+CoreWFError] errs) =
  ( "Error" & plural(errs) & " in transactional automaton definition: " & user_repr(decl.name),
    source_code_location_string(source_code_location(decl))) &
  ("    " & l : l <- join((error_message(e) : e <- rand_sort(errs))));


String* dependency_loop_error_message(AnyReactAutoVar signal, [AnyReactAutoVar]  deps) = (
  "Dependency cycle detected. Signal involved: " & user_repr(signal)
);


String* invalid_auto_var_error_message(Var var, Atom signal, <Expr, TimeVaryingCond> expr) = (
  "Signal " & _str_(signal) & " is not permitted to depend on signal " & user_repr(var)
);


String* invalid_nested_auto_input_var_error_message(Var var, Atom auto_id, Atom input_id, Expr expr) = (
  "Input " & _str_(input_id) & " of nested automaton " & _str_(auto_id) & " is not permitted to depend on signal " & user_repr(var)
);

////////////////////////////////////////////////////////////////////////////////

String source_code_location_string((String, NzNat, NzNat) loc_info) {
  fn, sl, el = loc_info;
  return "File " & fn & " line" & if sl == el then " " & printed(sl) else "s " & printed(sl) & "-" & printed(el);
}

////////////////////////////////////////////////////////////////////////////////

String artifact_type_name(SgnDecl) =
  function()  = "function",
  method()    = "method",
  update()    = "update",
  handler()   = "message handler";


String artifact_name(SgnDecl decl) =
  function()  |
  method()    |
  update()    = user_repr(decl.name, |decl.args|),
  handler()   = "";

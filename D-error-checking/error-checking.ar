[CoreWFError] core_wf_errors(Program prg) {
  schema_typedefs = [type_name(schema_type_symbol(bare_id(db.name)), 0) -> db_state_type(db) : db <- prg.data_bases];
  return core_wf_errors(program = prg, typedefs = prg.typedefs & schema_typedefs);
}

////////////////////////////////////////////////////////////////////////////////

implicit program : Program, typedefs : [TypeName -> NeType] {
  [CoreWFError] core_wf_errors {
    fndefs_families = group_by(program.fndefs, (family_id($.name), arity($)));
    errs = union([function_family_errors(fs) : unused_var, fs <- fndefs_families]);
    return errs & databases_errors & automata_errors;
  }

  //////////////////////////////////////////////////////////////////////////////

  [CoreWFError] function_family_errors([+Function] functions) {
    ord_fns = rand_sort(functions);
    return [overlapping_signatures(f1, f2) : f1 @ i1 <~ ord_fns, f2 <~ drop(ord_fns, i1+1), overlap(f1, f2)];

    Bool overlap(Function f1, Function f2) = none((are_disjoint(a1, a2) : a1, a2 <- zip(f1.args, f2.args)));

    Bool are_disjoint(FormalArg arg1, FormalArg arg2) =
      formal_obj_arg(), formal_obj_arg()  = are_ptype_disjoint(arg1.type, arg2.type),
      formal_cls_arg(), formal_cls_arg()  = false;
  }

  //////////////////////////////////////////////////////////////////////////////

  [CoreWFError] databases_errors {
    db_errs = union([database_errors(db) : db <- program.data_bases]);

    shallow_deps = [db.name -> values(db.nested_dbs) : db <- program.data_bases];
    deep_deps = transitive_closure(shallow_deps);
    rec_errs = [recursively_defined_auto_or_db(data_bases_by_id[db_type]) : db_type, deps <- deep_deps, deps(db_type)];

    return db_errs & rec_errs;
  }


  [CoreWFError] database_errors(Database database) {
    method_errs = union([
      [overlapping_signatures(m1, m2) : m1, m2 <- symmetric_cart_prod(ms), overlap(m1, m2)]
      : unused_var, ms <- group_by(database.methods, ($.name, arity($)))
    ]);

    updates_errs = union([
      [overlapping_signatures(u1, u2) : u1, u2 <- symmetric_cart_prod(us), overlap(u1, u2)]
      : unused_var, us <- group_by(database.updates, ($.name, arity($)))
    ]);

    handler_errs = [
      overlapping_signatures(h1, h2)
      : h1, h2 <- symmetric_cart_prod(database.handlers), not are_ptype_disjoint(h1.type, h2.type)
    ];

    errs = method_errs & updates_errs & handler_errs;
    return [error_cluster(database, errs) if errs != []];
  }

  //////////////////////////////////////////////////////////////////////////////

  [CoreWFError] automata_errors {
    auto_errs = union([automaton_errors(automaton=a) : a <- program.auto_defs]);

    shallow_deps = [auto.name -> [a.type : unused_var, a <- auto.nested_autos] : auto <- program.auto_defs];
    deep_deps = transitive_closure(shallow_deps);
    rec_errs = [recursively_defined_auto_or_db(automaton_by_id(auto_type)) : auto_type, deps <- deep_deps, deps(auto_type)];

    return auto_errs & rec_errs;
  }
}

////////////////////////////////////////////////////////////////////////////////

implicit program : Program, typedefs : [TypeName -> NeType], automaton : Automaton {
  [CoreWFError] automaton_errors {
    overlap_errs = union([
      [overlapping_signatures(m1, m2) : m1, m2 <- symmetric_cart_prod(ms), overlap(m1, m2)]
      : unused_var, ms <- group_by(automaton.methods, ($.name, arity($)))
    ]);
    var_errs = union(union([
      [param_errs(id, info.value) : id, info <- automaton.params],
      [state_var_errs(id, state_var) : id, state_var <- automaton.state],
      [rule_errs(id, expr) : id, expr <- automaton.rules],
      [time_rule_errs(id, rule) : id, rule <- automaton.time_rules],
      [discrete_rules_errs(id, rules) : id, rules <- automaton.discrete_rules],
      [nested_auto_errs(id, info.type, info.args) : id, info <- automaton.nested_autos],
      [nested_db_errs(id, info.msg_send_rule) : id, info <- automaton.nested_dbs, info.msg_send_rule?]
    ]));
    errs = overlap_errs & var_errs;
    errs = dependency_errors if errs == [];
    return if errs != [] then [error_cluster(automaton, errs)] else [];


    [CoreWFError] param_errs(AutoMembVar id, Expr value) = [
      invalid_auto_var(v, id, value) : v <- auto_expr_extern_vars(value), not is_key(v, automaton.params)
    ];


    [CoreWFError] state_var_errs(AutoMembVar id, StateVar state_var) {
      ## HERE I SHOULD ALSO CHECK THAT THE UPDATES ARE NOT GUARANTEED TO FIRE TOGETHER...
      init_vars = continuous_signals_level_1;
      init_errs = [
        invalid_auto_var(v, id, state_var.init_value)
        : v <- auto_expr_extern_vars(state_var.init_value),
          not (v :: QualDBMembVar or in(v, init_vars))
      ];
      update_errs = union([state_var_update_errs(id, u) : u <- state_var.updates]);
      return init_errs & update_errs;
    }


    [CoreWFError] state_var_update_errs(AutoMembVar id, StateVarUpdate update) {
      continuous_signals = continuous_signals_level_2;
      delayed_signals = delayed_signals;
      discrete_signals = enabled_discrete_signals(update.cond);
      // Condition expression check
      cond_expr_vars = auto_expr_extern_vars(update.cond.cond);
      cond_expr_errs = [
        invalid_auto_var(v, id, update.cond.cond)
        : v <- cond_expr_vars,
          not (v :: QualDBMembVar or in(v, continuous_signals) or in(v, discrete_signals))
      ];
      // Value expression check
      value_expr_vars = auto_expr_extern_vars(update.value);
      value_expr_errs = [
        invalid_auto_var(v, id, update.value)
        : v <- cond_expr_vars,
          not (v :: QualDBMembVar or in(v, continuous_signals) or in(v, delayed_signals) or in(v, discrete_signals))
      ];
      return cond_expr_errs & value_expr_errs;
    }


    [CoreWFError] rule_errs(AutoMembVar id, Expr value) {
      signals = continuous_signals_level_2;
      return [
        invalid_auto_var(v, id, value)
        : v <- auto_expr_extern_vars(value), not (v :: QualDBMembVar or in(v, signals))
      ];
    }


    [CoreWFError] time_rule_errs(AutoMembVar id, TimeRule rule) {
      continuous_signals = continuous_signals_level_2;
      discrete_signals = all_discrete_signals;
      return match (rule)
        boolean_time_rule()   |
        unchanged_time_rule() = [ invalid_auto_var(v, id, rule.expr)
                                  : v <- auto_expr_extern_vars(rule.expr),
                                    not (v :: QualDBMembVar or in(v, continuous_signals))
                                ],
        since_time_rule()     = [invalid_auto_var(v, id, v) : v <- rule.signals, not discrete_signals(v)];
    }


    // [CoreWFError] discrete_rules_errs(AutoMembVar id, [+DiscreteRule] rules) {
    ## RESTORE THE ABOVE SIGNATURE ONE THE TYPECHECKING BUG HAS BEEN FIXED
    [CoreWFError] discrete_rules_errs(AutoMembVar id, [DiscreteRule] rules) {
      ## HERE I SHOULD ALSO CHECK THAT THE RULES ARE NOT GUARANTEED TO FIRE TOGETHER...
      continuous_signals = continuous_signals_level_2;
      return [
        invalid_auto_var(v, id, e)
        : r <- rules,
          discrete_signals = enabled_discrete_signals(r.cond),
          e <- [r.cond.cond, r.value], v <- auto_expr_extern_vars(e),
          not (v :: QualDBMembVar or in(v, continuous_signals) or in(v, discrete_signals))
      ];
    }


    [CoreWFError] nested_auto_errs(MembAutoVar id, AutoSymbol type, [Atom -> Expr] args) {
      continuous_signals = continuous_signals_level_2;
      discrete_signals = all_discrete_signals;
      return [
        invalid_nested_auto_input_var(v, id, input_id, e)
        : input_id, e <- args,
          is_discrete = input_is_discrete(type, auto_memb_var(input_id)),
          v <- auto_expr_extern_vars(e),
          not (v :: QualDBMembVar or in(v, continuous_signals) or (is_discrete and in(v, discrete_signals)))
      ];
    }


    [CoreWFError] nested_db_errs(MembDBVar id, MsgSendRule rule) {
      continuous_signals = continuous_signals_level_2;
      discrete_signals = enabled_discrete_signals(rule.cond);
      return [
        invalid_nested_db_msg_var(v, id, rule)
        : e <- [rule.cond.cond, rule.message], v <- auto_expr_extern_vars(e),
          not (v :: QualDBMembVar or in(v, continuous_signals) or in(v, discrete_signals))
      ];
    }
  }


  [CoreWFError] dependency_errors {
    shallow_deps = merge([
      [id -> dependencies(info.value) : id, info <- automaton.params],
      [id -> dependencies(id, sv) : id, sv <- automaton.state],
      [id -> dependencies(e) : id, e <- automaton.rules],
      [id -> dependencies(r) : id, r <- automaton.time_rules],
      [id -> union([dependencies(r) : r <- rs]) : id, rs <- automaton.discrete_rules],
      [id -> union([dependencies(e) : unused_var, e <- info.args]) : id, info <- automaton.nested_autos],
      [id -> dependencies(db.msg_send_rule) : id, db <- automaton.nested_dbs, db.msg_send_rule?]
    ]);
    deep_deps = transitive_closure(shallow_deps);
    return [dependency_loop(v, nonempty(ds)) : v, ds <- deep_deps, ds(v)];


    [AutoMembVar] dependency(AutoMembVar var)     = [var];
    [MembAutoVar] dependency(QualAutoMembVar var) = [cast_memb_auto_var(var.auto_var)];
    [MembDBVar]   dependency(QualDBMembVar var)   = [cast_memb_db_var(var.db_var)];
    []            dependency(PrevVarValue)        = [];


    [<AutoMembVar, MembAutoVar, MembDBVar>] dependencies(Expr expr) =
      union([dependency(v) : v <- auto_expr_extern_vars(expr)]);


    [<AutoMembVar, MembAutoVar, MembDBVar>] dependencies(ReactCond cond) {
      signals_deps = match (cond)
        react_cond()            = union([dependency(v) : v, unused_var <- cond.signals_state]),
        on_becoming_true_cond() = [];
      return dependencies(cond.cond) & signals_deps;
    }


    [<AutoMembVar, MembAutoVar, MembDBVar>] dependencies(AutoMembVar id, StateVar state_var) {
      init_deps = dependencies(state_var.init_value);
      update_deps = union([dependencies(u.value) & dependencies(u.cond) : u <- state_var.updates]) - [id];
      return init_deps & update_deps;
    }


    [<AutoMembVar, MembAutoVar, MembDBVar>] dependencies(TimeRule rule) =
      boolean_time_rule()   |
      unchanged_time_rule() = dependencies(rule.expr),
      since_time_rule()     = rule.signals;


    [<AutoMembVar, MembAutoVar, MembDBVar>] dependencies(DiscreteRule rule) =
      dependencies(rule.value) & dependencies(rule.cond);


    [<AutoMembVar, MembAutoVar, MembDBVar>] dependencies(MsgSendRule rule) =
      dependencies(rule.message) & dependencies(rule.cond);
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  [AnyAutoMembVar] enabled_discrete_signals(ReactCond cond) =
    on_becoming_true_cond() = [],
    react_cond()            = [v : v, s <- cond.signals_state, s, is_discrete(v)];

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  [AutoMembVar] continuous_signals_level_1 =
    keys(automaton.params) &
    [id : id, input <- automaton.inputs, not input.discrete] &
    keys(automaton.state) &
    keys(automaton.rules);

  [AnyAutoMembVar] continuous_signals_level_2 =
    continuous_signals_level_1 &
    keys(automaton.time_rules) &
    [ qual_auto_memb_var(id, out_id)
      : id, info <- automaton.nested_autos,
        out_id, out_info <- automaton_by_id(info.type).outputs,
        not out_info.discrete
    ];

  [<AnyAutoMembVar, PrevVarValue>] delayed_signals =
    [prev_var_value(id) : id, input <- automaton.inputs, not input.discrete] &
    [prev_var_value(id) : id, unused_var <- automaton.state];

  [AnyAutoMembVar] all_discrete_signals =
    [id : id, input <- automaton.inputs, input.discrete] &
    keys(automaton.discrete_rules) &
    [ qual_auto_memb_var(id, out_id)
      : id, info <- automaton.nested_autos,
        out_id, out_info <- automaton_by_id(info.type).outputs,
        out_info.discrete
    ];
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit typedefs : [TypeName -> NeType] {
  Bool overlap(<Method, Update> d1, <Method, Update> d2) =
    none((are_ptype_disjoint(left(a1), left(a2)) : a1, a2 <- zip(d1.args, d2.args)));
}

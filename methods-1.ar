NzNat syn_case_arity(SynCase c) = nz_nat(length(c.patterns));

Nat arity(SynTypeSymbol type):
  type_symbol()     = 0,
  par_type_symbol() = length(type.params);

Nat   syn_type_arity(SynType)          = 0;
NzNat syn_type_arity(SynClsType type)  = length(type.in_types);

Nat arity(SynTypedef)         = 0;
NzNat arity(SynParTypedef td) = length(td.params);

Nat arity(SynFnDef d) = length(d.args);


Nat arity(SynProcDef p) = length(p.args);

Nat arity(SynSgn s) = length(s.args);

Nat arity(SynFnArg arg)
{
  // return 0 if not arg.type?;
  type = arg.type;
  return match (type)
    cls_type() = length(type.in_types),
    _         = 0;
}


[]         type_vars(SynTypedef)        = [];
[+TypeVar] type_vars(SynParTypedef td)  = set(td.params);

////////////////////////////////////////////////////////////////////////////////

[Atom -> (type: NeType, discrete: Bool)] inputs(SynAutoDef auto_def) =
  [i.name -> (type: syn_type_to_type(i.type, nil), discrete: i.discrete) | i <- set(auto_def.inputs)];


[Atom -> (type: NeType, discrete: Bool)] outputs(SynAutoDef auto_def) =
  if auto_def.res_type?
    then [bare_id(auto_def.name) -> (type: syn_type_to_type(auto_def.res_type, nil), discrete: false)]
    else [o.name -> (type: syn_type_to_type(o.type, nil), discrete: o.discrete)
          | o <- set(auto_def.outputs)];


type AutoInterface  =  ( inputs:         [Atom -> (discrete: Bool)],
                         outputs:        [Atom -> (discrete: Bool)],
                         pos_inputs:     Atom*,
                         default_output: Bool
                       );

type DBInterface    = (memb_vars: [Atom], nested_dbs: [Atom -> Atom]);


AutoInterface interface_info(SynAutoDef auto_def) = (
    inputs:         [n -> (discrete: info.discrete) | n : info <- inputs(auto_def)],
    outputs:        [n -> (discrete: info.discrete) | n : info <- outputs(auto_def)],
    pos_inputs:     auto_def.pos_inputs,
    default_output: auto_def.res_type?
  );


DBInterface interface_info(SynDBDef db_def) = (
    memb_vars:    [d.name | d <- set(db_def.decls), state_var_decl() <~ d],
    nested_dbs:   [d.name -> d.type | d <- set(db_def.decls), nested_db_decl() <~ d]
  );

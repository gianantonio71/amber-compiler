type AutoInterface  =  ( inputs:          [Atom -> (discrete: Bool)],
                         outputs:         [Atom -> (discrete: Bool)],
                         state_vars:      [Atom],
                         rule_vars:       [Atom],
                         pos_inputs:      Atom*,
                         default_output:  Maybe[Atom]
                       );

type DBInterface    = ( memb_vars:  [Atom],
                        rel_vars:   [Atom -> NzNat],
                        nested_dbs: [Atom -> Atom]
                      );

////////////////////////////////////////////////////////////////////////////////

NzNat syn_case_arity(SynCase c) = nz_nat(|c.patterns|);

Nat arity(SynTypeSymbol type) =
  type_symbol()     = 0,
  par_type_symbol() = |type.params|;

Nat   syn_type_arity(SynType)          = 0;
NzNat syn_type_arity(SynClsType type)  = |type.in_types|;

Nat arity(SynTypedef)         = 0;
NzNat arity(SynParTypedef td) = |td.params|;

Nat arity(SynFnDef d) = |d.args|;

Nat arity(SynProcDef p) = |p.args|;

Nat arity(AutoMethodDef m) = |m.args|;

Nat arity(UpdateDef u) = |u.args|;

Nat arity(SynArg arg) = syn_type_arity(arg.type);

[]         type_vars(SynTypedef)        = [];
[+TypeVar] type_vars(SynParTypedef td)  = set(td.params);

////////////////////////////////////////////////////////////////////////////////

[Atom -> (type: NeType, discrete: Bool)] inputs(SynAutoDef auto_def) =
  [i.name -> (type: desugar_type(i.type), discrete: i.discrete) : i <~ auto_def.inputs];


[Atom -> (type: NeType, discrete: Bool)] outputs(SynAutoDef auto_def) =
  if auto_def.res_type?
    then [bare_id(auto_def.name) -> (type: desugar_type(auto_def.res_type), discrete: false)]
    else [o.name -> (type: desugar_type(o.type), discrete: o.discrete)
          : o <~ auto_def.outputs];


implicit syn_prg : SynPrg {
  AutoInterface interface_info(SynAutoDef auto_def) {
    inputs = inputs(auto_def);
    outputs = outputs(auto_def);
    return (
      inputs:         [n -> (discrete: info.discrete) : n, info <- inputs],
      outputs:        [n -> (discrete: info.discrete) : n, info <- outputs],
      state_vars:     set((d.name : d <- auto_def.state_vars)),
      rule_vars:      [r.name : r <- syn_plain_rules(auto_def=auto_def)],
      pos_inputs:     auto_def.pos_inputs,
      default_output: if auto_def.res_type? then just(only(keys(outputs))) else nothing
    );
  }
}



DBInterface interface_info(SynDBDef db_def) {
  decls = set(db_def.decls);
  relvars_decls = [d : d <- decls, relvars_decl() ?= d];

  main_relvars = [d.name -> |d.col_types| : d <- relvars_decls];
  attr_relvars = merge_values([
    [a.name -> nz_nat(|d.col_types| + 1)]
    : d <- relvars_decls, a <~ d.attributes
  ]);

  return (
    memb_vars:    [d.name : d <- decls, state_var_decl() ?= d],
    rel_vars:     main_relvars & [n -> only(as) : n, as <- attr_relvars],
    nested_dbs:   [d.name -> d.type : d <~ db_def.decls, nested_db_decl() ?= d]
  );
}
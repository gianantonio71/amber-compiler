
SynParTypeSymbol syn_par_type_symbol(BasicTypeSymbol s, [SynType^] ps) = par_type_symbol(symbol: s, params: ps);

////////////////////////////////////////////////////////////////////////////////

SynType       syn_int_range(Int min, Int max)                       = syn_int_range(min: min, max: max);
SynTypeRef    syn_type_ref(BasicTypeSymbol s)                       = :type_ref(s); //## BAD: THIS IS A DUPLICATE OF type_ref(), ONLY THE SIGNATURE IS DIFFERENT
SynTypeRef    syn_type_ref(BasicTypeSymbol s, [SynType^] ps)        = :type_ref(syn_par_type_symbol(s, ps));
SynRecordType syn_record_type([SynRecordField^] fields)             = :record_type(fields);
SynTagObjType syn_tag_obj_type(TagType tag_type, SynType obj_type)  = tag_obj_type(tag_type: tag_type, obj_type: obj_type);
SynTagObjType syn_any_tag_obj_type(SynType obj_type)                = syn_tag_obj_type(atom_type, obj_type);
SynType       syn_union_type([SynType^] types)                      = if length(types) == 1 then types[0] else :union_type(types);

SynTupleType syn_tuple_type([SynType^] ts)
{
  assert length(ts) >= 2;
  return :tuple_type(ts);
}

SynType syn_set_type(SynType elem_type, Bool non_empty)
{
  res_type = ne_set_type(elem_type: elem_type);
  res_type = syn_union_type([empty_set_type, res_type]) if not non_empty;
  return res_type;
}

SynType syn_seq_type(SynType elem_type, Bool non_empty)
{
  res_type = ne_seq_type(elem_type: elem_type);
  res_type = syn_union_type([empty_seq_type, res_type]) if not non_empty;
  return res_type;
}

SynType syn_map_type(SynType key_type, SynType value_type) =
  syn_union_type([
    empty_map_type,
    ne_map_type(key_type: key_type, value_type: value_type)
  ]);

////////////////////////////////////////////////////////////////////////////////

SynClsType syn_cls_type([SynType^] its, SynType ot) = cls_type(in_types: its, out_type: ot);

////////////////////////////////////////////////////////////////////////////////

SynTypedef syn_typedef(BasicTypeSymbol n, SynType t) = typedef(name: n, type: t);

SynParTypedef syn_par_typedef(BasicTypeSymbol n, [TypeVar^] ps, SynType t) = par_typedef(name: n, params: ps, type: t);

////////////////////////////////////////////////////////////////////////////////


ConstOrVar const_or_var(Atom a)                           = :const_or_var(a);

ClsPar cls_par(Nat n)                                     = :cls_par(n);

SynSeqExpr syn_seq_expr([SynSubExpr] es)                  = :seq_expr(es);
SynSeqExpr syn_seq_tail_expr(SynExpr s, [SynExpr^] t)     = seq_tail_expr(seq: s, tail: t);

SynTupleExpr syn_tuple_expr([SynExpr^] es)                = :tuple_expr(es);
SynSetExpr syn_set_expr([SynSubExpr] ses)                 = :set_expr(set(ses));
SynMapExpr syn_map_expr([SynMapExprEntry] es)             = :map_expr(set(es));
SynTagObjExpr syn_tag_obj_expr(SynExpr t, SynExpr o)      = tag_obj_expr(tag: t, obj: o);

SynFnCall syn_fn_call(FnSymbol n, [SynExpr^] ps) = syn_fn_call(n, ps, []);
SynFnCall syn_fn_call(FnSymbol n, [SynExpr^] ps, [(NamedArg, [<var(Atom)>], SynExpr)] nps) = fn_call(name: n, args: ps, named_args: nps);

SynBuiltInCall syn_builtin_call(BuiltIn bi, [SynExpr^] ps) = builtin_call(name: bi, args: ps);

SynBoolExpr syn_and(SynExpr l, SynExpr r) = and(left: l, right: r);
SynBoolExpr syn_or(SynExpr l, SynExpr r)  = or(left: l, right: r);
SynBoolExpr syn_not(SynExpr e)            = :not(e);

SynCmpExpr syn_eq(SynExpr l, SynExpr r)   = eq(left: l, right: r);
SynCmpExpr syn_neq(SynExpr l, SynExpr r)  = neq(left: l, right: r);

SynMembExpr syn_membership(SynExpr e, SynType t) = membership(obj: e, type: t);
// type SynCastExpr    = cast_expr(expr: SynExpr, type: SynType);

SynAccExpr syn_accessor(SynExpr e, Atom f)    = syn_accessor(e, object(f));
SynAccExpr syn_accessor(SynExpr e, SymbObj f) = accessor(expr: e, field: f);

SynAccTestExpr syn_accessor_test(SynExpr e, Atom f)    = syn_accessor_test(e, object(f));
SynAccTestExpr syn_accessor_test(SynExpr e, SymbObj f) = accessor_test(expr: e, field: f);

SynExQualExpr syn_ex_qual([SynClause^] cs, SynExpr c)         = ex_qual(source: cs, cond: c);
SynSCExpr syn_set_comp(SynExpr e, [SynClause^] cs)            = set_comp(expr: e, source: cs);
SynMCExpr syn_map_comp(SynExpr k, SynExpr v, [SynClause^] cs) = map_comp(key_expr: k, value_expr: v, source: cs);

SynIfExpr syn_if_expr([(cond: SynExpr, expr: SynExpr)^] bs, SynExpr ee) = if_expr(branches: bs, else: ee);

SynTryExpr syn_try_expr([SynExpr^] es, [SynCase^] cs) = match_expr(exprs: es, cases: cs);

SynDoExpr syn_do_expr([SynStmt^] ss) = :do_expr(ss);

////////////////////////////////////////////////////////////////////////////////

SynCondExpr syn_cond_expr(SynExpr e, SynExpr c) = cond_expr(expr: e, cond: c);

////////////////////////////////////////////////////////////////////////////////

SynAsgnStmt syn_asgnm_stmt([StdVar^] vs, SynExpr e)                           = assignment_stmt(vars: vs, value: e);
SynReturnStmt syn_ret_stmt(SynExpr e)                                         = :return_stmt(e);
SynIfStmt syn_if_stmt(SynExpr c, [SynStmt^] ss)                               = syn_if_stmt([(cond: c, body: ss)], []);
SynIfStmt syn_if_stmt([(cond: SynExpr, body: [SynStmt^])^] bs, [SynStmt] e)   = if_stmt(branches: bs, else: e);
SynLoopStmt syn_loop_stmt(SynExpr c, [SynStmt^] b)                            = syn_loop_stmt(c, b, false);
SynLoopStmt syn_loop_stmt(SynExpr c, [SynStmt^] b, Bool s)                    = loop_stmt(cond: c, skip_first: s, body: b);
SynInfLoopStmt syn_inf_loop_stmt([SynStmt^] ss)                               = :inf_loop_stmt(ss);
SynForStmt syn_for_stmt([SynIter^] ls, [SynStmt^] b)                          = for_stmt(loops: ls, body: b);
SynLetStmt syn_let_stmt([(NamedArg, SynExpr)^] a, [SynStmt^] b)               = let_stmt(asgnms: a, body: b);
SynAssertStmt syn_assert_stmt(SynExpr c, String f, NzNat l, Maybe[String] t)  = assert_stmt(cond: c, file: f, line: l, text: t);
SynPrintStmt syn_print_stmt(SynExpr e)                                        = :print_stmt(e);
SynImpUpdateStmt syn_imp_update_stmt(StdVar o, SynExpr i, SynExpr v)          = imp_update_stmt(obj: o, idx: i, value: v);

SynProcOnlyStmt syn_proc_call(ProcSymbol n, [SynExpr] ps)                     = proc_call(proc_name: n, args: ps);
SynProcOnlyStmt syn_proc_call(StdVar v, ProcSymbol n, [SynExpr] ps)           = proc_call(res_var: v, proc_name: n, args: ps);

SynAutoUpdateStmt syn_auto_input_update_stmt(AutoVar v, [(input: Atom, value: SynExpr)^] is)  = auto_input_update_stmt(var: v, inputs: is);

SynFnDefStmt syn_fn_def_stmt(SynFnDef fd)                                     = :fn_def_stmt(fd);

SynIter syn_seq_iter([StdVar^] vs, SynExpr e)             = seq_iter(vars: vs, values: e);
SynIter syn_seq_iter([StdVar^] vs, StdVar iv, SynExpr e)  = seq_iter(vars: vs, idx_var: iv, values: e);

////////////////////////////////////////////////////////////////////////////////

SynClause syn_set_elem_clause(StdVar v, SynExpr e)              = set_elem_clause(var: v, src: e);
SynClause syn_map_entry_clause(StdVar kv, StdVar vv, SynExpr e) = map_entry_clause(key_var: kv, value_var: vv, src: e);
SynClause syn_seq_elem_clause(StdVar v, SynExpr e)              = seq_elem_clause(var: v, src: e);
SynClause syn_and_clause([SynClause^] cs)                       = if length(cs) == 1 then cs[0] else :and_clause(cs);
SynClause syn_or_clause(SynClause l, SynClause r)               = or_clause(left: l, right: r);
SynClause syn_match_clause(SynPtrn p, SynExpr e)                = match_clause(ptrn: p, expr: e);
SynClause syn_asgnm_clause(StdVar v, SynExpr e)                 = asgnm_clause(var: v, expr: e);
SynClause syn_filter_clause(SynExpr c)                          = filter_clause(cond: c);

////////////////////////////////////////////////////////////////////////////////

SynPtrn syn_ptrn_integer                          = :ptrn_integer(:integer);
SynPtrn syn_ptrn_integer(Int n)                   = :ptrn_integer(object(n));

SynPtrn syn_ptrn_seq                              = :ptrn_seq;
SynPtrn syn_ptrn_set                              = :ptrn_set;
SynPtrn syn_ptrn_map                              = :ptrn_map;

SynPtrn syn_ptrn_tag_obj(Atom a)                  = syn_ptrn_tag_obj(ptrn_symbol(a), :ptrn_any);
SynPtrn syn_ptrn_tag_obj(TagPtrn tp, SynPtrn op)  = ptrn_tag_obj(tag: tp, obj: op);

SynPtrn syn_ptrn_var(Atom a)                      = syn_ptrn_var(var(a));
SynPtrn syn_ptrn_var(StdVar v)                    = syn_ptrn_var(v, :ptrn_any);
SynPtrn syn_ptrn_var(StdVar v, SynPtrn p)         = ptrn_var(var: v, ptrn: p);

SynPtrn syn_ptrn_type(SynType t)                  = :ptrn_type(t);


SynCase syn_case([SynPtrn^] ps, SynExpr e) = case(patterns: ps, expr: e);

////////////////////////////////////////////////////////////////////////////////

SynSgn syn_sgn(NamedArg n, [SynType] ps, SynType rt) = syn_sgn(name: n, args: ps, res_type: rt);

SynUsingBlock syn_using_block([SynSgn^] ss, [SynFnDef^] fds) = using_block(signatures: ss, fn_defs: fds);

////////////////////////////////////////////////////////////////////////////////

SynInputDecl  syn_input(Atom n, SynType t, Bool d)                        = syn_input(name: n, type: t, discrete: d);
SynOutputDecl syn_output(Atom n, SynType t, Bool d)                       = syn_output(name: n, type: t, discrete: d);
SynStateDecl  syn_state(Atom n, SynType t, SynExpr d)                     = syn_state(name: n, type: t, init_value: d);
SynPlainRule  syn_plain_rule(Atom n, SynExpr e)                           = syn_plain_rule(name: n, expr: e);
SynCondRule   syn_cond_rule(Atom n, [(expr: SynExpr, cond: SynExpr)^] bs) = syn_cond_rule(name: n, branches: bs);

SynAutoDef syn_auto_def(Atom n, [Atom] ps, [AutoDecl] ds)   = syn_auto_def(name: auto_symbol(n), pos_args: ps, decls: ds);

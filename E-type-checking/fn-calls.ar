type SgnSet = sgn_set(
                sgns:           [+FnType],
                agg_sgns:       [FnType],
                ret_type:       Maybe[Type],
                disp_arg_idxs:  Maybe[Nat+],
                refines_env:    Bool
              );


SgnSet preprocess_signatures([+FnType] signatures, [TypeName -> NeType] tdefs)
{
  sgns_by_ret_type = equiv_groups(signatures, is_eq($a.ret_type, $b.ret_type, typedefs=tdefs));
  // new_sgns = nonempty(union({aggregate_signatures(ss, tdefs) : ss <- sgns_by_ret_type}));
  agg_sgns = aggregate_signatures(signatures, tdefs) - signatures;
  if size(sgns_by_ret_type) == 1:
    ret_type = an_elem(only(sgns_by_ret_type)).ret_type;
    maybe_ret_type = if is_param_type(ret_type) then nothing else just(ret_type);
  else
    maybe_ret_type = nothing;
  ;
  disp_arg_idxs = dispatch_args(signatures, tdefs);
  let typedefs = tdefs:
    refines_env = not (s <- signatures : not is_subset(s.ret_type, type_bool)) and
                  (s <- signatures : is_eq(s.ret_type, type_true) or is_eq(s.ret_type, type_false));
  ;
  return sgn_set(
    sgns:           signatures,
    agg_sgns:       agg_sgns,
    ret_type:       maybe_ret_type,
    disp_arg_idxs:  disp_arg_idxs,
    refines_env:    refines_env
  );


  Maybe[Nat+] dispatch_args([+FnType] signatures, [TypeName -> NeType] tdefs)
  {
    a_sgn = an_elem(signatures);
    return nothing if arity(a_sgn) == 0 or (s <- signatures : is_param_type(s));
    sgns = rand_sort(signatures);
    for t @ i <- a_sgn.args:
      return just((i)) if t :: Type and is_dispatch_arg(i, sgns, tdefs);
    ;
    //## THIS CAN BE IMPROVED, I DON'T GENERALLY NEED TO CHECK ALL THE ARGUMENTS
    return just(nonempty((i : a @ i <- a_sgn.args, a :: Type)));
  }


  Bool is_dispatch_arg(Nat idx, FnType+ sgns, [TypeName -> NeType] tdefs)
  {
    count = length(sgns);
    types = (s.args(idx) : s <- sgns);
    fail if not types :: Type*;
    ptypes = (pseudotype(t, tdefs) : t <- types);
    for i < count:
      for j = i+1..count:
        return false if not are_disjoint(ptypes(i), ptypes(j));
      ;
    ;
    return true;
  }
}


[+FnType] aggregate_signatures([+FnType] signatures, [TypeName -> NeType] tdefs) {
  a_sgn = an_elem(signatures);
  sgns = signatures;
  for i < arity(a_sgn):
    sgns = merge_comp_sgns(sgns, i, tdefs);
  ;
  for i < arity(a_sgn):
    sgns = [extend_sgn(s, sgns, i, tdefs) : s <- sgns];
  ;
  return sgns;


  FnType extend_sgn(FnType signature, [+FnType] signatures, Nat arg_idx, [TypeName -> NeType] tdefs) {
    ext_sgns = [s : s <- signatures, other_args_are_supersets(signature, s, arg_idx, tdefs)];
    fail if ext_sgns == [];
    return only(ext_sgns) if size(ext_sgns) == 1;

    merged_arg_type = ne_union_type([cast_type(s.args(arg_idx)) : s <- ext_sgns]);
    if (s <- ext_sgns : not is_subset(s.ret_type, signature.ret_type, typedefs=tdefs)):
      merged_ret_type = type_any;
    else
      merged_ret_type = signature.ret_type;
    ;

    // merged_ret_type = ne_union_superset([s.ret_type : s <- ext_sgns]);
    args = (if i == arg_idx then merged_arg_type else t : t @ i <- signature.args);
    constrs = merge_value_sets_nonempty([s.constrs : s <- ext_sgns]);
    return fn_type(args, signature.impl_args, merged_ret_type, constrs);
  }

  Bool other_args_are_supersets(FnType sgn1, FnType sgn2, Nat arg_idx, [TypeName -> NeType] tdefs) {
    for t1, t2 @ i <- zip(sgn1.args, sgn2.args):
      return false if i!= arg_idx and not is_subset_ex(t1, t2, tdefs);
    ;
    nargs = keys(sgn1.impl_args);
    return false if nargs != keys(sgn2.impl_args);
    for a <- rand_sort(nargs):
      t1 = sgn1.impl_args[a];
      t2 = sgn2.impl_args[a];
      return false if not is_subset_ex(t1, t2, tdefs);
    ;
    return true;
  }

  Bool is_subset_ex(AnyType t1, AnyType t2, [TypeName -> NeType] tdefs) {
    if is_type(t1) and is_type(t2):
      return is_subset(t1, t2, typedefs=tdefs);
    elif is_cls_type(t1) and is_cls_type(t2):
      return is_fn_subtype(t1.in_types, t1.out_type, t2.in_types, t2.out_type, typedefs=tdefs);
    else
      assert false;
      return false;
    ;
  }

  [+FnType] merge_comp_sgns([+FnType] signatures, Nat par_idx, [TypeName -> NeType] tdefs)
  {
    new_sgns = [];
    sgns = signatures;
    while sgns != []:
      sgn = an_elem(sgns);
      comp_sgns = [s : s <- sgns, other_params_are_eq(sgn, s, par_idx, tdefs)];
      new_sgn = if size(comp_sgns) > 1 then merge_all_sgns(nonempty(comp_sgns), par_idx, tdefs) else only(comp_sgns);
      new_sgns = new_sgns & [new_sgn];
      sgns = sgns - comp_sgns;
    ;
    return nonempty(new_sgns);
  }

  FnType merge_all_sgns([+FnType] signatures, Nat par_idx, [TypeName -> Type] tdefs)
  {
    //## BUG BUG BUG: THERE'S PROBABLY A BUG WITH CLOSURE PARAMETERS HERE. INVESTIGATE
    merged_par_type = ne_union_type([cast_type(s.args(par_idx)) : s <- signatures]);
    merged_ret_type = ne_union_superset([s.ret_type : s <- signatures]);
    a_sgn = an_elem(signatures);
    args = (if i == par_idx then merged_par_type else p : p @ i <- an_elem(signatures).args);
    constrs = merge_value_sets_nonempty([s.constrs : s <- signatures]);
    return fn_type(args, a_sgn.impl_args, merged_ret_type, constrs);
  }

  Bool other_params_are_eq(FnType sgn1, FnType sgn2, Nat par_idx, [TypeName -> NeType] tdefs)
  {
    for p1, p2 @ i <- zip(sgn1.args, sgn2.args):
      return false if i != par_idx and not types_or_cls_types_are_eq(p1, p2, tdefs);
    ;
    nargs = keys(sgn1.impl_args);
    return false if nargs != keys(sgn2.impl_args);
    for a <- rand_sort(nargs):
      t1 = sgn1.impl_args[a];
      t2 = sgn2.impl_args[a];
      return false if not types_or_cls_types_are_eq(t1, t2, tdefs);
    ;
    return true;
  }

  Bool types_or_cls_types_are_eq(AnyType t1, AnyType t2, [TypeName -> NeType] tdefs) =
    Type,     Type      = is_eq(t1, t2, typedefs=tdefs),
    ClsType,  ClsType   = is_eq(t1, t2, typedefs=tdefs);
}


implicit
{
  typedefs    : [TypeName -> NeType],
  signatures  : [(FnFamilyId, Nat) -> SgnSet],
  closures    : [ClsVar -> ClsType],
  constraints : [(AtomicFnSymb, NzNat) -> [+ClsType]],
  var_aliases : [[Var]];


  Type fn_call_expr_type(FnSymbol name, AnyExpr* args, [ImplArg -> Expr] impl_args, [Var -> Type] env)
  {
    // If I already have a matching signature among the constraints, I just need that one
    if constraints != [:] and name :: AtomicFnSymb and impl_args == [:] and args :: Expr+:
      fn_key = (name, length(args));
      if constraints(fn_key):
        ret_types = [rs.out_type : rs <- constraints[fn_key], will_dispatch_to(rs, args, env)];
        //## IF THERE IS MORE THAN ONE MATCHING SIGNATURE, I SHOULD SELECT THE MOST
        //## SPECIFIC ONE, OR A SUPERSET OF THE INTERSECTION MAYBE. CERTAINLY NOT
        //## A SUPERSET OF THE UNION
        return union_superset(ret_types) if ret_types != [];
      ;
    ;

    // If all the functions have the same, non-parametric return type we just return that
    fn_key = (name, length(args));
    sgn_set = signatures[fn_key];
    ret_type = sgn_set.ret_type;
    return value(ret_type) if ret_type != nothing;

    sgns = sgn_set.sgns;

    // Now we see if there's one parameter that can "decide" the dispatch
    maybe_idxs = sgn_set.disp_arg_idxs;
    if maybe_idxs != nothing:
      idxs = value(maybe_idxs);
      if length(idxs) == 1:
        // This is treated as a special case for better performance.
        // It makes quite a difference in practice
        idx = only(idxs);
        disp_arg = args(idx);
        fail if not disp_arg :: Expr;
        arg_type = expr_type(disp_arg, env);
        arg_ptype = pseudotype(arg_type, typedefs);
        // I can do this because if disp_arg_idx != nothing then none of the polymorphic signatures is parametric
        ret_types = [s.ret_type : s <- sgns, may_match(s.args(idx), arg_ptype)];
        return union_type(ret_types);
      else
        disp_args = (args(i) : i <- idxs);
        fail if not disp_args :: Expr+;
        arg_types = (expr_type(e, env) : e <- disp_args);
        arg_ptypes = (pseudotype(t, typedefs) : t <- arg_types);
        // I can do this because if disp_arg_idx != nothing then none of the polymorphic signatures is parametric
        ret_types = [s.ret_type : s <- sgns, may_match((s.args(i) : i <- idxs), arg_ptypes)];
        return union_type(ret_types);
      ;
    ;

    // If we are here, it means at least one of the functions is parametric...

    return fn_call_expr_type_last_resort_impl(name, args, impl_args, env);


    Type fn_call_expr_type_last_resort_impl(FnSymbol name, AnyExpr* args, [ImplArg -> Expr] impl_args, [Var -> Type] env) {
      sgns_set = signatures[(name, length(args))];

      actual_args_types, args_idxs = unzip(((expr_type(a, env), i) : a @ i <- args, is_expr(a)));
      return empty_type if in(empty_type, actual_args_types);
      actual_args_ptypes = (pseudotype(t, typedefs) : t <- actual_args_types);

      cls_args, cls_args_idxs = unzip(((a, i) : a @ i <- args, not is_expr(a)));

      ret_types = ();
      for s <- rand_sort(sgns_set.sgns):
        formal_args_types = (cast_type(s.args(i)) : i <- args_idxs);
        if may_match(nonempty(formal_args_types), nonempty(actual_args_ptypes)):
          cls_types = (cast_cls_type(s.args(i)) : i <- cls_args_idxs);
          formal_args_ptypes = (pseudotype(t, typedefs) : t <- formal_args_types);
          actual_type_formal_ptype_pairs = zip(actual_args_types, formal_args_ptypes);
          restricted_actual_arg_types = (type_ptype_intersection(t, pt, typedefs) : t, pt <- actual_type_formal_ptype_pairs);
          type_var_insts = instantiate_type_vars(restricted_actual_arg_types, formal_args_types, cls_args, cls_types, env);
          ret_type = replace_type_vars(s.ret_type, type_var_insts);
          ret_types = (ret_types | ret_type);
        ;
      ;

      return union_type([t : t <~ ret_types]);
    }


    Bool may_match(AnyType+ types, PseudoType+ ptypes)
    {
      assert length(types) == length(ptypes);
      for t @ i <- types:
        fail if not t :: Type;
        return false if are_disjoint(pseudotype(t, typedefs), ptypes(i));
      ;
      return true;
    }


    Bool may_match(AnyType type, PseudoType ptype) =
      Type  = not are_disjoint(pseudotype(type, typedefs), ptype);
  }
}


implicit
{
  typedefs    : [TypeName -> NeType],
  signatures  : [(FnFamilyId, Nat) -> SgnSet],
  closures    : [ClsVar -> ClsType],
  constraints : [(AtomicFnSymb, NzNat) -> [+ClsType]],
  var_aliases : [[Var]];

  [TypeCheckingError] fully_typecheck_fn_call(FnSymbol name, AnyExpr* args, [ImplArg -> Expr] impl_args, Type exp_type, [Var -> Type] env)
  {
    // Making sure the scalar, positional arguments typecheck on their own
    errs = seq_union((typecheck(a, type_any, env) : a <- args, a :: Expr));
    return errs if errs != [];

    // Trying with required functions first
    if constraints != [:] and name :: AtomicFnSymb and impl_args == [:] and args :: Expr+:
      fn_key = (name, length(args));
      if constraints(fn_key):
        for rs <- rand_sort(constraints[fn_key]):
          if seq_union((typecheck(a, t, env) : a, t <- zip(args, rs.in_types))) == []:
            return [invalid_return_type(rs.out_type, exp_type) if not is_subset(rs.out_type, exp_type)];
          ;
        ;
      ;
    ;

    // Simple case first. If there's only one signature, we just typecheck that one directly
    fn_key = (name, length(args));
    if is_key(fn_key, signatures):
      sgn_set = signatures[fn_key];
      all_sgns = sgn_set.sgns;
      // return typecheck_fn_call(name, only(all_sgns), args, impl_args, exp_type) if size(all_sgns) == 1;
      for s <- rand_sort(all_sgns):
        errs = fully_typecheck_fn_call(name, s, args, impl_args, exp_type, env);
        return [] if errs == [];
      ;
      all_agg_sgns = sgn_set.agg_sgns;
      for s <- rand_sort(all_agg_sgns):
        errs = fully_typecheck_fn_call(name, s, args, impl_args, exp_type, env);
        return [] if errs == [];
      ;
    ;

    return gen_fn_call_err_msg(name, args, impl_args, exp_type, env);
  }


  [TypeCheckingError] gen_fn_call_err_msg(FnSymbol name, AnyExpr* args, [ImplArg -> Expr] impl_args, Type exp_type, [Var -> Type] env)
  {
    // If we get here, it means that the function call is not going to typecheck,
    // even though all its scalar, positional arguments do.
    // So we'll just try to determine the type of error.

    // Gathering all the type constraint signatures
    req_sgns = [];
    if name :: AtomicFnSymb and impl_args == [:] and args :: Expr+:
      fn_key = (name, length(args));
      req_sgns = constraints[fn_key] if constraints(fn_key);
    ;

    // Gathering all "real" function signatures
    fn_key = (name, length(args));
    if is_key(fn_key, signatures):
      sgn_set = signatures[fn_key];
      all_sgns = sgn_set.sgns;
      agg_sgns = sgn_set.agg_sgns;
    else
      all_sgns = [];
      agg_sgns = [];
    ;


    // Here we try to determine the (possibly aggregated) signature
    // of the polymorphic functions that may be actually called
    arg_types = (if a :: Expr then just(expr_type(a, env)) else nothing : a <- args);

    candidate_signatures = [s : s <- all_sgns, will_dispatch_to(s, args, env)];
    if candidate_signatures == []:
      candidate_signatures = [s : s <- agg_sgns, will_dispatch_to(s, args, env)];
      if candidate_signatures == []:
        arg_types = (if a :: Expr then just(expr_type(a, env)) else nothing : a <- args);
        avail_sgns = nonempty(all_sgns & [cls_to_fn_type(rs) : rs <- req_sgns]);
        return [no_dispatchable_function_found(name, nz_nat(length(args)), avail_sgns, nonempty(arg_types))];
      ;
    ;

    // There might be more than one candidate signature
    // if the type of one or more parameters is the empty type
    err_sets = [fully_typecheck_fn_call(name, s, args, impl_args, exp_type, env) : s <- candidate_signatures];
    return if in([], err_sets) then [] else an_elem(err_sets);
  }


  [TypeCheckingError] fully_typecheck_fn_call(FnSymbol name, FnType signature, AnyExpr* args, [ImplArg -> Expr] impl_args, Type exp_type, [Var -> Type] env)
  {
    // We first check that all scalar positional parameters (and those parameters only) match
    // the type of the corresponding formal parameter (we already know they typecheck)
    invalid_args = [];
    for p, t @ i <- zip(args, signature.args):
      if p :: Expr and t :: Type:
        actual_arg_type = expr_type(p, env);
        if not is_subset(actual_arg_type, replace_type_vars_with_type_any(t)):
          invalid_args = invalid_args & [(i, p, actual_arg_type)];
        ;
      ;
    ;
    return [invalid_param_types(name, signature, invalid_args)] if invalid_args != [];

    // Now we can instantiate the concrete type for type variables
    if is_param_type(signature):
      res = try_to_instantiate_type_vars(args, signature.args, env);
      return [invalid_cls_param_types(signature, get_error(res))] if is_failure(res);
      type_var_insts = get_result(res);
    else
      type_var_insts = [:];
    ;

    // If there are constraints on those type variable instantiations we check them
    if type_var_insts != [:]:
      errs = union([check_type_var_insts(type_var_insts, n, t) : n, ts <- signature.constrs, t <- ts]);
      return errs if errs != [];
    ;

    // With the type variables instantiated, we can "instantiate" the formal type
    // of the other parameters and verify the corresponding actual parameters typecheck

    // Let's start with positional closure parameters
    cls_errs = [];
    for arg, type <- zip(args, signature.args):
      if arg :: ClsExpr and type :: ClsType:
        arg_types = (replace_type_vars(t, type_var_insts) : t <- type.in_types);
        ret_type = replace_type_vars(type.out_type, type_var_insts);
        cls_errs = cls_errs & typecheck(arg, arg_types, ret_type, env); //## BUG: I THINK THIS IS BROKEN...
      ;
    ;

    // Now implicit parameters
    impl_arg_errs = [];
    // Going through all the implicit arguments in the signature
    for n, t <- rand_sort_pairs(signature.impl_args):
      // Instantiating type variables in the formal type
      //## IMPLICIT ARGUMENTS TYPES ARE NOT SUPPOSED TO CONTAIN TYPE VARIABLES ANYMORE,
      //## SO THIS STEP SHOULD BE USELESS...
      inst_type = replace_type_vars(t, type_var_insts);
      if impl_args(n):
        // The implicit argument has been specified as part of the function call
        impl_arg_errs = impl_arg_errs & typecheck(impl_args[n], inst_type, env);
      elif env(n):
        // The argument has been specified implicitly, as a scalar object
        // The actual parameter is an object, and the formal parameter must be an object too
        // (unless there's a bug in the well-formedness checking code)
        actual_type = env[n];
        if actual_type != empty_type and (inst_type == empty_type or not is_subset(actual_type, cast_type(inst_type))):
          impl_arg_errs = impl_arg_errs & [invalid_implicit_par_type(signature, n, t, inst_type, actual_type)];
        ;
      else
        // The implicit argument has not been provided, either implicitly or explicitly
        impl_arg_errs = impl_arg_errs & [missing_impl_argument(name, n)];
      ;
    ;

    // Now making sure all the function actually has all the provided implicit arguments
    invalid_nargs = keys(impl_args) - keys(signature.impl_args);
    impl_arg_errs = impl_arg_errs & [invalid_impl_argument(a) : a <- invalid_nargs];

    // Now let's see if the type of the result is OK.
    actual_ret_type = replace_type_vars(signature.ret_type, type_var_insts);
    ret_type_errs = [invalid_return_type(actual_ret_type, exp_type) if not is_subset(actual_ret_type, exp_type)];

    //## BAD: HERE I SHOULD PROVIDE MORE INFORMATION ABOUT THESE ERRORS
    return cls_errs & impl_arg_errs & ret_type_errs;
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  [TypeCheckingError] check_type_var_insts([TypeVar -> Type] insts, AtomicFnSymb fn_name, ClsType fn_type)
  {
    args_types = (replace_type_vars(t, insts) : t <- fn_type.in_types);
    ret_type = replace_type_vars(fn_type.out_type, insts);

    fn_key = (fn_name, length(args_types));

    constrs = if constraints(fn_key) then constraints[fn_key] else [];
    for rs <- rand_sort(constrs):
      if all((is_subset(at, et) : at, et <- zip(args_types, rs.in_types))):
        err = invalid_prot_method_return_type(fn_name, args_types, ret_type, rs.out_type);
        return [err if not is_subset(rs.out_type, ret_type)];
      ;
    ;

    fn_key = (fn_name, arity(fn_type));
    if signatures(fn_key):
      sgn_set = signatures[fn_key];
      all_sgns = sgn_set.sgns;
      all_agg_sgns = sgn_set.agg_sgns;
      for s <- rand_sort(all_sgns) & rand_sort(all_agg_sgns):
        if s.impl_args == [:] and s.constrs == [:]:
          if all((is_ne_type(et) and is_subset(at, et) : at, et <- zip(args_types, s.args))):
            err = invalid_prot_method_return_type(fn_name, args_types, ret_type, s.ret_type);
            return [err if not is_subset(s.ret_type, ret_type)];
          ;
        ;
      ;
    else
      all_sgns = [];
    ;

    return [
      no_suitable_prot_method_found(
        method_name:    fn_name,
        args_types:     args_types,
        ret_type:       ret_type,
        instantiations: insts,
        constraints:    constrs,
        signatures:     all_sgns
      )
    ];
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  Result[[TypeVar -> Type], [TypeCheckingError]] try_to_instantiate_type_vars(AnyExpr* args, AnyType* arg_types, [Var -> Type] env)
  {
    actual_types = ();
    formal_types = ();
    for p, t <- zip(args, arg_types):
      if p :: Expr and t :: Type:
        actual_types = (actual_types | expr_type(p, env));
        formal_types = (formal_types | t);
      ;
    ;
    type_var_insts = type_var_instantiations_for_subset(actual_types, formal_types);

    // OK, now we have our initial instantiations, based on the type of scalar parameters.
    // Next we must complete and refine those instantiations by looking at closure parameters

    cls_pars = ((p, t) : p, t <- zip(args, arg_types), p :: ClsExpr and t :: ClsType);
    for 5:
      new_type_pairs = ();
      for p, t <- cls_pars:
        rp = rewrite_cls_expr(p);
        errs = typecheck_closure_params(rp, t, type_var_insts, env);
        return failure(errs) if errs != [];
        actual_ret_type = get_return_type(rp, t, type_var_insts, env);
        if not is_subset(actual_ret_type, replace_type_vars_with_type_any(t.out_type)):
          return failure([]); //## BAD: ADD MEANINGFUL ERROR MESSAGE
        ;
        new_type_pairs = (new_type_pairs | (actual_ret_type, t.out_type));
      ;
      new_actual_types, new_formal_types = unzip(new_type_pairs);
      new_type_var_insts = type_var_instantiations_for_subset(new_actual_types, new_formal_types);
      return success(type_var_insts) if has_reached_fixpoint(type_var_insts, new_type_var_insts);
      type_var_insts = merge_insts(type_var_insts, new_type_var_insts);
    ;
    return failure([]); //## BAD: ADD MEANINGFUL ERROR MESSAGE


    [TypeCheckingError] typecheck_closure_params(ClsExpr expr, ClsType type, [TypeVar -> Type] type_var_insts, [Var -> Type] env) =
      ClsVar      = {
        actual_type = closures[expr];
        errs = [];
        for actual_par_type, formal_par_type <- zip(actual_type.in_types, type.in_types):
          if not is_subset(replace_type_vars(formal_par_type, type_var_insts), actual_par_type):
            errs = errs & [invalid_cls_var_type(expr, type, type_var_insts)];
          ;
        ;
        return errs;
      },
      fn_ptr()    = {fail;},
      cls_expr()  = {
        inst_formal_par_types = (replace_type_vars(t, type_var_insts) : t <- type.in_types);
        new_env = get_updated_env(env, expr.args, inst_formal_par_types);
        return typecheck(expr.expr, replace_type_vars_with_type_any(type.out_type), new_env);
      };
  }
}

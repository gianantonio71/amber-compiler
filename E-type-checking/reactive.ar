implicit program : Program, typedefs : [TypeName -> NeType] {
  [<Automaton, Method> -> [+TypeCheckingError]] typecheck_automaton(Automaton auto) =
    typecheck_automaton(context=auto, var_aliases=[], typed_vars=[]);
}


implicit program : Program, typedefs : [TypeName -> NeType], context : Automaton, var_aliases : [], typed_vars : [] {
  [<Automaton, Method> -> [+TypeCheckingError]] typecheck_automaton {
    // Typechecking and inferring type of consts
    consts = context.params;
    consts_vars = [id -> dependencies(info.value) : id, info <- consts];
    expl_consts_types = [auto_memb_var(id) -> info.type : id, info <- consts, info.type?];

    consts_ids = keys(consts);
    curr_env = expl_consts_types;
    while consts_ids != []:
      ready_consts = [c : c <- consts_ids, not (v <- consts_vars[c] : not curr_env(v, *))];
      return [context -> [auto_typechecking_cycle(context.name, consts_ids)]] if ready_consts == [];
      errs = union([
        typecheck(info.value, if info.type? then info.type else type_any, curr_env)
        : c <- ready_consts, info = consts[c]
      ]);
      return [context -> errs] if errs != [];
      env_delta = [
        v -> expr_type(consts[c].value, curr_env)
        : c <- ready_consts, v = auto_memb_var(c), not curr_env(v, *)
      ];
      curr_env = curr_env & env_delta;
      consts_ids = consts_ids - ready_consts;
    ;

    // All explicitly declared types, except for outputs
    inputs_types      = [auto_memb_var(id) -> info.type : id, info <- context.inputs];
    state_vars_types  = [auto_memb_var(id) -> info.type : id, info <- context.state];
    time_rules_types  = [auto_memb_var(id) -> type_bool : id, unused_var <- context.time_rules];

    expl_types = inputs_types & state_vars_types & time_rules_types;

    // Typechecking and inferring types of rules
    rules = context.rules;
    rules_vars = [id -> dependencies(expr) : id, expr <- rules];

    rule_ids = keys(rules);
    curr_env = curr_env & expl_types;
    while rule_ids != []:
      ready_rules = [r : r <- rule_ids, not (v <- rules_vars[r] : not curr_env(v, *))];
      return [context -> [auto_typechecking_cycle(context.name, rule_ids)]] if ready_rules == [];
      errs = union([typecheck(rules[r], type_any, curr_env) : r <- ready_rules]);
      return [context -> errs] if errs != [];
      env_delta = [auto_memb_var(r) -> expr_type(rules[r], curr_env) : r <- ready_rules];
      assert disjoint(keys(curr_env), keys(env_delta));
      curr_env = curr_env & env_delta;
      rule_ids = rule_ids - ready_rules;
    ;

    // Typechecking and inferring types of discrete rules
    actions = context.actions & context.rep_actions;
    actions_deps = [a -> action_deps(a) : a <- actions];

    while actions != []:
      ready_actions = [a : a <- actions, not (v <- actions_deps[a] : not curr_env(v, *))];
      if ready_actions == []:
        disc_rule_ids = nonempty(union([disc_rule_ids(a) : a <- actions]));
        return [context -> [auto_typechecking_cycle(context.name, disc_rule_ids)]];
      ;
      errs = union([typecheck_action(a, curr_env) : a <- ready_actions]);
      return [context -> errs] if errs != [];
      env_delta = [v -> union_superset(ts) : v, ts <- merge_values([disc_signals_types(a, curr_env) : a <- ready_actions])];
      ## NOTE THAT HERE I'M ASSUMING DISCRETE RULES HAVE A SINGLE DEFINITION,
      ## WHICH IS CURRENTLY TRUE BUT MAY CHANGE IN THE FUTURE
      assert disjoint(keys(curr_env), keys(env_delta));
      curr_env = curr_env & env_delta;
      actions = actions - ready_actions;
    ;

    // Checking all outputs have the right type
    errs = [
      invalid_output_type(id, actual_type, info.type)
      : id, info <- context.outputs, actual_type = curr_env[auto_memb_var(id)], not is_subset(actual_type, info.type)
    ];
    return [context -> errs] if errs != [];

    // Now that we have the type of all member variables, we can typecheck all the remaining expressions
    errs = union([
      // Initial value of all state variables
      union([typecheck(info.init_value, info.type, curr_env) : unused_var, info <- context.state]),
      // Time-varying conditions
      union([typecheck_time_varying_cond(tvc, curr_env) : unused_var, tvc <- context.time_rules]),
      // Nested automata inputs
      union([typecheck_nested_auto_inputs(info.type, info.args, curr_env) : unused_var, info <- context.nested_autos])
    ]);
    return [context -> errs] if errs != [];

    // Typechecking methods
    return [m -> es : m <- context.methods, es = typecheck_auto_method(m, curr_env), es != []];
  }


  [TypeCheckingError] typecheck_time_varying_cond(TimeVaryingCond cond, [EnvVar -> Type] env) =
    time_varying_boolean_cond()   = typecheck(cond.expr, type_bool, env),
    time_varying_unchanged_cond() = typecheck(cond.expr, type_any, env),
    time_varying_since_cond()     = [];


  [TypeCheckingError] typecheck_action(<AutoCondAction, AutoRepAction> action, [EnvVar -> Type] env) {
    errs = typecheck(action.cond, type_bool, env);
    return errs if errs != [];
    env_when_true, env_when_false = refine_env(action.cond, env);
    return union([typecheck_action(a, env_when_true)  : a <- action.body]) &
           union([typecheck_action(a, env_when_false) : a <- action.else]);
  }


  [TypeCheckingError] typecheck_action(AutoUpdate action, [EnvVar -> Type] env) {
    exp_type = env[auto_memb_var(action.target)];
    return typecheck(action.value, exp_type, env);
  }


  [TypeCheckingError] typecheck_action(AutoSetDiscrete action, [EnvVar -> Type] env) =
    typecheck(action.value, type_any, env);


  [TypeCheckingError] typecheck_action(AutoMsgSend action, [EnvVar -> Type] env) {
    db_type = var_type(action.target);
    db_msg_type = msg_type_by_db[db_type];
    return typecheck(action.message, db_msg_type, env);
  }


  [TypeCheckingError] typecheck_nested_auto_inputs(AutoSymbol auto_type, [Atom -> Expr] args, [EnvVar -> Type] env) {
    inputs = automata_by_id[auto_type].inputs;
    return union([typecheck(e, inputs[i].type, env) : i, e <- args]);
  }


  [TypeCheckingError] typecheck_auto_method(Method method, [EnvVar -> Type] env) {
    aliases = [[fn_par(i), value(v)] : unused_var, v @ i <~ method.args, v != nothing];
    env_delta = merge([[fn_par(i) -> t, value(v) -> t if v != nothing] : t, v @ i <~ method.args]);
    return typecheck(method.expr, method.ret_type, env & env_delta, var_aliases = aliases);
  }

  //////////////////////////////////////////////////////////////////////////////

  [AutoMembVar -> Type] disc_signals_types(<AutoCondAction, AutoRepAction> action, [EnvVar -> Type] env) {
    env_when_true, env_when_false = refine_env(action.cond, env);
    body_types = [disc_signals_types(a, env_when_true) : a <- action.body];
    else_types = [disc_signals_types(a, env_when_false) : a <- action.else];
    merged_types = merge_values(body_types & else_types);
    return [v -> union_superset(ts) : v, ts <- merged_types];
  }


  [AutoMembVar -> Type] disc_signals_types(AutoSetDiscrete action, [EnvVar -> Type] env) =
    [auto_memb_var(action.target) -> expr_type(action.value, env)];


  [] disc_signals_types(<AutoUpdate, AutoMsgSend>, [EnvVar -> Type]) = [];
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[AutoMembVar] action_deps(AutoAtomicAction action) =
  state_update()        = [],
  discrete_signal_def() = dependencies(action.value),
  msg_send()            = [];

[AutoMembVar] action_deps(<AutoCondAction, AutoRepAction> action) =
  dependencies(action.cond) & union([action_deps(a) : a <- action.body | a <- action.else]);

////////////////////////////////////////////////////////////////////////////////

[AutoMembVar] dependencies(Expr expr) {
  return [redirect(v) : v <- auto_expr_extern_vars(expr), is_self_var(v)];

  AutoMembVar redirect(AutoMembVar v)     = v;
  AutoMembVar redirect(AutoMembVarCopy v) = auto_memb_var(bare_id(v));

  True  is_self_var(<AutoMembVar, AutoMembVarCopy>)   = true;
  False is_self_var(<QualDBMembVar, QualAutoMembVar>) = false;
}

////////////////////////////////////////////////////////////////////////////////

[Atom] disc_rule_ids(AutoAtomicAction action) =
  state_update()        = [],
  discrete_signal_def() = [action.target],
  msg_send()            = [];

[Atom] disc_rule_ids(<AutoCondAction, AutoRepAction> action) =
  union([disc_rule_ids(a) : a <- action.body | a <- action.else]);

implicit
{
  typedefs    : [TypeName -> NeType],
  signatures  : [(FnFamilyId, Nat) -> SgnSet],
  closures    : [ClsVar -> ClsType],
  var_aliases : [[Var]];


  [TypeCheckingError] typecheck(Expr expr, Type exp_type, [Var -> Type] env)
  {
    // Preliminary typechecking, just to make sure we can safely calculate the expression type
    // For some types of expressions, this ends up being a complete type check
    errs = pre_typecheck(expr, exp_type, env);
    // Some types of expressions need errors to be made more detailed
    if errs != [] and expr :: <UnaryPseudoCall, RelMembTest, AccExpr, AccTestExpr>:
      ref_errs = gen_err_msgs(expr, exp_type, env);
      errs = ref_errs if ref_errs != [];
    ;
    if errs == [] and needs_res_type_check(expr):
      // Checking that the result type is (a subset of) the expected one
      actual_type = expr_type(expr, env);
      if not is_subset(actual_type, exp_type):
        errs = [unexpected_actual_type(actual_type, exp_type)];
      ;
    ;
    return [add_anchor_if_needed(err, expr) : err <- errs];


    Bool needs_res_type_check(Expr):
      fn_call()     |
      if_expr()     |
      match_expr()  |
      do_expr()     = false,
      _             = true;
  }


  [TypeCheckingError] pre_typecheck(Expr expr, Type exp_type, [Var -> Type] env):
    object(obj?)        = [],
    float_lit()         = [],
    seq_expr(ses?)      = seq_union((typecheck(se, type_any, env) : se <- ses)),
    tuple_expr(es?)     = seq_union((typecheck(e, type_any, env) : e <- es)),
    seq_tail_expr()     = typecheck(expr.seq, type_seq, env) & seq_union((typecheck(e, type_any, env) : e <- expr.tail)),
    set_expr(ses?)      = union([typecheck(se, type_any, env) : se <- ses]),
    map_expr(es?)       = union([pre_typecheck_map_entry(e, env) : e <- es]),
    bin_rel_expr(es?)   |
    tern_rel_expr(es?)  = union([pre_typecheck_rel_entry(e, env) : e <- es]),
    tag_obj_expr()      = typecheck(expr.tag, atom_type, env) & typecheck(expr.obj, type_any, env),
    Var                 = [],
    fn_call()           = fully_typecheck_fn_call(expr.name, expr.args, expr.impl_args, exp_type, env),
    cls_call()          = seq_union((typecheck(e, t, env) : e, t <- zip(expr.args, closures[expr.name].in_types))),
    builtin_call()      = seq_union((typecheck(p, t, env) : p, t <- zip(expr.args, builtin_signature(expr.name).param_types))),
    unary_pseudo_call() = pre_typecheck_unary_pseudo_call(expr.target, expr.arg, env),
    rel_memb_test()     = pre_typecheck_rel_memb_test(expr.rel, expr.args, env),
    singl_only_elem()   = typecheck(expr.set, type_set, env),
    and_expr()          = pre_typecheck_and_expr(expr.left, expr.right, env),
    or_expr()           = pre_typecheck_or_expr(expr.left, expr.right, env),
    not_expr(e?)        = typecheck(e, type_bool, env),
    eq()                = pre_typecheck_eq_expr(expr.left, expr.right, env),
    membership()        = pre_typecheck_membership(expr.obj, expr.type, env),
    cast_expr()         = pre_typecheck_cast_expr(expr.expr, expr.type, env),
    accessor()          = pre_typecheck_accessor_expr(expr.expr, expr.field, env),
    accessor_test()     = typecheck(expr.expr, type_dot_access_target, env),
    if_expr()           = fully_typecheck_if_expr(expr.cond, expr.then, expr.else, exp_type, env),
    match_expr()        = fully_typecheck_match_expr(expr.exprs, expr.cases, exp_type, env),
    do_expr()           = typecheck(expr.body, exp_type, env, typed_vars=expr.typed_vars),
    ex_qual()           = pre_typecheck_ex_qual_expr(expr.source, expr.cond, env),
    set_comp()          = pre_typecheck_rel_comp((expr.expr), expr.source, env),
    map_comp()          = pre_typecheck_rel_comp((expr.key_expr, expr.value_expr), expr.source, env),
    bin_rel_comp()      |
    tern_rel_comp()     = pre_typecheck_rel_comp(expr.exprs, expr.source, env),
    seq_comp()          = pre_typecheck_seq_comp_expr(expr, env),
    range_comp()        = pre_typecheck_range_comp_expr(expr, env);


  [TypeCheckingError] pre_typecheck_rel_entry((args: Expr+, cond: Expr?) entry, [Var -> Type] env)
  {
    if entry.cond?:
      errs = typecheck(entry.cond, type_bool, env);
      return errs if errs != [];
      new_env, unused_var = refine_env(entry.cond, env);
    else
      new_env = env;
    ;
    return seq_union((typecheck(a, type_any, new_env) : a <- entry.args));
  }


  //## BAD BAD: IT'S ALMOST THE SAME CODE AS ABOVE
  [TypeCheckingError] pre_typecheck_map_entry((key: Expr, value: Expr, cond: Expr?) entry, [Var -> Type] env)
  {
    if entry.cond?:
      errs = typecheck(entry.cond, type_bool, env);
      return errs if errs != [];
      new_env, unused_var = refine_env(entry.cond, env);
    else
      new_env = env;
    ;
    return typecheck(entry.key, type_any, new_env) & typecheck(entry.value, type_any, new_env);
  }


  [TypeCheckingError] pre_typecheck_unary_pseudo_call(Expr target, Expr value, [Var -> Type] env)
  {
    errs = typecheck(target, type_unary_pseudocall_target, env);
    return errs if errs != [];

    target_type = expr_type(target, env);
    if target_type == empty_type:
      exp_value_type = type_any;
    elif is_subset(target_type, atom_type):
      exp_value_type = type_any;
    elif is_subset(target_type, type_seq):
      exp_value_type = integer;
    elif is_subset(target_type, type_set):
      exp_value_type = set_elem_supertype(target_type);
    elif is_subset(target_type, type_map):
      exp_value_type = bin_rel_arg_supertype(target_type, 0);
    else
      //## BAD BAD: THIS ERROR MESSAGE IS ACTUALLY WRONG...
      return [unexpected_actual_type(target_type, type_unary_pseudocall_target)];
    ;

    return typecheck(value, exp_value_type, env);
  }


  [TypeCheckingError] pre_typecheck_rel_memb_test(Expr rel, Maybe[Expr]+ args, [Var -> Type] env)
  {
    return match (args)
      (a0?, a1?)  = pre_typecheck_bin_rel_memb_test(rel, a0, a1, env),
      (_, _, _)   = pre_typecheck_tern_rel_memb_test(rel, args, env);


    [TypeCheckingError] pre_typecheck_bin_rel_memb_test(Expr rel, Maybe[Expr] maybe_arg0, Maybe[Expr] maybe_arg1, [Var -> Type] env)
    {
      errs = typecheck(rel, type_bin_rel, env);
      return errs if errs != [];
      rel_type = expr_type(rel, env);
      exp_arg0_type, exp_arg1_type = if rel_type != empty_type
        then bin_rel_args_supertypes(rel_type)
        else (type_any, type_any);

      if maybe_arg0 != nil:
        arg0 = value(maybe_arg0);
        errs = typecheck(arg0, exp_arg0_type, env);
        return errs if errs != [];
        actual_arg0_type = expr_type(arg0, env);
        if rel_type != empty_type and actual_arg0_type != empty_type and is_subset(rel_type, type_map):
          exp_arg1_type = restricted_bin_rel_arg1_supertype(rel_type, actual_arg0_type);
        ;
      ;

      return if maybe_arg1 != nil then typecheck(value(maybe_arg1), exp_arg1_type, env) else [];
    }


    [TypeCheckingError] pre_typecheck_tern_rel_memb_test(Expr rel, (Maybe[Expr], Maybe[Expr], Maybe[Expr]) args, [Var -> Type] env)
    {
      errs = typecheck(rel, type_tern_rel, env);
      return errs if errs != [];
      rel_type = expr_type(rel, env);
      exp_args_types = if rel_type != empty_type then tern_rel_args_supertypes(rel_type) else (type_any : i < 3);
      return seq_union((typecheck(value(a), t, env) : a, t <- zip(args, exp_args_types); a != nil));
    }
  }


  [TypeCheckingError] pre_typecheck_and_expr(Expr left_expr, Expr right_expr, [Var -> Type] env)
  {
    errs = typecheck(left_expr, type_bool, env);
    return errs if errs != [];
    new_env, unused_var = refine_env(left_expr, env);
    return typecheck(right_expr, type_bool, new_env);
  }


  [TypeCheckingError] pre_typecheck_or_expr(Expr left_expr, Expr right_expr, [Var -> Type] env)
  {
    errs = typecheck(left_expr, type_bool, env);
    return errs if errs != [];
    unused_var, new_env = refine_env(left_expr, env);
    return typecheck(right_expr, type_bool, new_env);
  }


  [TypeCheckingError] pre_typecheck_eq_expr(Expr left_expr, Expr right_expr, [Var -> Type] env)
  {
    return typecheck(left_expr, type_any, env) & typecheck(right_expr, type_any, env);

    //## UNCOMMENTING THE FOLLOWING LINES OF CODE, WITHOUT REMOVING
    //## THE ONE ABOVE CAUSES THE TYPECHECKER TO CRASH
    // errs = typecheck(left_expr, type_any) & typecheck(right_expr, type_any);
    // return errs if errs != [];
    // left_type = expr_type(left_expr, env);
    // right_type = expr_type(right_expr, env);
    // // If either type is empty, that means the comparison can never take
    // // place, and we don't want to produce an error in that case
    // always_false = left_type != empty_type and right_type != empty_type and
    //                pseudotypes_are_disjoint(left_type, right_type, typedefs);
    // return [expressions_can_never_be_equal(left_type, right_type) if always_false];
  }


  [TypeCheckingError] pre_typecheck_membership(Expr obj, NeType type, [Var -> Type] env)
  {
    errs = typecheck(obj, type_any, env);
    return errs if errs != [];
    actual_type = expr_type(obj, env);
    // No error is produced if the expression is never evaluated, i.e. the actual type is empty
    always_false = actual_type != empty_type and pseudotypes_are_disjoint(actual_type, type, typedefs);
    return [expression_can_never_belong_to_type(actual_type, type) if always_false];
  }


  [TypeCheckingError] pre_typecheck_cast_expr(Expr expr, NeType type, [Var -> Type] env)
  {
    errs = typecheck(expr, type_any, env);
    return errs if errs != [];
    actual_type = expr_type(expr, env);
    // No error is produced if the expression is never evaluated, i.e. the actual type is empty
    never_succeeds = actual_type != empty_type and pseudotypes_are_disjoint(actual_type, type, typedefs);
    return [expression_can_never_belong_to_type(actual_type, type) if never_succeeds];
  }


  [TypeCheckingError] pre_typecheck_accessor_expr(Expr expr, SymbObj field, [Var -> Type] env)
  {
    errs = typecheck(expr, type_dot_access_target, env);
    return errs if errs != [];
    target_type = expr_type(expr, env);
    return [] if target_type == empty_type;
    return [may_not_have_field(target_type, field) if not always_has_field(target_type, field)];
  }


  [TypeCheckingError] fully_typecheck_if_expr(Expr cond, Expr then_expr, Expr else_expr, Type exp_type, [Var -> Type] env)
  {
    errs = typecheck(cond, type_bool, env);
    return errs if errs != [];
    if_true_env, if_false_env = refine_env(cond, env);
    return typecheck(then_expr, exp_type, if_true_env) &
           typecheck(else_expr, exp_type, if_false_env);
  }


  [TypeCheckingError] fully_typecheck_match_expr(Expr+ exprs, (ptrns: Pattern+, expr: Expr)+ cases, Type exp_type, [Var -> Type] env)
  {
    errs = seq_union((typecheck(e, type_any, env) : e <- exprs));
    return errs if errs != [];
    types = (expr_type(e, env) : e <- exprs);
    return seq_union((fully_typecheck_case(exprs, types, c.ptrns, c.expr, exp_type, env) : c <- cases));


    [TypeCheckingError] fully_typecheck_case(Expr+ exprs, Type+ types, Pattern+ ptrns, Expr expr, Type exp_type, [Var -> Type] env)
    {
      errs = (ptrn_cannot_match_type(p, t) : p, t <- zip(ptrns, types); t != empty_type and not may_match(p, t));
      return set(errs) if errs != ();
      case_expr_env = update_env(exprs, ptrns, env);
      return typecheck(expr, exp_type, case_expr_env);
    }
  }


  [TypeCheckingError] pre_typecheck_ex_qual_expr(Clause source, Expr cond, [Var -> Type] env)
  {
    errs = typecheck(source, env);
    return errs if errs != [];
    new_env = generate_env(source, env);
    return typecheck(cond, type_bool, new_env);
  }


  [TypeCheckingError] pre_typecheck_rel_comp(Expr+ exprs, Clause source, [Var -> Type] env)
  {
    errs = typecheck(source, env);
    return errs if errs != [];
    iter_tree = full_iter_tree(source, env);
    return seq_union((pre_typecheck(iter_tree, e) : e <- exprs));


    [TypeCheckingError] pre_typecheck(IterTree tree, Expr expr):
      never         = [], //## CAN WE DO BETTER HERE?
      once(e?)      = typecheck(expr, type_any, e),
      repeated(t?)  = pre_typecheck(t, expr),
      any(ts?)      = union([pre_typecheck(t, expr) : t <- ts]),
      all(ts?)      = seq_union((pre_typecheck(t, expr) : t <- ts));
  }


  [TypeCheckingError] pre_typecheck_seq_comp_expr(SeqCompExpr expr, [Var -> Type] env)
  {
    nvars = nz_nat(length(expr.vars));
    exp_src_type = type_seq(if nvars == 1 then type_any else type_tuple(nvars));
    errs = typecheck(expr.src_expr, exp_src_type, env);
    return errs if errs != [];

    src_type = expr_type(expr.src_expr, env);
    elem_type = seq_elem_supertype(src_type);
    env_delta = asgnm_env_updates(expr.vars, elem_type) & [expr.idx_var -> type_nat if expr.idx_var?];
    new_env = update(env, env_delta);

    if expr.sel_expr?:
      errs = typecheck(expr.sel_expr, type_bool, new_env);
      return errs if errs != [];
      new_env, unused_var = refine_env(expr.sel_expr, new_env);
    ;

    return typecheck(expr.expr, type_any, new_env);
  }


  [TypeCheckingError] pre_typecheck_range_comp_expr(RangeCompExpr expr, [Var -> Type] env)
  {
    errs = typecheck(expr.bound_expr, integer, env);
    return errs if errs != [];

    //## BAD: HERE WE COULD TAKE ADVANTAGE OF THE KNOWLEDGE ON THE TYPE OF THE UPPER BOUND
    new_env = update(env, [expr.var -> type_nat]);

    if expr.sel_expr?:
      errs = typecheck(expr.sel_expr, type_bool, new_env);
      return errs if errs != [];
      new_env, unused_var = refine_env(expr.sel_expr, new_env);
    ;

    return typecheck(expr.expr, type_any, new_env);
  }
}
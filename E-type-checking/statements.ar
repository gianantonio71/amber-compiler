implicit program : Program, typedefs : [TypeName -> NeType], context : ContextTC, var_aliases : [[LocVar2]], typed_vars : [StdVar -> NeType] {

  [TypeCheckingError] typecheck(Statement* stmts, Type exp_type, [EnvVar -> Type] env) {
    curr_env = env;
    for s <- stmts:
      errs = typecheck(s, exp_type, curr_env);
      return errs if errs != [];
      curr_env = update_env(s, curr_env);
    ;
    return [];
  }


  [TypeCheckingError] typecheck(Statement stmt, Type exp_type, [EnvVar -> Type] env) {
    errs = typecheck_without_annotations(stmt, exp_type, env);
    return [add_anchor_if_needed(e, stmt) : e <- errs];


    [TypeCheckingError] typecheck_without_annotations(Statement stmt, Type exp_type, [EnvVar -> Type] env) =
      assignment_stmt()   = typecheck_assignment_stmt(stmt.vars, stmt.value, env),
      return_stmt(e?)     = typecheck(e, exp_type, env),
      if_stmt()           = typecheck_if_stmt(stmt.cond, stmt.body, stmt.else, exp_type, env),
      loop_stmt(ss?)      = typecheck_loop_stmt(ss, exp_type, env),
      foreach_stmt()      = { maybe_idx_var = if stmt.idx_var? then just(stmt.idx_var) else nothing;
                              return typecheck_foreach_stmt(stmt.vars, maybe_idx_var, stmt.values, stmt.body, exp_type, env);
                            },
      for_stmt()          = { maybe_var = if stmt.var? then just(stmt.var) else nothing;
                              return typecheck_for_stmt(maybe_var, stmt.start_val,
                                stmt.end_val, stmt.end_val_incl, stmt.body, exp_type, env);
                            },
      let_stmt()          = typecheck_let_stmt(stmt.asgnms, stmt.body, exp_type, env),
      break_stmt          = [],
      fail_stmt           = [],
      assert_stmt()       = typecheck(stmt.cond, type_bool, env),
      print_stmt(e?)      = typecheck(e, type_any, env);
  }


  [TypeCheckingError] typecheck_assignment_stmt(Var+ vars, Expr value, [EnvVar -> Type] env) {
    vars_types = (lookup(typed_vars, v, type_any) : v <- vars);
    exp_type = if |vars| == 1 then only(vars_types) else tuple_type(vars_types);
    return typecheck(value, exp_type, env);
  }


  [TypeCheckingError] typecheck_if_stmt(Expr cond, Statement+ body, Statement* else_body, Type exp_type, [EnvVar -> Type] env) {
    errs = typecheck(cond, type_bool, env);
    return errs if errs != [];
    if_true_env, if_false_env = refine_env(cond, env);
    return typecheck(body, exp_type, if_true_env) &
           typecheck(else_body, exp_type, if_false_env);
  }


  [TypeCheckingError] typecheck_loop_stmt(Statement+ body, Type exp_type, [EnvVar -> Type] env) {
    out_of_loop_vars = keys(env);
    entry_env = env;
    for 2:
      errs = typecheck(body, exp_type, entry_env);
      return errs if errs != [];
      exit_env = select_by_key(update_env(body, entry_env), out_of_loop_vars);
      return [] if not (v, t <- exit_env : not is_subset(t, entry_env[v]));
      entry_env = exit_env;
    ;
    return [loop_did_not_converge(2)];
  }


  [TypeCheckingError] typecheck_foreach_stmt(StdVar+ vars, Maybe[StdVar] maybe_idx_var, Expr values, Statement+ body, Type exp_type, [EnvVar -> Type] env) {
    nvars = nz_nat(|vars|);
    exp_src_type = if nvars == 1 then type_seq else type_seq(type_tuple(nvars));
    errs = typecheck(values, exp_src_type, env);
    return errs if errs != [];
    elem_type = seq_elem_supertype(expr_type(values, env));

    // return {not_a_seq_type} if elem_type == empty_type; ## COULD I ACCEPT A TUPLE TYPE HERE ALSO?

    num_vars = nz_nat(|vars|);
    if num_vars == 1:
      loop_vars = [vars(0) -> elem_type];
    else
      field_types = tuple_field_supertypes(elem_type, num_vars);
      loop_vars = merge(([v -> t] : v, t <- zip(vars, field_types)));
    ;
    loop_vars = loop_vars & [value(maybe_idx_var) -> type_nat] if maybe_idx_var != nothing;

    out_of_loop_vars = keys(env);

    entry_env = env & loop_vars;
    for 2:
      errs = typecheck(body, exp_type, entry_env);
      return errs if errs != [];
      exit_env = select_by_key(update_env(body, entry_env), out_of_loop_vars);
      return [] if not (v, t <- exit_env : not is_subset(t, entry_env[v]));
      entry_env = exit_env & loop_vars;
    ;

    return [loop_did_not_converge(2)];
  }


  [TypeCheckingError] typecheck_for_stmt(Maybe[StdVar] maybe_var, Expr start_val, Expr end_val, Bool end_val_incl, Statement+ body, Type exp_type, [EnvVar -> Type] env) {
    errs = typecheck(start_val, integer, env) & typecheck(end_val, integer, env);
    return errs if errs != [];

    loop_vars = [
      value(maybe_var) ->
        loop_var_type(
          expr_type(start_val, env),
          expr_type(end_val, env),
          end_val_incl
        ) if maybe_var != nothing
    ];

    out_of_loop_vars = keys(env);

    entry_env = env & loop_vars;
    for 2:
      errs = typecheck(body, exp_type, entry_env);
      return errs if errs != [];
      exit_env = select_by_key(update_env(body, entry_env), out_of_loop_vars);
      return [] if not (v, t <- exit_env : not is_subset(t, entry_env[v]));
      entry_env = exit_env & loop_vars;
    ;
    return [loop_did_not_converge(2)];
  }


  [TypeCheckingError] typecheck_let_stmt([ImplArg -> Expr] asgnms, Statement+ body, Type exp_type, [EnvVar -> Type] env) {
    errs = union([typecheck(e, type_any, env) : v, e <- asgnms]);
    return errs if errs != [];
    env_delta = [v -> expr_type(e, env) : v, e <- asgnms];
    new_env = update(env, env_delta);
    return typecheck(body, exp_type, new_env); ## BUG BUG BUG (WHY?)
  }
}
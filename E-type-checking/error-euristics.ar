implicit program : Program, typedefs : [TypeName -> NeType], context : ContextTC, var_aliases : [[LocVar2]], typed_vars : [StdVar -> NeType] {

  [TypeCheckingError] gen_err_msgs(AccExpr expr, Type exp_type, [EnvVar -> Type] env) {
    errs = typecheck(expr.expr, type_any, env);
    return errs if errs != [];
    target_type = expr_type(expr.expr, env);
    return [not_a_record_type(target_type) if not is_subset(target_type, type_dot_access_target)];
  }


  [TypeCheckingError] gen_err_msgs(AccTestExpr expr, Type exp_type, [EnvVar -> Type] env) {
    errs = typecheck(expr.expr, type_any, env);
    return errs if errs != [];
    target_type = expr_type(expr.expr, env);
    return [not_a_record_type(target_type) if not is_subset(target_type, type_dot_access_target)];
    ## EMIT A WARNING WHEN THE TARGET TYPE ALWAYS HAS THE SPECIFIED FIELD
  }


  [TypeCheckingError] gen_err_msgs(UnaryPseudoCall expr, Type exp_type, [EnvVar -> Type] env) {
    target = expr.target;
    arg = expr.arg;

    errs = typecheck(target, type_any, env);
    return errs if errs != [];

    target_type = expr_type(target, env);
    return if   target_type == empty_type         then typecheck(arg, type_any, env)
           elif is_subset(target_type, atom_type) then typecheck(arg, type_any, env)
           elif is_subset(target_type, type_seq)  then seq_lookup_err_msgs(target_type, arg, exp_type, env)
           elif is_subset(target_type, type_set)  then set_memb_test_err_msgs(target_type, arg, exp_type, env)
           // elif is_subset(target_type, type_map)  then map_lookup_err_msg(target_type, arg, exp_type, env)
                                                  else [not_a_valid_unary_pseudocall_target(target_type)];


    [TypeCheckingError] seq_lookup_err_msgs(Type seq_type, Expr idx_expr, Type exp_type, [EnvVar -> Type] env) {
      errs = typecheck(idx_expr, integer, env);
      return errs if errs != [];
      res_type = restricted_seq_elem_supertype(seq_type, expr_type(idx_expr, env));
      return invalid_type_if_not_subset(res_type, exp_type);
    }


    [TypeCheckingError] set_memb_test_err_msgs(Type set_type, Expr value, Type exp_type, [EnvVar -> Type] env) {
      exp_value_type = set_elem_supertype(set_type);
      errs = typecheck(value, exp_value_type, env);
      if errs != []:
        loose_errs = typecheck(value, type_any, env);
        return loose_errs if loose_errs != [];
        return [invalid_set_memb_test_elem_type(exp_value_type, expr_type(value, env))];
      ;
      return invalid_type_if_not_subset(type_bool, exp_type);
    }


    // [TypeCheckingError] map_lookup_err_msg(Type map_type, Expr key_expr, Type exp_type, [EnvVar -> Type] env)
    // {
    //   exp_key_type = bin_rel_arg_supertype(map_type, 0);
    //   errs = typecheck(key_expr, exp_key_type, env);
    //   if errs != []:
    //     loose_errs = typecheck(key_expr, type_any, env);
    //     return loose_errs if loose_errs != [];
    //     return [invalid_map_lookup_key_type(exp_key_type, expr_type(key_expr, env))];
    //   ;
    //   res_type = restricted_bin_rel_arg1_supertype(map_type, expr_type(key_expr, env));
    //   return invalid_type_if_not_subset(res_type, exp_type);
    // }
  }


  [TypeCheckingError] gen_err_msgs(RelMembTest expr, Type exp_type, [EnvVar -> Type] env) {
    return match (expr.args)
      (a0?, a1?)  = bin_rel_err_msgs(expr.rel, a0, a1, env),
      (_, _, _)   = tern_rel_err_msgs(expr.rel, expr.args, env);


    [TypeCheckingError] bin_rel_err_msgs(Expr rel, Maybe[Expr] arg0, Maybe[Expr] arg1, [EnvVar -> Type] env) {
      errs = typecheck(rel, type_bin_rel, env);
      errs = errs & typecheck(value(arg0), type_any, env) if arg0 != nothing;
      errs = errs & typecheck(value(arg1), type_any, env) if arg1 != nothing;
      return errs if errs != [];

      rel_type = expr_type(rel, env);
      return [] if rel_type == empty_type;
      exp_type_0, exp_type_1 = bin_rel_args_supertypes(rel_type);

      restr_type_1 = exp_type_1;
      if arg0 != nothing:
        actual_type_0 = expr_type(value(arg0), env);
        return [invalid_rel_arg_type(0, actual_type_0, exp_type_0)] if not is_subset(actual_type_0, exp_type_0);
        if actual_type_0 != empty_type and is_subset(rel_type, type_map):
          restr_type_1 = restricted_bin_rel_arg1_supertype(rel_type, actual_type_0);
        ;
      ;

      if arg1 != nothing:
        actual_type_1 = expr_type(value(arg1), env);
        if not is_subset(actual_type_1, exp_type_1):
          return [invalid_rel_arg_type(1, actual_type_1, exp_type_1)];
        elif not is_subset(actual_type_1, restr_type_1):
          ## MAYBE I SHOULD BE USING A DIFFERENT ERROR TYPE HERE...
          return [invalid_rel_arg_type(1, actual_type_1, restr_type_1)];
        ;
      ;

      return [];
    }


    [TypeCheckingError] tern_rel_err_msgs(Expr rel, (Maybe[Expr], Maybe[Expr], Maybe[Expr]) maybe_args, [EnvVar -> Type] env) {
      errs = typecheck(rel, type_tern_rel, env);
      errs = errs & seq_union((typecheck(value(a), type_any, env) : a <- maybe_args, a != nothing));
      return errs if errs != [];

      rel_type = expr_type(rel, env);
      return [] if rel_type == empty_type;

      exp_args_types = tern_rel_args_supertypes(rel_type);
      return [
        invalid_rel_arg_type(i, at, et)
        : i <- [0, 1, 2],
          a = maybe_args(i), a != nothing,
          at = expr_type(value(a), env),
          et = exp_args_types(i),
          not is_subset(at, et)
      ];
    }
  }
}

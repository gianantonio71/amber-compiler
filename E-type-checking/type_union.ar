Bool union_superset(AnonType t1, AnonType t2) = union_superset({t1, t2});
Bool union_superset(AnonType+ types) = union_superset_impl(types, allow_incompatible_groups=false);


type Pretype = LeafType, TypeVar, SelfPretype, CompType[AnonType], UnionType[AnonType], RecType[AnonType], UnionPretype;

type UnionPretype = union_pretype(AnonType+);


UnionPretype union_pretype(AnonType+ types)
{
  assert size(types) > 1;
  return :union_pretype(types);
}


AnonType rec_type_union_superset(AnonType* types)
{
  pre_unions = ();
  type_sets_to_do = {types};

  while (type_sets_to_do /= {})
    pre_unions = pre_unions & (ts => union_superset_impl({unfold(t) : t <- ts}, allow_incompatible_groups=true) : ts <- type_sets_to_do);
    type_sets_to_do = union({illegal_unions(pu) : _ => pu <- pre_unions}) - keys(pre_unions);

  ;

  final_unions = ();
  pre_unions_left = pre_unions;
  types_left = keys(pre_unions);
  while (types_left /= {})
    cs = clusters(pre_unions_left);
    ncs = {normalize(c, pre_unions_left) : c <- cs};
    new_final_unions = merge(ncs);
    final_unions = final_unions & new_final_unions;
    types_left = types_left - keys(new_final_unions);
    pre_unions_left = (ts => replace_final_preunions(pre_unions_left[ts], final_unions) : ts <- types_left);
  ;

  return final_unions[types];


  (AnonType+ => AnonType) normalize(AnonType++ cluster, (AnonType+ => Pretype) pre_unions)
  {
    if (size(cluster) == 1)
      ts = only_element(cluster);
      type = replace_preunions(pre_unions[ts], (ts => self));
      type = self_rec_type(type) if has_rec_branches(type);
      return (ts => type);
    ;

    sort_type_sets = rand_sort(cluster);
    rec_map = (sort_type_sets[i] => self(i) : i <- index_set(sort_type_sets));
    types = [replace_preunions(pre_unions[ts], rec_map) : ts <- sort_type_sets];
    return (sort_type_sets[i] => mut_rec_type(i, types) : i <- index_set(sort_type_sets));
  }


  // AnonType replace_preunions(Pretype pretype, (AnonType+ => SelfPretype) rec_map) = repl-ace union_pretype(ts) in pretype with rec_map[ts] end;

  //## replace_preunions() AND replace_final_unions() ARE SO SIMILAR. ISN'T THERE A WAY OF MERGING THEM?

  //## THERE MUST BE A BETTER WAY EVEN WITHOUT A REPLACE INSTRUCTION...
  AnonType replace_preunions(Pretype pretype, (AnonType+ => SelfPretype) rec_map):
    LeafType            = pretype,
    TypeVar             = pretype,
    SelfPretype         = pretype,
    ne_seq_type()       = ne_seq_type(replace_preunions(pretype.elem_type, rec_map)),
    ne_set_type()       = ne_set_type(replace_preunions(pretype.elem_type, rec_map)),
    ne_map_type()       = ne_map_type(replace_preunions(pretype.key_type, rec_map), replace_preunions(pretype.value_type, rec_map)),
    record_type(fs?)    = record_type((l => (type: replace_preunions(f.type, rec_map), optional: f.optional) : l => f <- fs)),
    tuple_type(ts?)     = {fail;},
    tag_obj_type()      = tag_obj_type(pretype.tag_type, replace_preunions(pretype.obj_type, rec_map)),
    union_type(ts?)     = union_type({replace_preunions(t, rec_map) : t <- ts}),
    union_pretype(ts?)  = rec_map[ts],
    self_rec_type(t?)   = self_rec_type(replace_preunions(t, rec_map)),
    mut_rec_type()      = mut_rec_type(pretype.index, [replace_preunions(t, rec_map) : t <- pretype.types]);

  // Pretype replace_final_preunions(Pretype pretype, (AnonType+ => AnonType) final_unions) =
  //   rep-lace union_pretype(ts) pt
  //   in pretype
  //   with lookup(final_unions, ts, pt) end; //## WHY DO WE HAVE TO PROVIDE A DEFAULT HERE? I CAN'T REMEMBER...

  //## THERE MUST BE A BETTER WAY EVEN WITHOUT A REPLACE INSTRUCTION...
  Pretype replace_final_preunions(Pretype pretype, (AnonType+ => AnonType) final_unions):
    LeafType            = pretype,
    TypeVar             = pretype,
    SelfPretype         = pretype,
    ne_seq_type()       = ne_seq_type(replace_final_preunions(pretype.elem_type, final_unions)),
    ne_set_type()       = ne_set_type(replace_final_preunions(pretype.elem_type, final_unions)),
    ne_map_type()       = ne_map_type(replace_final_preunions(pretype.key_type, final_unions), replace_final_preunions(pretype.value_type, final_unions)),
    record_type(fs?)    = record_type((l => (type: replace_final_preunions(f.type, final_unions), optional: f.optional) : l => f <- fs)),
    tuple_type(ts?)     = {fail;},
    tag_obj_type()      = tag_obj_type(pretype.tag_type, replace_final_preunions(pretype.obj_type, final_unions)),
    union_type(ts?)     = union_type({replace_final_preunions(t, final_unions) : t <- ts}),
    union_pretype(ts?)  = lookup(final_unions, ts, pretype), //## WHY DO WE HAVE TO PROVIDE A DEFAULT HERE? I CAN'T REMEMBER...
    self_rec_type(t?)   = self_rec_type(replace_final_preunions(t, final_unions)),
    mut_rec_type()      = mut_rec_type(pretype.index, [replace_final_preunions(t, final_unions) : t <- pretype.types]);

  AnonType+** clusters((AnonType+ => Pretype) pre_unions)
  {
    ref_map        = (ts => illegal_unions(pu) : ts => pu <- pre_unions);
    deep_ref_map   = transitive_closure(ref_map);
    conn_comps     = {{s} & ss : s => ss <- deep_ref_map};
    min_conn_comps = {c1 : c1 <- conn_comps, not (? c2 <- conn_comps : c1 /= c2, subset(c2, c1))};
    return min_conn_comps;
  }

  // AnonType+* illegal_unions(Pretype pretype) = retrieve ts from union_pretype(ts) in pretype end;
  AnonType+* illegal_unions(Pretype pretype) = {_obj_(pt) : pt <- select(pretype, $ :: UnionPretype)}; //## THE ABOVE VERSION WITH RETRIEVE WAS LESS UGLY
}

using Bool allow_incompatible_groups
{
  Pretype union_superset_impl(AnonType+ types)
  {
    exp_types = union({expand_union_type(t) : t <- types});

    //## TODO: DEAL WITH RECURSIVE TYPES, RECURSIVE REFERENCES AND TYPE VARIABLES HERE
    assert not (? union_type() <- exp_types);

    return only_element(exp_types, type_any) if (? t <- exp_types : t :: TypeVar);

    rec_types = {t : self_rec_type() t <- exp_types};
    exp_types = exp_types - rec_types;

    // assert exp_types :: <<LeafType, CompType[AnonType]>+>; //## WHY WAS IT NON-EMPTY?
    assert exp_types :: <LeafType, CompType[AnonType]>*;

    types_by_group = merge_values({(type_group(t) => t) : t <- exp_types});

    res_types = union({
      {atom_type}                                                     if types_by_group.atom?,
      types_by_group.symb                                             if types_by_group.symb? and not types_by_group.atom?,
      {int_types_union_superset(types_by_group.int)}                  if types_by_group.int?,
      {empty_seq_type}                                                if types_by_group.empty_seq?,
      {ne_seq_and_tuple_types_union_superset(types_by_group.ne_seq)}  if types_by_group.ne_seq?,
      {empty_set_type}                                                if types_by_group.empty_set?,
      {set_types_union_superset(types_by_group.ne_set)}               if types_by_group.ne_set?,
      tag_obj_types_union_superset(types_by_group.tag_obj)            if types_by_group.tag_obj?
    });

    if (types_by_group.ne_map?)
      res_ne_map_type = map_types_union_superset(types_by_group.ne_map);
      if (types_by_group.record?)
        res_record_type = record_types_union_superset(types_by_group.record);
        res_map_types = map_record_union_superset(res_ne_map_type, res_record_type, types_by_group.empty_map?);
      else
        res_map_types = {res_ne_map_type, empty_map_type if types_by_group.empty_map?};
      ;
    else
      if (types_by_group.record?)
        res_record_type = record_types_union_superset(types_by_group.record);
        if (types_by_group.empty_map?)
          res_record_type = record_type((l => (type: f.type, optional: true) : l => f <- _obj_(res_record_type)));
        ;
        res_map_types = {res_record_type};
      else
        res_map_types = {empty_map_type if types_by_group.empty_map?};
      ;
    ;

    res_types = res_types & res_map_types;

    // assert not (? t <- res_types : not anon_type_is_wf(t));
    // assert not (? t1 <- res_types, t2 <- res_types : t1 /= t2 and not anon_types_are_compatible(t1, t2));

    type_groups = group_types_by_incompatibility(res_types & rec_types);

    standalone_types = {only_element(g) : g <- type_groups, size(g) == 1};  //## BAD: DOING MULTIPLE PASSES OVER THE SET IN ORDER TO PARTITION IT
    incompatible_groups = {g : g <- type_groups, size(g) > 1};              //## BAD: DITTO

    if (allow_incompatible_groups)
      illegal_unions = {union_pretype(g) : g <- incompatible_groups};
      return union_type(standalone_types & illegal_unions);
    ;

    reformed_unions = {rec_type_union_superset(g) : g <- incompatible_groups};
    return union_type(standalone_types & reformed_unions);


    AnonType+ expand_union_type(type):
      union_type(ts?) = union({expand_union_type(t) : t <- ts}),
      _               = {type};


    type_group(AnonType type):
      atom_type         = :atom,
      SymbType          = :symb,
      IntType           = :int,
      empty_seq_type    = :empty_seq,
      empty_set_type    = :empty_set,
      empty_map_type    = :empty_map,
      ne_seq_type()     = :ne_seq,
      tuple_type()      = :ne_seq,
      ne_set_type()     = :ne_set,
      ne_map_type()     = :ne_map,
      record_type()     = :record,
      tag_obj_type()    = :tag_obj;


    AnonType** group_types_by_incompatibility(AnonType* types)
    {
      inc_map = (t1 => {t2 : t2 <- types, not anon_types_are_compatible(t1, t2)} : t1 <- types);
      return values(transitive_closure(inc_map));
    }
  }


  IntType int_types_union_superset(IntType+ int_types)
  {
    if (in(:integer, int_types) or (? low_ints() <- int_types, high_ints() <- int_types)) //## NOT SURE ABOUT THIS ONE
      return :integer;
    elif ((? low_ints() <- int_types))
      max_val = max({max(t) : t <- int_types});
      return low_ints(max: max_val);
    elif ((? high_ints() <- int_types))
      min_val = min({t.min : t <- int_types});
      return high_ints(min: min_val);
    else
      max_val = max({max(t) : t <- int_types});  //## IMPLEMENT max(Int+)
      min_val = min({t.min  : t <- int_types});  //## IMPLEMENT min(Int+)
      return int_range(min_val, max_val);
    ;
  }


  NeSetType[AnonType] set_types_union_superset(NeSetType[AnonType]+ types) = ne_set_type(union_superset_impl({t.elem_type : t <- types}));

  NeMapType[AnonType] map_types_union_superset(NeMapType[AnonType]+ types) = ne_map_type(union_superset_impl({t.key_type : t <- types}), union_superset_impl({t.value_type : t <- types}));


  RecordType[AnonType] record_types_union_superset(RecordType[AnonType]+ record_types)
  {
    fields_by_label = merge_values({fm : record_type(fm) <- record_types});
    res_fields = for (l => fs <- fields_by_label) (
      l => (type: union_superset_impl({f.type : f <- fs}), optional: (? f <- fs : f.optional) or (? record_type(fm) <- record_types : not has_key(fm, l)))
    );
    return record_type(res_fields);
  }


  <NeSeqType[AnonType], TupleType[AnonType]> ne_seq_and_tuple_types_union_superset(<NeSeqType[AnonType], TupleType[AnonType]>+ types)
  {
    assert types /= {};

    return only_element(types) if size(types) == 1;

    Bool is_ne_seq_type(<NeSeqType[AnonType], TupleType[AnonType]>): //## BAD: THIS IS DEFINITELY OVERKILL FOR WHAT IT DOES...
      ne_seq_type()   = true,
      tuple_type()    = false;

    if (not (? t <- types : is_ne_seq_type(t)))
      lengths = {length(_obj_(t)) : t <- types};
      if (size(lengths) == 1)
        len = only_element(lengths);
        res_field_types = [union({fts[i] : tuple_type(fts) <- types}) : i < len];
        return tuple_type(res_field_types);
      ;
    ;

    AnonType+ elem_types(<NeSeqType[AnonType], TupleType[AnonType]> type):
      ne_seq_type()   = {type.elem_type},
      tuple_type(ts?) = set(ts);

    all_elem_types = union({elem_types(t) : t <- types});
    res_seq_elem_type = union_superset(all_elem_types);
    return ne_seq_type(res_seq_elem_type);
  }


  AnonType+ map_record_union_superset(MapType[AnonType] map_type, RecordType[AnonType] record_type, Bool includes_empty_map)
  {
    fields = _obj_(record_type);
    res_key_type = union_superset_impl({map_type.key_type, union_type({symb_type(l) : l => f <- fields})});
    res_value_type = union_superset_impl({map_type.value_type} & {f.type : l => f <- fields});
    res_map_type = ne_map_type(res_key_type, res_value_type);
    needs_empty_map = includes_empty_map or not (? l => f <- fields : not f.optional);
    return if needs_empty_map then {empty_map_type, res_map_type} else {res_map_type};
  }


  TagObjType[AnonType]+ tag_obj_types_union_superset(TagObjType[AnonType]+ tagged_types)
  {
    tag_types = {t.tag_type : t <- tagged_types};
    if (in(atom_type, tag_types))
      return {tag_obj_type(atom_type, union_superset_impl({t.obj_type : t <- tagged_types}))};
    else
      assert tag_types :: <SymbType+>;
      tag_to_obj_types = merge_values({(t.tag_type => t.obj_type) : t <- tagged_types});
      return {tag_obj_type(tt, union_superset_impl(ots)) : tt => ots <- tag_to_obj_types};
    ;
  }
}

using
{
  [TypeName -> Type]              typedefs,
  [(FnSymbol, Nat) -> SgnSet]     signatures,
  [Var -> Type]                   environment,
  [<ClsVar, NamedArg> -> ClsType] closures,
  [[Var]]                         var_aliases;


  Type expr_type(CondExpr expr) = expr_type(expr.expr, environment=left(refine_environment(expr.cond)));


  // I assume that the expression typechecks
  Type expr_type(Expr expr):
    object(+)             = symb_type(expr),
    object(* n?)          = int_range(min: n, size: 1),
    float_lit()           = float_type,
    seq_expr(ses?)        = seq_expr_type(set(ses)),
    tuple_expr(es?)       = tuple_type((expr_type(e) : e <- es)),
    seq_tail_expr()       = seq_tail_expr_type(expr.seq, expr.tail),
    set_expr(ses?)        = set_expr_type(ses),
    map_expr(es?)         = map_expr_type(es),
    tag_obj_expr()        = tag_obj_expr_type(expr.tag, expr.obj),
    Var                   = environment[expr],
    fn_call()             = fn_call_expr_type(expr.name, expr.params, expr.named_args),
    cls_call()            = closures[expr.name].out_type,
    builtin_call()        = builtin_call_expr_type(expr.name, expr.params),
    incl_test_or_lookup() = incl_test_or_lookup_expr_type(expr.collection, expr.value),
    map_search()          = type_bool,
    key_search()          = type_bool,
    singl_only_elem()     = set_elem_supertype(expr_type(expr.set)),
    and_expr()            = type_bool,
    or_expr()             = type_bool,
    not_expr()            = type_bool,
    eq()                  = type_bool,
    membership()          = type_bool,
    cast_expr()           = expr.type,
    accessor()            = accessor_expr_type(expr.expr, expr.field),
    accessor_test()       = type_bool,
    if_expr()             = if_expr_type(expr.cond, expr.then, expr.else),
    match_expr()          = match_expr_type(expr.exprs, expr.cases),
    do_expr(ss?)          = return_type(ss),
    ex_qual()             = type_bool,
    set_comp()            = set_comp_expr_type(expr.expr, expr.source),
    map_comp()            = map_comp_expr_type(expr.key_expr, expr.value_expr, expr.source),
    seq_comp()            = seq_comp_expr_type(expr),
    range_comp()          = range_comp_expr_type(expr);


  Type set_expr_type([SubExpr] subexprs)
  {
    actual_elem_type = union_superset([expr_type(se) : se <- subexprs]);
    nonempty = (? se <- subexprs : not is_cond_expr(se));
    return type_set(actual_elem_type, nonempty);
  }


  Type seq_expr_type([SubExpr] subexprs)
  {
    actual_elem_type = union_superset([expr_type(se) : se <- subexprs]);
    nonempty = (? se <- subexprs : not is_cond_expr(se));
    return type_seq(actual_elem_type, nonempty);
  }


  Type seq_tail_expr_type(Expr seq, Expr+ tail)
  {
    head_elem_type = seq_elem_supertype(expr_type(seq));
    tail_elem_types = (expr_type(e) : e <- tail);
    final_elem_type = union_superset([head_elem_type] & set(tail_elem_types));
    return ne_seq_type(final_elem_type);
  }


  Type map_expr_type([[key: Expr, value: Expr, cond: Expr?]] raw_entries)
  {
    entries = [entry_info(e) : e <- raw_entries];
    is_record = not (? e <- entries : not is_symb_singl_type(e.key_type));

    if is_record:
      fields = [only_symb(e.key_type) -> [type: e.value_type, optional: e.optional] : e <- entries];
      return record_type(fields);
    else
      actual_key_type = union_superset([e.key_type : e <- entries]);
      actual_value_type = union_superset([e.value_type : e <- entries]);
      nonempty = (? e <- entries : not e.optional);
      return type_map(actual_key_type, actual_value_type, nonempty);
    ;


    [key_type: Type, value_type: Type, optional: Bool] entry_info([key: Expr, value: Expr, cond: Expr?] entry)
    {
      new_env = if entry.cond? then left(refine_environment(entry.cond)) else environment;
      return [
        key_type:   expr_type(entry.key, environment=new_env),
        value_type: expr_type(entry.value, environment=new_env),
        optional:   entry.cond?
      ];
    }
  }


  Type tag_obj_expr_type(Expr tag_expr, Expr obj_expr)
  {
    tag_types = disassemble_tag_type(expr_type(tag_expr));
    obj_type = expr_type(obj_expr);
    return union_type([tag_obj_type(t, obj_type) : t <- tag_types]);
  }


  Type builtin_call_expr_type(BuiltIn name, Expr+ params):
    obj   = untagged_objs_supertype(expr_type(params[0])),
    tag   = tag_supertype(expr_type(params[0])),
    _     = fn_call_type(builtin_to_fn_type(builtin_signature(name)), params, [:]);


  Type incl_test_or_lookup_expr_type(Expr collection, Expr value)
  {
    coll_type = expr_type(collection);

    return empty_type if coll_type == empty_type;
    return type_bool  if is_subset(coll_type, type_set);

    value_type = expr_type(value);

    if is_subset(coll_type, type_seq):
      return restricted_seq_elem_supertype(coll_type, value_type);
    else
      assert is_subset(coll_type, type_map);
      return restricted_map_value_supertype(coll_type, value_type);
    ;
  }


  Type accessor_expr_type(Expr target, SymbObj field)
  {
    target_type = expr_type(target);
    return if target_type != empty_type then mandatory_field_type(target_type, field) else empty_type;
  }


  Type if_expr_type(Expr cond, Expr then_expr, Expr else_expr)
  {
    if_true_env, if_false_env = refine_environment(cond);
    return union_superset(expr_type(then_expr, environment=if_true_env), expr_type(else_expr, environment=if_false_env));
  }


  Type match_expr_type(Expr+ exprs, [ptrns: Pattern+, expr: Expr]+ cases)
  {
    types = (case_expr_type(exprs, c.ptrns, c.expr) : c <- cases);
    return union_superset(set(types));


    Type case_expr_type(Expr+ exprs, Pattern+ ptrns, Expr expr)
    {
      case_expr_env = update_environment(exprs, ptrns);
      return expr_type(expr, environment=case_expr_env);
    }
  }


  Type set_comp_expr_type(Expr expr, Clause source)
  {
    expr_env = generate_env(source);
    actual_elem_type = expr_type(expr, environment=expr_env);
    nonempty = always_yields_results(source);
    return type_set(actual_elem_type, nonempty);
  }


  Type map_comp_expr_type(Expr key_expr, Expr value_expr, Clause source)
  {
    new_env = generate_env(source);
    let environment = new_env:
      key_type = expr_type(key_expr);
      value_type = expr_type(value_expr);
    ;
    nonempty = always_yields_results(source);
    return type_map(key_type, value_type, nonempty);
  }


  Type seq_comp_expr_type(SeqCompExpr expr)
  {
    src_type = expr_type(expr.src_expr);
    return empty_type if src_type == empty_type;
    return empty_seq_type if is_subset(src_type, empty_seq_type);
    src_elem_type = seq_elem_supertype(src_type);
    assert src_elem_type != empty_type;

    env_delta = asgnm_env_updates(expr.vars, src_elem_type) & [expr.idx_var -> type_nat if expr.idx_var?];
    new_env = update(environment, env_delta);
    new_env, unused_var = refine_environment(expr.sel_expr, environment=new_env) if expr.sel_expr?;

    elem_type = expr_type(expr.expr, environment=new_env);
    nonempty = not (type_contains_obj(src_type, ()) or expr.sel_expr?);
    return type_seq(elem_type, nonempty);
  }


  Type range_comp_expr_type(RangeCompExpr expr)
  {
    bound_expr_type = expr_type(expr.bound_expr);
    //## BAD: HERE WE COULD TAKE ADVANTAGE OF THE KNOWLEDGE ON THE TYPE OF THE UPPER BOUND
    new_env = update(environment, [expr.var -> type_nat]);
    new_env, unused_var = refine_environment(expr.sel_expr, environment=new_env) if expr.sel_expr?;
    elem_type = expr_type(expr.expr, environment=new_env);
    nonempty = not expr.sel_expr? and is_subset(bound_expr_type, if expr.inclusive then type_nat else type_nz_nat);
    return type_seq(elem_type, nonempty);
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  Type return_type(Statement* stmts)
  {
    env = environment;
    ret_types = [];
    for s <- stmts:
      ret_type = return_type(s, environment=env);
      ret_types = ret_types & [ret_type];
      env = update_environment(s, environment=env);
    ;
    return union_superset(ret_types);
  }


  Type return_type(Statement stmt):
    assignment_stmt()   = empty_type,
    return_stmt(e?)     = expr_type(e),
    if_stmt()           = if_stmt_return_type(stmt.cond, stmt.body, stmt.else),
    loop_stmt(ss?)      = loop_stmt_return_type(ss),
    foreach_stmt()      = foreach_stmt_return_type(stmt.vars, if stmt.idx_var? then just(stmt.idx_var) else nil, stmt.values, stmt.body),
    for_stmt()          = for_stmt_return_type(if stmt.var? then just(stmt.var) else nil, stmt.start_val, stmt.end_val, stmt.end_val_incl, stmt.body),
    let_stmt()          = let_stmt_return_type(stmt.asgnms, stmt.body),
    break_stmt          = empty_type,
    fail_stmt           = empty_type,
    assert_stmt()       = empty_type,
    print_stmt()        = empty_type,
    imp_update_stmt()   = {fail;},
    return_stmt         = {fail;},
    proc_call()         = {fail;};


  Type if_stmt_return_type(Expr cond, Statement+ body, Statement* else_body)
  {
    if_true_env, if_false_env = refine_environment(cond);
    true_ret_type = return_type(body, environment=if_true_env);
    false_ret_type = return_type(else_body, environment=if_false_env);
    return union_superset(true_ret_type, false_ret_type);
  }


  Type loop_stmt_return_type(Statement+ body)
  {
    env_0 = environment;
    env_1 = update_environment(body, environment=env_0);
    ret_type_0 = return_type(body, environment=env_0);
    ret_type_1 = return_type(body, environment=env_1);
    return union_superset(ret_type_0, ret_type_1);
  }


  Type foreach_stmt_return_type(Var+ vars, Maybe[Var] maybe_idx_var, Expr values, Statement+ body)
  {
    elem_type = seq_elem_supertype(expr_type(values));
    assert elem_type != empty_type;
    env_delta = asgnm_env_updates(vars, elem_type) & [value(maybe_idx_var) -> type_nat if maybe_idx_var != nil];
    env_0 = update(environment, env_delta);
    env_1 = update_environment(body, environment=env_0);
    ret_type_0 = return_type(body, environment=env_0);
    ret_type_1 = return_type(body, environment=env_1);
    return union_superset(ret_type_0, ret_type_1);
  }


  Type for_stmt_return_type(Maybe[Var] maybe_var, Expr start_val, Expr end_val, Bool end_val_incl, Statement+ body)
  {
    env_0 = environment & [value(maybe_var) -> type_nat if maybe_var != nil];
    env_1 = update_environment(body, environment=env_0);
    ret_type_0 = return_type(body, environment=env_0);
    ret_type_1 = return_type(body, environment=env_1);
    return union_superset(ret_type_0, ret_type_1);
  }


  Type let_stmt_return_type([NamedArg -> Expr] asgnms, Statement+ body)
  {
    env_delta = [v -> expr_type(e) : e @ v <- asgnms];
    new_env = update(environment, env_delta);
    return return_type(body, environment=new_env);
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  [Var -> Type] update_environment(Statement* stmts)
  {
    env = environment;
    for s <- stmts:
      env = update_environment(s, environment=env);
    ;
    assert may_fall_through(stmts) or env :: [Var -> <empty_type>];
    return env;
  }


  [Var -> <empty_type>] empty_env = [v -> empty_type : unused_var @ v <- environment];


  // Returns the empty map when the statement cannot fall through
  [Var -> Type] update_environment(Statement stmt):
    assignment_stmt()   = update(environment, asgnm_env_updates(stmt.vars, expr_type(stmt.value))),
    return_stmt(e?)     = empty_env,
    if_stmt()           = if_stmt_update_environment(stmt.cond, stmt.body, stmt.else),
    loop_stmt(ss?)      = loop_stmt_update_environment(ss),
    foreach_stmt()      = foreach_stmt_update_environment(stmt.vars, if stmt.idx_var? then just(stmt.idx_var) else nil, stmt.values, stmt.body),
    for_stmt()          = for_stmt_update_environment(if stmt.var? then just(stmt.var) else nil, stmt.start_val, stmt.end_val, stmt.end_val_incl, stmt.body),
    let_stmt()          = let_stmt_update_environment(stmt.asgnms, stmt.body),
    break_stmt          = empty_env,
    fail_stmt           = empty_env,
    //## THIS IS AN INTERESTING CASE: IF I DECIDE TO MAKE ASSERTIONS REMOVABLE ONLY
    //## WHEN THEY ARE NOT NECESSARY TO MAKE THE CODE STATICALLY TYPE CHECKABLE,
    //## HOW CAN I DO IT? I WOULD NEED TO SOMEHOW STORE THE FACT THAT THE ASSERTION
    //## IS REMOVABLE OR NOT DURING STATIC TYPE CHECKING...
    assert_stmt(e?)     = environment, // refine_environment(e).if_true, //## SHOULD I RELY ON THIS? WHAT HAPPENS IF THE ASSERTIONS ARE REMOVED? MAYBE I NEED A NON-REMOVABLE ASSERTION TYPE
    print_stmt()        = environment;


  [Var -> Type] if_stmt_update_environment(Expr cond, Statement+ body, Statement* else_body)
  {
    if_true_env, if_false_env = refine_environment(cond);
    res_env_true = update_environment(body, environment=if_true_env);
    res_env_false = update_environment(else_body, environment=if_false_env);

    if may_fall_through(body):
      if may_fall_through(else_body):
        return merge_envs(res_env_true, res_env_false);
      else
        return res_env_true;
      ;
    else
      if may_fall_through(else_body):
        return res_env_false;
      else
        return empty_env;
      ;
    ;
  }


  [Var -> Type] loop_stmt_update_environment(Statement+ body)
  {
    return empty_env if not may_fall_through(body);
    env_0 = environment;
    env_1 = update_environment(body); //, environment=env_0); //## WHY WAS IT LIKE THIS?
    return merge_envs(env_0, env_1);
  }


  [Var -> Type] foreach_stmt_update_environment(Var+ vars, Maybe[Var] maybe_idx_var, Expr values, Statement+ body)
  {
    elem_type = seq_elem_supertype(expr_type(values));
    // assert elem_type != empty_type;
    loop_vars = set(vars) & [value(maybe_idx_var) if maybe_idx_var != nil];
    assert disjoint(keys(environment), loop_vars);
    nvars = nz_nat(length(vars));
    if nvars == 1:
      non_idx_typed_loop_vars = [vars[0] -> elem_type];
    else
      field_types = tuple_field_supertypes(elem_type, nvars);
      non_idx_typed_loop_vars = merge(([v -> t] : v, t <- zip(vars, field_types)));
    ;
    env_0 = environment & non_idx_typed_loop_vars & [value(maybe_idx_var) -> type_nat if maybe_idx_var != nil];
    env_1 = update_environment(body, environment=env_0);
    return merge_envs(environment, remove_keys(env_1, loop_vars));
  }


  [Var -> Type] for_stmt_update_environment(Maybe[Var] maybe_var, Expr start_val, Expr end_val, Bool end_val_incl, Statement+ body)
  {
    env_0 = environment & [
      value(maybe_var) -> loop_var_type(expr_type(start_val), expr_type(end_val), end_val_incl) if maybe_var != nil
    ];
    env_1 = update_environment(body, environment=env_0);
    return merge_envs(environment, remove_keys(env_1, [value(maybe_var) if maybe_var != nil]));
  }


  [Var -> Type] let_stmt_update_environment([NamedArg -> Expr] asgnms, Statement+ body)
  {
    return empty_env if not may_fall_through(body); //## SEE COMMENT FOR loop_stmt() ABOVE
    env_delta = [v -> expr_type(e) : e @ v <- asgnms];
    new_env = update(environment, env_delta);
    return update_environment(body, environment=new_env);
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  Bool will_dispatch_to(FnType signature, AnyExpr* params)
  {
    assert length(params) == arity(signature); //## MAYBE I SHOULD RETURN FALSE IF THE TWO DON'T MATCH

    for e, t <- zip(params, signature.params):
      //## THIS IS A CHECK THAT SHOULD BE PERFORMED ELSEWHERE.
      assert (e :: Expr and t :: Type) or (e :: ClsExpr and t :: ClsType);
      if e :: Expr and t :: Type:
        return false if not is_subset(expr_type(e), replace_type_vars_with_type_any(t));
      ;
    ;

    return true;
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  ([Var -> Type], [Var -> Type]) refine_environment(Expr cond)
  {
    if_true_env = environment;
    if_false_env = environment;

    if cond :: <membership(obj: Expr, type: Type)>: //## BAD BAD BAD: SHOULD BE SOMETHING LIKE cond ~= membership()
      obj = cond.obj;
      if obj :: Var:
        if_true_env = update(if_true_env, [obj -> cond.type]);
        //## HERE MAYBE I COULD TRY TO REFINE THE FALSE BRANCH AS WELL...
      ;

    elif cond :: <eq(left: Expr, right: Expr)>:
      expr1, expr2 = if cond.left :: Var then (cond.left, cond.right) else (cond.right, cond.left);
      if expr1 :: Var:
        type_if_eq, type_if_not_eq = eq_refine(environment[expr1], expr_type(expr2));
        if_true_env = update(if_true_env, [expr1 -> type_if_eq]);
        if_false_env = update(if_false_env, [expr1 -> type_if_not_eq]);
      ;

    elif cond :: <not_expr(Expr)>:
      if_false_env, if_true_env = refine_environment(_obj_(cond));

    elif cond :: <accessor_test(expr: Var, field: SymbObj)>:
      type_if_true, type_if_false = accessor_test_refine(environment[cond.expr], cond.field, true);
      if_true_env = update(if_true_env, [cond.expr -> type_if_true]) if type_if_true != empty_type;
      if_false_env = update(if_false_env, [cond.expr -> type_if_false]) if type_if_false != empty_type;

    elif cond :: <and_expr(left: Expr, right: Expr)>:
      et, ef = refine_environment(cond.left);
      if_true_env, ef = refine_environment(cond.right, environment=et);

    elif cond :: <or_expr(left: Expr, right: Expr)>:
      et, ef = refine_environment(cond.left);
      et, if_false_env = refine_environment(cond.right, environment=ef);
    ;

    return (if_true_env, if_false_env);


    (Type, Type) eq_refine(Type var_type, Type expr_type)
    {
      type_if_eq, type_if_not_eq = match (expr_type)
        symb_type(object(a?))   = (expr_type,       subtract_obj_from_type(var_type, a)),
        empty_set_type          = (empty_set_type,  subtract_obj_from_type(var_type, [])),
        empty_seq_type          = (empty_seq_type,  subtract_obj_from_type(var_type, ())),
        empty_map_type          = (empty_map_type,  subtract_obj_from_type(var_type, [:])),
        int_range()             = (expr_type,       if expr_type.size == 1
                                                      then subtract_obj_from_type(var_type, expr_type.min)
                                                      else var_type),
        _                       = (var_type,        var_type);

      type_if_eq = var_type if type_if_eq == empty_type;
      type_if_not_eq = var_type if type_if_not_eq == empty_type;
      return (type_if_eq, type_if_not_eq);
    }


    (Type, Type) accessor_test_refine(Type type, SymbObj field, Bool look_inside):
      LeafType                = (empty_type, type),
      type_var()              = (type, type),
      type_ref(ts?)           = accessor_test_refine(expand_type_ref(ts, typedefs), field, look_inside),
      ne_seq_type()           = (empty_type, type),
      ne_set_type()           = (empty_type, type),
      ne_map_type()           = (type, type),
      ne_record_type(fs?)     =
        if has_key(fs, field)
          then (record_type([l -> [type: f.type, optional: l != field and f.optional] : f @ l <- fs]), type)
          else (empty_type, type),
      tuple_type()            = (empty_type, type),
      tag_obj_type()          = {
        if look_inside:
          ref_types = accessor_test_refine(type.obj_type, field, false);
          return (tag_obj_type(type.tag_type, left(ref_types)), tag_obj_type(type.tag_type, right(ref_types)));
        else
          return (empty_type, type);
        ;
      },
      union_type(ts?)         = {
        rts = [accessor_test_refine(t, field, look_inside) : t <- ts];
        rts_if_true = [rtt : rt <- rts, rtt = left(rt), rtt != empty_type];
        rts_if_false = [rtf : rt <- rts, rtf = right(rt), rtf != empty_type];
        return (
          if rts_if_true  == [] then empty_type else union_type(rts_if_true),
          if rts_if_false == [] then empty_type else union_type(rts_if_false)
        );
      };
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  [Var -> Type] generate_env(Clause cls):
    set_elem_clause()   = environment & [cls.var -> set_elem_supertype(expr_type(cls.src))],
    map_entry_clause()  = { src_expr_type = expr_type(cls.src);
                            env_delta = [
                              cls.key_var -> map_key_supertype(src_expr_type),
                              cls.value_var -> map_value_supertype(src_expr_type)
                            ];
                            return environment & env_delta;
                          },
    seq_elem_clause()   = environment & [cls.var -> set_elem_supertype(expr_type(cls.src))],
    and_clause()        = { new_env = generate_env(cls.left);
                            return generate_env(cls.right, environment=new_env);
                          },
    or_clause()         = merge_envs(generate_env(cls.left), generate_env(cls.right)),
    // match_clause()      = environment & generate_env(cls.ptrn, expr_type(cls.expr)),
    match_clause()      = update_environment(cls.expr, cls.ptrn),
    asgnm_clause()      = environment & [cls.var -> expr_type(cls.expr)],
    filter_clause(e?)   = left(refine_environment(e));

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  // We assume the assignment typechecks
  [Var -> Type] asgnm_env_updates(Var+ vars, Type value_type)
  {
    nvars = nz_nat(length(vars));
    if nvars == 1:
      return [vars[0] -> value_type];
    else
      types = tuple_field_supertypes(value_type, nvars);
      return merge(([v -> t] : v, t <- zip(vars, types)));
    ;
  }


  [Var -> Type] merge_envs([Var -> Type] env1, [Var -> Type] env2)
  {
    ks = intersection(keys(env1), keys(env2));
    return [k -> union_superset([env1[k], env2[k]]) : k <- ks];
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  Type fn_call_type(FnType signature, AnyExpr* params, [NamedArg -> AnyExpr] named_args)//## DO I NEED THE THIRD PARAMETER?
  {
    type_var_insts = instantiate_type_vars(params, signature.params);
    return replace_type_vars(signature.ret_type, type_var_insts);
  }


  [TypeVar -> Type] instantiate_type_vars(AnyExpr* params, AnyType* param_types)
  {
    actual_types = ();
    formal_types = ();
    for p, t <- zip(params, param_types):
      if p :: Expr and t :: Type:
        actual_types = (actual_types | expr_type(p));
        formal_types = (formal_types | t);
      ;
    ;
    type_var_insts = type_var_instantiations_for_subset(actual_types, formal_types);

    cls_pars = ((p, t) : p, t <- zip(params, param_types), p :: ClsExpr and t :: ClsType);
    loop
      new_type_pairs = ();
      for p, t <- cls_pars:
        rp = rewrite_cls_expr(p);
        actual_ret_type = get_return_type(rp, t, type_var_insts);
        assert is_subset(actual_ret_type, replace_type_vars_with_type_any(t.out_type));
        new_type_pairs = (new_type_pairs | (actual_ret_type, t.out_type));
      ;
      new_actual_types, new_formal_types = unzip(new_type_pairs);
      new_type_var_insts = type_var_instantiations_for_subset(new_actual_types, new_formal_types);
      return type_var_insts if has_reached_fixpoint(type_var_insts, new_type_var_insts);
      type_var_insts = merge_insts(type_var_insts, new_type_var_insts);
    ;
  }


  Type get_return_type(ClsExpr expr, ClsType type, [TypeVar -> Type] type_var_insts):
    ClsVar      = closures[expr].out_type,
    fn_ptr()    = {fail;},
    cls_expr()  = { inst_formal_par_types = (replace_type_vars(t, type_var_insts) : t <- type.in_types);
                    new_env = get_updated_env(expr.params, expr.expr, inst_formal_par_types);
                    return expr_type(expr.expr, environment=new_env);
                  };

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  Type loop_var_type(Type lower_bound_type, Type upper_bound_type, Bool upper_bound_included)
  {
    upper_bound_adj = bit(not upper_bound_included);
    lower_bound = lower_bound(lower_bound_type);
    upper_bound = upper_bound(upper_bound_type);

    if lower_bound == nil:
      if upper_bound == nil:
        return integer;
      else
        return low_ints(value(upper_bound) + upper_bound_adj);
      ;
    else
      if upper_bound == nil:
        return high_ints(value(lower_bound));
      else
        return int_range(value(lower_bound), value(upper_bound) + upper_bound_adj);
      ;
    ;


    Maybe[Int] lower_bound(Type type):
      integer           = nil,
      low_ints()        = nil,
      high_ints()       = just(type.min),
      int_range()       = just(type.min),
      union_type(ts?)   = { lbs = [lower_bound(t) : t <- ts];
                            return if in(nil, lbs) then nil else just(min([value(lb) : lb <- lbs]));
                          },
      type_ref(ts?)     = lower_bound(expand_type_ref(ts, typedefs));


    Maybe[Int] upper_bound(Type type):
      integer           = nil,
      low_ints()        = just(type.max),
      high_ints()       = nil,
      int_range()       = just(max(type)),
      union_type(ts?)   = { ubs = [upper_bound(t) : t <- ts];
                            return if in(nil, ubs) then nil else just(max([value(ub) : ub <- ubs]));
                          },
      type_ref(ts?)     = upper_bound(expand_type_ref(ts, typedefs));
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  [Var -> Type] update_environment(Expr+ exprs, Pattern+ ptrns)
  {
    assert length(exprs) == length(ptrns);
    new_env = environment;
    for expr, ptrn <- zip(exprs, ptrns):
      new_env = update_environment(expr, ptrn, environment=new_env);
    ;
    return new_env;
  }


  [Var -> Type] update_environment(Expr expr, Pattern ptrn)
  {
    new_env = environment;

    type = expr_type(expr);
    //## THE EMPTY TYPE SHOULD NOT BE TREATED AS A SPECIAL CASE HERE.
    //## AM I SURE generate_env(Pattern, Type) CANNOT ACCEPT THE EMPTY TYPE?
    return new_env & [v -> empty_type : v <- pattern_vars(ptrn)] if type == empty_type;

    if expr :: Var:
      refined_type = type_pattern_intersection_superset(type, ptrn);
      assert refined_type != empty_type; //## WHAT IS THIS ASSERTION FOR? WHY CAN'T THE ORIGINAL TYPE ITSELF BE EMPTY?
      var_group = only_element_or_def_if_empty([as : as <- var_aliases, in(expr, as)], [expr]);
      new_env = update(new_env, [v -> refined_type : v <- var_group]);

    elif expr :: <accessor(expr: Var, field: SymbObj)>:
      var_type = expr_type(expr.expr);
      refined_field_type = type_pattern_intersection_superset(type, ptrn);
      fail if var_type == empty_type or refined_field_type == empty_type;
      refined_type = update_mandatory_field_type(var_type, expr.field, refined_field_type);
      var_group = only_element_or_def_if_empty([as : as <- var_aliases, in(expr.expr, as)], [expr.expr]);
      new_env = update(new_env, [v -> refined_type : v <- var_group]);
    ;

    return new_env & generate_env(ptrn, type);
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  Bool always_yields_results(Clause cls): //## FIND BETTER NAME
    set_elem_clause()   = is_subset(expr_type(cls.src), type_ne_set),
    map_entry_clause()  = is_subset(expr_type(cls.src), type_ne_map),
    seq_elem_clause()   = is_subset(expr_type(cls.src), type_ne_seq),
    and_clause()        = always_yields_results(cls.left) and always_yields_results(cls.right),
    or_clause()         = always_yields_results(cls.left) or always_yields_results(cls.right),
    match_clause()      = false, //## WE CAN DO BETTER HERE
    asgnm_clause()      = true,
    filter_clause()     = false;
}
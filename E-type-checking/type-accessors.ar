using (TypeName => Type) typedefs
{
  Type* seq_elem_types(Type type) = {t.elem_type : ne_seq_type() t <- split_type(type)};

  Type seq_elem_supertype(Type type):
    empty_type        = empty_type,
    empty_seq_type    = empty_type,
    ne_seq_type()     = type.elem_type,
    tuple_type(ts?)   = union_superset(set(ts)),
    type_ref(ts?)     = seq_elem_supertype(expand_type_ref(ts, typedefs)),
    union_type(ts?)   = union_superset({seq_elem_supertype(t) : t <- ts});


  Type* set_elem_types(Type type) = {t.elem_type : ne_set_type() t <- split_type(type)};

  Type set_elem_supertype(Type type) = union_superset(set_elem_types(type));


  (Type, Type)* map_key_value_type_pairs(Type type) = {(t.key_type, t.value_type) : ne_map_type() t <- split_type(type)};

  Type map_key_supertype(Type type)   = union_superset({left(p) : p <- map_key_value_type_pairs(type)});
  Type map_value_supertype(Type type) = union_superset({right(p) : p <- map_key_value_type_pairs(type)});


  RecordType* record_types(Type type) = {t : record_type() t <- split_type(type)};


  TagObjType* tagged_obj_types(Type type) = {t : tag_obj_type() t <- split_type(type)};


  [Type^] tuple_field_supertypes(Type type, [2..*] tuple_length):
    type_ref(ts?)     = tuple_field_supertypes(expand_type_ref(ts, typedefs), tuple_length),
    tuple_type(ts?)   = if length(ts) == tuple_length then ts else {fail;},
    union_type(ts?)   = { ftss = {tuple_field_supertypes(t, tuple_length) : t <- ts};
                          return [union_superset({fts[i] : fts <- ftss}) : i < tuple_length];
                        };


  [Type^]* tuple_field_types_set(Type type) = {ts : tuple_type(ts) <- split_type(type)};

  //////////////////////////////////////////////////////////////////////////////

  Bool is_ne_seq_type(Type type) = not (? t <- split_type(type) : not t :: <ne_seq_type(Any)>); //## SUPER UGLY

  Bool is_ne_set_type(Type type) = not (? t <- split_type(type) : not t :: <ne_set_type(Any)>); //## DITTO

  Bool is_type_var(Type type)
  {
    types = split_type(type);
    type_vars = {t : type_var() t <- types}; //## SUPER UGLY
    other_types = types - type_vars;
    assert type_vars & other_types == types;
    assert size(type_vars) <= 1;
    return type_vars /= {} and other_types == {};
  }
}

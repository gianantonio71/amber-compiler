using [TypeName -> Type] typedefs
{
  [Type] seq_elem_types(Type type) = [t.elem_type : t <- split_type(type), ne_seq_type() << t];

  Type seq_elem_supertype(Type type):
    empty_type        = empty_type,
    empty_seq_type    = empty_type,
    ne_seq_type()     = type.elem_type,
    tuple_type(ts?)   = union_superset(set(ts)),
    type_ref(ts?)     = seq_elem_supertype(expand_type_ref(ts, typedefs)),
    union_type(ts?)   = union_superset([seq_elem_supertype(t) : t <- ts]);


  [Type] set_elem_types(Type type) = [t.elem_type : t <- split_type(type), ne_set_type() << t];

  Type set_elem_supertype(Type type) = union_superset(set_elem_types(type));


  [(Type, Type)] map_key_value_type_pairs(Type type) = [(t.key_type, t.value_type) : t <- split_type(type), ne_map_type() << t];

  Type map_key_supertype(Type type)   = union_superset([left(p) : p <- map_key_value_type_pairs(type)]);
  Type map_value_supertype(Type type) = union_superset([right(p) : p <- map_key_value_type_pairs(type)]);


  [RecordType] record_types(Type type) = [t : t <- split_type(type), record_type() << t];


  [TagObjType] tagged_obj_types(Type type) = [t : t <- split_type(type), tag_obj_type() << t];


  Type+ tuple_field_supertypes(Type type, <2..*> tuple_length):
    empty_type        = (empty_type : i < tuple_length),
    type_ref(ts?)     = tuple_field_supertypes(expand_type_ref(ts, typedefs), tuple_length),
    tuple_type(ts?)   = if length(ts) == tuple_length then ts else {fail;},
    union_type(ts?)   = { ftss = [tuple_field_supertypes(t, tuple_length) : t <- ts];
                          return (union_superset([fts[i] : fts <- ftss]) : i < tuple_length);
                        };


  [Type+] tuple_field_types_set(Type type) = [ts : t <- split_type(type), tuple_type(ts?) << t];

  //////////////////////////////////////////////////////////////////////////////

  Bool is_ne_seq_type(Type type) = not (? t <- split_type(type) : not t :: <ne_seq_type(Any)>); //## SUPER UGLY

  Bool is_ne_set_type(Type type) = not (? t <- split_type(type) : not t :: <ne_set_type(Any)>); //## DITTO

  Bool is_type_var(Type type)
  {
    types = split_type(type);
    type_vars = [t : t <- types, type_var() << t]; //## SUPER UGLY
    other_types = types - type_vars;
    assert type_vars & other_types == types;
    assert size(type_vars) <= 1;
    return type_vars != [] and other_types == [];
  }
}

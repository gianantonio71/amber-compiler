Type unfold(Type type, (SelfPretype => Type) sub_map):
  LeafType          = type,
  TypeVar           = type,
  SelfPretype       = sub_map[type],
  ne_seq_type()     = ne_seq_type(unfold(type.elem_type, sub_map)),
  ne_set_type()     = ne_set_type(unfold(type.elem_type, sub_map)),
  ne_map_type()     = ne_map_type(unfold(type.key_type, sub_map), unfold(type.value_type, sub_map)),
  record_type(fs?)  = record_type((l => (type: unfold(f.type, sub_map), optional: f.optional) : l => f <- fs)),
  tuple_type(ts?)   = tuple_type([unfold(t, sub_map) : t <- ts]),
  tag_obj_type()    = tag_obj_type(type.tag_type, unfold(type.obj_type, sub_map)),
  union_type(ts?)   = union_type({unfold(t, sub_map) : t <- ts}),
  self_rec_type()   = type,
  mut_rec_type()    = type;


Type unfold(Type type):
  self_rec_type(t?) = unfold(t, (self => type)),
  mut_rec_type()    = unfold(type.types[type.index], (self(i) => mut_rec_type(i, type.types) : i <- index_set(type.types))),
  _                 = type;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Type replace_type_vars_with_type_any(ExtType type) = replace_type_vars_computed(type, type_any);

Type replace_type_vars(ExtType type, (TypeVar => Type) substitutions) = replace_type_vars_computed(type, substitutions[$]);

Type replace_known_type_vars(ExtType type, (TypeVar => Type) substitutions) =
  replace_type_vars_computed(type, if has_key(substitutions, $) then substitutions[$] else $);


//## BAD: FIND DECENT NAME, OR EVEN BETTER, REMOVE THE RESTRICTIONS ABOUT CLOSURE PARAMETERS FOR FUNCTIONS WITH SAME NAME AND ARITY
Type replace_type_vars_computed(Type type, (TypeVar -> Type) replace):
  LeafType          = type,
  SelfPretype       = type,
  TypeVar           = replace(type),
  ne_seq_type()     = ne_seq_type(replace_type_vars_computed(type.elem_type, replace)),
  ne_set_type()     = ne_set_type(replace_type_vars_computed(type.elem_type, replace)),
  ne_map_type()     = ne_map_type(replace_type_vars_computed(type.key_type, replace), replace_type_vars_computed(type.value_type, replace)),
  record_type(fs?)  = record_type((l => (type: replace_type_vars_computed(f.type, replace), optional: f.optional) : l => f <- fs)), //## BAD: WOULD BE GOOD TO HAVE A "DECLARATIVE" UPDATE OPERATION
  tuple_type(ts?)   = tuple_type([replace_type_vars_computed(t, replace) : t <- ts]),
  tag_obj_type()    = tag_obj_type(type.tag_type, replace_type_vars_computed(type.obj_type, replace)),
  union_type(ts?)   = union_type({replace_type_vars_computed(t, replace) : t <- ts}),
  self_rec_type(t?) = self_rec_type(replace_type_vars_computed(t, replace)),
  mut_rec_type()    = mut_rec_type(index: type.index, types: [replace_type_vars_computed(t, replace) : t <- type.types]);


ClsType replace_type_vars_computed(ClsType type, (TypeVar -> Type) replace) =
  cls_type(
    [replace_type_vars_computed(t, replace) : t <- type.in_types],
    replace_type_vars_computed(type.out_type, replace)
  );

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ClosedType replace_type_vars_with_void_default(Type type, (TypeVar => ClosedType) substitutions) =
  closed_replace_type_vars(type, if has_key(substitutions, $) then substitutions[$] else void_type);


//## BAD: FIND BETTER NAME
ClosedType closed_replace_type_vars(Type type, (TypeVar -> ClosedType) replace):
  LeafType          = type,
  SelfPretype       = type,
  TypeVar           = replace(type),
  ne_seq_type()     = closed_ne_seq_type(closed_replace_type_vars(type.elem_type, replace)),
  ne_set_type()     = closed_ne_set_type(closed_replace_type_vars(type.elem_type, replace)),
  ne_map_type()     = closed_ne_map_type(closed_replace_type_vars(type.key_type, replace), closed_replace_type_vars(type.value_type, replace)),
  record_type(fs?)  = closed_record_type((l => (type: closed_replace_type_vars(f.type, replace), optional: f.optional) : l => f <- fs)), //## BAD: WOULD BE GOOD TO HAVE A "DECLARATIVE" UPDATE OPERATION
  tuple_type(ts?)   = closed_tuple_type([closed_replace_type_vars(t, replace) : t <- ts]),
  tag_obj_type()    = closed_tag_obj_type(type.tag_type, closed_replace_type_vars(type.obj_type, replace)),
  union_type(ts?)   = closed_union_type({closed_replace_type_vars(t, replace) : t <- ts}),
  self_rec_type(t?) = closed_self_rec_type(closed_replace_type_vars(t, replace)),
  mut_rec_type()    = closed_mut_rec_type(type.index, [closed_replace_type_vars(t, replace) : t <- type.types]);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//## HOW IS THIS DIFFERENT FROM split_type()?
// Type+ expand_type(Type type):
//   union_type(ts?)   = union({expand_type(t) : t <- ts}),
//   self_rec_type(t?) = expand_type(replace_rec_refs(t, (self => type))),
//   mut_rec_type()    = expand_type(replace_rec_refs(type.types[type.index], (self(i) => mut_rec_type(i, type.types) : i < length(type.types)))),
//   _                 = {type};

<LeafType, TypeVar, CompType>* split_type(Type type):
  LeafType        = {type}, //## BAD: EXACT SAME EXPRESSION REPEATED 8 TIMES
  type_var()      = {type},
  ne_seq_type()   = {type},
  ne_set_type()   = {type},
  ne_map_type()   = {type},
  record_type()   = {type},
  tuple_type()    = {type},
  tag_obj_type()  = {type},
  union_type(ts?) = union({split_type(t) : t <- ts}),
  self_rec_type() = split_type(unfold(type)),
  mut_rec_type()  = split_type(unfold(type));

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//## WHERE SHOULD THIS GO? IT LOGICALLY BELONG TO THE CODE THAT CALCULATE THE
//## INTERSECTION OF TWO TYPES, BUT APART FROM THE FACT THAT THAT CODE HAS
//## BEEN REMOVED, IT IS ALSO USED BY THE CODE THAT CALCULATE THE INTERSECTION
//## OF A PATTERN AND A TYPE, AND I DON'T WANT THAT CODE TO DEPEND ON THE CODE
//## THAT CALCULATES THE (APPROXIMATE) INTERSECTION OF TWO TYPES

<IntType, void_type> int_types_intersection(<IntType, void_type> int_type_1, <IntType, void_type> int_type_2):
  integer,      _             = int_type_2,

  low_ints(),   low_ints()    = low_ints(min(int_type_1.max, int_type_2.max)),
  low_ints(),   high_ints()   = maybe_int_range(int_type_2.min, int_type_1.max),
  low_ints(),   int_range()   = maybe_int_range(int_type_2.min, min(int_type_1.max, max(int_type_2))),

  high_ints(),  high_ints()   = high_ints(max(int_type_1.min, int_type_2.min)),
  high_ints(),  int_range()   = maybe_int_range(max(int_type_1.min, int_type_2.min), max(int_type_2)),

  int_range(),  int_range()   = maybe_int_range(max(int_type_1.min, int_type_2.min), min(max(int_type_1), max(int_type_2))),

  _,            _             = int_types_intersection(int_type_2, int_type_1);


//## THIS SHOULD BE MOVED TO THE utils_2_ctors.h FILE
<IntType, void_type> maybe_int_range(Int min, Int max) = if max >= min then int_range(min, max) else void_type;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Bool may_match(Pattern ptrn, Type type) = type_pattern_intersection_superset(type, ptrn) /= void_type;


// Rule: the type returned by this function is always a subset of the input one
// With one exception (record types which include the empty map) the returned
// type is also a subset of the [type implicitly defined by] the input pattern
ClosedType type_pattern_intersection_superset(Type type, Pattern ptrn):
  _,                  ptrn_any          = type,
  _,                  ptrn_var()        = type_pattern_intersection_superset(type, ptrn.ptrn),
  _,                  ptrn_union(ps?)   = type_patterns_intersection_superset(type, ps),

  type_var(),         _                 = type_pattern_intersection_superset(type_any, ptrn),

  atom_type,          ptrn_symbol       = atom_type,
  atom_type,          ptrn_symbol(s?)   = symb_type(s),
  atom_type,          _                 = void_type,

  symb_type(),        ptrn_symbol       = type,
  symb_type(ts?),     ptrn_symbol(ps?)  = if ts == ps then type else void_type,
  symb_type(),        _                 = void_type,

  IntType,            ptrn_integer(t?)  = int_types_intersection(type, t),
  IntType,            _                 = void_type,

  float_type,         _                 = if ptrn == ptrn_float then float_type else void_type,

  empty_seq_type,     _                 = if ptrn == ptrn_empty_seq then empty_seq_type else void_type,
  empty_set_type,     _                 = if ptrn == ptrn_empty_set then empty_set_type else void_type,
  empty_map_type,     _                 = if ptrn == ptrn_empty_map then empty_map_type else void_type,

  ne_seq_type(),      _                 = if ptrn == ptrn_ne_seq then type else void_type,
  ne_set_type(),      _                 = if ptrn == ptrn_ne_set then type else void_type,
  ne_map_type(),      _                 = if ptrn == ptrn_ne_map then type else void_type,

  record_type(fs?),   ptrn_empty_map    = if (? l => f <- fs : not f.optional) then void_type else empty_map_type,
  record_type(fs?),   ptrn_ne_map       = type, // This is the reason why this function does not return the exact intersection but a superset of it
  record_type(fs?),   _                 = void_type,

  tuple_type(ts?),    _                 = if ptrn == ptrn_ne_seq then type else void_type,

  tag_obj_type(),     ptrn_tag_obj()    = { tag_type_int = type_pattern_intersection_superset(type.tag_type, ptrn.tag);
                                            obj_type_int = type_pattern_intersection_superset(type.obj_type, ptrn.obj);
                                            if (tag_type_int == void_type or obj_type_int == void_type)
                                              return void_type;
                                            else
                                              return tag_obj_type(tag_type_int, obj_type_int);
                                            ;
                                          },
  tag_obj_type(),     _                 = void_type,

  union_type(ts?),    _                 = { int_types = {type_pattern_intersection_superset(t, ptrn) : t <- ts} - {void_type};
                                            return void_type if int_types == {};
                                            return only_element(int_types) if size(int_types) == 1;
                                            // The types here are all union-compatible, since they are all
                                            // subsets of types that were union-compatible to begin with
                                            return union_type(int_types);
                                          },

  self_rec_type(t?),  _                 = type_pattern_intersection_superset(unfold(type), ptrn),

  mut_rec_type(),     _                 = type_pattern_intersection_superset(unfold(type), ptrn);


ClosedType type_patterns_intersection_superset(Type type, Pattern* ptrns)
{
  types = {type_pattern_intersection_superset(type, p) : p <- ptrns} - {void_type};
  return void_type if types == {};
  return only_element(types) if size(types) == 1;
  // This is actually pretty tricky. Since the patterns in a union
  // are supposed to be pseudotype-compatible, and since the returned
  // type is generally supposed to be a subset of the input pattern,
  // the types should all be pseudotype-compatible as well.
  // There is one exception we have to deal with though, and that's
  // when we have a record type that includes the empty map, and a
  // pattern union that includes both the empty and non-empty map
  // patterns.
  if (in(empty_map_type, types) and (? t <- types : t /= empty_map_type and type_contains_obj(t, ())))
    types = types - {empty_map_type};
  ;
  return union_type(types);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//## THIS IS PRETTY MUCH UNTESTED. IT SHOULD BE TESTED WITH THE TYPE SUBSET TESTING CODE,
//## AND MAYBE IT WOULD BE GOOD TO DO SOME MANUAL TESTING, ESPECIALLY FOR TUPLE TYPES
Bool type_contains_obj(Type type, Any obj):
  atom_type,        +           = true,
  atom_type,        _           = false,

  symb_type(s?),    _           = obj == _obj_(s),

  integer,          *           = true,
  integer,          _           = false,

  low_ints(),       *           = obj <= type.max,
  low_ints(),       _           = false,

  high_ints(),      *           = obj >= type.min,
  high_ints(),      _           = false,

  int_range(),      *           = obj >= type.min and obj <= max(type),
  int_range(),      _           = false,

  float_type,       ^           = true,
  float_type,       _           = false,

  type_var(),       _           = {fail;},

  empty_seq_type,   _           = obj == [],
  empty_set_type,   _           = obj == {},
  empty_map_type,   _           = obj == (),

  ne_seq_type(),    [...]       = obj /= [] and all([type_contains_obj(type.elem_type, e) : e <- obj]),
  ne_seq_type(),    _           = false,

  ne_set_type(),    {...}       = obj /= {} and not (? e <- obj : not type_contains_obj(type.elem_type, e)),
  ne_set_type(),    _           = false,

  ne_map_type(),    (...)       = obj /= () and not (? k => v <- obj : not type_contains_obj(type.key_type, k) or not type_contains_obj(type.value_type, v)),
  ne_map_type(),    _           = false,

  record_type(fs?), (...)       = not (? k => v <- obj : not has_key(fs, k) or not type_contains_obj(fs[k].type, v)) and
                                  subset({l : l => f <- fs, not f.optional}, keys(obj)),
  record_type(fs?), _           = false,

  tuple_type(ts?),  [...]       = length(ts) == length(obj) and all([type_contains_obj(t, e) : t, e <- zip(ts, obj)]),
  tuple_type(ts?),  _           = false,

  tag_obj_type(),   tag @ iobj  = type_contains_obj(type.tag_type, tag) and type_contains_obj(type.obj_type, iobj),
  tag_obj_type(),   _           = false,

  union_type(ts?),  _           = (? t <- ts : type_contains_obj(t, obj)),

  self_rec_type(),  _           = type_contains_obj(unfold(type), obj),
  mut_rec_type(),   _           = type_contains_obj(unfold(type), obj);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//## I COULD ASSERT THAT THE RESULTING TYPE IS A SUBSET OF THE ORIGINAL ONE
//## THAT WOULD INTRODUCE A CYCLIC DEPENDENCY (ALBEIT ONLY IN DEBUG MODE) BETWEEN
//## TYPE UTILS AND SUBTYPE CHECKING. ALSO THE SYNTAX WOULD NOT BE GREAT.
ClosedType subtract_obj_from_type(Type type, Any obj):
  symb_type(object(s?))   = if obj == s then void_type else type,

  low_ints()              = if obj == type.max then low_ints(type.max-1) else type,
  high_ints()             = if obj == type.min then high_ints(type.min+1) else type,
  int_range()             = { new_min = type.min + bit(obj == type.min);
                              new_max = type.max - bit(obj == type.max);
                              return if new_min <= new_max then int_range(new_min, new_max) else void_type;
                            },

  empty_seq_type          = if obj == [] then void_type else type,
  empty_set_type          = if obj == {} then void_type else type,
  empty_map_type          = if obj == () then void_type else type,

  union_type(ts?)         = { nts = {nt : t <- ts, nt = subtract_obj_from_type(t, obj), nt /= void_type};
                              return if nts == {} then void_type else union_type(nts);
                            },

  self_rec_type()         = { unfolded_type = unfold(type);
                              refined_type = subtract_obj_from_type(unfolded_type, obj);
                              assert refined_type /= void_type;
                              assert refined_type == unfolded_type or
                                     ( type_contains_obj(unfolded_type, obj) and
                                       not type_contains_obj(refined_type, obj)
                                     );
                              return if refined_type /= unfolded_type then refined_type else type;
                            },

  mut_rec_type()          = { unfolded_type = unfold(type);
                              refined_type = subtract_obj_from_type(unfolded_type, obj);
                              assert refined_type /= void_type;
                              assert refined_type == unfolded_type or
                                     ( type_contains_obj(unfolded_type, obj) and
                                       not type_contains_obj(refined_type, obj)
                                     );
                              return if refined_type /= unfolded_type then refined_type else type;
                            },

  _                       = type;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

FnType signature(FnDef fn_def, (TypeName => Type) typedefs) =
  fn_type(
    params:       [user_type_to_anon_type(p.type, typedefs=typedefs) : p <- fn_def.params],
    named_params: (n => user_type_to_anon_type(t, typedefs=typedefs) : n => t <- fn_def.named_params),
    ret_type:     user_type_to_anon_type(fn_def.res_type, typedefs=typedefs)
  );

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

FnType builtin_signature(BuiltIn):
  neg             = unary_int_op,
  add             = binary_int_op,
  sub             = binary_int_op,
  mult            = binary_int_op,
  div             = binary_int_op,
  mod             = binary_int_op,

  lt              = binary_int_pred,
  le              = binary_int_pred,
  gt              = binary_int_pred,
  ge              = binary_int_pred,

  str             = fn_type([atom_type],                          type_string),
  symb            = fn_type([type_string],                        atom_type),
  at              = fn_type([type_seq_t, integer],                type_var(:t)),
  len             = fn_type([type_seq],                           high_ints(0)),
  slice           = fn_type([type_seq_t, integer, integer],       type_seq_t),
  cat             = fn_type([type_seq_t, type_seq_t],             type_seq_t),
  mcat            = fn_type([type_seq(type_seq_t)],               type_seq_t),
  set             = fn_type([type_seq_t],                         type_set_t),
  rev             = fn_type([type_seq_t],                         type_seq_t),
  mset            = fn_type([type_seq_t],                         type_mset(type_var(:t))),
  isort           = fn_type([type_set_t],                         type_seq_t),
  list_to_seq     = fn_type([type_bare_list(type_var(:t))],       type_seq_t),

  tag             = fn_type([type_tagged_obj],                    atom_type), // The return type is too loose, and it is ignore in the code
  obj             = fn_type([type_tagged_obj],                    type_any),  // Ditto

  in              = fn_type([type_any, type_set],                 type_bool),
  has_key         = fn_type([type_map, type_any],                 type_bool),
  lookup          = fn_type([type_map_t1_t2, type_var(:t1)],      type_var(:t2)),
  union           = fn_type([type_set(type_set_t)],               type_set_t),
  merge           = fn_type([type_set(type_map_t1_t2)],           type_map_t1_t2),

  fneg            = unary_float_op,
  fadd            = binary_float_op,
  fsub            = binary_float_op,
  fmult           = binary_float_op,
  fdiv            = binary_float_op,
  fsqrt           = unary_float_op,
  // floor           = ,
  // ceiling         = ,
  float           = fn_type([integer],                            float_type),
  mantissa        = fn_type([float_type],                         integer),
  dec_exp         = fn_type([float_type],                         integer),

  rand_nat        = fn_type([type_nat],                           type_nat),
  rand_elem       = fn_type([type_set_t],                         type_var(:t)),
  counter         = fn_type([type_any],                           integer),

  ticks           = fn_type([type_any],                           integer);


FnType unary_int_op     = fn_type([integer], integer);
FnType binary_int_op    = fn_type([integer, integer], integer);
FnType binary_int_pred  = fn_type([integer, integer], type_bool);

FnType unary_float_op   = fn_type([float_type], float_type);
FnType binary_float_op  = fn_type([float_type, float_type], float_type);

Type type_seq_t     = type_seq(type_var(:t));
Type type_set_t     = type_set(type_var(:t));
Type type_map_t1_t2 = type_map(type_var(:t1), type_var(:t2));

Type type_bare_list(Type elem_type) =
  self_rec_type(
    union_type({
      empty_seq_type,
      tuple_type([elem_type, self])
    })
  );

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Type type_bool = union_type({symb_type(true), symb_type(false)});

Type type_nat = high_ints(0);

Type type_seq = type_seq(type_any);
Type type_set = type_set(type_any);
Type type_map = type_map(type_any, type_any);

Type type_tagged_obj = tag_obj_type(atom_type, type_any);

Type type_seq(Type elem_type)  = union_type({empty_seq_type, ne_seq_type(elem_type)});
Type type_set(Type elem_type)  = union_type({empty_set_type, ne_set_type(elem_type)});
Type type_mset(Type elem_type) = union_type({empty_map_type, ne_map_type(elem_type, high_ints(1))});

Type type_tuple([2..*] size)  = tuple_type(size * [type_any]);

Type type_map(Type key_type, Type value_type)  = union_type({empty_map_type, ne_map_type(key_type, value_type)});

Type type_string = tag_obj_type(symb_type(:string), union_type({empty_seq_type, ne_seq_type(type_nat)}));

Type type_any =
  self_rec_type(
    union_type({
      atom_type,
      integer,
      float_type,
      empty_seq_type,
      empty_set_type,
      empty_map_type,
      ne_seq_type(self),
      ne_set_type(self),
      ne_map_type(self, self),
      tag_obj_type(atom_type, self)
    })
  );


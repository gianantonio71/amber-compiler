AnonType unfold(AnonType type, (SelfPretype => AnonType) sub_map):
  LeafType          = type,
  TypeVar           = type,
  SelfPretype       = sub_map[type],
  ne_seq_type()     = ne_seq_type(unfold(type.elem_type, sub_map)),
  ne_set_type()     = ne_set_type(unfold(type.elem_type, sub_map)),
  ne_map_type()     = ne_map_type(unfold(type.key_type, sub_map), unfold(type.value_type, sub_map)),
  record_type(fs?)  = record_type((l => (type: unfold(f.type, sub_map), optional: f.optional) : l => f <- fs)),
  tuple_type(ts?)   = tuple_type([unfold(t, sub_map) : t <- ts]),
  tag_obj_type()    = tag_obj_type(type.tag_type, unfold(type.obj_type, sub_map)),
  union_type(ts?)   = union_type({unfold(t, sub_map) : t <- ts}),
  self_rec_type()   = type,
  mut_rec_type()    = type;


AnonType unfold(AnonType type):
  self_rec_type(t?) = unfold(t, (self => type)),
  mut_rec_type()    = unfold(type.types[type.index], (self(i) => mut_rec_type(i, type.types) : i <- index_set(type.types))),
  _                 = type;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

AnonType replace_type_vars_with_type_any(ExtType type) = replace_type_vars_computed(type, type_any);

AnonType replace_type_vars(ExtType type, (TypeVar => AnonType) substitutions) = replace_type_vars_computed(type, substitutions[$]);

AnonType replace_known_type_vars(ExtType type, (TypeVar => AnonType) substitutions) =
  replace_type_vars_computed(type, if has_key(substitutions, $) then substitutions[$] else $);


//## BAD: FIND DECENT NAME, OR EVEN BETTER, REMOVE THE RESTRICTIONS ABOUT CLOSURE PARAMETERS FOR FUNCTIONS WITH SAME NAME AND ARITY
AnonType replace_type_vars_computed(AnonType type, (TypeVar -> AnonType) replace):
  LeafType          = type,
  SelfPretype       = type,
  TypeVar           = replace(type),
  ne_seq_type()     = ne_seq_type(replace_type_vars_computed(type.elem_type, replace)),
  ne_set_type()     = ne_set_type(replace_type_vars_computed(type.elem_type, replace)),
  ne_map_type()     = ne_map_type(replace_type_vars_computed(type.key_type, replace), replace_type_vars_computed(type.value_type, replace)),
  record_type(fs?)  = record_type((l => (type: replace_type_vars_computed(f.type, replace), optional: f.optional) : l => f <- fs)), //## BAD: WOULD BE GOOD TO HAVE A "DECLARATIVE" UPDATE OPERATION
  tuple_type(ts?)   = tuple_type([replace_type_vars_computed(t, replace) : t <- ts]),
  tag_obj_type()    = tag_obj_type(type.tag_type, replace_type_vars_computed(type.obj_type, replace)),
  union_type(ts?)   = union_type({replace_type_vars_computed(t, replace) : t <- ts}),
  self_rec_type(t?) = self_rec_type(replace_type_vars_computed(t, replace)),
  mut_rec_type()    = mut_rec_type(index: type.index, types: [replace_type_vars_computed(t, replace) : t <- type.types]);


ClsType replace_type_vars_computed(ClsType type, (TypeVar -> AnonType) replace) =
  cls_type(
    [replace_type_vars_computed(t, replace) : t <- type.in_types],
    replace_type_vars_computed(type.out_type, replace)
  );

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//## HOW IS THIS DIFFERENT FROM split_type()?
// AnonType+ expand_type(AnonType type):
//   union_type(ts?)   = union({expand_type(t) : t <- ts}),
//   self_rec_type(t?) = expand_type(replace_rec_refs(t, (self => type))),
//   mut_rec_type()    = expand_type(replace_rec_refs(type.types[type.index], (self(i) => mut_rec_type(i, type.types) : i < length(type.types)))),
//   _                 = {type};

<LeafType, TypeVar, CompType[AnonType]>* split_type(AnonType type):
  LeafType        = {type}, //## BAD: EXACT SAME EXPRESSION REPEATED 8 TIMES
  type_var()      = {type},
  ne_seq_type()   = {type},
  ne_set_type()   = {type},
  ne_map_type()   = {type},
  record_type()   = {type},
  tuple_type()    = {type},
  tag_obj_type()  = {type},
  union_type(ts?) = union({split_type(t) : t <- ts}),
  self_rec_type() = split_type(unfold(type)),
  mut_rec_type()  = split_type(unfold(type));

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//## WHERE SHOULD THIS GO? IT LOGICALLY BELONG TO THE CODE THAT CALCULATE THE
//## INTERSECTION OF TWO TYPES, BUT APART FROM THE FACT THAT THAT CODE HAS
//## BEEN REMOVED, IT IS ALSO USED BY THE CODE THAT CALCULATE THE INTERSECTION
//## OF A PATTERN AND A TYPE, AND I DON'T WANT THAT CODE TO DEPEND ON THE CODE
//## THAT CALCULATES THE (APPROXIMATE) INTERSECTION OF TWO TYPES

<IntType, void_type> int_types_intersection(<IntType, void_type> int_type_1, <IntType, void_type> int_type_2):
  integer,      _             = int_type_2,

  low_ints(),   low_ints()    = low_ints(min(int_type_1.max, int_type_2.max)),
  low_ints(),   high_ints()   = maybe_int_range(int_type_2.min, int_type_1.max),
  low_ints(),   int_range()   = maybe_int_range(int_type_2.min, min(int_type_1.max, max(int_type_2))),

  high_ints(),  high_ints()   = high_ints(max(int_type_1.min, int_type_2.min)),
  high_ints(),  int_range()   = maybe_int_range(max(int_type_1.min, int_type_2.min), max(int_type_2)),

  int_range(),  int_range()   = maybe_int_range(max(int_type_1.min, int_type_2.min), min(max(int_type_1), max(int_type_2))),

  _,            _             = int_types_intersection(int_type_2, int_type_1);


//## THIS SHOULD BE MOVED TO THE utils_2_ctors.h FILE
<IntType, void_type> maybe_int_range(Int min, Int max) = if max >= min then int_range(min, max) else void_type;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Bool may_match(Pattern ptrn, AnonType type) = type_pattern_intersection_superset(type, ptrn) /= void_type;


// Rule: the type returned by this function is always a subset of the input one
// With one exception (record types which include the empty map) the returned
// type is also a subset of the [type implicitly defined by] the input pattern
ClosedType type_pattern_intersection_superset(AnonType type, Pattern ptrn):
  _,                  ptrn_any          = type,
  _,                  ptrn_var()        = type_pattern_intersection_superset(type, ptrn.ptrn),
  _,                  ptrn_union(ps?)   = type_patterns_intersection_superset(type, ps),

  atom_type,          ptrn_symbol       = atom_type,
  atom_type,          ptrn_symbol(s?)   = symb_type(s),
  atom_type,          _                 = void_type,

  symb_type(),        ptrn_symbol       = type,
  symb_type(ts?),     ptrn_symbol(ps?)  = if ts == ps then type else void_type,
  symb_type(),        _                 = void_type,

  IntType,            ptrn_integer(t?)  = int_types_intersection(type, t),
  IntType,            _                 = void_type,

  float_type,         _                 = if ptrn == ptrn_float then float_type else void_type,

  empty_seq_type,     _                 = if ptrn == ptrn_empty_seq then empty_seq_type else void_type,
  empty_set_type,     _                 = if ptrn == ptrn_empty_set then empty_set_type else void_type,
  empty_map_type,     _                 = if ptrn == ptrn_empty_map then empty_map_type else void_type,

  ne_seq_type(),      _                 = if ptrn == ptrn_ne_seq then type else void_type,
  ne_set_type(),      _                 = if ptrn == ptrn_ne_set then type else void_type,
  ne_map_type(),      _                 = if ptrn == ptrn_ne_map then type else void_type,

  record_type(fs?),   ptrn_empty_map    = if (? l => f <- fs : not f.optional) then void_type else empty_map_type,
  record_type(fs?),   ptrn_ne_map       = type, // This is the reason why this function does not return the exact intersection but a superset of it
  record_type(fs?),   _                 = void_type,

  tuple_type(ts?),    _                 = if ptrn == ptrn_ne_seq then type else void_type,

  tag_obj_type(),     ptrn_tag_obj()    = { tag_type_int = type_pattern_intersection_superset(type.tag_type, ptrn.tag);
                                            obj_type_int = type_pattern_intersection_superset(type.obj_type, ptrn.obj);
                                            if (tag_type_int == void_type or obj_type_int == void_type)
                                              return void_type;
                                            else
                                              return tag_obj_type(tag_type_int, obj_type_int);
                                            ;
                                          },
  tag_obj_type(),     _                 = void_type,

  union_type(ts?),    _                 = { int_types = {type_pattern_intersection_superset(t, ptrn) : t <- ts} - {void_type};
                                            return void_type if int_types == {};
                                            return only_element(int_types) if size(int_types) == 1;
                                            // The types here are all union-compatible, since they are all
                                            // subsets of types that were union-compatible to begin with
                                            return union_type(int_types);
                                          },

  self_rec_type(t?),  _                 = type_pattern_intersection_superset(unfold(type), ptrn),

  mut_rec_type(),     _                 = type_pattern_intersection_superset(unfold(type), ptrn);


ClosedType type_patterns_intersection_superset(AnonType type, Pattern* ptrns)
{
  types = {type_pattern_intersection_superset(type, p) : p <- ptrns} - {void_type};
  return void_type if types == {};
  return only_element(types) if size(types) == 1;
  // This is actually pretty tricky. Since the patterns in a union
  // are supposed to be pseudotype-compatible, and since the returned
  // type is generally supposed to be a subset of the input pattern,
  // the types should all be pseudotype-compatible as well.
  // There is one exception we have to deal with though, and that's
  // when we have a record type that includes the empty map, and a
  // pattern union that includes both the empty and non-empty map
  // patterns.
  if (in(empty_map_type, types) and (? t <- types : t /= empty_map_type and type_contains_obj(t, ())))
    types = types - {empty_map_type};
  ;
  return union_type(types);
}

// ClosedType tag_obj_ptrn_type_intersection_superset(TagPtrn tag_ptrn, Pattern obj_ptrn, AnonType type)
// {
//   tag_obj_types = tagged_obj_types(type);
//   sel_types = {
//     tag_obj_type(tag_type_int, obj_type_int):
//     t <- tag_obj_types,
//     tag_type_int = pattern_type_intersection_superset(tag_ptrn, t.tag_type),
//     obj_type_int = pattern_type_intersection_superset(obj_ptrn, t.obj_type),
//     tag_type_int /= void_type,
//     obj_type_int /= void_type
//   };
//   assert sel_types /= {}; //## THIS ASSERTION IS JUST A TEMPORARY CHECK, IT SHOULD EVENTUALLY BE REMOVED
//   assert sel_types == {} or anon_type_is_wf(union_type(sel_types));
//   return if sel_types == {} then void_type else union_type(sel_types);
// }

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//## THIS IS TOTALLY UNTESTED. IT SHOULD BE TESTED WITH THE TYPE SUBSET TESTING CODE,
//## AND MAYBE IT WOULD BE GOOD TO DO SOME MANUAL TESTING, ESPECIALLY FOR TUPLE TYPES
Bool type_contains_obj(AnonType type, Any obj):
  atom_type,        +           = true,
  atom_type,        _           = false,

  symb_type(s?),    _           = obj == s,

  integer,          *           = true,
  integer,          _           = false,

  low_ints(),       *           = obj <= type.max,
  low_ints(),       _           = false,

  high_ints(),      *           = obj >= type.min,
  high_ints(),      _           = false,

  int_range(),      *           = obj >= type.min and obj <= max(type),
  int_range(),      _           = false,

  float_type,       ^           = true,
  float_type,       _           = false,

  type_var(),       _           = {fail;},

  empty_seq_type,   _           = obj == [],
  empty_set_type,   _           = obj == {},
  empty_map_type,   _           = obj == (),

  ne_seq_type(),    [...]       = obj /= [] and all([type_contains_obj(type.elem_type, e) : e <- obj]),
  ne_seq_type(),    _           = false,

  ne_set_type(),    {...}       = obj /= {} and not (? e <- obj : not type_contains_obj(type.elem_type, e)),
  ne_set_type(),    _           = false,

  ne_map_type(),    (...)       = obj /= () and not (? k => v <- obj : not type_contains_obj(type.key_type, k) or not type_contains_obj(type.value_type, v)),
  ne_map_type(),    _           = false,

  record_type(fs?), (...)       = not (? k => v <- obj : not has_key(fs, k) or not type_contains_obj(fs[k].type, v)) and
                                  subset({l : l => f <- fs, not f.optional}, keys(obj)),
  record_type(fs?), _           = false,

  tuple_type(ts?),  [...]       = length(ts) == length(obj) and all([type_contains_obj(t, e) : t, e <- zip(ts, obj)]),
  tuple_type(ts?),  _           = false,

  tag_obj_type(),   tag @ iobj  = type_contains_obj(type.tag_type, tag) and type_contains_obj(type.obj_type, iobj),
  tag_obj_type(),   _           = false,

  union_type(ts?),  _           = (? t <- ts : type_contains_obj(t, obj)),

  self_rec_type(),  _           = type_contains_obj(unfold(type), obj),
  mut_rec_type(),   _           = type_contains_obj(unfold(type), obj);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

FnType signature(FnDef fn_def, (TypeName => AnonType) typedefs) =
  fn_type(
    params:       [user_type_to_anon_type(p.type, typedefs=typedefs) : p <- fn_def.params],
    named_params: (n => user_type_to_anon_type(t, typedefs=typedefs) : n => t <- fn_def.named_params),
    ret_type:     user_type_to_anon_type(fn_def.res_type, typedefs=typedefs)
  );

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

FnType builtin_signature(BuiltIn):
  neg             = unary_int_op,
  add             = binary_int_op,
  sub             = binary_int_op,
  mult            = binary_int_op,
  div             = binary_int_op,
  mod             = binary_int_op,

  lt              = binary_int_pred,
  le              = binary_int_pred,
  gt              = binary_int_pred,
  ge              = binary_int_pred,

  str             = fn_type([atom_type],                          type_string),
  symb            = fn_type([type_string],                        atom_type),
  at              = fn_type([type_seq_t, integer],                type_var(:t)),
  len             = fn_type([type_seq],                           high_ints(0)),
  slice           = fn_type([type_seq_t, integer, integer],       type_seq_t),
  cat             = fn_type([type_seq_t, type_seq_t],             type_seq_t),
  mcat            = fn_type([type_seq(type_seq_t)],               type_seq_t),
  set             = fn_type([type_seq_t],                         type_set_t),
  rev             = fn_type([type_seq_t],                         type_seq_t),
  mset            = fn_type([type_seq_t],                         type_mset(type_var(:t))),
  isort           = fn_type([type_set_t],                         type_seq_t),
  list_to_seq     = fn_type([type_bare_list(type_var(:t))],       type_seq_t),

  tag             = fn_type([type_tagged_obj],                    atom_type), // The return type is too loose, and it is ignore in the code
  obj             = fn_type([type_tagged_obj],                    type_any),  // Ditto

  in              = fn_type([type_any, type_set],                 type_bool),
  has_key         = fn_type([type_map, type_any],                 type_bool),
  lookup          = fn_type([type_map_t1_t2, type_var(:t1)],      type_var(:t2)),
  union           = fn_type([type_set(type_set_t)],               type_set_t),
  merge           = fn_type([type_set(type_map_t1_t2)],           type_map_t1_t2),

  fneg            = unary_float_op,
  fadd            = binary_float_op,
  fsub            = binary_float_op,
  fmult           = binary_float_op,
  fdiv            = binary_float_op,
  fsqrt           = unary_float_op,
  // floor           = ,
  // ceiling         = ,
  float           = fn_type([integer],                            float_type),
  mantissa        = fn_type([float_type],                         integer),
  dec_exp         = fn_type([float_type],                         integer),

  rand_nat        = fn_type([type_nat],                           type_nat),
  rand_elem       = fn_type([type_set_t],                         type_var(:t)),
  counter         = fn_type([type_any],                           integer),

  ticks           = fn_type([type_any],                           integer);


FnType unary_int_op     = fn_type([integer], integer);
FnType binary_int_op    = fn_type([integer, integer], integer);
FnType binary_int_pred  = fn_type([integer, integer], type_bool);

FnType unary_float_op   = fn_type([float_type], float_type);
FnType binary_float_op  = fn_type([float_type, float_type], float_type);

AnonType type_seq_t     = type_seq(type_var(:t));
AnonType type_set_t     = type_set(type_var(:t));
AnonType type_map_t1_t2 = type_map(type_var(:t1), type_var(:t2));

AnonType type_bare_list(AnonType elem_type) =
  self_rec_type(
    union_type({
      empty_seq_type,
      tuple_type([elem_type, self])
    })
  );

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

AnonType type_bool = union_type({symb_type(true), symb_type(false)});

AnonType type_nat = high_ints(0);

AnonType type_seq = type_seq(type_any);
AnonType type_set = type_set(type_any);
AnonType type_map = type_map(type_any, type_any);

AnonType type_tagged_obj = tag_obj_type(atom_type, type_any);

AnonType type_seq(AnonType elem_type)  = union_type({empty_seq_type, ne_seq_type(elem_type)});
AnonType type_set(AnonType elem_type)  = union_type({empty_set_type, ne_set_type(elem_type)});
AnonType type_mset(AnonType elem_type) = union_type({empty_map_type, ne_map_type(elem_type, high_ints(1))});

AnonType type_tuple([2..*] size)  = tuple_type(size * [type_any]);

AnonType type_map(AnonType key_type, AnonType value_type)  = union_type({empty_map_type, ne_map_type(key_type, value_type)});

AnonType type_string = tag_obj_type(symb_type(:string), union_type({empty_seq_type, ne_seq_type(type_nat)}));

AnonType type_any =
  self_rec_type(
    union_type({
      atom_type,
      integer,
      float_type,
      empty_seq_type,
      empty_set_type,
      empty_map_type,
      ne_seq_type(self),
      ne_set_type(self),
      ne_map_type(self, self),
      tag_obj_type(atom_type, self)
    })
  );




Bool typechecks(Program prg)
{
  typedefs = prg.anon_tdefs;
  signatures = merge_values({(fd.name => signature(fd, typedefs)) : fd <- prg.fndefs});
  for (fd : rand_sort(prg.fndefs))
// if (to_c_fn_name(fd.name) /= "To_Text__Match_Idxs")
//## NON TYPECHECKING: Parse_Obj__Parse_Seq, Parse_Obj__Parse_Set, Parse_Obj__Parse_Map_Or_Record, Tokenize
// if (not in(to_c_fn_name(fd.name), {"To_Text__Match_Idxs"}))
// if (to_c_fn_name(fd.name) == "Parse_Obj__Parse_Obj")
    // print "Now doing function " & to_c_fn_name(fd.name);
    // print fd.params;
    if (not typechecks(fd, typedefs, signatures))
      // print "ERROR ERROR ERROR ERROR ERROR";
      // print "Function " & to_c_fn_name(fd.name) & " does not typecheck";
      // print fd.params;
      return false;
    // else
    //   print "Function " & to_c_fn_name(fd.name) & " typechecks";
    ;
// ;
  ;
  return true;
}


Bool typechecks(FnDef fn_def, (TypeName => AnonType) typedefs, (FnSymbol => FnType*) signatures)
{
  if (at_least_one([not p.type? : p <- fn_def.params]))
    print "Parameter type non provided";
    return true;
  ;

  if (not fn_def.res_type?)
    print "Return type not provided";
    return true;
  ;

  let (typedefs=typedefs, signatures=signatures, var_aliases=set([{fn_par(i), p.var} : p @ i <- fn_def.params, p.var?]), halt_on_failure_to_typecheck=false)
    scalar_vars = (p.var => user_type_to_anon_type(p.type) : p <- set(fn_def.params), p.var?, p.type :: UserType) &
                   (fn_par(i) => user_type_to_anon_type(fn_def.params[i].type) : i <- index_set(fn_def.params), fn_def.params[i].type :: UserType) &
                   (v => user_type_to_anon_type(t) : v => t <- fn_def.named_params, t :: UserType);

    assert scalar_vars :: (Var => AnonType);

    cls_vars = (p.var => user_type_to_anon_type(p.type) : p <- set(fn_def.params), p.var?, p.type :: UserClsType) &
                (v => user_type_to_anon_type(t) : v => t <- fn_def.named_params, t :: UserClsType);

    assert cls_vars :: (ClsVar => ClsType);

    // return typechecks(fn_def.expr, user_type_to_anon_type(fn_def.res_type), environment=scalar_vars, closures=cls_vars);
    //## THIS IS A TEMPORARY HACK TO WORK AROUND AN UNIMPLEMENTED FEATURE IN THE CODE GENERATION CODE
    res = typechecks(fn_def.expr, user_type_to_anon_type(fn_def.res_type), environment=scalar_vars, closures=cls_vars);
  ;
  return res;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using
{
  Bool                    halt_on_failure_to_typecheck, //## THIS IS A TEMPORARY HACK
  (TypeName => AnonType)  typedefs,
  (FnSymbol => FnType*)   signatures,   //## MAYBE HERE I SHOULD INCLUDE THE ARITY IN THE KEY. UPDATE: I DEFINITELY SHOULD
  (Var => AnonType)       environment,
  (ClsVar => ClsType)     closures,
  Var**                   var_aliases;

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  Bool typechecks(CondExpr expr, AnonType exp_type) = typechecks(expr.expr, exp_type) and typechecks(expr.cond, type_bool);

  //## THIS FUNCTION SHOULD BE NEXT TO ITS ONLY CALLER
  Bool typechecks((key: Expr, value: Expr, cond: Expr?) entry, AnonType exp_key_type, AnonType exp_value_type) =
    typechecks(entry.key, exp_key_type) and typechecks(entry.value, exp_value_type) and (not entry.cond? or typechecks(entry.cond. type_bool));

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  Bool typechecks(Expr expr, AnonType exp_type)
  {
    res = typechecks_impl(expr, exp_type);
if (not res and halt_on_failure_to_typecheck)
// if (not res)
  print "=============================================================";
  print expr;
  print exp_type;
  print environment;
  print expr_type(expr);
  print "= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =";
  // print environment[:var(:res)];
  fail;
;
    return res;
  }

  Bool typechecks_impl(Expr expr, AnonType exp_type):
    SymbObj               = is_subset(symb_type(expr), exp_type),
    object(Int n?)        = is_subset(int_range(min: n, size: 1), exp_type),

    set_expr(ses?)        = {
      return type_contains_obj(exp_type, {}) if ses == {};
      elem_type = set_elem_type(exp_type);
      return false if elem_type == void_type;
      return not (? se <- ses : not typechecks(se, elem_type));
    },

    // seq_expr([SubExpr])
    seq_expr(ses?)            = {
      return type_contains_obj(exp_type, []) if ses == [];
      exp_elem_type = seq_elem_type(exp_type);
      return false if exp_elem_type == void_type;
      return all([typechecks(es, exp_elem_type) : es <- ses]);
    },

    // seq_tail_expr(seq: Expr, tail: [Expr^]),
    seq_tail_expr() = {
      exp_elem_type = seq_elem_type(exp_type);
      return false if exp_elem_type == void_type;
      return typechecks(expr.seq, type_seq(exp_elem_type)) and
             all([typechecks(e, exp_elem_type) : e <- expr.tail]);
    },

    tuple_expr(es?) = {
      if (has_tuple_type(exp_type))
        types = tuple_field_types(exp_type);
        return length(es) == length(types) and all([typechecks(e, t) : e, t <- zip(es, types)]);
      else
        elem_type = seq_elem_type(exp_type);
        return exp_type /= void_type and all([typechecks(e, elem_type) : e <- es]);
      ;
    },

    //## TRY TO REWRITE THIS IN PROLOG-LIKE PSEUDOCODE
    map_expr(ses?) = {
      // If it's the empty map, we just check that the empty map is included in the expected type
      return type_contains_obj(exp_type, ()) if ses == {};
      // Inclusion conditions, if they exist, must typecheck as booleans
      return false if (? se <- ses : se.cond? and not typechecks(se.cond, type_bool));
      // The expected type could contain either a map or a record type (or none at all).
      // Here we check to see if there's a map type
      exp_key_type = map_key_type(exp_type);
      exp_value_type = map_value_type(exp_type);
      assert (exp_key_type == void_type) == (exp_value_type == void_type);
      if (exp_key_type /= void_type and exp_value_type /= void_type) // A DOUBLE CHECK SHOULD HELP THE TYPE CHECKER
        // If the expected type includes a map type, we go for that
        return not (? se <- ses : not typechecks(se.key, exp_key_type) or not typechecks(se.value, exp_value_type));
      ;
      // There wasn't a map type. Now we check to see if there is a record type
      exp_record_type = record_type(exp_type);
      // If there is no record type we are done, the expression does not typecheck
      return false if exp_record_type == void_type;
      fields = _obj_(exp_record_type);
      exp_labels = keys(fields);
      // Making sure that the resulting record will always have all the required fields
      return false if not subset({l : l => f <- fields, not f.optional}, {se.key : se <- ses, not se.cond?});
      // Checking that the keys are symbols, that they are among the expected labels
      // and that the corresponding types all typecheck to the respective types.
      //## IN THEORY WE SHOULD CHECK THAT ALL EXPRESSIONS EVALUATE TO A SYMBOL, BUT WOULD THAT BE ANY USEFUL?
      return not (? se <- ses : not (se.key :: SymbObj and in(se.key, exp_labels) and typechecks(se.value, fields[se.key].type)));
    },

    // tag_obj_expr(tag: Expr, obj: Expr),
    tag_obj_expr()        = {
      tag_types = tagged_obj_types(exp_type);
      //## BUG: WHAT HAPPENS IF THE TAG EXPRESSION HAS TWO POSSIBLE VALUES
      //## AND THERE ARE TWO EXPECTED TYPES?
      return (? t <- tag_types : typechecks(expr.tag, t.tag_type), typechecks(expr.obj, t.obj_type));
    },

    Var                   = is_subset(environment[expr], exp_type),

    fn_call()             = fn_call_typechecks(expr.name, expr.params, expr.named_params, exp_type),

    cls_call()            = typechecks(expr.params, closures[expr.name], exp_type),

    builtin_call()        = all([typechecks(p, type_any) : p <- expr.params])                 and
                            matches_signature(builtin_signature(expr.name), expr.params, ())  and
                            is_subset(expr_type(expr), exp_type),
    //   mtc_sgn = matches_signature(builtin_signature(expr.name), expr.params, ());
    //   ret_type_ok = is_subset(expr_type(expr), exp_type);
    //   if (not mtc_sgn or not ret_type_ok)
    //     print "--------------------";
    //     print mtc_sgn;
    //     print ret_type_ok;
    //     print builtin_signature(expr.name);
    //     print expr;
    //     print expr_type(expr);
    //     print exp_type;
    //     fail;
    //   ;
    //   return mtc_sgn and ret_type_ok;
    // },

    and_expr()            = is_subset(type_bool, exp_type) and typechecks(expr.left, type_bool) and typechecks(expr.right, type_bool),
    or_expr()             = is_subset(type_bool, exp_type) and typechecks(expr.left, type_bool) and typechecks(expr.right, type_bool),
    not_expr(e?)          = is_subset(type_bool, exp_type) and typechecks(e, type_bool),

    //## HERE I COULD ALSO CHECK THAT THE TYPES OF THE TWO EXPRESSIONS ARE NOT DISJOINT
    eq()                  = is_subset(type_bool, exp_type) and typechecks(expr.left, type_any) and typechecks(expr.right, type_any),

    membership()          = is_subset(type_bool, exp_type) and typechecks(expr.obj, type_any),

    cast_expr()           = typechecks(expr.expr, type_any), //## TODO: CHECK THAT THE TWO TYPES ARE NOT DISJOINT?

    accessor()            = {
      return false if not typechecks(expr.expr, type_any);
      types = split_type(expr_type(expr.expr));
      for (t : rand_sort(types)) //## UGLY UGLY
        if (t :: RecordType[AnonType])
          record_type = t;
        elif (t :: TagObjType[AnonType] and t.obj_type :: RecordType[AnonType])
          record_type = t.obj_type;
        else
          return false;
        ;
        field_type = mandatory_record_field_type(record_type, expr.field);
        return false if field_type == void_type or not is_subset(field_type, exp_type);
      ;
      return true;
    },

    accessor_test()       = {
      return false if not is_subset(type_bool, exp_type);
      type = expr_type(expr);
      return if type :: RecordType[AnonType] then record_has_field(type, expr.field),
                type :: MapType[AnonType]   then is_subset(symb_type(expr.field), type.key_type)
                                            else false;
    },

    if_expr()             = {
      return false if not typechecks(expr.cond, type_bool);
      if_true_env, if_false_env = refine_environment(expr.cond);
      return typechecks(expr.then, exp_type, environment=if_true_env) and
             typechecks(expr.else, exp_type, environment=if_false_env);
    },

    //## HERE I SHOULD ALSO CHECK THAT THE PATTERNS WILL EVENTUALLY COVER ALL THE POSSIBILITIES...
    match_expr()          = {
      return false if not all([typechecks(e, type_any) : e <- expr.exprs]);
      ts = [expr_type(e) : e <- expr.exprs];
      for (c : expr.cases)
        ps = c.ptrns;
        e  = c.expr;
        //## A ZIP FUNCTION WOULD BE NICE HERE (OR, EVEN BETTER, LIST COMPREHENSION AND FOR LOOP THAT CAN WORK ON MULTIPLE LISTS)
        assert length(ps) == length(ts);
        for (i < length(ts))
          return false if not may_match(ps[i], ts[i]);
        ;
        new_env = update_environment(expr.exprs, ps);
        return false if not typechecks(e, exp_type, environment=new_env);
      ;
      return true;
    },

    do_expr(ss?)          = typecheck(ss, exp_type),

    ex_qual()             = {
      return false if not typechecks(expr.source);
      new_env = update(environment, generated_environment(expr.source));
      return not expr.sel_expr? or typechecks(expr.sel_expr, type_bool, environment=new_env);
    },

    set_comp()            = {
      return false if not typechecks(expr.source);
      new_env = refine_environment(expr.source);
      return false if expr.sel_expr? and not typechecks(expr.sel_expr, type_bool, environment=new_env);
      exp_elem_type = set_elem_type(exp_type);
      return false if exp_elem_type == void_type;
      return typechecks(expr.expr, exp_elem_type, environment=new_env);
    },

    map_comp()            = {
      return false if not typechecks(expr.source);
      new_env = refine_environment(expr.source);
      return false if expr.sel_expr? and not typechecks(expr.sel_expr, type_bool, environment=new_env);
      exp_key_type = map_key_type(exp_type);
      exp_value_type = map_value_type(exp_type);
      return false if exp_key_type == void_type or exp_value_type == void_type;
      return typechecks(expr.key_expr, exp_key_type, environment=new_env) and
             typechecks(expr.value_expr, exp_value_type, environment=new_env);
    },

    seq_comp()            = if expr.src_expr_type == :sequence
                              then seq_comp_typechecks(
                                expr.expr,
                                expr.vars,
                                if expr.idx_var? then just(expr.idx_var) else nil,
                                expr.src_expr,
                                if expr.sel_expr? then just(expr.sel_expr) else nil,
                                exp_type
                              )
                              else int_range_seq_comp_typechecks(
                                expr.expr,
                                expr.vars[0],
                                expr.src_expr,
                                expr.src_expr_type.included,
                                if expr.sel_expr? then just(expr.sel_expr) else nil,
                                exp_type
                              );


  Bool fn_call_typechecks(FnSymbol name, [ExtExpr] params, (<named_par(Atom)> => ExtExpr) named_params, AnonType exp_type)
  {
    // First I check that all scalar positional parameters typecheck. This is something that
    // I need to do before trying to determine the functions this call may dispatch to.
    return false if not all([typechecks(p, type_any) : p <- params, p :: Expr]);

    //## BUG: FROM NOW ON IT'S ALL BROKEN, OF COURSE...

    candidate_signatures = {s : s <- signatures[name], length(params) == arity(s), will_dispatch_to(s, params)};
    return false if candidate_signatures == {};

    assert size(candidate_signatures) == 1;
    target_signature = only_element(candidate_signatures);

    // We first check that all scalar positional parameters (and those parameters only) match
    // the type of the corresponding formal parameter (we already know they typecheck)
    for (p, t : zip(params, target_signature.params))
      if (p :: Expr and t :: AnonType)
        return false if not matches(p, replace_type_vars_with_type_any(t));
      ;
    ;

    // Now we can instantiate the concrete type for type variables
    actual_types = [];
    formal_types = [];
    for (p, t : zip(params, target_signature.params))
      if (p :: Expr and t :: AnonType)
        actual_types = [actual_types | expr_type(p)];
        formal_types = [formal_types | t];
      ;
    ;
    type_var_insts = type_var_instantiations_for_subset(actual_types, formal_types);

    // With the type variables instantiated, we can "instantiate" the formal type
    // of the other parameters and verify the corresponding actual parameters typecheck

    // Let's start with positional closure parameters
    for (p, t : zip(params, target_signature.params))
      if (p :: ClsExpr and t :: ClsType)
        return false if not typechecks(p, replace_type_vars(t, type_var_insts));
      ;
    ;

    // Now named parameters
    for (n, t : rand_sort_pairs(target_signature.named_params))
      p = if has_key(named_params, n) then named_params[n],
             has_key(environment, n)  then environment[n]
                                      else closures[n];
      return false if not typechecks(p, replace_type_vars(t, type_var_insts));
    ;

    // The parameters all typechecks. Now let's see if the type of the result is OK.
    return is_subset(replace_type_vars(target_signature.ret_type, type_var_insts), exp_type);

    Bool matches(ExtExpr e, ExtType t):
      Expr,     AnonType  = is_subset(expr_type(e), t),
      ClsExpr,  ClsType   = {fail;};
  }

// type ClsExpr  = ClsVar,
//                 fn_ptr(name: FnSymbol, arity: NzNat),
//                 cls_expr(params: [<var(Atom), nil>^], expr: Expr);

  // Maybe[(TypeVar => AnonType)] check_that_expr_matches_and_adjust_type_var_assignments(ClsExpr expr, ClsType type, (TypeVar => AnonType) initial_assgnments):
  //   ClsVar      =
  //   fn_ptr()    =
  //   cls_expr()  =


  Bool seq_comp_typechecks(Expr expr, [Var^] vars, Maybe[Var] maybe_idx_var, Expr src_expr, Maybe[Expr] sel_expr, AnonType exp_type)
  {
    return false if not typechecks(src_expr, type_seq);
    src_type = expr_type(src_expr);
    assert is_subset(src_type, type_seq); //## WHY WAS IT LIKE THIS?: return false if not is_subset(src_type, type_seq);
    elem_type = seq_elem_type(src_type);
    assert elem_type /= void_type;
    env_delta = asgnm_env_updates(vars, elem_type) & (value(maybe_idx_var) => high_ints(0) if maybe_idx_var /= nil);
    new_env = update(environment, env_delta);
    exp_elem_type = seq_elem_type(exp_type);
    return false if exp_elem_type == void_type;
    return false if sel_expr /= nil and typechecks(value(sel_expr), type_bool, environment=new_env);
    return typechecks(expr, exp_elem_type, environment=new_env);
  }


  Bool int_range_seq_comp_typechecks(Expr expr, Var var, Expr upper_bound_expr, Bool includes_upper_bound, Maybe[Expr] maybe_sel_expr, AnonType exp_type)
  {
    return false if not typechecks(upper_bound_expr, integer);
    new_env = update(environment, (var => type_nat)); //## BAD: HERE WE COULD TAKE ADVANTAGE OF THE KNOWLEDGE ON THE TYPE OF THE UPPER BOUND
    return false if maybe_sel_expr /= nil and typechecks(value(maybe_sel_expr), type_bool, environment=new_env);
    return false if not type_contains_obj(exp_type, []); //## BAD: HERE TOO WE COULD TAKE ADVANTAGE OF THE INFORMATION WE HAVE ABOUT THE UPPER BOUND TYPE
    exp_elem_type = seq_elem_type(exp_type);
    return false if exp_elem_type == void_type;
    return typechecks(expr, exp_elem_type, environment=new_env);
  }


  Bool typechecks(ClsExpr expr, ClsType exp_type):
    ClsVar = {
      var_type = closures[expr];
      return is_subset(var_type, exp_type);
    },
    fn_ptr() = {
      sgns = {s : s <- signatures[expr.name], expr.arity == arity(s)};
      assert size(sgns) == 1;
      sgn = only_element(sgns);
      assert sgn.named_params == ();
      assert not (? p <- sgn.params : not p :: AnonType);
      sgn_cls = cls_type(sgn.params, sgn.ret_type);
      return is_subset(sgn_cls, exp_type);
    },
    cls_expr() = {
      assert all([p == nil : p <- exp_type.params]); //## FOR NOW ALL VARIABLES SHOULD BE ANONYMOUS...
      delta_env = merge([(fn_par(i) => t, v => t if v /= nil) : v, t @ i <- zip(expr.params, exp_type.in_types)]);
      new_env = environment & delta_env;
      return typechecks(expr.expr, exp_type.out_type, environment=new_env);
    };


// type ClsType  = cls_type(in_types: [AnonType^], out_type: AnonType);

// type FnType   = fn_type(
//                   params:       [ExtType],
//                   named_params: (<named_par(Atom)> => ExtType),
//                   ret_type:     AnonType
//                 );


//   (FnSymbol => FnType*)   signatures,   //## MAYBE HERE I SHOULD INCLUDE THE ARITY IN THE KEY. UPDATE: I DEFINITELY SHOULD
//   (Var => AnonType)       environment,
//   (ClsVar => ClsType)     closures,

// type ClsExpr  = ClsVar,
//                 fn_ptr(name: FnSymbol, arity: NzNat),
//                 cls_expr(params: [<var(Atom), nil>^], expr: Expr);


  // Bool typechecks(ClsExpr expr, UserClsType exp_type)
  // {
  //   assert length(expr.params) == length(exp_type.in_types);

  //   idxs = index_set(expr.params);
  //   ps = expr.params;
  //   ts = exp_type.in_types;
  //   env_override = (fn_par(i) => ts[i] : i <- idxs) & (p => ts[i] : i <- idxs, p = ps[i], p /= nil);
  //   new_env = update(environment, env_override);

  //   return typechecks(expr.expr, exp_type.out_type);
  // }


  Bool typechecks([Expr] params, ClsType signature, AnonType exp_type)
  {
    assert length(params) == length(signature.in_types);

    for (e, t : zip(params, signature.in_types))
      return false if not typechecks(e, replace_type_vars_with_type_any(t));
    ;

    return is_subset(cls_call_type(signature, [expr_type(p) : p <- params]), exp_type);
  }


  Bool typechecks(Clause clause, Expr sel_expr)
  {
    return false if not typechecks(clause);
    new_env = update(environment, generated_environment(clause));
    return typechecks(sel_expr, type_bool);
  }


  Bool typechecks(Clause clause):
    in_clause()           = typechecks(clause.src, type_set),
    map_in_clause()       = typechecks(clause.src, type_map),
    and_clause()          = typechecks(clause.left) and typechecks(clause.right, environment=update(environment, generated_environment(clause.left))),
    or_clause()           = typechecks(clause.left) and typechecks(clause.right);




  Bool typecheck([Statement] stmts, AnonType exp_type)
  {
    res = typecheck_impl(stmts, exp_type);
// if (not res and halt_on_failure_to_typecheck)
//   print "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@";
//   print stmts;
// ;
    return res;
  }

  Bool typecheck_impl([Statement] stmts, AnonType exp_type)
  {
// print "*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*";
    env = environment;
// print env;
    for (s : stmts)
      if (not typechecks(s, exp_type, environment=env))
        print "FAILURE!";
        print s;
        print exp_type;
        print env;
      ;
      // return false if not typechecks(s, exp_type, environment=env);
      env = update_environment(s, environment=env);
// print env;
    ;
// print "___________________________________________";
    return true;
  }

  Bool typechecks(Statement stmt, AnonType exp_type)
  {
    res = typechecks_impl(stmt, exp_type);

if (not res and halt_on_failure_to_typecheck)
  print "******************************";
  print stmt;
  fail;
;
    return res;
  }

  Bool typechecks_impl(Statement stmt, AnonType exp_type):
    assignment_stmt()   = typechecks(stmt.value, type_any),
    // return_stmt(e?)     = typechecks(e, exp_type),
    return_stmt(e?)     = {
      if (not typechecks(e, exp_type))
        print e;
        print environment;
        print exp_type;
        fail;
      ;
      return typechecks(e, exp_type);
    },
    if_stmt()           = {
      return false if not typechecks(stmt.cond, type_bool);
      if_true_env, if_false_env = refine_environment(stmt.cond);
      return typecheck(stmt.body, exp_type, environment=if_true_env) and typecheck(stmt.else, exp_type, environment=if_false_env);
    },
    loop_stmt(ss?)      = {
      env = environment;
      for (5) //## BAD: THIS IS A TOTALLY ARBITRARY NUMBER...
        return false if not typecheck(ss, exp_type, environment=env);
        new_env = update_environment(ss, environment=env);
        return true if env == new_env;
        env = new_env;
      ;
      print "Five iterations of the loop where not enought to stabilize the environment";
      return false;
// print "LOOP STATEMENT #1";
// print environment;
//       return false if not typecheck(ss, exp_type);
// print "LOOP STATEMENT #2";
//       env_1 = update_environment(ss);
// print "LOOP STATEMENT #3";
// print env_1;
//       return false if not typecheck(ss, exp_type, environment=env_1);
// print "LOOP STATEMENT #4";
//       env_2 = update_environment(ss, environment=env_1);
// print "LOOP STATEMENT #5";
// print env_2;
//       return env_1 == env_2;
    },
    foreach_stmt()      = { //## BUG: THE OBJECT HAS BEEN UPDATED: .var (Var) => .vars ([Var^])
      return false if not typechecks(stmt.values, type_seq);
      elem_type = seq_elem_type(expr_type(stmt.values));
      return false if elem_type == void_type;
      num_vars = length(stmt.vars);
      if (num_vars == 1)
        loop_vars = (stmt.vars[0] => elem_type, stmt.idx_var => type_nat if stmt.idx_var?);
      else
        return false if not is_subset(elem_type, type_tuple(num_vars));
        field_types = tuple_field_types(elem_type);
        loop_vars = merge(set([(v => t) : v, t <- zip(stmt.vars, field_types)]));
      ;
      env_0 = update(environment, loop_vars);
      return false if not typecheck(stmt.body, exp_type, environment=env_0);
      env_1 = update_environment(stmt.body, environment=env_0);
      return false if not typecheck(stmt.body, exp_type, environment=env_1);
      env_2 = update_environment(stmt.body, environment=env_1);
      return env_1 == env_2;
    },
    // for_stmt(var: Var?, start_val: Expr, end_val: Expr, end_val_incl: Bool, body: [Statement^]),
// type IntType        = integer, low_ints(max: Int), high_ints(min: Int), int_range(min: Int, size: NzNat);
    //## BUG: THIS IS ALL WRONG
    for_stmt() = {
      return false if not typechecks(stmt.start_val, integer) or not typechecks(stmt.end_val, integer);
      if (stmt.var?)
        start_val_type = expr_type(stmt.start_val);
        end_val_type = expr_type(stmt.end_val);
        env_delta = (stmt.var => loop_var_type(start_val_type, end_val_type, stmt.end_val_incl));
      else
        env_delta = ();
      ;
      return typecheck(stmt.body, exp_type, environment=environment & env_delta);
    },
    let_stmt()          = {
      return false if (? v => e <- stmt.asgnms : not typechecks(e, type_any));
      env_delta = (v => expr_type(e) : v => e <- stmt.asgnms);
      new_env = update(environment, env_delta);
      return typecheck(stmt.body, exp_type, environment=new_env); //## BUG BUG BUG
    },
    break_stmt          = true,
    fail_stmt           = true,
    assert_stmt(e?)     = typechecks(e, type_bool),
    print_stmt(e?)      = typechecks(e, type_any);


  //## THIS IS ALL A TEMPORARY HACK TO WORK AROUND AN UNFINISHED FEATURE IN CODE GENERATION
  Bool matches_signature(FnType signature, [ExtExpr] params, (<named_par(Atom)> => ExtExpr) named_params) =
    matches_signature_impl(signature, params, named_params, halt_on_failure_to_typecheck=false);

  Bool matches_signature_impl(FnType signature, [ExtExpr] params, (<named_par(Atom)> => ExtExpr) named_params)
  {
    // let (halt_on_failure_to_typecheck=false)
      return false if length(params) /= length(signature.params);
      for (e, t : zip(params, signature.params))
        return false if not is_subset(expr_type(e), replace_type_vars_with_type_any(t));
      ;

      for (p : rand_sort(keys(signature.named_params))) //## WOULD BE GOOD TO USE A ZIP (BY KEY) FUNCION HERE
        formal_type = signature.named_params[p];
        if (formal_type :: AnonType)
          formal_type = replace_type_vars_with_type_any(formal_type);
          if (has_key(named_params, p))
            expr = named_params[p];
            assert expr :: Expr;
            return false if not is_subset(expr_type(expr), formal_type);
          else
            actual_type = environment[p];
            assert actual_type :: AnonType;
            return false if not is_subset(actual_type, formal_type);
          ;
        else
          assert formal_type :: ClsType;
          if (has_key(named_params, p))
            cls_expr = named_params[p];
            assert cls_expr :: ClsExpr;
            return false if not is_subset(expr_type(cls_expr), formal_type);
          else
            actual_type = closures[p];
            assert actual_type :: ClsType;
            return false if not is_subset(actual_type, formal_type);
          ;
        ;
      ;
    // ;
    return true;
  }
}





AnonType loop_var_type(AnonType lower_bound_type, AnonType upper_bound_type, Bool upper_bound_included)
{
  upper_bound_adj = bit(not upper_bound_included);

  // lower_bound = match (lower_bound_type)
  //   integer     = nil,
  //   low_ints()  = nil,
  //   high_ints() = just(lower_bound_type.min),
  //   int_range() = just(lower_bound_type.min);
  // ;

  // upper_bound = match (upper_bound_type)
  //   integer     = nil,
  //   low_ints()  = upper_bound_type.max,
  //   high_ints() = nil,
  //   int_range() = max(upper_bound_type);
  // ;

  dummy_int_range = int_range(1, 1); // BUG BUG BUG: HERE I SHOULD BE USING THE VOID TYPE...

  loop_var_type = match (lower_bound_type, upper_bound_type)
    integer,      integer       = integer,
    integer,      low_ints()    = low_ints(upper_bound_type.max - upper_bound_adj),
    integer,      high_ints()   = integer,
    integer,      int_range()   = low_ints(max(upper_bound_type) - upper_bound_adj),
    low_ints(),   integer       = integer,
    low_ints(),   low_ints()    = low_ints(upper_bound_type.max - upper_bound_adj),
    low_ints(),   high_ints()   = integer,
    low_ints(),   int_range()   = low_ints(max(upper_bound_type) - upper_bound_adj),
    high_ints(),  integer       = lower_bound_type,
    high_ints(),  low_ints()    = { min = lower_bound_type.min;
                                    max = upper_bound_type.max - upper_bound_adj;
                                    return if min <= max then int_range(min, max) else dummy_int_range;
                                  },
    high_ints(),  high_ints()   = lower_bound_type,
    high_ints(),  int_range()   = { min = lower_bound_type.min;
                                    max = max(upper_bound_type) - upper_bound_adj;
                                    return if min <= max then int_range(min, max) else dummy_int_range;
                                  },
    int_range(),  integer       = high_ints(lower_bound_type.min),
    int_range(),  low_ints()    = { min = lower_bound_type.min;
                                    max = upper_bound_type.max - upper_bound_adj;
                                    return if min <= max then int_range(min, max) else dummy_int_range;
                                  },
    int_range(),  high_ints()   = high_ints(lower_bound_type.min),
    int_range(),  int_range()   = { min = lower_bound_type.min;
                                    max = max(upper_bound_type) - upper_bound_adj;
                                    return if min <= max then int_range(min, max) else dummy_int_range;
                                  };
  ;

  return loop_var_type;
}

// Exported functions:
//   Bool is_subset(AnonType t1, AnonType t2);
//   (TypeVar => AnonType*) subset_conds(AnonType t1, AnonType t2);



Bool is_subset(AnonType t1, AnonType t2) = is_subset_if(t1, t2, inst_type_vars=false) == {};

(TypeVar => AnonType*) subset_conds(AnonType t1, AnonType t2)
{
  cs = is_subset_if(t1, t2, inst_type_vars=true);
  assert cs :: <<subset_when(type_var: TypeVar, inst_type: AnonType)>*>;
  return merge_values({(c.type_var => c.inst_type) : c <- cs});
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

type IsSubset = not_a_subset, <subset_if(subset: SelfPretype, superset: AnonType), subset_when(type_var: TypeVar, inst_type: AnonType)>*;

IsSubset not_a_subset = :not_a_subset;
IsSubset subset_if(SelfPretype self, AnonType type) = {subset_if(subset: self, superset: type)};
IsSubset subset_when(TypeVar var, AnonType type)    = {subset_when(type_var: var, inst_type: type)};

IsSubset all_conds(IsSubset* iss) = if in(not_a_subset, iss) then not_a_subset else union(iss);

IsSubset at_least_one_cond(IsSubset *iss)
{
  red_iss = iss - {not_a_subset};
  assert size(red_iss) <= 1;
  return if red_iss == {} then not_a_subset else only_element(red_iss);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

using Bool inst_type_vars
{
  IsSubset is_self_rec_subset_if(SelfRecType[AnonType] t1, AnonType t2)
  {
    tested_supertypes   = {};
    untested_supertypes = {t2};
    type_var_conds = {};

    loop
      // Trying all the untested supertypes and merging all conditions
      new_hypotheses = all_conds({is_subset_if(inner_pretype(t1), t) : t <- untested_supertypes});

      // If at least one of the types cannot possibly be a supertype, then we are done
      return not_a_subset if new_hypotheses == not_a_subset;

      // Separating hypotheses about recursion from the ones about type variables
      new_rec_hypotheses = {h : subset_if() h <- new_hypotheses};
      new_var_hypotheses = {h : subset_when() h <- new_hypotheses};

      assert new_hypotheses == new_rec_hypotheses & new_var_hypotheses;
      assert not (? h <- new_rec_hypotheses : h.subset /= self);

      // Generating the next round of candidate supertypes to test
      tested_supertypes = tested_supertypes & untested_supertypes;
      untested_supertypes = {h.superset : h <- new_rec_hypotheses} - tested_supertypes;

      // Adding the new hypotheses about type variables to the previous ones
      type_var_conds = type_var_conds & new_var_hypotheses;

      // If there are no new candidate supertypes to test, we just return the constraints on the type variable
      return type_var_conds if untested_supertypes == {};
    ;
  }


  IsSubset is_mut_rec_subset_if(MutRecType[AnonType] t1, AnonType t2)
  {
    tested_hypotheses = {};
    untested_hypotheses = {(t1, t2)};
    type_var_conds = {};

    loop
      new_untested_hypotheses = {};

      for (subtype, supertype : rand_sort(untested_hypotheses))
        // Trying all the untested supertypes and merging all conditions
        new_conds = is_subset_if(inner_pretype(subtype), supertype);

        // If at least one of the types cannot possibly be a supertype, then we are done
        return not_a_subset if new_conds == not_a_subset;

        // Separating constraints about recursion from the ones about type variables
        new_rec_conds = {h : subset_if() h <- new_conds};
        new_var_conds = {h : subset_when() h <- new_conds};

        assert new_conds == new_rec_conds & new_var_conds;

        // Generating the next round of candidate supertypes to test
        new_untested_hypotheses = new_untested_hypotheses & {(expand_rec_ref(c.subset, subtype), c.superset) : c <- new_rec_conds};

        // Adding the new hypotheses about type variables to the previous ones
        type_var_conds = type_var_conds & new_var_conds;
      ;

      // Removing the hypotheses that have already been tested
      new_untested_hypotheses = new_untested_hypotheses - tested_hypotheses;

      // If there are no new candidate supertypes to test, we just return the constraints on the type variable
      return type_var_conds if new_untested_hypotheses == {};

      // Generating the next round of candidate supertypes to test
      tested_hypotheses = tested_hypotheses & untested_hypotheses;
      untested_hypotheses = new_untested_hypotheses;
    ;

    MutRecType[AnonType] expand_rec_ref(SelfPretype ref, MutRecType[AnonType] type):
      self(n?)  = mut_rec_type(n, type.types);
  }


  IsSubset is_subset_if(AnonType t1, AnonType t2):
    // Type vars only match themselves or type any
    // _,                    type_var()          = if inst_type_vars then subset_when(t2, t1) else if t1 == t2 then {} else not_a_subset end end,
    _,                    type_var()          = if inst_type_vars then subset_when(t2, t1), t1 == t2 then {} else not_a_subset,

    type_var(),           _                   = if is_type_any(t2) then {} else not_a_subset,

    // Dealing with all the recursive stuff
    SelfPretype,          _                   = subset_if(t1, t2),
    _,                    SelfPretype         = {fail;},

    self_rec_type(),      _                   = is_self_rec_subset_if(t1, t2),
    _,                    self_rec_type()     = is_subset_if(t1, unfold(t2)),

    mut_rec_type(),       _                   = is_mut_rec_subset_if(t1, t2),
    _,                    mut_rec_type()      = is_subset_if(t1, unfold(t2)),

    // Type unions now
    union_type(ts1?),     _                   = all_conds({is_subset_if(t, t2) : t <- ts1}),
    _,                    union_type(ts2?)    = at_least_one_cond({is_subset_if(t1, t) : t <- ts2}),   //## INEFFICIENT

    // Leaf types
    symb_type(),          _                   = if t1 == t2 or t2 == atom_type then {} else not_a_subset,
    atom_type,            _                   = if t1 == t2 then {} else not_a_subset,
    IntType,              IntType             = if is_integer_subset(t1, t2) then {} else not_a_subset,
    IntType,              _                   = not_a_subset,
    float_type,           _                   = if t1 == t2 then {} else not_a_subset,

    // Sequence types
    empty_seq_type,       empty_seq_type      = {},
    empty_seq_type,       _                   = not_a_subset,

    ne_seq_type(),        ne_seq_type()       = is_subset_if(t1.elem_type, t2.elem_type),
    ne_seq_type(),        _                   = not_a_subset,

    // Set types
    empty_set_type,       empty_set_type      = {},
    empty_set_type,       _                   = not_a_subset,

    ne_set_type(),        ne_set_type()       = is_subset_if(t1.elem_type, t2.elem_type),
    ne_set_type(),           _                = not_a_subset,

    // Map types
    empty_map_type,       empty_map_type      = {},
    empty_map_type,       record_type(fs?)    = if not (? l => f <- fs : not f.optional) then {} else not_a_subset,
    empty_map_type,       _                   = not_a_subset,

    ne_map_type(),        ne_map_type()       = all_conds({is_subset_if(t1.key_type, t2.key_type), is_subset_if(t1.value_type, t2.value_type)}),
    ne_map_type(),        record_type(fs?)    = is_ne_map_record_subset_if(t1.key_type, t1.value_type, fs),
    ne_map_type(),        _                   = not_a_subset,

    // Record types
    record_type(fs1?),    record_type(fs2?)   = is_record_subset_if(fs1, fs2),
    record_type(fs?),     ne_map_type()       = is_record_map_subset_if(fs, t2),
    record_type(),        _                   = not_a_subset,

    // Tuple types
    tuple_type(fts1?),    tuple_type(fts2?)   = if length(fts1) == length(fts2)
                                                  then all_conds(set([is_subset_if(ft1, ft2) : ft1, ft2 <- zip(fts1, fts2)]))
                                                  else not_a_subset,
    tuple_type(fts?),     ne_seq_type()       = all_conds({is_subset_if(ft, t2.elem_type) : ft <- set(fts)}),
    tuple_type(),         _                   = not_a_subset,

    // Tagged types
    tag_obj_type(),       tag_obj_type()      = all_conds({is_subset_if(t1.tag_type, t2.tag_type), is_subset_if(t1.obj_type, t2.obj_type)}),
    tag_obj_type(),       _                   = not_a_subset;


  IsSubset is_record_subset_if((SymbObj => (type: AnonType, optional: Bool)) fs1, (SymbObj => (type: AnonType, optional: Bool)) fs2)
  {
    labels_1 = keys(fs1);
    labels_2 = keys(fs2);
    mandatory_labels_1 = {l : l => f <- fs1, not f.optional};
    mandatory_labels_2 = {l : l => f <- fs2, not f.optional};
    optional_labels_1  = labels_1 - mandatory_labels_1;
    optional_labels_2  = labels_2 - mandatory_labels_2;

    // Mandatory labels in the subtype must be present in the supertype (can be either mandatory or optional)
    return not_a_subset if not subset(mandatory_labels_1, mandatory_labels_2 & optional_labels_2);

    // Optional labels in the subtype must be optional in the supertype as well
    return not_a_subset if not subset(optional_labels_1, optional_labels_2);

    // Mandatory labels in the supertype must be mandatory in the subtype as well
    return not_a_subset if not subset(mandatory_labels_2, mandatory_labels_1);

    // No particular requirement for optional labels in the supertype

    label_type_map_1 = (l => f.type : l => f <- fs1);
    label_type_map_2 = (l => f.type : l => f <- fs2);

    return all_conds({is_subset_if(label_type_map_1[l], label_type_map_2[l]) : l <- labels_1});
  }


  IsSubset is_record_map_subset_if((SymbObj => (type: AnonType, optional: Bool)) record_fields, MapType[AnonType] map_type) =
    all_conds(
      for (l => f <- record_fields) {
        all_conds(
          { is_subset_if(symb_type(l), map_type.key_type),
            is_subset_if(f.type, map_type.value_type)
          }
        )
      }
    );


  IsSubset is_ne_map_record_subset_if(AnonType key_type, AnonType value_type, (SymbObj => (type: T, optional: Bool)) record_fields)
  {
    return not_a_subset if not is_subset(key_type, union_type({symb_type(l) : l => _ <- record_fields}));

    if (key_type :: SymbType)
      only_key_obj = _obj_(key_type);
      return not_a_subset if (? l => f <- record_fields : l /= only_key_obj, not f.optional);
    else
      return not_a_subset if (? _ => f <- record_fields : not f.optional);
    ;

    return all_conds({is_subset_if(key_type, f.type) : l => f <- record_fields, includes_symbol(key_type, l)});
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool is_integer_subset(IntType t1, IntType t2):
  _,            integer     = true,
  integer,      _           = false,

  high_ints(),  high_ints() = t1.min >= t2.min,
  high_ints(),  _           = false,

  low_ints(),   low_ints()  = t1.max <= t2.max,
  low_ints(),   _           = false,

  int_range(),  int_range() = t1.min >= t2.min and max(t1) <= max(t2),
  int_range(),  high_ints() = t1.min >= t2.min,
  int_range(),  low_ints()  = max(t1) <= t2.max;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool is_type_any(AnonType type) = is_subset(type_any, type);

Bool includes_symbol(AnonType type, SymbObj symb) = is_subset(symb_type(symb), type);

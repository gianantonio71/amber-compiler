## BUG: I ALSO HAVE TO CHECK THAT FOR ALL FUNCTIONS WITH THE SAME
## NAME AND ARITY ALL IMPLICIT PARAMETERS HAVE THE SAME TYPE, AND
## THAT ALL CLOSURE PARAMETERS HAVE EXACTLY THE SAME TYPE.

type EnvVar   = StdVar, FnPar, ImplArg, AutoMembVar;
type LocVar2  = StdVar, FnPar;


[<Function, Database, Method, Update, Handler, Automaton> -> [+TypeCheckingError]] typecheck(Program prg) {
  let program = prg, typedefs = prg.typedefs:
    fn_errs = [fd -> es : fd <- prg.fndefs, es = typecheck_function(fd), es != []];
    db_errs = merge([typecheck_database(db) : db <- prg.data_bases]);
    ra_errs = merge([typecheck_automaton(auto) : auto <- prg.auto_defs]);
  ;
  return fn_errs & db_errs & ra_errs;
}


implicit program : Program, typedefs : [TypeName -> NeType] {
  [TypeCheckingError] typecheck_function(Function func) {
    args = func.args;
    var_aliases = [[fn_par(i), a.var] : a @ i <~ args, a :: FormalObjArg and a.var?];
    obj_vars = [a.var -> a.type : a <~ args, formal_obj_arg() ?= a, a.var?] &
               [fn_par(i) -> a.type : a @ i <~ args, formal_obj_arg() ?= a] &
               [v -> t : v, t <- func.impl_args];
    let context=func, var_aliases=var_aliases, typed_vars = []:
      errs = typecheck(func.expr, func.res_type, obj_vars);
    ;
    return errs;
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit program : Program, typedefs : [TypeName -> NeType], context : Context, var_aliases : [[LocVar2]], typed_vars : [StdVar -> NeType] {
  [TypeCheckingError] typecheck(CondExpr expr, Type exp_type, [EnvVar -> Type] env) {
    errs = typecheck(expr.cond, type_bool, env);
    return errs if errs != [];
    new_env = left(refine_env(expr.cond, env));
    return typecheck(expr.expr, exp_type, new_env);
  }

  //////////////////////////////////////////////////////////////////////////////

  [TypeCheckingError] typecheck(ClsVar expr, Type+ arg_types, Type ret_type, [EnvVar -> Type] env) {
    var_type = closures[expr];
    is_subtype = is_fn_subtype(var_type.in_types, var_type.out_type, arg_types, ret_type);
    return [invalid_cls_param_type(var_type, arg_types, ret_type) if not is_subtype];
  }


  [TypeCheckingError] typecheck(FnPtr expr, Type+ arg_types, Type ret_type, [EnvVar -> Type] env) {
    sgn_set = signatures[(expr.name, expr.arity)];
    sgns = sgn_set.sgns;
    assert |sgns| == 1;
    sgn = only(sgns);
    assert sgn.impl_args == []; ## BUG BUG BUG: THIS IS NOT CHECKED IN THE WELL-FORMEDNESS CHECKING LAYER
    assert not (a <~ sgn.args : not a :: NeType);
    sgn_cls = cls_type(cast_type_ne_seq(sgn.args), sgn.ret_type);
    is_subtype = is_fn_subtype(sgn_cls.in_types, sgn_cls.out_type, arg_types, ret_type);
    return [invalid_cls_param_type(sgn_cls, arg_types, ret_type) if not is_subtype];
  }


  [TypeCheckingError] typecheck(ClsExpr expr, Type+ arg_types, Type ret_type, [EnvVar -> Type] env) {
    delta_env = merge(([fn_par(i) -> t, value(v) -> t if v != nothing] : v, t @ i <- zip(expr.args, arg_types)));
    new_env = update(env, delta_env);
    return typecheck(expr.expr, ret_type, new_env); ## BAD: HERE I SHOULD PROVIDE MORE INFORMATION
  }

  //////////////////////////////////////////////////////////////////////////////

  [TypeCheckingError] typecheck(Clause cls, [EnvVar -> Type] env) {
    errs = typecheck_without_annotations(cls, env);
    return [add_anchor_if_needed(e, cls) : e <- errs];


    [TypeCheckingError] typecheck_without_annotations(Clause cls, [EnvVar -> Type] env) =
      set_clause()      = typecheck(cls.src, type_set, env),
      rel_clause()      = typecheck_rel_clause(cls.vars, cls.src, cls.args, env),
      relvar_clause()   = typecheck_relvar_clause(cls.vars, cls.rel_var, cls.args, env),
      seq_clause()      = typecheck(cls.src, type_seq, env),
      and_clause()      = typecheck_and_clause(cls.left, cls.right, env),
      or_clause()       = typecheck(cls.left, env) & typecheck(cls.right, env),
      match_clause()    = typecheck_match_clause(cls.ptrn, cls.expr, env),
      asgnm_clause()    = typecheck(cls.expr, type_any, env),
      filter_clause(e?) = typecheck(e, type_bool, env);
  }


  [TypeCheckingError] typecheck_rel_clause(StdVar+ vars, Expr src, Maybe[Expr]+ args, [EnvVar -> Type] env) {
    assert |vars| == count(args, $ == nothing);

    return match (args)
      (a1?, a2?)      = typecheck_bin_rel_clause(src, args, env),
      (a1?, a2?, a3?) = typecheck_tern_rel_clause(src, args, env);


    [TypeCheckingError] typecheck_bin_rel_clause(Expr src, (Maybe[Expr], Maybe[Expr]) args, [EnvVar -> Type] env) {
      errs = typecheck(src, type_bin_rel, env);
      return errs if errs != [];
      args_types = bin_rel_args_supertypes(expr_type(src, env));
      return seq_union((if a != nothing then typecheck(value(a), t, env) else [] : a, t <- zip(args, args_types)));
    }


    [TypeCheckingError] typecheck_tern_rel_clause(Expr src, (Maybe[Expr], Maybe[Expr], Maybe[Expr]) args, [EnvVar -> Type] env) {
      errs = typecheck(src, type_tern_rel, env);
      return errs if errs != [];
      args_types = tern_rel_args_supertypes(expr_type(src, env));
      return seq_union((if a != nothing then typecheck(value(a), t, env) else [] : a, t <- zip(args, args_types)));
    }
  }


  [TypeCheckingError] typecheck_relvar_clause(StdVar+ vars, AnyRelVar rel_var, Maybe[Expr]+ args, [EnvVar -> Type] env) {
    assert |vars| == count(args, $ == nothing);

    errs = seq_union((typecheck(value(a), type_any, env) : a <- args, a != nothing));
    return errs if errs != [];

    rv_sgns = relvar_signatures(rel_var);
    assert not (s <- rv_sgns : |s| != |args|); ## THIS SHOULD NOT BE AN ASSERTION, BUT A REGULAR WELL-FORMEDNESS CHECK

    return [];
  }


  [TypeCheckingError] typecheck_and_clause(Clause left, Clause right, [EnvVar -> Type] env) {
    errs = typecheck(left, env);
    return errs if errs != [];
    new_env = generate_env(left, env);
    return typecheck(right, new_env);
  }


  [TypeCheckingError] typecheck_match_clause(Pattern ptrn, Expr source, [EnvVar -> Type] env) {
    errs = typecheck(source, type_any, env);
    return errs if errs != [];
    type = expr_type(source, env);
    return [ptrn_cannot_match_type(ptrn, type) if type != empty_type and not may_match(ptrn, type)];
  }
}

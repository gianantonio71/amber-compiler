//## BUG: I ALSO HAVE TO CHECK THAT FOR ALL FUNCTIONS WITH THE SAME
//## NAME AND ARITY ALL IMPLICIT PARAMETERS HAVE THE SAME TYPE, AND
//## THAT ALL CLOSURE PARAMETERS HAVE EXACTLY THE SAME TYPE.


[Function -> [+TypeCheckingError]] typecheck(Program prg)
{
  typedefs = prg.typedefs;
  signatures = merge_values([[(family_id(fd.name), arity(fd)) -> signature(fd)] : fd <- prg.fndefs]);
  sgn_sets = [n -> preprocess_signatures(ss, typedefs) : n, ss <- signatures];
  let typedefs = typedefs, signatures = sgn_sets:
    errors = [fd -> typecheck_function(fd) : fd <- prg.fndefs];
  ;
  return [fd -> es : fd, es <- errors; es != []];
}


implicit typedefs : [TypeName -> NeType], signatures : [(FnFamilyId, Nat) -> SgnSet]
{
  [TypeCheckingError] typecheck_function(Function func)
  {
    args = func.args;
    var_aliases = set(([fn_par(i); a.var] : a @ i <- args; a :: FormalObjArg and a.var?));

    obj_vars = [a.var -> a.type : a <- set(args); formal_obj_arg() <~ a; a.var?] &
               [fn_par(i) -> a.type : i <- index_set(args); a = args[i]; formal_obj_arg() <~ a] &
               [v -> t : v, t <- func.impl_args];

    cls_vars = [a.var -> a.type : a <- set(args); formal_cls_arg() <~ a];

    //## THE FOLLOWING LINE WAS PRODUCING A COMPLETELY WRONG ERROR MESSAGE
    // errs = typecheck(func.expr, nonexistent_function(func), environment=obj_vars, closures=cls_vars);

    constraints = merge_values([[(n, arity(s)) -> s] : n, ss <- func.constrs; s <- ss]);

    let var_aliases=var_aliases, closures=cls_vars, constraints=constraints:
      errs = typecheck(func.expr, func.res_type, obj_vars);
    ;
    return errs;
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit
{
  typedefs    : [TypeName -> NeType],
  signatures  : [(FnFamilyId, Nat) -> SgnSet],
  closures    : [ClsVar -> ClsType],
  constraints : [(AtomicFnSymb, NzNat) -> [+ClsType]],
  var_aliases : [[Var]];


  [TypeCheckingError] typecheck(CondExpr expr, Type exp_type, [Var -> Type] env)
  {
    errs = typecheck(expr.cond, type_bool, env);
    return errs if errs != [];
    new_env = left(refine_env(expr.cond, env));
    return typecheck(expr.expr, exp_type, new_env);
  }

  //////////////////////////////////////////////////////////////////////////////

  [TypeCheckingError] typecheck(ClsExpr expr, Type+ arg_types, Type ret_type, [Var -> Type] env):
    ClsVar = {
      var_type = closures(expr);
      is_subtype = is_fn_subtype(var_type.in_types, var_type.out_type, arg_types, ret_type);
      return [invalid_cls_param_type(var_type, arg_types, ret_type) if not is_subtype];
    },
    fn_ptr() = {
      sgn_set = signatures[(expr.name, expr.arity)];
      sgns = sgn_set.sgns;
      assert size(sgns) == 1;
      sgn = only(sgns);
      assert sgn.impl_args == [:]; //## BUG BUG BUG: THIS IS NOT CHECKED IN THE WELL-FORMEDNESS CHECKING LAYER
      assert not (a <- set(sgn.args) : not a :: NeType);
      sgn_cls = cls_type(cast_type_ne_seq(sgn.args), sgn.ret_type);
      is_subtype = is_fn_subtype(sgn_cls.in_types, sgn_cls.out_type, arg_types, ret_type);
      return [invalid_cls_param_type(sgn_cls, arg_types, ret_type) if not is_subtype];
    },
    cls_expr() = {
      delta_env = merge(([fn_par(i) -> t; value(v) -> t if v != nil] : v, t @ i <- zip(expr.args, arg_types)));
      new_env = update(env, delta_env);
      return typecheck(expr.expr, ret_type, new_env); //## BAD: HERE I SHOULD PROVIDE MORE INFORMATION
    };

  NeType+ cast_type_ne_seq(AnyType* ts) = (cast_type(t) : t <- nonempty(ts));

  //////////////////////////////////////////////////////////////////////////////

  [TypeCheckingError] typecheck(Clause cls, [Var -> Type] env)
  {
    errs = typecheck_without_annotations(cls, env);
    return [add_anchor_if_needed(e, cls) : e <- errs];


    [TypeCheckingError] typecheck_without_annotations(Clause cls, [Var -> Type] env):
      set_clause()      = typecheck(cls.src, type_set, env),
      rel_clause()      = typecheck_rel_clause(cls.vars, cls.src, cls.args, env),
      relvar_clause()   = {fail;},
      seq_clause()      = typecheck(cls.src, type_seq, env),
      and_clause()      = typecheck_and_clause(cls.left, cls.right, env),
      or_clause()       = typecheck(cls.left, env) & typecheck(cls.right, env),
      match_clause()    = typecheck_match_clause(cls.ptrn, cls.expr, env),
      asgnm_clause()    = typecheck(cls.expr, type_any, env),
      filter_clause(e?) = typecheck(e, type_bool, env);
  }


  [TypeCheckingError] typecheck_rel_clause(StdVar+ vars, Expr src, Maybe[Expr]+ args, [Var -> Type] env)
  {
    assert length(vars) == count(args, $ == nil);

    return match (args)
      (a1?, a2?)      = typecheck_bin_rel_clause(src, args, env),
      (a1?, a2?, a3?) = typecheck_tern_rel_clause(src, args, env);


    [TypeCheckingError] typecheck_bin_rel_clause(Expr src, (Maybe[Expr], Maybe[Expr]) args, [Var -> Type] env)
    {
      errs = typecheck(src, type_bin_rel, env);
      return errs if errs != [];
      args_types = bin_rel_args_supertypes(expr_type(src, env));
      return seq_union((if a != nil then typecheck(value(a), t, env) else [] : a, t <- zip(args, args_types)));
    }


    [TypeCheckingError] typecheck_tern_rel_clause(Expr src, (Maybe[Expr], Maybe[Expr], Maybe[Expr]) args, [Var -> Type] env)
    {
      errs = typecheck(src, type_tern_rel, env);
      return errs if errs != [];
      args_types = tern_rel_args_supertypes(expr_type(src, env));
      return seq_union((if a != nil then typecheck(value(a), t, env) else [] : a, t <- zip(args, args_types)));
    }
  }


  [TypeCheckingError] typecheck_and_clause(Clause left, Clause right, [Var -> Type] env)
  {
    errs = typecheck(left, env);
    return errs if errs != [];
    new_env = generate_env(left, env);
    return typecheck(right, new_env);
  }


  [TypeCheckingError] typecheck_match_clause(Pattern ptrn, Expr source, [Var -> Type] env)
  {
    errs = typecheck(source, type_any, env);
    return errs if errs != [];
    type = expr_type(source, env);
    return [ptrn_cannot_match_type(ptrn, type) if type != empty_type and not may_match(ptrn, type)];
  }
}

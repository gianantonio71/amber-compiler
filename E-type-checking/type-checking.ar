//## BUG: I ALSO HAVE TO CHECK THAT FOR ALL FUNCTIONS WITH THE SAME
//## NAME AND ARITY ALL NAMED PARAMETERS HAVE THE SAME TYPE, AND
//## THAT ALL CLOSURE PARAMETERS HAVE EXACTLY THE SAME TYPE.


[Function -> [+TypeCheckingError]] typecheck(Program prg, Bool verbose)
{
  typedefs = prg.typedefs;
  signatures = merge_values([[(family_id(fd.name), arity(fd)) -> signature(fd)] | fd <- prg.fndefs]);
  sgn_sets = [n -> preprocess_signatures(ss, typedefs) | n : ss <- signatures];
  let typedefs = typedefs, signatures = sgn_sets, verbose = verbose:
    errors = [fd -> typecheck_function(fd) | fd <- prg.fndefs];
  ;
  return [fd -> es | fd : es <- errors, es != []];
}


implicit typedefs : [TypeName -> Type], signatures : [(FnFamilyId, Nat) -> SgnSet], verbose : Bool
{
  [TypeCheckingError] typecheck_function(Function func)
  {
    args = func.args;
    var_aliases = set(([fn_par(i), a.var] | a @ i <- args, a :: FormalObjArg and a.var?));

    obj_vars = [a.var -> a.type | a <- set(args), formal_obj_arg() <~ a, a.var?] &
               [fn_par(i) -> a.type | i <- index_set(args), a = args[i], formal_obj_arg() <~ a] &
               [v -> t | v : t <- func.impl_args, t :: Type];

    cls_vars = [a.var -> a.type | a <- set(args), formal_cls_arg() <~ a] &
               [v -> t | v : t <- func.impl_args, t :: ClsType];

    //## THE FOLLOWING LINE WAS PRODUCING A COMPLETELY WRONG ERROR MESSAGE
    // errs = typecheck(func.expr, nonexistent_function(func), environment=obj_vars, closures=cls_vars);
    return typecheck(func.expr, func.res_type, var_aliases=var_aliases, environment=obj_vars, closures=cls_vars);
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit
{
  typedefs    : [TypeName -> Type],
  signatures  : [(FnFamilyId, Nat) -> SgnSet],
  environment : [Var -> Type],
  closures    : [<ClsVar, NamedArg> -> ClsType],
  var_aliases : [[Var]],
  verbose     : Bool;


  [TypeCheckingError] typecheck(CondExpr expr, Type exp_type)
  {
    errs = typecheck(expr.cond, type_bool);
    return errs if errs != [];
    new_env = left(refine_environment(expr.cond));
    return typecheck(expr.expr, exp_type, environment=new_env);
  }

  //////////////////////////////////////////////////////////////////////////////

  [TypeCheckingError] typecheck(ClsExpr expr, ClsType exp_type):
    ClsVar = {
      var_type = closures[expr];
      return [invalid_cls_param_type(var_type, exp_type) if not is_subset(var_type, exp_type)];
    },
    fn_ptr() = {
      sgn_set = signatures[(expr.name, expr.arity)];
      sgns = sgn_set.sgns;
      assert size(sgns) == 1;
      sgn = only(sgns);
      assert sgn.named_args == [:]; //## BUG BUG BUG: THIS IS NOT CHECKED IN THE WELL-FORMEDNESS CHECKING LAYER
      assert not (p <- set(sgn.params) | not p :: Type);
      sgn_cls = cls_type(cast_as_type_ne_seq(sgn.params), sgn.ret_type);
      return [invalid_cls_param_type(sgn_cls, exp_type) if not is_subset(sgn_cls, exp_type)];
    },
    cls_expr() = {
      delta_env = merge(([fn_par(i) -> t, value(v) -> t if v != nil] | v, t @ i <- zip(expr.args, exp_type.in_types)));
      new_env = update(environment, delta_env);
      return typecheck(expr.expr, exp_type.out_type, environment=new_env); //## BAD: HERE I SHOULD PROVIDE MORE INFORMATION
    };

  Type+ cast_as_type_ne_seq(AnyType* ts) = (cast_as_type(t) | t <- nonempty(ts));

  //////////////////////////////////////////////////////////////////////////////

  [TypeCheckingError] typecheck(Clause cls)
  {
    errs = typecheck_without_annotations(cls);
    return [add_anchor_if_needed(e, cls) | e <- errs];


    [TypeCheckingError] typecheck_without_annotations(Clause cls):
      set_elem_clause()   = typecheck(cls.src, type_set),
      map_entry_clause()  = typecheck(cls.src, type_map),
      seq_elem_clause()   = typecheck(cls.src, type_seq),
      and_clause()        = typecheck_and_clause(cls.left, cls.right),
      or_clause()         = typecheck(cls.left) & typecheck(cls.right),
      match_clause()      = typecheck_match_clause(cls.ptrn, cls.expr),
      asgnm_clause()      = typecheck(cls.expr, type_any),
      filter_clause(e?)   = typecheck(e, type_bool);
  }


  [TypeCheckingError] typecheck_and_clause(Clause left, Clause right)
  {
    errs = typecheck(left);
    return errs if errs != [];
    new_env = generate_env(left);
    return typecheck(right, environment=new_env);
  }


  [TypeCheckingError] typecheck_match_clause(Pattern ptrn, Expr source)
  {
    errs = typecheck(source, type_any);
    return errs if errs != [];
    type = expr_type(source);
    return [ptrn_cannot_match_type(ptrn, type) if type != empty_type and not may_match(ptrn, type)];
  }
}

Atom bare_id(StdVar):            var(a?)       = a;
Atom bare_id(NamedArg):          named_arg(a?) = a;
Atom bare_id(MembVar):           memb_var(a?)  = a;
Atom bare_id(MembCopyVar):       memb_copy_var(a?)  = a;
Atom bare_id(PendingStateVar):   pending_state_var(a?) = a;

Atom bare_id(AnyAutoVar):
  loc_auto_var(a?)  |
  memb_auto_var(a?) = a;

Atom bare_id(AnyDBVar):
  loc_db_var(a?)    |
  memb_db_var(a?)   = a;

Atom bare_id(FnSymbol):
  fn_symbol(a?)   = a;

Atom bare_id(AutoSymbol):
  auto_symbol(a?) = a;

Atom bare_id(DBSymbol):
  db_symbol(a?) = a;

Atom bare_id(MethodSymbol):
  method_symbol(a?) = a;

Atom bare_id(UpdateSymbol):
  update_symbol(a?) = a;

////////////////////////////////////////////////////////////////////////////////

Atom bare_obj(SymbObj):
  object(a?)  = a;

////////////////////////////////////////////////////////////////////////////////

Bool is_cond_expr(SubExpr):
  CondExpr  = true,
  Expr      = false;

Bool is_scalar_expr(AnyExpr):
  Expr      = true,
  ClsExpr   = false;


Type* params(TypeSymbol ts):
  type_symbol()     = (),
  par_type_symbol() = ts.params;


Int max(<int_range(min: Int, size: NzNat)> t) = t.min + t.size - 1; //## BAD BAD
Int max(<low_ints(max: Int)> t) = t.max;


TypeName type_symb_to_name(TypeSymbol ts):
  BasicTypeSymbol   = type_name(symbol: ts, arity: 0),
  par_type_symbol() = type_name(symbol: ts.symbol, arity: length(ts.params));

////////////////////////////////////////////////////////////////////////////////

FnType builtin_to_fn_type(BuiltInType type) = fn_type(type.param_types, type.ret_type);

////////////////////////////////////////////////////////////////////////////////

Type cast_as_type(AnyType type):
  Type    = type,
  ClsType = {fail;};

ClsType cast_as_cls_type(AnyType type):
  Type    = {fail;},
  ClsType = type;

////////////////////////////////////////////////////////////////////////////////

Bool is_expr(Expr)      = true;
Bool is_expr(CondExpr)  = false;
Bool is_expr(ClsExpr)   = false;

Expr cast_as_expr(Expr expr)  = expr;
Expr cast_as_expr(CondExpr)   = {fail;};
Expr cast_as_expr(ClsExpr)    = {fail;};

ClsExpr cast_as_cls_expr(ClsExpr expr)  = expr;
ClsExpr cast_as_cls_expr(Expr)          = {fail;};

////////////////////////////////////////////////////////////////////////////////

Nat arity(Function fn) = length(fn.args);

Nat arity(Procedure pc) = length(pc.args);

NzNat arity(ClsType t)  = nz_nat(length(t.in_types));
Nat arity(Type)         = 0;

Nat arity(FnType t) = length(t.params);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

AtomicFnSymb      family_id(AtomicFnSymb symb) = symb;
AtomicFnSymb      family_id(UniqueFnSymb symb) = symb.symbol;
NestedFnFamilyId  family_id(NestedFnSymb symb) = nested_fn_symbol(outer: symb.outer, inner: family_id(symb.inner));

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//## FIND BETTER NAME FOR THESE FUNCTIONS

MembVar one_level_down(QualAutoMembVar var) = var.memb_var;

<MembVar, QualDBMembVar> one_level_down(QualDBMembVar var) =
  match (var.db_var)
    loc_db_var()    = var.memb_var,
    memb_db_var()   = var.memb_var,
    nested_db_var() = qual_db_memb_var(one_level_down(var.db_var), var.memb_var);

AnyDBVar one_level_down(NestedDBVar var) =
  match (var.outer)
    loc_db_var()    = var.inner,
    memb_db_var()   = var.inner,
    nested_db_var() = one_level_down(var.outer);

AnyRelVar one_level_down(QualRelVar var) =
  match (var.db_var)
    loc_db_var()    = var.rel_var,
    memb_db_var()   = var.rel_var,
    nested_db_var() = qual_rel_var(one_level_down(var.db_var), var.rel_var);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//## NOT PARTICULARLY EFFICIENT, SHOULD BE CACHED...
Nat+ table_cols_perm(NzNat arity, [[+Nat]] keys)
{
  return (i : i < arity) if keys == [];
  ps = [nonempty(p) : p <- permutations(arity)];
  valid_keys = valid_keys_by_arity[arity];
  for p <- rand_sort(ps):
    perm_keys = permutate_keys(keys, p);
    return p if valid_keys(perm_keys);
  ;
  fail;


  [NzNat -> [+[[+Nat]]]] valid_keys_by_arity = [
      1 -> [[]];
      2 -> [[[0]]; [[1]]; [[0]; [1]]];
      3 -> [
        [[0; 1]];
        [[0; 1]; [2]];
        [[0; 1]; [1; 2]];
        [[0; 1]; [1; 2]; [0; 2]]
      ]
    ];
}


[[+Nat]] permutate_keys([[+Nat]] keys, Nat+ perm)
{
  rev_perm = reverse_perm(perm);
  return [[rev_perm(i) : i <- k] : k <- keys];
}

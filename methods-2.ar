Atom bare_id(StdVar)          = var(a?)                 = a;
Atom bare_id(ImplArg)         = impl_arg(a?)            = a;
Atom bare_id(MembVar)         = memb_var(a?)            = a;
Atom bare_id(AutoMembVar)     = auto_memb_var(a?)       = a;
Atom bare_id(AutoMembVarCopy) = auto_memb_var_copy(a?)  = a;

Atom bare_id(AnyAutoVar) =
  loc_auto_var(a?)  |
  memb_auto_var(a?) = a;

Atom bare_id(AnyDBVar) =
  loc_db_var(a?)    |
  memb_db_var(a?)   = a;

Atom bare_id(FnSymbol) =
  fn_symbol(a?)   = a;

Atom bare_id(AutoSymbol) =
  auto_symbol(a?) = a;

Atom bare_id(DBSymbol) =
  db_symbol(a?) = a;

Atom bare_id(MethodSymbol) =
  method_symbol(a?) = a;

Atom bare_id(UpdateSymbol) =
  update_symbol(a?) = a;

Atom bare_id(RelVar) =
  rel_var(a?) = a;

Atom bare_id(ProcSymbol) =
  proc_symbol(a?) = a;

////////////////////////////////////////////////////////////////////////////////

Atom bare_obj(SymbObj) =
  object(a?)  = a;

////////////////////////////////////////////////////////////////////////////////

TypeSymbol type_symb(TypeRef) =
  type_ref(ts?) = ts;

[+NeType] types(UnionType) =
  union_type(ts?) = ts;

////////////////////////////////////////////////////////////////////////////////

True  is_expr(Expr)         = true;
// False is_expr(CondExpr)  = false;
False is_expr(AnyClsExpr)   = false;

False is_cond_expr(Expr)      = false;
True  is_cond_expr(CondExpr)  = true;

False is_cls_expr(Expr)       = false;
True  is_cls_expr(AnyClsExpr) = true;

True  is_rel_var(AnyRelVar) = true;
False is_rel_var(Expr)      = false;

////////////////////////////////////////////////////////////////////////////////

True  is_type(Type)     = true;
False is_type(ClsType)  = false;

True  is_ne_type(NeType)  = true;
False is_ne_type(ClsType) = false;

False is_cls_type(Type)     = false;
True  is_cls_type(ClsType)  = true;

////////////////////////////////////////////////////////////////////////////////

Type* params(TypeSymbol ts) =
  type_symbol()     = (),
  par_type_symbol() = ts.params;


Int max(<int_range(min: Int, size: NzNat)> t) = t.min + t.size - 1; ## BAD BAD
Int max(<low_ints(max: Int)> t) = t.max;


TypeName type_symb_to_name(TypeSymbol ts) =
  BasicTypeSymbol   = type_name(symbol: ts, arity: 0),
  par_type_symbol() = type_name(symbol: ts.symbol, arity: |ts.params|);

////////////////////////////////////////////////////////////////////////////////

FnType cls_to_fn_type(ClsType type)         = fn_type(type.in_types, type.out_type);
FnType builtin_to_fn_type(BuiltInType type) = fn_type(type.param_types, type.ret_type);

////////////////////////////////////////////////////////////////////////////////

NeType cast_type(NeType type) = type;
NeType cast_type(ClsType) {fail;}

ClsType cast_cls_type(ClsType type) = type;
ClsType cast_cls_type(NeType) {fail;}

NeType cast_ne_type(Type type) = if type != empty_type then type else {fail;};

////////////////////////////////////////////////////////////////////////////////

NeType+ cast_type_ne_seq(AnyType* ts) = (cast_type(t) : t <- nonempty(ts));

////////////////////////////////////////////////////////////////////////////////

Expr cast_as_expr(Expr expr)  = expr;
Expr cast_as_expr(CondExpr)   = {fail;};
Expr cast_as_expr(AnyClsExpr) = {fail;};

AnyClsExpr cast_as_cls_expr(AnyClsExpr expr)  = expr;
AnyClsExpr cast_as_cls_expr(Expr)             = {fail;};

ClsVar cast_cls_var(ClsVar var) = var;
ClsVar cast_cls_var(CaptClsVar) = {fail;};

////////////////////////////////////////////////////////////////////////////////

Database cast_database(Context context) =
  data_base() = context;

////////////////////////////////////////////////////////////////////////////////

Nat arity(Function fn) = |fn.args|;

Nat arity(Method m) = |m.args|;

Nat arity(Update u) = |u.args|;

Nat arity(Handler) = 1;

Nat arity(Procedure pc) = |pc.args|;

NzNat arity(ClsType t)  = nz_nat(|t.in_types|);
Nat arity(Type)         = 0;

Nat arity(FnType t) = |t.args|;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

AtomicFnSymb      family_id(AtomicFnSymb symb) = symb;
AtomicFnSymb      family_id(UniqueFnSymb symb) = symb.symbol;
NestedFnFamilyId  family_id(NestedFnSymb symb) = nested_fn_symbol(outer: symb.outer, inner: family_id(symb.inner));

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

## FIND BETTER NAME FOR THESE FUNCTIONS

AutoMembVar one_level_down(QualAutoMembVar var) = var.memb_var;

<MembVar, QualDBMembVar> one_level_down(QualDBMembVar var) =
  match (var.db_var)
    loc_db_var()    = var.memb_var,
    memb_db_var()   = var.memb_var,
    nested_db_var() = qual_db_memb_var(one_level_down(var.db_var), var.memb_var);

AnyDBVar one_level_down(NestedDBVar var) =
  match (var.outer)
    loc_db_var()    = var.inner,
    memb_db_var()   = var.inner,
    nested_db_var() = one_level_down(var.outer);

AnyRelVar one_level_down(QualRelVar var) =
  match (var.db_var)
    loc_db_var()    = var.rel_var,
    memb_db_var()   = var.rel_var,
    nested_db_var() = qual_rel_var(one_level_down(var.db_var), var.rel_var);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

## NOT PARTICULARLY EFFICIENT, SHOULD BE CACHED...
Nat+ table_cols_perm(NzNat arity, [[+Nat]] keys) {
  return (i : i < arity) if keys == [];
  ps = [nonempty(p) : p <- permutations(arity)];
  valid_keys = valid_keys_by_arity[arity];
  for p <- rand_sort(ps):
    perm_keys = permutate_keys(keys, p);
    return p if valid_keys(perm_keys);
  ;
  fail;


  [NzNat -> [+[[+Nat]]]] valid_keys_by_arity = [
      1 -> [[]],
      2 -> [[[0]], [[0], [1]]],
      3 -> [
        [[0, 1]],
        [[0, 1], [2]],
        [[0, 1], [1, 2]],
        [[0, 1], [1, 2], [0, 2]]
      ]
    ];
}


[[+Nat]] permutate_keys([[+Nat]] keys, Nat+ perm) {
  rev_perm = reverse_perm(perm);
  return [[rev_perm(i) : i <- k] : k <- keys];
}

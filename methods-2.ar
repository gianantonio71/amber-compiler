Atom bare_id(StdVar):            var(a?)       = a;
Atom bare_id(NamedArg):          named_arg(a?) = a;
Atom bare_id(MembVar):           memb_var(a?)  = a;
Atom bare_id(MembCopyVar):       memb_copy_var(a?)  = a;
Atom bare_id(PendingStateVar):   pending_state_var(a?) = a;

Atom bare_id(AnyAutoVar):
  loc_auto_var(a?)  |
  memb_auto_var(a?) = a;

Atom bare_id(AnyDBVar):
  loc_db_var(a?)    |
  memb_db_var(a?)   = a;

Atom bare_id(FnSymbol):
  fn_symbol(a?)   = a;

Atom bare_id(AutoSymbol):
  auto_symbol(a?) = a;

Atom bare_id(MethodSymbol):
  method_symbol(a?) = a;

Atom bare_id(UpdateSymbol):
  update_symbol(a?) = a;

////////////////////////////////////////////////////////////////////////////////

Atom bare_obj(SymbObj):
  object(a?)  = a;

////////////////////////////////////////////////////////////////////////////////

Bool is_cond_expr(SubExpr):
  CondExpr  = true,
  Expr      = false;

Bool is_scalar_expr(AnyExpr):
  Expr      = true,
  ClsExpr   = false;


Type* params(TypeSymbol ts):
  type_symbol()     = (),
  par_type_symbol() = ts.params;


Int max(<int_range(min: Int, size: NzNat)> t) = t.min + t.size - 1; //## BAD BAD
Int max(<low_ints(max: Int)> t) = t.max;


TypeName type_symb_to_name(TypeSymbol ts):
  BasicTypeSymbol   = type_name(symbol: ts, arity: 0),
  par_type_symbol() = type_name(symbol: ts.symbol, arity: length(ts.params));

////////////////////////////////////////////////////////////////////////////////

FnType builtin_to_fn_type(BuiltInType type) = fn_type(type.param_types, type.ret_type);

////////////////////////////////////////////////////////////////////////////////

Type cast_as_type(AnyType type):
  Type    = type,
  ClsType = {fail;};

ClsType cast_as_cls_type(AnyType type):
  Type    = {fail;},
  ClsType = type;

////////////////////////////////////////////////////////////////////////////////

Bool is_expr(Expr)      = true;
Bool is_expr(CondExpr)  = false;
Bool is_expr(ClsExpr)   = false;

Expr cast_as_expr(Expr expr)  = expr;
Expr cast_as_expr(CondExpr)   = {fail;};
Expr cast_as_expr(ClsExpr)    = {fail;};

ClsExpr cast_as_cls_expr(ClsExpr expr)  = expr;
ClsExpr cast_as_cls_expr(Expr)          = {fail;};

////////////////////////////////////////////////////////////////////////////////

//Nat arity(<FnDef, Signature> obj) = length(obj.params);
Nat arity(FnDef fd) = length(fd.params);

Nat arity(ProcDef2 pd) = length(pd.args);

NzNat arity(ClsType t)  = nz_nat(length(t.in_types));
Nat arity(Type)         = 0;

// NzNat arity(ClsExpr e) = length(e.params);
// Nat arity(Expr)        = 0;

Nat arity(FnType t) = length(t.params);

Bool is_scalar_par(FnFrmPar):
  scalar_par()      = true,
  non_scalar_par()  = false;

Bool is_cls_par(FnFrmPar param) = not is_scalar_par(param);


Var scalar_var(FnFrmPar param):
  scalar_par()      = if param.var? then param.var else {fail;},
  non_scalar_par()  = {fail;};

ClsVar cls_var(FnFrmPar param):
  scalar_par()      = {fail;},
  non_scalar_par()  = if param.var? then param.var else {fail;};


Type scalar_param_type(FnFrmPar param):
  scalar_par()      = if param.type? then param.type else {fail;},
  non_scalar_par()  = {fail;};

ClsType cls_param_type(FnFrmPar param):
  scalar_par()      = {fail;},
  non_scalar_par()  = if param.type? then param.type else {fail;};


Type return_type(FnDef fn_def) = if fn_def.res_type? then fn_def.res_type else {fail;};


[Var] scalar_vars(FnDef fndef)
{
  pos_vars = seq_union((scalar_vars_if_any(p, i) | p @ i <- fndef.params));
  named_vars = [v | v : t <- fndef.named_args, t :: Type];
  return pos_vars & named_vars;

  [Var] scalar_vars_if_any(FnFrmPar par, Nat pos):
    scalar_par()      = [:fn_par(pos), par.var if par.var?],
    non_scalar_par()  = [];
}

// Var* scalar_vars(FnDef fndef) = {p.var : p <- set(fn_def.params), p.var? and (not p.type? or p.type :: Type)} &
//                                 set([:fn_par(i) : p @ i <- fn_def.params, not p.type? or p.type :: Type])     &
//                                 {v : t @ v <- fn_def.named_args, t :: Type};


[Var -> NzNat] cls_vars(FnDef fn_def) = {fail;};

//## FOR THE TIME BEING, THE fn_par(Nat) VARIABLES ARE DEFINED ONLY FOR SCALAR PARAMETERS, NOT CLOSURES
// THIS FUNCTION FAILS IF THERE ARE DUPLICATE PARAMETER NAMES. THIS IS CHECHED BEFORE THE FUNCTION IS INVOKED THOUGH
// (Var => NzNat) cls_vars(FnDef fn_def) = (p.var => length(p.type.in_types) : p <- set(fn_def.params), p.var? and (p.type? and p.type :: ClsType)) &
//                                         (v => length(t.in_types) : t @ v <- fn_def.named_args, t :: ClsType);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//## FIND BETTER NAME FOR THESE FUNCTIONS

MembVar one_level_down(QualAutoMembVar var) = var.memb_var;

<MembVar, QualDBMembVar> one_level_down(QualDBMembVar var) =
  match (var.db_var)
    loc_db_var()    = var.memb_var,
    memb_db_var()   = var.memb_var,
    nested_db_var() = qual_db_memb_var(one_level_down(var.db_var), var.memb_var);

AnyDBVar one_level_down(NestedDBVar var) =
  match (var.outer)
    loc_db_var()    = var.inner,
    memb_db_var()   = var.inner,
    nested_db_var() = one_level_down(var.outer);



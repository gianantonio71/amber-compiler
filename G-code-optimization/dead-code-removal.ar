ProcDef remove_dead_code(ObjProcDef pd) =
  obj_proc_def(
    pd.name,
    pd.params,
    pd.named_args,
    nonempty(remove_dead_code(pd.body)),
    pd.cached
  );


Block remove_dead_code(Block b) =
  block(
    name:               b.name,
    inputs:             b.inputs,
    outputs:            b.outputs,
    memb_vars:          b.memb_vars,
    init_code:          remove_dead_code(b.init_code),
    update_code:        remove_dead_code(b.update_code),
    cleanup_code:       b.cleanup_code,
    queue_update_code:  b.queue_update_code,
    methods_code:       b.methods_code,
    const_data:         b.const_data,
    time_rules_count:   b.time_rules_count
  );

////////////////////////////////////////////////////////////////////////////////

[Instr] remove_dead_code([Instr] code)
{
  opt_code = [];
  for (instr : code)
    opt_instr = remove_dead_code(instr);
    opt_code = opt_code & opt_instr;
    break if not in(falls_through, code_outcomes(opt_instr));
  ;
  return opt_code;
}


[Instr] remove_dead_code(Instr instr):
  no_op               = [],
  set_var()           = [instr if instr.var != instr.value],
  set_bvar()          = [instr if instr.var != instr.value], //## BAD: IDENTICAL TO ABOVE CASE
  set_ivar()          = [instr if instr.var != instr.value], //## DITTO
  branch()            = remove_dead_branch_code(instr.cond, instr.when_true, instr.when_false),
  switch_on_nat()     = remove_dead_switch_code(instr.value, instr.cases),
  repeat(is?)         = remove_dead_loop_code(is),
  execute_block(is?)  = remove_dead_block_code(is),
  cls_scope()         = remove_cls_scope_dead_code(instr.var, instr.bound_cls, instr.body),
  _                   = [instr];


[Instr] remove_dead_branch_code(BoolExpr cond, [Instr^] if_body, [Instr] else_body)
{
  opt_if_body = remove_dead_code(if_body);
  opt_else_body = remove_dead_code(else_body);
  return [branch(cond, opt_if_body, opt_else_body) if opt_if_body != [] or opt_else_body != []];
}


[Instr] remove_dead_switch_code(IntExpr expr, [[Instr]^] cases)
{
  opt_cases = [remove_dead_code(c) : c <- cases];
  //## HERE WHEN WE OPTIMIZE THEN SINGLE-CASE SWITCH WE SHOULD ALSO ADD A CHECK TO MAKE SURE THE SWITCH VAR IS 0
  return if length(cases) == 1 then only_item(opt_cases) else [switch_on_nat(expr, opt_cases)];
}


[Instr] remove_dead_loop_code([Instr^] body)
{
  opt_body = remove_dead_code(body);
  return [repeat(opt_body) if opt_body != []];
}


[Instr] remove_dead_block_code([Instr^] body)
{
  opt_body = remove_dead_code(body);
  opt_body = remove_useless_exit_blocks(opt_body);
  return [] if opt_body == [];
  return if in(exits_block, code_outcomes(opt_body)) then [execute_block(opt_body)] else opt_body;

  [Instr] remove_useless_exit_blocks([Instr] body) =
    if body != []
      then subseq(body, 0, nil, 1) & remove_useless_exit_blocks(rev_at(body, 0))
      else [];

  [Instr] remove_useless_exit_blocks(Instr instr):
    exit_block      = [],
    branch()        = remove_useless_exit_blocks(instr.cond, instr.when_true, instr.when_false),
    _               = [instr];

  [Instr] remove_useless_exit_blocks(BoolExpr cond, [Instr^] if_body, [Instr] else_body)
  {
    opt_if_body = remove_useless_exit_blocks(if_body);
    opt_else_body = remove_useless_exit_blocks(else_body);
    return [branch(cond, opt_if_body, opt_else_body) if opt_if_body != [] or opt_else_body != []];
  }
}


[Instr] remove_cls_scope_dead_code(NamedArg var, BoundCls cls, [Instr^] body)
{
  opt_body = nonempty(remove_dead_code(body));
  opt_cls = remove_cls_body_dead_code(cls);
  return [cls_scope(var, opt_cls, opt_body)];

  BoundCls remove_cls_body_dead_code(BoundCls cls):
    ClsVar        = cls,
    bound_cls()   = bound_cls(cls_def(cls.cls.arity, nonempty(remove_dead_code(cls.cls.body))), cls.env);
}

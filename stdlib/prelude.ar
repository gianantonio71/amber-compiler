type Atom           = <+>;
type Int            = <*..*>;
type Float          = <^>;

type Set            = [Any];
type Seq            = Any*;
type Map            = [Any -> Any];

type TagObj         = (<+> @ Any);

type Any            = Atom, Int, Float, Seq, Set, Map, TagObj;


type Bool           = true, false;

type Nat            = <0..*>;
type NzNat          = <1..*>;
type NegInt         = <*..-1>;

type NeSet          = [+Any];
type NeSeq          = Any+;
type Record         = [Atom -> Any];


type Byte           = <0..255>;
type String         = string(Nat*);


type Maybe[T]       = nil, just(T);
type Result[TS, TF] = success(TS), failure(TF);

type List[T]        = nil, list(head: T, tail: List[T]);
type Stack[T]       = nil, stack(top: T, rest: Stack[T]);

////////////////////////////////////////////////////////////////////////////////

Stack[T] push(Stack[T] stack, T item) = stack(top: item, rest: stack);

Stack[T] pop(Stack[T] stack):
  stack()   = stack.rest,
  _         = {fail;};

T peek(Stack[T] stack):
  stack()   = stack.top,
  _         = {fail;};

Stack[T] replace_top(Stack[T] stack, T new_top):
  stack()   = push(stack.rest, new_top),
  _         = {fail;};

////////////////////////////////////////////////////////////////////////////////

// Replace this with === or ~=
Bool is_eq(T x, Maybe[T] maybe) = maybe == :just(x);

Maybe[T] just(T x) = :just(x);

T value(Maybe[T]):
  just(x?)  = x,
  _         = {fail;};

T try_value(Maybe[T]):
  just(x?)  = x,
  _         = {fail;};

Maybe[T] maybe(T x, Bool cond) = if cond then :just(x) else nil;

T* values(Maybe[T]* maybe_seq) = (value(maybe_value) : maybe_value <- maybe_seq, maybe_value != nil);

[T] values([Maybe[T]] maybe_seq) = [value(maybe_value) : maybe_value <- maybe_seq, maybe_value != nil];

////////////////////////////////////////////////////////////////////////////////

<success(T)> success(T r) = :success(r);
<failure(T)> failure(T e) = :failure(e);

Bool is_success(Result[TS, TF]):
  success()   = true,
  failure()   = false;

Bool is_failure(Result[TS, TF]):
  success()   = false,
  failure()   = true;

TS get_result(Result[TS, TF]):
  success(r?) = r,
  _           = {fail;};

TF get_error(Result[TS, TF]):
  failure(e?) = e,
  _           = {fail;};

////////////////////////////////////////////////////////////////////////////////

// Still not ideal, both of them. No need to always evaluate all arguments.
Bool some([+Bool] bs) = (? b <- bs : b);
Bool all([+Bool] bs)  = not (? b <- bs : not b);

// No element is false
Bool all(Bool* s)   = not in(false, s);

// No element is true
Bool none(Bool* s)  = not in(true, s);

// At least one element is true
Bool at_least_one(Bool* s)  = in(true, s);

// At least one element is false
Bool not_all(Bool+ s) = in(true, s);

////////////////////////////////////////////////////////////////////////////////

<0..1> bit(Bool b) = if b then 1 else 0;

////////////////////////////////////////////////////////////////////////////////

Nat nat(Int n):
  Nat   = n;

NzNat nz_nat(Int n):
  NzNat = n;

T+ nonempty(T* s) = if s != () then s else {fail;};

[+T] nonempty([T] s)    = if s != [] then s else {fail;};

////////////////////////////////////////////////////////////////////////////////

Int (-_)  (Int n)         = _neg_(n);
Int (_+_) (Int a, Int b)  = _add_(a, b);
Int (_-_) (Int a, Int b)  = _sub_(a, b);
Int (_*_) (Int a, Int b)  = _mult_(a, b);
Int (_/_) (Int a, Int b)  = _div_(a, b);

Int mod(Int a, Int b)     = _mod_(a, b);

Bool (_<_)  (Int a, Int b) = _lt_(a, b);
Bool (_<=_) (Int a, Int b) = _le_(a, b);
Bool (_>_)  (Int a, Int b) = _gt_(a, b);
Bool (_>=_) (Int a, Int b) = _ge_(a, b);

Int min(Int a, Int b) = if a < b then a else b;
Int max(Int a, Int b) = if a > b then a else b;

Int min([+Int] ns) = min(rand_sort(ns));

Int min(Int+ ns)
{
  min = ns[0];
  for n <- ns:
    min = n if n < min;
  ;
  return min;
}

Int max([+Int] ns) = max(rand_sort(ns));

Int max(Int+ ns)
{
  max = ns[0];
  for n <- ns:
    max = n if n > max;
  ;
  return max;
}

Int sum(Int* ns)
{
  res = 0;
  for n <- ns:
    res = res + n;
  ;
  return res;
}

////////////////////////////////////////////////////////////////////////////////

// Should it be defined for empty sequences (and negative integers)
// as well? It's always going to fail...

// T (_[_]) ([T^] seq, Nat idx) = _at_(seq, idx);
T (_[_]) (T* seq, Int idx) = _at_(seq, idx);

// T rev_at([T^] seq, Nat idx) = _at_(seq, _len_(seq)-idx-1);
T rev_at(T* seq, Int idx) = _at_(seq, _len_(seq)-idx-1);

<0..0> length(() seq) = 0;
NzNat  length(T+ seq) = nz_nat(_len_(seq));
// Nat length(Seq seq) = _len_(seq);

// T at([T^] seq, Nat idx, T default) = if idx < _len_(seq) then _at_(seq, idx) else default;
T at(T* seq, Int idx, T default) = if idx < _len_(seq) then _at_(seq, idx) else default;

// T1 left((T1, T2) s)  = _at_(s, 0);
T1 left((T1, T2) t)
{
  l, r = t;
  return l;
}

// T2 right((T1, T2) s) = _at_(s, 1);
T2 right((T1, T2) t)
{
  l, r = t;
  return r;
}

(T1, T2)* zip(T1* s1, T2* s2)
{
  assert length(s1) == length(s2);
  return ((e1, s2[i]) : e1 @ i <- s1); //## NOT PARTICULARLY ELEGANT...
}

(T1, T2, T3)* zip(T1* s1, T2* s2, T3* s3)
{
  assert length(s1) == length(s2) and length(s2) == length(s3);
  return ((e1, s2[i], s3[i]) : e1 @ i <- s1); //## NOT PARTICULARLY ELEGANT...
}

(T1, T2, T3, T4)* zip(T1* s1, T2* s2, T3* s3, T4* s4)
{
  assert length(s1) == length(s2) and length(s2) == length(s3) and length(s3) == length(s4);
  return ((e1, s2[i], s3[i], s4[i]) : e1 @ i <- s1); //## NOT PARTICULARLY ELEGANT...
}

(T1*, T2*) unzip((T1, T2)* ts) = ((left(t) : t <- ts), (right(t) : t <- ts)); //## NOT PARTICULARLY ELEGANT EITHER...

T head(T+ s) = _at_(s, 0);
T* tail(T+ s) = _slice_(s, 1, _len_(s)-1);
T last(T+ s) = _at_(s, _len_(s)-1);

Bool is_valid_idx(Seq seq, Int idx) = idx >= 0 and idx < length(seq);

T* (_&_)(T* s1, T* s2) = _cat_(s1, s2);

Bool in(Any e, Seq s)
{
  for x <- s:
    return true if x == e;
  ;
  return false;
}

Nat index_first(Any e, Seq s)
{
  for x @ i <- s:
    return i if x == e;
  ;
  fail;
}

T* join(T** seqs)
{
  res = ();
  for s <- seqs:
    res = _cat_(res, s);
  ;
  return res;
}

T* reverse(T* seq) = _rev_(seq);

// [T] right_subseq([T] seq, Nat first) = _slice_(seq, first, length(seq) - first);
T* right_subseq(T* seq, Int first) = _slice_(seq, first, length(seq) - first);

// [T] subseq([T] seq, Nat first, Nat count) = _slice_(seq, first, count);
T* subseq(T* seq, Int first, Int count) = _slice_(seq, first, count);

// [T] subseq([T] s, <nil>, Nat m, Nat r) = subseq(s, length(s)-m-r, m);
T* subseq(T* s, <nil>, Int m, Int r) = subseq(s, length(s)-m-r, m);
// [T] subseq([T] s, Nat l, <nil>, Nat r) = subseq(s, l, length(s)-l-r);
T* subseq(T* s, Int l, <nil>, Int r) = subseq(s, l, length(s)-l-r);
// [T] subseq([T] s, Nat l, Nat m, <nil>) = subseq(s, l, m);
T* subseq(T* s, Int l, Int m, <nil>) = subseq(s, l, m);


T** split(T* seq, T sep)
{
  len = length(seq);
  subseqs = ();
  start = 0;
  for x @ i <- seq:
    if x == sep:
      subseqs = subseqs & (subseq(seq, start, i-start));
      start = i + 1;
    ;
  ;
  subseqs = subseqs & (subseq(seq, start, len-start)) if start < len;
  return subseqs;
}


Maybe[Nat] left_search(Seq seq, Seq subseq)
{
  last_idx = length(seq) - length(subseq);
  for i < max(0, last_idx+1):
    return just(i) if subseq_matches(seq, subseq, i);
  ;
  return nil;

  Bool subseq_matches(Seq seq, Seq subseq, Nat offset)
  {
    for i < length(subseq):
      return false if seq[offset+i] != subseq[i];
    ;
    return true;
  }
}


T* (_*_)(Nat count, T* seq)
{
  l = length(seq);
  res = ();
  for i < count:
    for x <- seq:
      res = res & (x);
    ;
  ;
  return res;
}


[Nat] index_set(Seq s) = set((i : i < length(s)));

Bool* bit_map(Int* idxs, Nat len) = (in(i, idxs) : i < len); //## BAD: HORRIBLY INEFFICIENT

//## BAD: THE NAME IS TOTALLY MEANINGLESS, AND THE IMPLEMENTATION IS INEFFICIENT
Maybe[Nat]* packed_indexes(Bool* bs)
{
  idxs = ();
  for b <- bs:
    idxs = idxs & (if b then just(length(idxs)) else nil);
  ;
  return idxs;
}

Nat count(T* xs, (T -> Bool) p) = nat(sum((bit(p(x)) : x <- xs)));

/////////////////////////////////////////////////////////////////////////////////////////

Bool in(Any x, Set s) = _in_(x, s);

//## THE WELL-FORMEDNESS CHECKER DOESN'T ALLOW IT, BUT THE CODE GENERATOR CAN ACTUALLY HANDLE IT...
// T* intersection(T* s1, T* s2)     = {e : e <- s1, e <- s2};

[T] union([T] s1, [T] s2)            = _union_([s1, s2]);
[T] intersection([T] s1, [T] s2)     = [e : e <- s1, in(e, s2)];
[T1] difference([T1] s1, [T2] s2)    = [e : e <- s1, not in(e, s2)];

[T] (_&_)([T] s1, [T] s2)    = union(s1, s2);
[T1] (_-_)([T1] s1, [T2] s2) = difference(s1, s2);

Bool disjoint(Set s1, Set s2) = intersection(s1, s2) == [];
Bool subset(Set s1, Set s2)   = s1 - s2 == [];

[T] union([[T]] sets) = _union_(sets);

[T] intersection([[T]] sets)
{
  return [] if sets == [];
  ss  = rand_sort(sets);
  int = ss[0];
  for i = 1..length(ss):
    int = intersection(int, ss[i]);
  ;
  return int;
}

Nat size([Any] s) = length(rand_sort(s));

Bool is_singleton([Any] s) = size(s) == 1;

T only_element([T] set)
{
  seq = rand_sort(set);
  return seq[0] if length(seq) == 1;
  fail;
}

T only_element([T] set, T default)
{
  seq = rand_sort(set);
  return if length(seq) == 1 then seq[0] else default;
}

T only_element_or_def_if_empty([T] set, T default)
{
  seq = rand_sort(set);
  len = length(seq);

  fail if len > 1;

  return if length(seq) == 1 then seq[0] else default;
}

/////////////////////////////////////////////////////////////////////////////////////////

[T] seq_union([T]* sets) = union(set(sets));

/////////////////////////////////////////////////////////////////////////////////////////

T2 (_[_])([T1 -> T2] map, T1 key) = _lookup_(map, key);

T2 lookup([T1 -> T2] map, T1 key, T2 default) = if has_key(map, key) then map[key] else default;

Maybe[T2] maybe_lookup([T1 -> T2] map, T1 key) = if has_key(map, key) then just(map[key]) else nil;

[T1 -> T2] update([T1 -> T2] map, [T1 -> T2] diffs) = [k -> map[k] : k <- keys(map) - keys(diffs)] & diffs;

[T1 -> T2] update([T1 -> T2] map, T1 key, T2 new_val) = update(map, [key -> new_val]);

Nat size([Any -> Any] map) = size(keys(map));

[T1] keys([T1 -> T2] map) = [k : unused_var @ k <- map];

Bool has_key([T1 -> T2] map, T1 key) = _has_key_(map, key);

[T1 -> T2] (_&_)([T1 -> T2] map1, [T1 -> T2] map2) = _merge_([map1, map2]);

[K -> [+V]] merge_values([[K -> V]] maps)
{
  all_keys = union([keys(m) : m <- maps]);
  return [k -> [m[k] : m <- maps, has_key(m, k)] : k <- all_keys];
}

//## BUG: ACTUAL SIGNATURE IS (K => V+) merge_value_sets((K => V+)* maps). FIX.
[K -> [V]] merge_value_sets([[K -> [V]]] maps) = [k -> union(vss) : vss @ k <- merge_values(maps)];

[K -> V+] merge_sorted_values([K -> V]* maps)
{
  all_keys = seq_union((keys(m) : m <- maps));
  return [k -> nonempty((m[k] : m <- maps, has_key(m, k))) : k <- all_keys];
}

[T1 -> T2] merge([[T1 -> T2]] maps) = _merge_(maps);

[T1 -> T2] merge([T1 -> T2]* maps) = merge(set(maps));

[T1 -> T2] remove_key([T1 -> T2] m, T3 kr) = [k -> v : v @ k <- m, k != kr];

[T1 -> T2] remove_keys([T1 -> T2] m, [T3] ks) = [k -> m[k] : k <- keys(m) - ks];

[T1 -> T2] select_by_key([T1 -> T2] map, [T1] keys) = [k -> map[k] : k <- keys];

[KT -> (VT1, VT2)] zip_by_key([KT -> VT1] map1, [KT -> VT2] map2)
{
  assert keys(map1) == keys(map2);
  return [k -> (v1, map2[k]) : v1 @ k <- map1];
}

/////////////////////////////////////////////////////////////////////////////////////////

[]   set(())     = [];
[+T] set(T+ seq) = nonempty(_set_(seq));

//## THIS IS DIFFICULT TO IMPLEMENT EFFICIENTLY WITHOUT ACCESS TO THE INTERNAL COMPARISON OPERATOR
//## IMPLEMENT A seq_to_multiset FUNCTION AND SEE IF IT CAN BE USED TO IMPLEMENT dupl_elements efficiently
[T] dupl_elems(T* s)
{
  r = [];
  for e1 @ i1 <- s ; e2 @ i2 <- s:
    r = r & [e1, e2] if e1 == e2 and i1 != i2;
  ;
  return r;
}

Bool has_duplicates(Any* s) = dupl_elems(s) != [];

() rand_sort([])        = ();
T+ rand_sort([+T] set)  = nonempty(_isort_(set));

(TK, TV)* rand_sort_pairs([TK -> TV] map) = rand_sort([(k, v) : v @ k <- map]);

T an_elem([+T] s) = {ses = rand_sort(s); return ses[0];};

[T -> NzNat] set_to_mset([T] s) = [e -> 1 : e <- s];

/////////////////////////////////////////////////////////////////////////////////////////

[T -> NzNat] bag(T* s) = _mset_(s);

[T2] values([T1 -> T2] map) = [v : v @ unused_var <- map];

/////////////////////////////////////////////////////////////////////////////////////////

T* intermix(T* seq, T obj) = join(((obj if i != 0, e) : e @ i <- seq));

///////////////////////////////////////////////////////////////////////////////

Int to_int(String str)
{
  assert length(str) > 0;

  res = 0;
  neg = false;

  for ch @ i <- _obj_(str):
    if ch == ascii_minus and i == 0:
      neg = true;
      assert length(str) > 1;
    else
      code = ch - ascii_0;
      assert code >= 0 and code <= 9;
      res = 10 * res + code;
    ;
  ;

  return if neg then -res else res;
}

///////////////////////////////////////////////////////////////////////////////

String string(Nat* raw)                  = :string(raw);

Nat* raw_str(String str)                 = _obj_(str);

Nat length(String s)                      = length(_obj_(s));
Nat (_[_]) (String s, Int n)              = (_[_])(_obj_(s), n);

String (_&_) (String s1, String s2)       = string(_obj_(s1) & _obj_(s2));
String append(String* ss)                = string(join((raw_str(s) : s <- ss)));
String append(String* ss, String sep)    = string(join(intermix((raw_str(s) : s <- ss), raw_str(sep))));
String reverse(String s)                  = string(reverse(_obj_(s)));
String substr(String s, Int n, Int m)     = string(subseq(_obj_(s), n, m));

String substr(String s, <nil> l, Int m, Int r) = string(subseq(raw_str(s), l, m, r));
String substr(String s, Int l, <nil> m, Int r) = string(subseq(raw_str(s), l, m, r));
String substr(String s, Int l, Int m, <nil> r) = string(subseq(raw_str(s), l, m, r));

String (_*_) (Nat len, String str)    = string(len * raw_str(str));
<Nat, nil> at(String str, Int idx)    = at(raw_str(str), idx, nil);

Bool (_<_)(String str1, String str2)
{
  len1 = length(str1);
  len2 = length(str2);

  min_len = min(len1, len2);

  i = 0;
  while i < min_len:
    ch1 = str1[i];
    ch2 = str2[i];

    return true if ch1 < ch2;
    return false if ch1 > ch2;

    i = i + 1;
  ;

  return len1 < len2;
}

Bool is_digit(Nat ch) = ch >= ascii_0 and ch <= ascii_9;
Bool is_lower(Nat ch) = ch >= ascii_lower_a and ch <= ascii_lower_z;
Bool is_upper(Nat ch) = ch >= ascii_upper_a and ch <= ascii_upper_z;

Bool is_space(Int ch) = ch == ascii_space or ch == ascii_tab or ch == ascii_newline or ch == ascii_carriage_return;

Bool is_ascii_symbol(Nat ch) = (ch >= ascii_exclamation_mark and ch <= ascii_slash)     or
                               (ch >= ascii_colon            and ch <= ascii_at)        or
                               (ch >= ascii_left_bracket     and ch <= ascii_backquote) or
                               (ch >= ascii_left_brace       and ch <= ascii_tilde);

Bool is_ascii_printable(Nat ch) = ch >= ascii_space and ch <= ascii_tilde;

Bool is_lower_or_digit(Nat ch) = is_lower(ch) or is_digit(ch);

Nat lower(Nat ch) = if is_upper(ch) then nat(ch + 32) else ch;
Nat upper(Nat ch) = if is_lower(ch) then nat(ch - 32) else ch;

String lower(String str) = :string((lower(ch) : ch <- _obj_(str)));
String upper(String str) = :string((upper(ch) : ch <- _obj_(str)));

///////////////////////////////////////////////////////////////////////////////

Nat ascii_null              = 0;
Nat ascii_tab               = 9;
Nat ascii_newline           = 10;
Nat ascii_carriage_return   = 13;

Nat ascii_space             = 32;
Nat ascii_exclamation_mark  = 33;
Nat ascii_double_quotes     = 34; // quotation marks, quote, double quote
Nat ascii_hash              = 35;
Nat ascii_dollar            = 36;
Nat ascii_percent           = 37; // percent sign
Nat ascii_ampersand         = 38;
Nat ascii_single_quote      = 39;
Nat ascii_left_parenthesis  = 40;
Nat ascii_right_parenthesis = 41;
Nat ascii_asterisk          = 42;
Nat ascii_plus              = 43;
Nat ascii_comma             = 44;
Nat ascii_minus             = 45; // dash, hyphen
Nat ascii_dot               = 46; // period, point, decimal point
Nat ascii_slash             = 47;
Nat ascii_0                 = 48;
Nat ascii_1                 = 49;
Nat ascii_2                 = 50;
Nat ascii_3                 = 51;
Nat ascii_4                 = 52;
Nat ascii_5                 = 53;
Nat ascii_6                 = 54;
Nat ascii_7                 = 55;
Nat ascii_8                 = 56;
Nat ascii_9                 = 57;
Nat ascii_colon             = 58;
Nat ascii_semicolon         = 59;
Nat ascii_lower             = 60; // less than, bra
Nat ascii_equals            = 61;
Nat ascii_greater           = 62; // greater than, ket
Nat ascii_question_mark     = 63;
Nat ascii_at                = 64;
Nat ascii_upper_a           = 65;
Nat ascii_upper_b           = 66;
Nat ascii_upper_c           = 67;
Nat ascii_upper_d           = 68;
Nat ascii_upper_e           = 69;
Nat ascii_upper_f           = 70;
Nat ascii_upper_g           = 71;
Nat ascii_upper_h           = 72;
Nat ascii_upper_i           = 73;
Nat ascii_upper_j           = 74;
Nat ascii_upper_k           = 75;
Nat ascii_upper_l           = 76;
Nat ascii_upper_m           = 77;
Nat ascii_upper_n           = 78;
Nat ascii_upper_o           = 79;
Nat ascii_upper_p           = 80;
Nat ascii_upper_q           = 81;
Nat ascii_upper_r           = 82;
Nat ascii_upper_s           = 83;
Nat ascii_upper_t           = 84;
Nat ascii_upper_u           = 85;
Nat ascii_upper_v           = 86;
Nat ascii_upper_w           = 87;
Nat ascii_upper_x           = 88;
Nat ascii_upper_y           = 89;
Nat ascii_upper_z           = 90;
Nat ascii_left_bracket      = 91;
Nat ascii_backslash         = 92;
Nat ascii_right_bracket     = 93;
Nat ascii_circumflex        = 94;
Nat ascii_underscore        = 95;
Nat ascii_backquote         = 96;
Nat ascii_lower_a           = 97;
Nat ascii_lower_b           = 98;
Nat ascii_lower_c           = 99;
Nat ascii_lower_d           = 100;
Nat ascii_lower_e           = 101;
Nat ascii_lower_f           = 102;
Nat ascii_lower_g           = 103;
Nat ascii_lower_h           = 104;
Nat ascii_lower_i           = 105;
Nat ascii_lower_j           = 106;
Nat ascii_lower_k           = 107;
Nat ascii_lower_l           = 108;
Nat ascii_lower_m           = 109;
Nat ascii_lower_n           = 110;
Nat ascii_lower_o           = 111;
Nat ascii_lower_p           = 112;
Nat ascii_lower_q           = 113;
Nat ascii_lower_r           = 114;
Nat ascii_lower_s           = 115;
Nat ascii_lower_t           = 116;
Nat ascii_lower_u           = 117;
Nat ascii_lower_v           = 118;
Nat ascii_lower_w           = 119;
Nat ascii_lower_x           = 120;
Nat ascii_lower_y           = 121;
Nat ascii_lower_z           = 122;
Nat ascii_left_brace        = 123;
Nat ascii_bar               = 124; // vertical bar, pipe
Nat ascii_right_brace       = 125;
Nat ascii_tilde             = 126;

///////////////////////////////////////////////////////////////////////////////

Nat** split_lines(Nat* chs)
{
  return (rem_trail_cr(l) : l <- split(chs, ascii_newline));

  Nat* rem_trail_cr(Nat* line)
  {
    has_cr = line != () and rev_at(line, 0) == ascii_carriage_return;
    return if has_cr then subseq(line, 0, length(line)-1) else line;
  }
}


String* split(String str)
{
  len = length(str);
  frags = ();
  start = 0;
  for ch @ i <- _obj_(str):
    if is_space(ch):
      frags = (frags | substr(str, start, i-start)) if start != i;
      start = i + 1;
    ;
  ;
  frags = (frags | substr(str, start, len-start)) if start < len;
  return frags;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// (T2 => T1+) reverse((T1 => T2) map) = merge_values({(v => k) : v @ k <- map});

[T2 -> T1] reverse([T1 -> T2] map) = merge([[v -> k] : v @ k <- map]);

[T2 -> [+T1]] reverse_relation([T1 -> T2] map) = merge_values([[v -> k] : v @ k <- map]);

[T2 -> [+T1]] reverse_multi([T1 -> [T2]] map) = merge_values([[v -> k : v <- vs] : vs @ k <- map]);





// Bool is_prefix([T] prefix, [T] seq)
// {
//   return false if length(prefix) > length(seq);
//   for (e @ i : prefix)
//     return false if e != seq[i];
//   ;
//   return true;
// }


T only_item(T* seq)
{
  fail if length(seq) > 1;
  return seq[0];
}


Maybe[T] maybe_only_item(T* seq)
{
  fail if length(seq) > 1;
  return if seq != () then just(seq[0]) else nil;
}


T reduce([+T] xs, (T, T -> T) f) = reduce(nonempty(rand_sort(xs)), f);

T reduce(T+ xs, (T, T -> T) f)
{
  rx = head(xs);
  for i = 1..length(xs):
    rx = f(rx, xs[i]);
  ;
  return rx;
}


(T, T)* unique_seq_pairs(T* seq)
{
  len = length(seq);
  ps = ();
  for i1 < len; i2 = i1+1..len:
    ps = (ps | (seq[i1], seq[i2]));
  ;
  return ps;
}


[KT -> [+T]]  group_by([T] set, (T -> KT) f)                   = merge_values([[f(e) -> e] : e <- set]);
[KT -> [+VT]] group_by([T] set, (T -> KT) kf, (T -> VT) vf)    = merge_values([[kf(e) -> vf(e)] : e <- set]);

[KT -> [+T]]  group_by(T* seq, (T -> KT) f)                  = group_by(set(seq), f);
[KT -> [+VT]] group_by(T* seq, (T -> KT) kf, (T -> VT) vf)   = group_by(set(seq), kf, vf);

// [RT] map_pairs([T*] seq, (T, T -> Maybe[RT]) f)
// {
//   len = length(seq);
//   res = [];
//   for (x1 @ i1 : seq)
//     for (i2 = i1+1 .. len)
//       maybe = f(x1, seq[x2]);
//       res = [res | value(maybe)] if maybe != nil;
//     ;
//   ;
//   return res;
// }

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

T* array_map([Nat -> T] map) = if map == [:] then () else (map[i] : i <= max(nonempty(keys(map))));

//## WOULD NEED SUBSIGNATURES HERE: [Nat] -> [Nat], [Int] -> [Int], [Float -> Float]
//## AND THE TYPE OF THE ELEMENTS SHOULD BE PARAMETRIC
Nat* partial_sums(Nat* xs)
{
  sum = 0;
  sums = ();
  for x <- xs:
    sum = nat(sum + x);
    sums = (sums | sum);
  ;
  return sums;
}

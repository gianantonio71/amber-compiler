//type NzInt          = [1..*], [*..-1];
type Rat            = Int, rat(num: Int, den: [2..*]);
type Point          = point(x: Rat, y: Rat);

type BinTree[T]     = leaf, bin_tree(value: T, left: BinTree[T], right: BinTree[T]);
type BinTree        = BinTree[Any];



// using T2 f(T1)
// {
//   (T2 => NzNat) apply(T1* s) = _mset_([f(x) : x <- rand_sort(s)]);
// }

// Bool in(Any x, Set s) = (? e <- s : e == x);
// [T1, T2]* cart_prod(T1* s1, T2* s2)  = {[e1, e2] : e1 <- s1, e2 <- s2};

//Set cart_prod([{T*}^] ss) = {[e1a, e1b, e2] : [e1a, e1b] <- s1 /\ e2 <- s2};

// T* union(T* s1, T* s2)         = {e : e <- s1 \/ e <- s2};

// T* union(T** sets)
// {
//   ss = rand_sort(sets);
//   u  = {};
//   for (s : ss)
//     u = union(u, s);
//   ;
//   return u;
// }

// Int max(Int+ set)
// {
//   seq = rand_sort(set);

//   max = seq[0];
//   for (x : seq)
//     max = x if x > max;
//   ;

//   return max;
// }

// T2 (_[_])((T1 => T2) map, T1 key) = only_element({v : k => v <- map ; k == key});

// T2 lookup((T1 => T2) map, T1 key, T2 default) = only_element_or_def_if_empty({v : k => v <- map ; k == key}, default);

// (T1 => T2) (_&_)((T1 => T2) map1, (T1 => T2) map2)
// {
//   assert {
//     ks1 = keys(map1);
//     ks2 = keys(map2);

//     for (k : rand_sort(intersection(ks1, ks2)))
//       return false if map1[k] /= map2[k];
//     ;

//     return true;

//     //disj  = disjoint(ks1, ks2);
//     //
//     //if (not disj)
//     //  print intersection(ks1, ks2);;

//     //return disj;
//   };

//   return (k => v : k => v <- map1 \/ k => v <- map2);
// }

// (T1 => T2) merge((T1 => T2)* maps) = (k => v : m <- maps, k => v <- m);

// [T2 -> {T1+}] reverse([T1 -> {T2+}] map)
// {
//   // HOW TO MAKE THIS EFFICIENT?
//   vs = union({v : [k, v] <- map});
//   return [v -> {k : [k, s] <- map ; in(v, s)} : v <- vs];
// }

//(T => NzNat) seq_to_multiset(



// (T => NzNat) multiset_union(T** s) = union({set_to_mset(e) : e <- s});

String to_str(Int n)
{
  m   = n;
  neg = false;
  if (m < 0)
    m   = -m;
    neg = true;
  ;

  assert m >= 0;

  div  = 10;
  divs = [1];
  while (div <= m)
    divs = [div] & divs;
    div  = 10 * div;
  ;

  str = "";

  for (d : divs)
    count = 0;
    while (m >= d)
      m     = m - d;
      count = count + 1;
    ;
    str = str & string([nat(ascii_0 + count)]);
  ;

  return if neg then "-" & str else str;
}


String float_to_str(Int mantissa, Int dec_exp)
{
  mant_str = to_str(mantissa);
  shift = -dec_exp;
  padd_zeros = max(0, shift + 1 - length(mant_str));
  mant_str = append(nat(padd_zeros) * ["0"]) & mant_str;
  left = substr(mant_str, 0, nil, shift);
  right = substr(mant_str, nil, shift, 0);
  return left & "." & right;
}

///////////////////////////////////////////////////////////////////////////////

String to_text(Any obj)
{
  return to_txt(obj);

  String to_txt(Any obj):
    +           = _str_(obj),
    *           = to_str(obj),
    ^           = float_to_str(_mantissa_(obj), _dec_exp_(obj)),
    string()    = if obj :: String then quote(obj) else to_txt_tag_obj(:string, _obj_(obj)),
    [...]       = "[" & append(intermix([to_txt(x) : x <- obj], ", ")) & "]",
    {...}       = "{" & append(intermix([to_txt(x) : x <- rand_sort(obj)], ", ")) & "}",
    (...)       = to_txt(obj, if keys(obj) :: <Atom*> then ": " else " => "),
    // tag @ iobj  = to_txt(tag,  iobj);
    tag @ iobj  = to_txt_tag_obj(tag,  iobj);

  String to_txt_tag_obj(Atom tag, Any obj)
  {
    str = to_txt(obj);
    str = "(" & str & ")" if not obj :: Record;
    return _str_(tag) & str;
  }

  String to_txt(Map map, String key_val_sep)
  {
    es   = rand_sort({(key: k, value: v) : v @ k <- map});
    strs = [to_txt(e.key) & key_val_sep & to_txt(e.value) : e <- es];
    return "(" & append(intermix(strs, ", ")) & ")";
  }
}


String quote(String str)
{
  qstr = [];
  for (ch : _obj_(str))
    if (ch == ascii_newline)
      qchs = [ascii_backslash, ascii_lower_n];
    elif (ch == ascii_backslash)
      qchs = [ascii_backslash, ascii_backslash];
    elif (ch == ascii_double_quotes)
      qchs = [ascii_backslash, ascii_double_quotes];
    else
      qchs = [ch];
    ;

    qstr = qstr & qchs;
  ;
  return "\"" & string(qstr) & "\"";
}


String to_text(Any obj, Nat line_len, Nat indent_level)
{
  ind_str = indent_level * "  ";
  return append(intermix([ind_str & l : l <- to_text(obj, line_len)], "\n"));
}


// [String^] to_text(Any obj, Nat line_len)
[String] to_text(Any obj, Nat line_len)
{
  return to_txt(obj, line_len);

  // [String^] to_txt(Any obj, Nat line_len):
  [String] to_txt(Any obj, Nat line_len):
    +           = [_str_(obj)],
    *           = [to_str(obj)],
    ^           = [float_to_str(_mantissa_(obj), _dec_exp_(obj))],
    string()    = if obj :: String then [quote(obj)] else to_txt_tag_obj(:string, _obj_(obj), line_len),
    [...]       = to_txt_collection(obj, line_len, "[", "]"),
    {...}       = to_txt_collection(rand_sort(obj), line_len, "{", "}"),
    (...)       = to_txt_map(obj, line_len),
    tag @ iobj  = to_txt_tag_obj(tag, iobj, line_len);

  // [String^] to_txt_tag_obj(Atom tag, Any obj, Nat line_len)
  [String] to_txt_tag_obj(Atom tag, Any obj, Nat line_len)
  {
    obj_is_record = match (obj)
      (...)   = keys(obj) :: <Atom*>,
      _       = false;
    tag_str      = _str_(tag);
    obj_lines    = to_txt(obj, line_len);
    line_count   = length(obj_lines);
    first_line   = obj_lines[0];

    if (line_count == 1)
      if (obj_is_record or length(first_line) + length(tag_str) + 2 <= line_len)
        return [tag_str & if obj_is_record then first_line else "(" & first_line & ")"];
      else
        return [tag_str & "(", "  " & first_line, ")"];
      ;
    else
      middle_lines = subseq(obj_lines, 1, line_count-2);
      last_line    = rev_at(obj_lines, 0);
      if (length(first_line) == 1)
        indent = "";
        head   = [tag_str & (if obj_is_record then "" else "(") & first_line];
        tail   = [last_line & if obj_is_record then "" else ")"];
      else
        indent = "  ";
        head = [tag_str & "(", "  " & first_line];
        tail = ["  " & last_line, ")"];
      ;
    ;

    return head & [indent & l : l <- middle_lines] & tail;
  }

  // [String^] to_txt_collection(Seq seq, Nat line_len, String left_del, String right_del)
  [String] to_txt_collection(Seq seq, Nat line_len, String left_del, String right_del)
  {
    lines_seq = [to_txt(obj, line_len) : obj <- seq];
    if (all([length(ls) == 1 : ls <- lines_seq]))
      len_sum = sum([length(ls[0]) : ls <- lines_seq]);
      if (len_sum + 2 * length(seq) + 2 < line_len)
        return [left_del & append(intermix([ls[0] : ls <- lines_seq], ", ")) & right_del];
      ;
    ;
    last_idx = length(lines_seq) - 1;
    indented_lines_with_commas = join([["  " & l : l <- if i != last_idx then append_to_last(ls, ",") else ls] : ls @ i <- lines_seq]);
    return [left_del] & indented_lines_with_commas & [right_del];
  }

  // [String^] append_to_last([String^] lines, String str) = [if i != last_idx then l else l & str : l @ i <- lines] let last_idx = length(lines) - 1;;
  // [String^] append_to_last([String^] lines, String str)
  [String] append_to_last([String] lines, String str)
  {
    fail if lines == [];
    last_idx = length(lines) - 1;
    return [if i != last_idx then l else l & str : l @ i <- lines];
  }

  // [String^] to_txt_map(Map map, Nat line_len)
  [String] to_txt_map(Map map, Nat line_len)
  {
    is_record   = keys(map) :: <Atom*>;
    key_val_sep = if is_record then ": " else " => ";
    size        = size(map);
    es          = rand_sort({(key: k, value: v) : v @ k <- map});
    lines       = [];
    single_line = "";
    is_single_line_so_far = true;
    for (e @ i : es)
      key_ls = to_txt(e.key, line_len);
      value_ls = to_txt(e.value, line_len);
      // The pair goes in a single line if both key and value must be on a single line and
      // either it's a record or the entire pair (including the separator) fits in a single line
      if (length(key_ls) == 1 and length(value_ls) == 1 and (is_record or length(key_ls[0]) + length(value_ls[0]) + 2 < line_len))
        ls = [key_ls[0] & key_val_sep & value_ls[0]];
      else
        ls = append_to_last(key_ls, key_val_sep) & value_ls;
      ;
      ls = append_to_last(ls, ",") if i < size - 1;
      lines = lines & ls;
      if (is_single_line_so_far)
        if (length(ls) == 1 and length(single_line) + length(ls[0]) < line_len)
          single_line = single_line & (if single_line == "" then "" else " ") & ls[0];
        else
          is_single_line_so_far = false;
        ;
      ;
    ;
    if (is_single_line_so_far)
      return ["(" & single_line & ")"];
    else
      return ["("] & ["  " & l : l <- lines] & [")"];
    ;
  }
}

///////////////////////////////////////////////////////////////////////////////

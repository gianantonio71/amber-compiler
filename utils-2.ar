Type replace_type_vars(Type type, (TypeVar => Type) substitutions) = replace_type_vars_computed(type, substitutions[$]);

ClsType replace_type_vars(ClsType type, (TypeVar => Type) substitutions) = replace_type_vars_computed(type, substitutions[$]);


//## BAD: FIND DECENT NAME, OR EVEN BETTER, REMOVE THE RESTRICTIONS ABOUT CLOSURE PARAMETERS FOR FUNCTIONS WITH SAME NAME AND ARITY
Type replace_type_vars_computed(Type type, (TypeVar -> Type) replace):
  empty_type        = empty_type,
  LeafType          = type,
  TypeVar           = replace(type),
  type_ref(ts?)     = type_ref(replace_type_vars_computed(ts, replace)),
  ne_seq_type()     = ne_seq_type(replace_type_vars_computed(type.elem_type, replace)),
  ne_set_type()     = ne_set_type(replace_type_vars_computed(type.elem_type, replace)),
  ne_map_type()     = ne_map_type(replace_type_vars_computed(type.key_type, replace), replace_type_vars_computed(type.value_type, replace)),
  record_type(fs?)  = record_type((l => (type: replace_type_vars_computed(f.type, replace), optional: f.optional) : l => f <- fs)), //## BAD: WOULD BE GOOD TO HAVE A "DECLARATIVE" UPDATE OPERATION
  tuple_type(ts?)   = tuple_type([replace_type_vars_computed(t, replace) : t <- ts]),
  tag_obj_type()    = tag_obj_type(type.tag_type, replace_type_vars_computed(type.obj_type, replace)),
  union_type(ts?)   = union_type({replace_type_vars_computed(t, replace) : t <- ts});


ClsType replace_type_vars_computed(ClsType type, (TypeVar -> Type) replace) =
  cls_type(
    [replace_type_vars_computed(t, replace) : t <- type.in_types],
    replace_type_vars_computed(type.out_type, replace)
  );


TypeSymbol replace_type_vars_computed(TypeSymbol type_symb, (TypeVar -> Type) replace):
  type_symbol()           = type_symb,
  builtin_type_symbol()   = type_symb,
  par_type_symbol()       = par_type_symbol(
                              type_symb.symbol,
                              [replace_type_vars_computed(t, replace) : t <- type_symb.params]
                            );

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

T* retrieve_from_nested_types(Type type, (Type -> T*) retrieve):
  empty_type        = {},
  LeafType          = {},
  type_ref(ts?)     = retrieve_from_nested_types(ts, retrieve),
  TypeVar           = {},
  ne_seq_type()     = retrieve(type.elem_type),
  ne_set_type()     = retrieve(type.elem_type),
  ne_map_type()     = retrieve(type.key_type) & retrieve(type.value_type),
  record_type(fs?)  = union({retrieve(f.type) : _ => f <- fs}),
  tuple_type(ts?)   = seq_union([retrieve(t) : t <- ts]),
  tag_obj_type()    = retrieve(type.tag_type) & retrieve(type.obj_type),
  union_type(ts?)   = union({retrieve(t) : t <- ts});


T* retrieve_from_nested_types(TypeSymbol type_symb, (Type -> T*) retrieve):
  BasicTypeSymbol     = {},
  par_type_symbol()   = seq_union([retrieve(t) : t <- type_symb.params]);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Type expand_type_ref(TypeSymbol type_symb, (TypeName => Type) typedefs)
{
  type_name = type_symb_to_name(type_symb);
  raw_type = typedefs[type_name];
  return raw_type if type_name.arity == 0;
  subst_map = merge([(type_var(i) => p) : p @ i <- params(type_symb)]);
  return replace_type_vars(raw_type, subst_map);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

T* retrieve_from_nested_exprs(Expr expr, (Expr -> T*) retrieve):
  LeafObj           = {},
  FloatLit          = {},
  set_expr(ses?)    = union({retrieve_from_nested_exprs(se, retrieve) : se <- ses}),
  seq_expr(ses?)    = seq_union([retrieve_from_nested_exprs(se, retrieve) : se <- ses]),
  tuple_expr(es?)   = seq_union([retrieve(e) : e <- es]),
  seq_tail_expr()   = retrieve(expr.seq) & seq_union([retrieve(e) : e <- expr.tail]),
  map_expr(es?)     = union({retrieve(e.key) & retrieve(e.value) & if e.cond? then retrieve(e.cond) else {} : e <- es}),
  tag_obj_expr()    = retrieve(expr.tag) & retrieve(expr.obj),
  Var               = {},
  fn_call()         = union({retrieve_from_nested_exprs(p, retrieve) : p <- set(expr.params) & values(expr.named_params)}),
  cls_call()        = seq_union([retrieve(p) : p <- expr.params]),
  builtin_call()    = seq_union([retrieve(p) : p <- expr.params]),
  and_expr()        = retrieve(expr.left) & retrieve(expr.right),
  or_expr()         = retrieve(expr.left) & retrieve(expr.right),
  not_expr(e?)      = retrieve(e),
  eq()              = retrieve(expr.left) & retrieve(expr.right),
  membership()      = retrieve(expr.obj),
  cast_expr()       = retrieve(expr.expr),
  accessor()        = retrieve(expr.expr),
  accessor_test()   = retrieve(expr.expr),
  if_expr()         = retrieve(expr.cond) & retrieve(expr.then) & retrieve(expr.else),
  match_expr()      = seq_union([retrieve(e) : e <- expr.exprs]) &
                      seq_union([retrieve(c.expr) : c <- expr.cases]),
  do_expr(ss?)      = retrieve_from_nested_exprs(ss, retrieve),
  ex_qual()         = retrieve_from_nested_exprs(expr.source, retrieve) &
                      if expr.sel_expr? then retrieve(expr.sel_expr) else {},
  set_comp()        = retrieve_from_nested_exprs(expr.source, retrieve) &
                      retrieve(expr.expr) &
                      if expr.sel_expr? then retrieve(expr.sel_expr) else {},
  map_comp()        = retrieve_from_nested_exprs(expr.source, retrieve) &
                      retrieve(expr.key_expr) &
                      retrieve(expr.value_expr) &
                      if expr.sel_expr? then retrieve(expr.sel_expr) else {},
  seq_comp()        = retrieve(expr.expr) &
                      retrieve(expr.src_expr) &
                      if expr.sel_expr? then retrieve(expr.sel_expr) else {},
  range_comp()      = retrieve(expr.expr) & retrieve(expr.bound_expr) & if expr.sel_expr? then retrieve(expr.sel_expr) else {};


T* retrieve_from_nested_exprs(CondExpr expr, (Expr -> T*) retrieve) = retrieve(expr.expr) & retrieve(expr.cond);


T* retrieve_from_nested_exprs(ClsExpr expr, (Expr -> T*) retrieve):
  ClsVar      = {},
  fn_ptr()    = {},
  cls_expr()  = retrieve(expr.expr);


T* retrieve_from_nested_exprs(Statement stmt, (Expr -> T*) retrieve):
  assignment_stmt()   = retrieve(stmt.value),
  return_stmt(e?)     = retrieve(e),
  if_stmt()           = retrieve(stmt.cond) & retrieve_from_nested_exprs(stmt.body, retrieve) & retrieve_from_nested_exprs(stmt.else, retrieve),
  loop_stmt(ss?)      = retrieve_from_nested_exprs(ss, retrieve),
  foreach_stmt()      = retrieve(stmt.values) & retrieve_from_nested_exprs(stmt.body, retrieve),
  for_stmt()          = retrieve(stmt.start_val) & retrieve(stmt.end_val) & retrieve_from_nested_exprs(stmt.body, retrieve),
  let_stmt()          = union({retrieve(e) : _ => e <- stmt.asgnms}) & retrieve_from_nested_exprs(stmt.body, retrieve),
  break_stmt          = {},
  fail_stmt           = {},
  assert_stmt(e?)     = retrieve(e),
  print_stmt(e?)      = retrieve(e),
  imp_update_stmt()   = retrieve(stmt.idx) & retrieve(stmt.value),
  return_stmt         = {},
  proc_call()         = seq_union([retrieve(p) : p <- stmt.params]);


T* retrieve_from_nested_exprs([Statement] stmts, (Expr -> T*) retrieve) = seq_union([retrieve_from_nested_exprs(s, retrieve) : s <- stmts]);


T* retrieve_from_nested_exprs(Clause cls, (Expr -> T*) retrieve):
  in_clause()       = retrieve(cls.src),
  map_in_clause()   = retrieve(cls.src),
  and_clause()      = retrieve_from_nested_exprs(cls.left, retrieve) & retrieve_from_nested_exprs(cls.right, retrieve),
  or_clause()       = retrieve_from_nested_exprs(cls.left, retrieve) & retrieve_from_nested_exprs(cls.right, retrieve);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Expr replace_nested_exprs(Expr expr, (Expr -> Expr) replace):
  LeafObj           = expr,
  FloatLit          = expr,
  set_expr(ses?)    = set_expr({replace_exprs_in_subexpr(se, replace) : se <- ses}),
  seq_expr(ses?)    = seq_expr([replace_exprs_in_subexpr(se, replace) : se <- ses]),
  tuple_expr(es?)   = tuple_expr([replace(e) : e <- es]),
  seq_tail_expr()   = seq_tail_expr(replace(expr.seq), [replace(e) : e <- expr.tail]),
  map_expr(es?)     = map_expr({(key: replace(e.key), value: replace(e.value), cond: replace(e.cond) if e.cond?) : e <- es}),
  tag_obj_expr()    = tag_obj_expr(replace(expr.tag), replace(expr.obj)),
  Var               = expr,
  fn_call()         = fn_call(
                        expr.name,
                        [replace_exprs_in_any_expr(p, replace) : p <- expr.params],
                        (n => replace_exprs_in_any_expr(e, replace) : n => e <- expr.named_params)
                      ),
  cls_call()        = cls_call(expr.name, [replace(p) : p <- expr.params]),
  builtin_call()    = builtin_call(expr.name, [replace(p) : p <- expr.params]),
  and_expr()        = and_expr(replace(expr.left), replace(expr.right)),
  or_expr()         = or_expr(replace(expr.left), replace(expr.right)),
  not_expr(e?)      = not_expr(replace(e)),
  eq()              = eq(replace(expr.left), replace(expr.right)),
  membership()      = membership(replace(expr.obj), expr.type),
  cast_expr()       = cast_expr(replace(expr.expr), expr.type),
  accessor()        = accessor(replace(expr.expr), expr.field),
  accessor_test()   = accessor_test(replace(expr.expr), expr.field),
  if_expr()         = if_expr(replace(expr.cond), replace(expr.then), replace(expr.else)),
  match_expr()      = match_expr([replace(e) : e <- expr.exprs], [(ptrns: c.ptrns, expr: replace(c.expr)) : c <- expr.cases]),
  do_expr(ss?)      = do_expr(replace_exprs_in_stmts(ss, replace)),
  ex_qual()         = ex_qual(
                        source:   replace_exprs_in_clause(expr.source, replace),
                        sel_expr: replace(expr.sel_expr) if expr.sel_expr?
                      ),
  set_comp()        = set_comp(
                        expr:     replace(expr.expr),
                        source:   replace_exprs_in_clause(expr.source, replace),
                        sel_expr: replace(expr.sel_expr) if expr.sel_expr?
                      ),
  map_comp()        = map_comp(
                        key_expr:   replace(expr.key_expr),
                        value_expr: replace(expr.value_expr),
                        source:     replace_exprs_in_clause(expr.source, replace),
                        sel_expr:   replace(expr.sel_expr) if expr.sel_expr?
                      ),
  seq_comp()        = seq_comp(
                        expr:     replace(expr.expr),
                        vars:     expr.vars,
                        idx_var:  expr.idx_var if expr.idx_var?,
                        src_expr: replace(expr.src_expr),
                        sel_expr: replace(expr.sel_expr) if expr.sel_expr?
                      ),
  range_comp()      = range_comp(
                        expr:       replace(expr.expr),
                        var:        expr.var,
                        bound_expr: replace(expr.bound_expr),
                        inclusive:  expr.inclusive,
                        sel_expr:   expr.sel_expr if expr.sel_expr?
                      );


CondExpr replace_exprs_in_cond_expr(CondExpr expr, (Expr -> Expr) replace) = cond_expr(replace(expr.expr), replace(expr.cond));


ClsExpr replace_exprs_in_cls_expr(ClsExpr expr, (Expr -> Expr) replace):
  ClsVar      = expr,
  fn_ptr()    = expr,
  cls_expr()  = cls_expr(expr.params, replace(expr.expr));


SubExpr replace_exprs_in_subexpr(SubExpr subexpr, (Expr -> Expr) replace):
  CondExpr  = replace_exprs_in_cond_expr(subexpr, replace),
  Expr      = replace(subexpr);


AnyExpr replace_exprs_in_any_expr(AnyExpr expr, (Expr -> Expr) replace):
  ClsExpr   = replace_exprs_in_cls_expr(expr, replace),
  Expr      = replace(expr);


Statement replace_exprs_in_stmt(Statement stmt, (Expr -> Expr) replace):
  assignment_stmt()   = assignment_stmt(stmt.vars, replace(stmt.value)),
  return_stmt(e?)     = return_stmt(replace(e)),
  if_stmt()           = if_stmt(
                          replace(stmt.cond),
                          replace_exprs_in_stmts(stmt.body, replace),
                          replace_exprs_in_stmts(stmt.else, replace)
                        ),
  loop_stmt(ss?)      = loop_stmt(replace_exprs_in_stmts(ss, replace)),
  foreach_stmt()      = foreach_stmt(
                          vars:     stmt.vars,
                          idx_var:  stmt.idx_var if stmt.idx_var?,
                          values:   replace(stmt.values),
                          body:     replace_exprs_in_stmts(stmt.body, replace)
                        ),
  for_stmt()          = for_stmt(
                          var:          stmt.var if stmt.var?,
                          start_val:    replace(stmt.start_val),
                          end_val:      replace(stmt.end_val),
                          end_val_incl: stmt.end_val_incl,
                          body:         replace_exprs_in_stmts(stmt.body, replace)
                        ),
  let_stmt()          = let_stmt((n => replace(e) : n => e <- stmt.asgnms), replace_exprs_in_stmts(stmt.body, replace)),
  break_stmt          = break_stmt,
  fail_stmt           = fail_stmt,
  assert_stmt(e?)     = assert_stmt(replace(e)),
  print_stmt(e?)      = print_stmt(replace(e)),
  imp_update_stmt()   = imp_update_stmt(stmt.obj, replace(stmt.idx), replace(stmt.value)),
  return_stmt         = return_stmt,
  proc_call()         = proc_call(
                          res_var:    stmt.res_var if stmt.res_var?,
                          proc_name:  stmt.proc_name,
                          params:     [replace(p) : p <- stmt.params]
                        );


<[]> replace_exprs_in_stmts(<[]>, (Expr -> Expr) replace) = [];

[Statement^] replace_exprs_in_stmts([Statement^] stmts, (Expr -> Expr) replace) = [replace_exprs_in_stmt(s, replace) : s <- stmts];


Clause replace_exprs_in_clause(Clause cls, (Expr -> Expr) replace):
  in_clause()       = in_clause(cls.ptrn, replace(cls.src)),
  map_in_clause()   = map_in_clause(cls.key_ptrn, cls.value_ptrn, replace(cls.src)),
  and_clause()      = and_clause(replace_exprs_in_clause(cls.left, replace), replace_exprs_in_clause(cls.right, replace)),
  or_clause()       = or_clause(replace_exprs_in_clause(cls.left, replace), replace_exprs_in_clause(cls.right, replace));

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Expr replace_external_vars(Expr expr, (Var => Var) subst_map):
  Var           = lookup(subst_map, expr, expr),
  fn_call()     = replace_external_vars_in_fn_call(expr, subst_map),
  match_expr()  = replace_external_vars_in_match_exprs(expr, subst_map),
  do_expr()     = replace_external_vars_in_do_expr(expr, subst_map),
  ex_qual()     = replace_external_vars_in_ex_qual(expr, subst_map),
  set_comp()    = replace_external_vars_in_set_comp(expr, subst_map),
  map_comp()    = replace_external_vars_in_map_comp(expr, subst_map),
  seq_comp()    = replace_external_vars_in_seq_comp(expr, subst_map),
  range_comp()  = replace_external_vars_in_range_comp(expr, subst_map),
  _             = replace_nested_exprs(expr, replace_external_vars($, subst_map));


Expr replace_external_vars_in_fn_call(FnCallExpr expr, (Var => Var) subst_map) =
  fn_call(
    expr.name,
    [replace_external_vars(p, subst_map) : p <- expr.params],
    (n => replace_external_vars(e, subst_map) : n => e <- expr.named_params)
  );


Expr replace_external_vars_in_match_exprs(MatchExpr expr, (Var => Var) subst_map)
{
  new_exprs = [replace_external_vars(e, subst_map) : e <- expr.exprs];
  new_cases = [];
  for (c : expr.cases)
    new_vars = seq_union([new_vars(p) : p <- c.ptrns]);
    assert disjoint(new_vars, keys(subst_map));
    new_subst_map = remove_keys(subst_map, new_vars);
    new_expr = replace_external_vars(c.expr, new_subst_map);
    new_cases = [new_cases | (ptrns: c.ptrns, expr: new_expr)];
  ;
  return match_expr(new_exprs, nonempty(new_cases));
}


Expr replace_external_vars_in_do_expr(DoExpr expr, (Var => Var) subst_map)
{
  fail; //## IMPLEMENT
}


Expr replace_external_vars_in_ex_qual(ExQualExpr expr, (Var => Var) subst_map)
{
  new_vars = new_vars(expr.source);
  assert disjoint(new_vars, keys(subst_map));
  new_subst_map = remove_keys(subst_map, new_vars);
  return ex_qual(
    source:     replace_external_vars_in_clause(expr.source, subst_map),
    sel_expr:   replace_external_vars(expr.sel_expr, new_subst_map) if expr.sel_expr?
  );
}


Expr replace_external_vars_in_set_comp(SetCompExpr expr, (Var => Var) subst_map)
{
  new_vars = new_vars(expr.source);
  assert disjoint(new_vars, keys(subst_map));
  new_subst_map = remove_keys(subst_map, new_vars);
  return set_comp(
    expr:       replace_external_vars(expr.expr, new_subst_map),
    source:     replace_external_vars_in_clause(expr.source, subst_map),
    sel_expr:   replace_external_vars(expr.sel_expr, new_subst_map) if expr.sel_expr?
  );
}


Expr replace_external_vars_in_map_comp(MapCompExpr expr, (Var => Var) subst_map)
{
  new_vars = new_vars(expr.source);
  assert disjoint(new_vars, keys(subst_map));
  new_subst_map = remove_keys(subst_map, new_vars);
  return map_comp(
    key_expr:   replace_external_vars(expr.key_expr, new_subst_map),
    value_expr: replace_external_vars(expr.value_expr, new_subst_map),
    source:     replace_external_vars_in_clause(expr.source, subst_map),
    sel_expr:   replace_external_vars(expr.sel_expr, new_subst_map) if expr.sel_expr?
  );
}


Expr replace_external_vars_in_seq_comp(SeqCompExpr expr, (Var => Var) subst_map)
{
  redef_vars = set(expr.vars) & {expr.idx_var if expr.idx_var?};
  assert disjoint(keys(subst_map), redef_vars);
  new_subst_map = remove_keys(subst_map, redef_vars);
  return seq_comp(
    expr:     replace_external_vars(expr.expr, new_subst_map),
    vars:     expr.vars,
    idx_var:  expr.idx_var if expr.idx_var?,
    src_expr: expr.src_expr,
    sel_expr: replace_external_vars(expr.sel_expr, new_subst_map) if expr.sel_expr?
  );
}


Expr replace_external_vars_in_range_comp(RangeCompExpr expr, (Var => Var) subst_map)
{
  assert not in(expr.var, keys(subst_map));
  new_subst_map = remove_key(subst_map, expr.var);
  return range_comp(
    expr:       replace_external_vars(expr.expr, new_subst_map),
    var:        expr.var,
    bound_expr: expr.bound_expr,
    inclusive:  expr.inclusive,
    sel_expr:   replace_external_vars(expr.sel_expr, new_subst_map) if expr.sel_expr?
  );
}


ClsExpr replace_external_vars(ClsExpr expr, (Var => Var) subst_map):
  ClsVar      = expr,
  fn_ptr()    = expr,
  cls_expr()  = replace_external_vars(expr.params, expr.expr, subst_map);


ClsExpr replace_external_vars([<var(Atom), nil>^] params, Expr expr, (Var => Var) subst_map)
{
  non_anon_params = set([p : p <- params, p /= nil]);

  // We cannot replace variables inside a closure with fn_par(n),
  // because those names refer to different variables inside the closure.
  // Same goes for the non-anonymous closure parameters.
  //## THIS HAS TO BE FIXED SOMEHOW...
  assert not (? _ => vv <- subst_map : vv :: FnPar or in(vv, non_anon_params));

  new_subst_map = (kv => vv : kv => vv <- subst_map, not in(kv, non_anon_params), not kv :: FnPar);
  return cls_expr(params, replace_external_vars(expr, new_subst_map));
}


Clause replace_external_vars_in_clause(Clause clause, (Var => Var) subst_map):
  in_clause()       = replace_external_vars_in_in_clause(clause.ptrn, clause.src, subst_map),
  map_in_clause()   = replace_external_vars_in_map_in_clause(clause.key_ptrn, clause.value_ptrn, clause.src, subst_map),
  and_clause()      = replace_external_vars_in_and_clause(clause.left, clause.right, subst_map),
  or_clause()       = replace_external_vars_in_or_clause(clause.left, clause.right, subst_map);


Clause replace_external_vars_in_in_clause(Pattern ptrn, Expr src, (Var => Var) subst_map)
{
  assert disjoint(new_vars(ptrn), keys(subst_map));
  new_src = replace_external_vars(src, subst_map);
  return in_clause(ptrn, new_src);
}


Clause replace_external_vars_in_map_in_clause(Pattern key_ptrn, Pattern value_ptrn, Expr src, (Var => Var) subst_map)
{
  assert disjoint(new_vars(key_ptrn) & new_vars(value_ptrn), keys(subst_map));
  new_src = replace_external_vars(src, subst_map);
  return map_in_clause(key_ptrn, value_ptrn, new_src);
}


Clause replace_external_vars_in_and_clause(Clause left_clause, Clause right_clause, (Var => Var) subst_map)
{
  new_left_clause = replace_external_vars_in_clause(left_clause, subst_map);
  new_subst_map = remove_keys(subst_map, new_vars(left_clause));
  new_right_clause = replace_external_vars_in_clause(right_clause, subst_map);
  return and_clause(new_left_clause, new_right_clause);
}


Clause replace_external_vars_in_or_clause(Clause left_clause, Clause right_clause, (Var => Var) subst_map)
{
  new_left_clause = replace_external_vars_in_clause(left_clause, subst_map);
  new_right_clause = replace_external_vars_in_clause(right_clause, subst_map);
  return or_clause(new_left_clause, new_right_clause);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Var* pattern_vars(Pattern ptrn):
  ptrn_tag_obj()    = pattern_vars(ptrn.tag) & pattern_vars(ptrn.obj),
  ptrn_var()        = {ptrn.var} & pattern_vars(ptrn.ptrn),
  ptrn_union(ps?)   = union({pattern_vars(p) : p <- ps}), //## SINCE PATTERNS IN A UNION ARE SUPPOSED TO DEFINE THE SAME SET OF VARIABLES, IT SHOULD BE FINE TO JUST PICK ONE ELEMENT OF THE UNION AND RETURN ITS VARIABLES
  _                 = {};


//## BUG BUG BUG: THIS IS INCOMPLETE, A PATTERN UNION COULD BE A PATTERN "ANY" TOO
Bool is_pattern_any(Pattern ptrn):
  ptrn_any    = true,
  _           = false;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Expr* ordinary_subexprs(Expr expr):
  object()        = {},
  seq_expr(ses?)  = union({subexprs(e) : e <- set(ses)}),
  tuple_expr(es?) = set(es),
  seq_tail_expr() = {expr.seq} & union({subexprs(e) : e <- set(expr.tail)}),
  set_expr(ses?)  = union({subexprs(e) : e <- ses}),
  map_expr(es?)   = union({{e.key, e.value, e.cond if e.cond?} : e <- es}),
  tag_obj_expr()  = {expr.tag, expr.obj},
  Var             = {},
  fn_call()       = {},
  cls_call()      = set(expr.params), //## BAD
  builtin_call()  = set(expr.params), //## BAD
  and_expr()      = {expr.left, expr.right},
  or_expr()       = {expr.left, expr.right}, //## BAD
  not_expr(e?)    = {e},
  eq()            = {expr.left, expr.right}, //## BAD
  membership()    = {expr.obj},
  cast_expr()     = {expr.expr},
  accessor()      = {expr.expr},
  accessor_test() = {expr.expr},
  if_expr()       = {expr.cond, expr.then, expr.else},
  // Expression that contain "special" subexpressions
  ex_qual()       = {},
  set_comp()      = {},
  map_comp()      = {},
  seq_comp()      = {expr.src_expr},
  range_comp()    = {expr.bound_expr},
  // Expression that require special treatment
  match_expr()    = set(expr.exprs),
  do_expr()       = {};

//## FIND BETTER NAME
Expr* subexprs(Expr expr)     = {expr};
Expr* subexprs(CondExpr expr) = {expr.expr, expr.cond};

Expr* special_subexprs(Expr expr):
  ex_qual()       = {expr.sel_expr if expr.sel_expr?},
  set_comp()      = {expr.expr, expr.sel_expr if expr.sel_expr?},
  map_comp()      = {expr.key_expr, expr.value_expr, expr.sel_expr if expr.sel_expr?},
  seq_comp()      = {expr.expr, expr.sel_expr if expr.sel_expr?}, //## BAD
  range_comp()    = {expr.expr, expr.sel_expr if expr.sel_expr?},
  _               = {};

Var* gen_vars(Expr expr):
  ex_qual()       = new_vars(expr.source),
  set_comp()      = new_vars(expr.source), //## BAD
  map_comp()      = new_vars(expr.source), //## BAD
  seq_comp()      = set(expr.vars) & {expr.idx_var if expr.idx_var?},
  range_comp()    = {expr.var},
  _               = {};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//## IS THIS CODE OK? IN CALCULATING THE NEW VARS, IT DOESN'T
//## CONSIDER THE VARIABLES THAT ARE ALREADY DEFINED

StdVar* new_vars(Pattern ptrn):
  ptrn_var()      = new_vars(ptrn.ptrn) & {ptrn.var},
  ptrn_tag_obj()  = new_vars(ptrn.tag) & new_vars(ptrn.obj),
  ptrn_union(ps?) = union({new_vars(p) : p <- ps}),
  _               = {};

StdVar* new_vars(Clause clause):
  in_clause()         = new_vars(clause.ptrn),
  map_in_clause()     = new_vars(clause.key_ptrn) & new_vars(clause.value_ptrn),
  and_clause()        = new_vars(clause.left) & new_vars(clause.right),
  or_clause()         = intersection(new_vars(clause.left), new_vars(clause.right));

Var* new_vars(Statement stmt):
  assignment_stmt() = set(stmt.vars),
  if_stmt()         = intersection({new_vars(stmt.body) if may_fall_through(stmt.body), new_vars(stmt.else) if may_fall_through(stmt.else)}),
  let_stmt()        = new_vars(stmt.body),
  proc_call()       = {stmt.res_var if stmt.res_var?},
  _                 = {};

Var* new_vars([Statement] stmts) = seq_union([new_vars(s) : s <- stmts]);

///////////////////////////////////////////////////////////////////////////////

Var* extern_vars(Expr expr)
{
  ord_expr_evs  = union({extern_vars(e) : e <- ordinary_subexprs(expr)});
  spec_expr_evs = union({extern_vars(e) : e <- special_subexprs(expr)}) - gen_vars(expr);
  spec_case_evs = special_cases(expr);

  return ord_expr_evs & spec_expr_evs & spec_case_evs;

  Var* special_cases(Expr expr):
      Var            = {expr},
      fn_call()      = union({extern_vars(e) : e <- set(expr.params)} & {extern_vars(e) : k => e <- expr.named_params}),
      ex_qual()      = extern_vars(expr.source),
      set_comp()     = extern_vars(expr.source), //## BAD
      map_comp()     = extern_vars(expr.source), //## BAD
      do_expr(ss?)   = extern_vars(ss),
      match_expr()   = { vs = {};
                         for (c : expr.cases)
                           pvs = seq_union([new_vars(p) : p <- c.ptrns]);
                           vs  = vs & (extern_vars(c.expr) - pvs);
                         ;
                         return vs;
                       },

      _              = {};
}


Var* extern_vars(Clause clause):
  in_clause()         = extern_vars(clause.src),
  map_in_clause()     = extern_vars(clause.src),
  and_clause()        = extern_vars(clause.left) & (extern_vars(clause.right) - new_vars(clause.left)),
  or_clause()         = extern_vars(clause.left) & extern_vars(clause.right);


Var* extern_vars([Statement] stmts)
{
  //## BUG BUG WHY IS THIS FUNCTION NEVER CALLED?
  def_vs = {};
  ext_vs = {};
  for (s : stmts)
    ext_vs = ext_vs & (extern_vars(s) - def_vs);
    def_vs = def_vs & new_vars(s);
  ;
  return ext_vs;
}


Var* extern_vars(Statement s):
  assignment_stmt() = extern_vars(s.value),
  return_stmt       = {},
  return_stmt(e?)   = extern_vars(e),
  if_stmt()         = extern_vars(s.cond) & extern_vars(s.body) & extern_vars(s.else),
  loop_stmt(ss?)    = extern_vars(ss),
  foreach_stmt()    = extern_vars(s.values) & (extern_vars(s.body) - (set(s.vars) & {s.idx_var if s.idx_var?})),
  for_stmt()        = extern_vars(s.start_val) & extern_vars(s.end_val) & (extern_vars(s.body) - {s.var if s.var?}),
  break_stmt        = {},
  fail_stmt         = {},
  assert_stmt(e?)   = extern_vars(e),
  print_stmt(e?)    = extern_vars(e),
  imp_update_stmt() = {s.obj} & extern_vars(s.idx) & extern_vars(s.value),
  proc_call()       = seq_union([extern_vars(p) : p <- s.params]);


Var* extern_vars(ClsExpr expr):
  ClsVar      = {},
  fn_ptr()    = {},
  cls_expr()  = extern_vars(expr.expr) - set([v : v <- expr.params, v /= nil] & [fn_par(i) : i < length(expr.params)]);

////////////////////////////////////////////////////////////////////////////////

type StmtOutcome = fails, returns, breaks, falls_through;


StmtOutcome+ outcomes([Statement] stmts)
{
  outcomes = {:falls_through};
  for (s : stmts)
    outcomes = (outcomes - {:falls_through}) & outcomes(s);
    break if not in(:falls_through, outcomes);
  ;
  return nonempty(outcomes);
}


StmtOutcome+ outcomes(Statement stmt):
  assignment_stmt() = {:fails, :falls_through},
  return_stmt       = {:returns},
  return_stmt()     = {:fails, :returns},
  if_stmt()         = nonempty({:fails} & outcomes(stmt.body) & outcomes(stmt.else)), // Shutting up the type checker
  loop_stmt(body?)  = {
    outcomes = outcomes(body);
    // Failures and returns in the body are transferred to the loop.
    // Fall throughs in the body are neutralized by the loop, but they
    // create the possibility of an infinite loop, which counts as failure.
    outcomes = (outcomes - {:falls_through}) & {:fails} if in(:falls_through, outcomes);
    // A break in the body becomes a fall through for the loop itself
    outcomes = (outcomes - {:breaks}) & {:falls_through} if in(:breaks, outcomes);
    return nonempty(outcomes); // Shutting up the type checker
  },
  foreach_stmt()    = nonempty({:fails, :falls_through} & outcomes(stmt.body) - {:breaks}), // Shutting up the type checker
  for_stmt()        = nonempty({:fails, :falls_through} & outcomes(stmt.body) - {:breaks}), // Shutting up the type checker //## BAD: SAME AS ABOVE
  let_stmt()        = nonempty({:fails} & outcomes(stmt.body)), // Shutting up the type checker
  break_stmt        = {:breaks},
  fail_stmt         = {:fails},
  assert_stmt()     = {:falls_through, :fails},
  print_stmt()      = {:falls_through, :fails},
  imp_update_stmt() = {:falls_through, :fails},
  proc_call()       = {:falls_through, :fails};

////////////////////////////////////////////////////////////////////////////////

Bool may_fall_through(Statement stmt) = in(:falls_through, outcomes(stmt));

Bool may_fall_through([Statement] stmts) = in(:falls_through, outcomes(stmts));

////////////////////////////////////////////////////////////////////////////////

(BuiltIn => NzNat) builtin_arities = (
  neg:         1,
  add:         2,
  sub:         2,
  mult:        2,
  div:         2,
  mod:         2,
  lt:          2,
  le:          2,
  gt:          2,
  ge:          2,
  str:         1,
  symb:        1,
  at:          2,
  len:         1,
  slice:       3,
  cat:         2,
  mcat:        1,
  rev:         1,
  set:         1,
  mset:        1,
  isort:       1,
  list_to_seq: 1,
  tag:         1,
  obj:         1,
  in:          2,
  has_key:     2,
  lookup:      2,
  union:       1,
  merge:       1,
  fneg:        1,
  fadd:        2,
  fsub:        2,
  fmult:       2,
  fdiv:        2,
  fsqrt:       1,
  floor:       1,
  ceiling:     1,
  float:       1,
  mantissa:    1,
  dec_exp:     1,
  rand_nat:    1,
  rand_elem:   1,
  counter:     1,
  ticks:       1,
  attach:      2,
  fetch:       1
);

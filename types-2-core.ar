
type Obj        = object(Any);

type SymbObj    = object(Atom);
type IntObj     = object(Int);
type LeafObj    = object(<Atom, Int>);

///////////////////////////////////////////////////////////////////////////////

type BasicTypeSymbol  = type_symbol(Atom), builtin_type_symbol(Atom);
type ParTypeSymbol    = par_type_symbol(symbol: BasicTypeSymbol, params: [Type^]); //## TOO LOOSE A TYPE, I THINK. MAYBE builtin_type_symbol() SHOULD BE PART OF TypeSymbol, NOT BasicTypeSymbol
type TypeSymbol       = BasicTypeSymbol, ParTypeSymbol;

type TypeName         = type_name(symbol: BasicTypeSymbol, arity: Nat);

///////////////////////////////////////////////////////////////////////////////

type SymbType           = symb_type(SymbObj);

type IntType            = integer, low_ints(max: Int), high_ints(min: Int), int_range(min: Int, size: NzNat);

type FloatType          = float_type;

type LeafType           = atom_type, SymbType, IntType, FloatType, empty_seq_type, empty_set_type, empty_map_type;

type TypeVar            = type_var(<Atom, Nat>);

type TypeRef            = type_ref(TypeSymbol);

type NeSeqType          = ne_seq_type(elem_type: NeType);

type NeSetType          = ne_set_type(elem_type: NeType);

type NeMapType          = ne_map_type(key_type: NeType, value_type: NeType);

type RecordTypeFields   = (SymbObj => (type: NeType, optional: Bool));
type RecordType         = record_type(RecordTypeFields);

type TupleType          = tuple_type([NeType^]);

type TagType            = SymbType, atom_type;
type TagObjType         = tag_obj_type(tag_type: TagType, obj_type: NeType);

type UnionType          = union_type(NeType+);

type NeType             = LeafType, TypeRef, TypeVar, NeSeqType, NeSetType, NeMapType,
                          RecordType, TupleType, TagObjType, UnionType;

type Type               = empty_type, NeType;

///////////////////////////////////////////////////////////////////////////////

type ClsType  = cls_type(in_types: [Type^], out_type: Type);
type AnyType  = Type, ClsType;

type FnType   = fn_type(
                  params:       [AnyType],
                  named_args:   (NamedArg => AnyType),
                  ret_type:     Type
                );

type BuiltInType  = builtin_type(param_types: [Type^], ret_type: Type);

///////////////////////////////////////////////////////////////////////////////

type SubtypeDecl  = subtype_decl(subtype: Type, supertype: Type);

///////////////////////////////////////////////////////////////////////////////

type Operator = plus, minus, star, slash, exp, amp, lower, greater, lower_eq, greater_eq, brackets;

type BuiltIn  = neg, add, sub, mult, div, mod, lt, le, gt, ge, str, symb, at, len, slice, cat, mcat,
                set, rev, mset, isort, list_to_seq, tag, obj, in, has_key, lookup, union, merge,
                fneg, fadd, fsub, fmult, fdiv, fsqrt, floor, ceiling, float, mantissa, dec_exp,
                rand_nat, rand_elem, counter, attach, fetch, ticks;

type FnSymbol = fn_symbol(Atom),
                op_symbol(Operator),
                //## BUG: AN FnSymbol IS NOT ENOUGH TO IDENTIFY WHICH WAS THE OUTER FUNCTION.
                //## TWO FUNCTIONS WITH THE SAME NAME COULD CONTAIN INNER FUNCTIONS WITH THE SAME NAME
                nested_fn_symbol(outer: FnSymbol, inner: FnSymbol),
                unique_fn_symbol(symbol: FnSymbol, id: Nat); //## THE symbol: FIELD SHOULD ONLY CONTAIN EITHER fn_symbol() OR op_symbol()

type MethodSymbol = msg_handler, method_symbol(Atom);

type AutoSymbol   = auto_symbol(Atom);

type StdVar           = var(Atom);
type FnPar            = fn_par(Nat);
type NamedArg         = named_arg(Atom);
type CaptVar          = cls_ext_par(Nat); //## RENAME THIS. BESIDES, DO I NEED IT HERE? OR IS IT ONLY USED IN THE LAYER 3?
type MembVar          = memb_var(Atom);
type MembCopyVar      = memb_copy_var(Atom);      //## FIND BETTER NAME...
type PendingStateVar  = pending_state_var(Atom);  //## FIND BETTER NAME...

type LocAutoVar   = loc_auto_var(Atom);
type MembAutoVar  = memb_auto_var(Atom);
type AnyAutoVar   = LocAutoVar, MembAutoVar;

type Var      = StdVar, FnPar, NamedArg, CaptVar, MembVar, MembCopyVar, PendingStateVar;

type ClsVar   = cls_var(<Atom, Nat>); //## BAD: THERE SHOULD BE A NAMED VERSION OF ClsVar

type CondExpr = cond_expr(expr: Expr, cond: Expr);

type SubExpr  = Expr, CondExpr;

type FloatLit = float_lit(mantissa: Int, dec_exp: Int);

type Expr     = LeafObj, FloatLit, Var,
                SetExpr, SeqExpr, TupleExpr, SeqTailExpr, MapExpr, TagObjExpr,
                FnCallExpr, ClsCall, BuiltinCall,
                AndExpr, OrExpr, NotExpr,
                EqExpr,
                MembExpr, CastExpr,
                AccExpr, AccTestExpr,
                GetOutputExpr, OutputIsSetExpr, OutputIsDefExpr,
                IfExpr, MatchExpr, DoExpr,
                ExQualExpr, SetCompExpr, MapCompExpr,
                SeqCompExpr, RangeCompExpr,
                IsSetExpr;

type SetExpr        = set_expr(SubExpr*);
type SeqExpr        = seq_expr([SubExpr]);
type TupleExpr      = tuple_expr([Expr^]);
type SeqTailExpr    = seq_tail_expr(seq: Expr, tail: [Expr^]);
type MapExpr        = map_expr((key: Expr, value: Expr, cond: Expr?)*);
type TagObjExpr     = tag_obj_expr(tag: Expr, obj: Expr);

//## CAN LOCAL FUNCTIONS HAVE NAMED PARAMETERS? IT WOULDN'T MAKE MUCH SENSE,
//## BUT THE DATA STRUCTURE AND THE SYNTAX ALLOW IT. MAKE SURE IT'S CHECHED
//## IN THE WELL-FORMEDNESS CHECKING LAYER.
type FnCallExpr     = fn_call(name: FnSymbol, params: [AnyExpr], named_args: (NamedArg => AnyExpr)); //## NO POINT USING NamedArg INSTEAD OF JUST Atom HERE
type ClsCall        = cls_call(name: <ClsVar, NamedArg>, params: [Expr^]);  //## BAD: THERE SHOULD BE A NAMED VERSION OF ClsVar
type BuiltinCall    = builtin_call(name: BuiltIn, params: [Expr^]); //## CAN A BUILTIN HAVE NO ARGUMENTS?

type AndExpr        = and_expr(left: Expr, right: Expr); //## NOT SURE HERE
type OrExpr         = or_expr(left: Expr, right: Expr);  //## NOT SURE HERE
type NotExpr        = not_expr(Expr);                    //## NOT SURE HERE

type EqExpr         = eq(left: Expr, right: Expr);

type MembExpr       = membership(obj: Expr, type: Type);
type CastExpr       = cast_expr(expr: Expr, type: Type);

type AccExpr        = accessor(expr: Expr, field: SymbObj);      //## SHOULD <field> BE AN OBJECT OR JUST A PLAIN SYMBOL?
type AccTestExpr    = accessor_test(expr: Expr, field: SymbObj); //## DITTO

type GetOutputExpr    = get_output(var: AnyAutoVar, output: Atom);
type OutputIsSetExpr  = output_is_set(var: AnyAutoVar, output: Atom);
type OutputIsDefExpr  = output_is_def(var: LocAutoVar, output: Atom);

type IfExpr         = if_expr(cond: Expr, then: Expr, else: Expr);
type MatchExpr      = match_expr(exprs: [Expr^], cases: [(ptrns: [Pattern^], expr: Expr)^]);
type DoExpr         = do_expr([Statement^]);

type ExQualExpr     = ex_qual(source: Clause, cond: Expr);
type SetCompExpr    = set_comp(expr: Expr, source: Clause);
type MapCompExpr    = map_comp(key_expr: Expr, value_expr: Expr, source: Clause);

type SeqCompExpr    = seq_comp(expr: Expr, vars: [StdVar^], idx_var: StdVar?, src_expr: Expr, sel_expr: Expr?);
type RangeCompExpr  = range_comp(expr: Expr, var: StdVar, bound_expr: Expr, inclusive: Bool, sel_expr: Expr?);

type IsSetExpr      = is_set(MembVar);

///////////////////////////////////////////////////////////////////////////////

type ClsExpr  = ClsVar,
                fn_ptr(name: FnSymbol, arity: NzNat),
                cls_expr(params: [<var(Atom), nil>^], expr: Expr); //## REPLACE params WITH arity, SINCE THERE'S NO WAY IN THE SYNTAX TO ACTUALLY NAME THE PARAMETERS OF A CLOSURE?

type AnyExpr  = Expr, ClsExpr;

///////////////////////////////////////////////////////////////////////////////

type Pattern  = ptrn_symbol, //## THE CORRESPONDING TYPE IS CALLED atom_type. RENAME ONE OF THE TWO?
                ptrn_float,
                ptrn_empty_set,
                ptrn_ne_set,
                ptrn_empty_seq,
                ptrn_ne_seq,
                ptrn_empty_map,
                ptrn_ne_map,
                ptrn_any,
                ptrn_symbol(SymbObj),
                ptrn_integer(IntType),
                ptrn_tag_obj(tag: TagPtrn, obj: Pattern),
                ptrn_var(var: StdVar, ptrn: Pattern),
                //## REMEMBER TO ENFORCE THE RULES BELOW. AT LEAST ONE PIECE OF CODE,
                //## THE ONE THAT CALCULATES A SUPERSET OF THE INTERSECTION BETWEEN A
                //## TYPE AND A PATTERN DEPENDS ON THE FIRST ASSUMPTION
                // Patterns in a union must be pseudotype-compatible.
                // They must also define the same set of variables
                ptrn_union(Pattern+);


type TagPtrn  = ptrn_symbol, ptrn_symbol(SymbObj), ptrn_var(var: StdVar, ptrn: ptrn_symbol);

////////////////////////////////////////////////////////////////////////////////

type Clause   = set_elem_clause(var: StdVar, src: Expr),
                map_entry_clause(key_var: StdVar, value_var: StdVar, src: Expr),
                seq_elem_clause(var: StdVar, src: Expr),
                and_clause(left: Clause, right: Clause),
                or_clause(left: Clause, right: Clause),
                match_clause(ptrn: Pattern, expr: Expr),
                asgnm_clause(var: StdVar, expr: Expr),
                filter_clause(Expr);

////////////////////////////////////////////////////////////////////////////////

type Statement  = assignment_stmt(vars: [StdVar^], value: Expr),
                  return_stmt(Expr),
                  if_stmt(cond: Expr, body: [Statement^], else: [Statement]),
                  loop_stmt([Statement^]),
                  foreach_stmt(vars: [StdVar^], idx_var: StdVar?, values: Expr, body: [Statement^]),
                  for_stmt(var: StdVar?, start_val: Expr, end_val: Expr, end_val_incl: Bool, body: [Statement^]),
                  let_stmt(asgnms: (NamedArg => Expr), body: [Statement^]), //## BAD
                  break_stmt,
                  fail_stmt,
                  assert_stmt(cond: Expr, file: String, line: NzNat, text: Maybe[String]),
                  print_stmt(Expr),
                  imp_update_stmt(obj: StdVar, idx: Expr, value: Expr),
                  //## BAD: MIXING PURE AND IMPURE STATEMENTS
                  return_stmt,
                  proc_call(res_var: StdVar?, proc_name: ProcSymbol, params: [Expr]),
                  auto_set_input_stmt(var: LocAutoVar, input: Atom, value: Maybe[Expr]),
                  SetMembVarStmt, MethodCallStmt,
                  AutoUpdateStmt;

type SetMembVarStmt   = set_memb_var_stmt(var: PendingStateVar, value: Expr);
type MethodCallStmt   = method_call_stmt(var: AnyAutoVar?, channel: Atom, args: [Expr]);

type AutoUpdateStmt = auto_update_stmt(var: LocAutoVar, elapsed_time: Expr?);

///////////////////////////////////////////////////////////////////////////////

type ScalarFrmParam = scalar_par(var: var(Atom)?, type: Type?);
type ClsFrmParam    = non_scalar_par(var: ClsVar?, arity: NzNat, type: ClsType?); //## BAD: THE VAR AND TYPE FIELDS HERE ARE OPTIONAL ONLY TO ALLOW MERGING OF FUNCTIONS WITH DIFFERENT ARITIES. ALSO, ARITY IS REDUNDANT WHEN TYPE IS PRESENT. CHECK THIS IN THE WELL-FORMEDNESS CHECKING LAYER. ALSO, REALLY BAD NAME.

type FnFrmPar   = ScalarFrmParam, ClsFrmParam;

type FnDef      = fn_def(
                    name:         FnSymbol,
                    params:       [FnFrmPar], //## BAD BAD
                    named_args:   (NamedArg => AnyType), //## BAD: THE TYPE IS TOO LOOSE. INCLUDE A CHECK IN THE WELL-FORMEDNESS CHECKING LAYER
                    res_type:     Type?,
                    expr:         Expr
                  );

type ProcSymbol = proc_symbol(Atom);

//## SERIOUSLY, FIND BETTER NAME...
type ProcDef2   = proc_def(
                    name:             ProcSymbol,
                    params:           [(var: StdVar, type: Type)],
                    res_type:         Maybe[Type],
                    auto_vars_types:  (LocAutoVar => AutoSymbol),
                    body:             [Statement]
                  );

///////////////////////////////////////////////////////////////////////////////

type BasicTimeExpr  = at_least(nanosecs: Nat),
                      time_neg(BasicTimeExpr),
                      time_and(left: BasicTimeExpr, right: BasicTimeExpr),
                      time_or(left: BasicTimeExpr, right: BasicTimeExpr);

type CyclicTimeExpr = every(expr: BasicTimeExpr, nanosecs: NzNat);

type TimeExpr       = BasicTimeExpr, CyclicTimeExpr;

type AutoUpdate         = update(target: Atom, value: Expr);
type AutoSetDiscrete    = set_discrete(target: Atom, value: Expr);
type AutoMethodCall     = method_call(target: MembAutoVar, method: MethodSymbol, message: Expr);

type AutoAtomicAction   = AutoUpdate, AutoSetDiscrete, AutoMethodCall;

type AutoCondAction     = cond_action(cond: Expr, body: AutoAnyCondAction*, else: AutoAnyCondAction*);
type AutoAnyCondAction  = AutoAtomicAction, AutoCondAction;

type AutoRepAction      = rep_action(cond: Expr, body: AutoAnyRepAction*, else: AutoAnyRepAction*);
type AutoAnyRepAction   = AutoAtomicAction, AutoRepAction;

type Method             = method(
                            name:     MethodSymbol,
                            args:     [(Type, StdVar)],
                            body:     [Statement]
                          );

type TimeVaryingCond    = time_varying_cond(cond: Expr, time_expr: TimeExpr);

type Automaton  = automaton(
                    name:         AutoSymbol,
                    pos_params:   [Atom],
                    inputs:       (Atom => (type: NeType, discrete: Bool)),
                    outputs:      (Atom => (type: NeType, discrete: Bool)),
                    state:        (Atom => (type: NeType, init_value: Expr)),
                    params:       (Atom => Expr),
                    rules:        (Atom => Expr),
                    time_rules:   (Atom => TimeVaryingCond),
                    actions:      AutoCondAction*,
                    rep_actions:  AutoRepAction*,
                    nested_autos: (Atom => (type: AutoSymbol, args: (Atom => Expr))),
                    methods:      Method*
                  );

///////////////////////////////////////////////////////////////////////////////

type Program    = program(
                    typedefs:       (TypeName => Type),
                    subtype_decls:  SubtypeDecl*,
                    fndefs:         FnDef*,
                    proc_defs:      ProcDef2*,
                    auto_defs:      Automaton*
                  );

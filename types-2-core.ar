type Obj        = object(Any);

type SymbObj    = object(Atom);
type IntObj     = object(Int);
type LeafObj    = object(<Atom, Int>);

///////////////////////////////////////////////////////////////////////////////

type BasicTypeSymbol  = type_symbol(Atom), builtin_type_symbol(any);
type ParTypeSymbol    = par_type_symbol(symbol: BasicTypeSymbol, params: Type+); //## TOO LOOSE A TYPE, I THINK. MAYBE builtin_type_symbol() SHOULD BE PART OF TypeSymbol, NOT BasicTypeSymbol
type TypeSymbol       = BasicTypeSymbol, ParTypeSymbol;

type TypeName         = type_name(symbol: BasicTypeSymbol, arity: Nat);

///////////////////////////////////////////////////////////////////////////////

type SymbType           = symb_type(SymbObj);

type IntType            = integer, low_ints(max: Int), high_ints(min: Int), int_range(min: Int, size: NzNat);

type FloatType          = float_type;

type EmptyCollType      = empty_seq_type, empty_set_type, empty_bin_rel_type, empty_tern_rel_type;

type LeafType           = atom_type, SymbType, IntType, FloatType, EmptyCollType;

type TypeVar            = type_var(<Atom, Nat>);

type TypeRef            = type_ref(TypeSymbol);

type NeSeqType          = ne_seq_type(elem_type: NeType);

type NeSetType          = ne_set_type(elem_type: NeType);

type NeMapType          = ne_map_type(key_type: NeType, value_type: NeType);

type NeBinRelType       = ne_bin_rel_type(args_types: (NeType, NeType));

type NeTernRelType      = ne_tern_rel_type(args_types: (NeType, NeType, NeType));

type RecordTypeFields   = [+SymbObj -> (type: NeType, optional: Bool)];
type RecordType         = ne_record_type(RecordTypeFields);

type TupleType          = tuple_type(NeType+);

type TagType            = SymbType, atom_type;
type TagObjType         = tag_obj_type(tag_type: TagType, obj_type: NeType);

type UnionType          = union_type([+NeType]);

type NeType             = LeafType, TypeRef, TypeVar, NeSeqType, NeSetType, NeMapType, NeBinRelType,
                          NeTernRelType, RecordType, TupleType, TagObjType, UnionType;

type Type               = empty_type, NeType;

///////////////////////////////////////////////////////////////////////////////

type ClsType  = cls_type(in_types: Type+, out_type: Type);
type AnyType  = Type, ClsType;

type FnType   = fn_type(params: AnyType*, impl_args: [ImplArg -> NeType], ret_type: Type);

type BuiltInType  = builtin_type(param_types: Type+, ret_type: Type);

///////////////////////////////////////////////////////////////////////////////

type UnaryOperator  = unary_minus;
type BinaryOperator = plus, minus, star, slash, exp, amp, lower, greater, lower_eq, greater_eq, brackets;

type Operator = UnaryOperator, BinaryOperator;

type BuiltIn  = neg, add, sub, mult, div, mod, lt, le, gt, ge, str, symb, at, len, size, slice, cat,
                set, rev, mset, tag, isort, obj, in, has_key, lookup, union, merge,
                fneg, fadd, fsub, fmult, fdiv, fsqrt, floor, ceiling, float, mantissa, dec_exp,
                rand_nat, rand_elem, counter, attach, fetch, ticks;

type StdFnSymb      = fn_symbol(Atom);
type OpSymb         = op_symbol(Operator);
type UniqueFnSymb   = unique_fn_symbol(symbol: AtomicFnSymb, id: Nat);
type NestedFnSymb   = nested_fn_symbol(outer: BasicFnSymb, inner: BasicFnSymb);

type AtomicFnSymb   = StdFnSymb, OpSymb;
type BasicFnSymb    = AtomicFnSymb, UniqueFnSymb;
type FnSymbol       = BasicFnSymb, NestedFnSymb;

type NestedFnFamilyId = nested_fn_symbol(outer: BasicFnSymb, inner: AtomicFnSymb);
type FnFamilyId       = AtomicFnSymb, NestedFnFamilyId;

type FnClassId      = fn_class_id(name: FnFamilyId, arity: Nat);

type MethodSymbol   = method_symbol(Atom);
type UpdateSymbol   = msg_handler, update_symbol(Atom);

type AutoSymbol     = auto_symbol(Atom);
type DBSymbol       = db_symbol(Atom);

type StdVar           = var(Atom);
type FnPar            = fn_par(Nat);
type ImplArg          = impl_arg(Atom);
type CaptVar          = capt_var(Nat); //## DO I NEED THIS HERE? OR IS IT ONLY USED IN THE LAYER 3?
type MembVar          = memb_var(Atom);
type MembCopyVar      = memb_copy_var(Atom);      //## FIND BETTER NAME...
type PendingStateVar  = pending_state_var(Atom);  //## FIND BETTER NAME...

type QualDBMembVar    = qual_db_memb_var(db_var: AnyDBVar, memb_var: MembVar);
type QualAutoMembVar  = qual_auto_memb_var(auto_var: AnyAutoVar, memb_var: MembVar);
type QualMembVar      = QualDBMembVar, QualAutoMembVar;

type AnyMembVar   = MembVar, QualMembVar;

type LocAutoVar   = loc_auto_var(Atom);
type MembAutoVar  = memb_auto_var(Atom);
type AnyAutoVar   = LocAutoVar, MembAutoVar;

type LocDBVar     = loc_db_var(Atom);
type MembDBVar    = memb_db_var(Atom);
type NestedDBVar  = nested_db_var(outer: AnyDBVar, inner: MembDBVar);
type AnyDBVar     = LocDBVar, MembDBVar, NestedDBVar;

type Var        = StdVar, FnPar, ImplArg, CaptVar, MembVar, QualMembVar, MembCopyVar, PendingStateVar;

type RelVar     = rel_var(Atom);
type QualRelVar = qual_rel_var(db_var: AnyDBVar, rel_var: RelVar);
type AnyRelVar  = RelVar, QualRelVar;

type ClsVar     = cls_var(<Atom, Nat>);
type CaptClsVar = capt_cls_var(Nat);
type AnyClsVar  = ClsVar, CaptClsVar;

type CondExpr = cond_expr(expr: Expr, cond: Expr);

type SubExpr  = Expr, CondExpr;

type FloatLit = float_lit(mantissa: Int, dec_exp: Int);

type Expr     = LeafObj, FloatLit, Var,
                SetExpr, SeqExpr, TupleExpr, SeqTailExpr,
                MapExpr, BinRelExpr, TernRelExpr, TagObjExpr,
                FnCallExpr, ClsCall, BuiltinCall,
                UnaryPseudoCall, RelMembTest, OnlyElemExpr,
                RelVarMembTest, RelVarLookup,
                AndExpr, OrExpr, NotExpr,
                EqExpr,
                MembExpr, CastExpr,
                AccExpr, AccTestExpr,
                OutputIsDefExpr, AutoMethodCall, DBMethodCall,
                IfExpr, MatchExpr, DoExpr,
                ExQualExpr, SetCompExpr, MapCompExpr, BinRelCompExpr, TernRelCompExpr,
                SeqCompExpr, RangeCompExpr,
                IsSetExpr;

type SeqExpr        = seq_expr(SubExpr*);
type TupleExpr      = tuple_expr(Expr+); //## THIS IS REDUNDANT NOW, IT'S STILL HERE ONLY BECAUSE REMOVING IT WOULD REQUIRE SOME MAINTENANCE OF THE TYPE CHECKING CODE
type SeqTailExpr    = seq_tail_expr(seq: Expr, tail: Expr+);
type SetExpr        = set_expr([SubExpr]);
type MapExpr        = map_expr([(key: Expr, value: Expr, cond: Expr?)]);
type BinRelExpr     = bin_rel_expr([(args: (Expr, Expr), cond: Expr?)]);
type TernRelExpr    = tern_rel_expr([(args: (Expr, Expr, Expr), cond: Expr?)]);
type TagObjExpr     = tag_obj_expr(tag: Expr, obj: Expr);

type FnCallExpr     = fn_call(name: FnFamilyId, args: AnyExpr*, impl_args: [ImplArg -> Expr]);
type ClsCall        = cls_call(name: AnyClsVar, args: Expr+);
type BuiltinCall    = builtin_call(name: BuiltIn, args: Expr+);

type UnaryPseudoCall  = unary_pseudo_call(target: Expr, arg: Expr);

type RelMembTest    = rel_memb_test(rel: Expr, args: Maybe[Expr]+);

type RelVarMembTest = relvar_memb_test(rel_var: AnyRelVar, args: Maybe[Expr]+);
type RelVarLookup   = relvar_lookup(rel_var: AnyRelVar, set_args: Expr+, unknown_arg_idx: Nat);

type OnlyElemExpr   = singl_only_elem(set: Expr);

type AndExpr        = and_expr(left: Expr, right: Expr); //## NOT SURE HERE
type OrExpr         = or_expr(left: Expr, right: Expr);  //## NOT SURE HERE
type NotExpr        = not_expr(Expr);                    //## NOT SURE HERE

type EqExpr         = eq(left: Expr, right: Expr);

type MembExpr       = membership(obj: Expr, type: NeType);
type CastExpr       = cast_expr(expr: Expr, type: NeType);

type AccExpr        = accessor(expr: Expr, field: SymbObj);      //## SHOULD <field> BE AN OBJECT OR JUST A PLAIN SYMBOL?
type AccTestExpr    = accessor_test(expr: Expr, field: SymbObj); //## DITTO

type OutputIsDefExpr  = output_is_def(var: LocAutoVar, output: Atom);

type AutoMethodCall = auto_method_call(var: AnyAutoVar?, name: MethodSymbol, args: Expr*);
type DBMethodCall   = db_method_call(var: AnyDBVar?, name: MethodSymbol, args: Expr*);

type IfExpr         = if_expr(cond: Expr, then: Expr, else: Expr);
type MatchExpr      = match_expr(exprs: Expr+, cases: (ptrns: Pattern+, expr: Expr)+);
type DoExpr         = do_expr(Statement+);

type ExQualExpr     = ex_qual(source: Clause, cond: Expr);

type SetCompExpr      = set_comp(expr: Expr, source: Clause);
type MapCompExpr      = map_comp(key_expr: Expr, value_expr: Expr, source: Clause);
type BinRelCompExpr   = bin_rel_comp(exprs: (Expr, Expr), source: Clause);
type TernRelCompExpr  = tern_rel_comp(exprs: (Expr, Expr, Expr), source: Clause);

type SeqCompExpr    = seq_comp(expr: Expr, vars: StdVar+, idx_var: StdVar?, src_expr: Expr, sel_expr: Expr?);
type RangeCompExpr  = range_comp(expr: Expr, var: StdVar, bound_expr: Expr, inclusive: Bool, sel_expr: Expr?);

type IsSetExpr      = is_set(<MembVar, QualAutoMembVar>);

///////////////////////////////////////////////////////////////////////////////

type ClsExpr  = AnyClsVar,
                fn_ptr(name: FnFamilyId, arity: NzNat),
                cls_expr(args: Maybe[StdVar]+, expr: Expr);

type AnyExpr  = Expr, ClsExpr;

///////////////////////////////////////////////////////////////////////////////

type Pattern  = ptrn_symbol, //## THE CORRESPONDING TYPE IS CALLED atom_type. RENAME ONE OF THE TWO?
                ptrn_float,
                ptrn_empty_set,
                ptrn_ne_set,
                ptrn_empty_seq,
                ptrn_ne_seq,
                ptrn_empty_bin_rel,
                ptrn_ne_map,
                ptrn_ne_bin_rel,
                ptrn_empty_tern_rel,
                ptrn_ne_tern_rel,
                ptrn_any,
                ptrn_symbol(SymbObj),
                ptrn_integer(IntType),
                ptrn_tuple(Pattern+),
                ptrn_tag_obj(tag: TagPtrn, obj: Pattern),
                ptrn_var(var: StdVar, ptrn: Pattern),
                //## REMEMBER TO ENFORCE THE RULES BELOW. AT LEAST ONE PIECE OF CODE,
                //## THE ONE THAT CALCULATES A SUPERSET OF THE INTERSECTION BETWEEN A
                //## TYPE AND A PATTERN DEPENDS ON THE FIRST ASSUMPTION
                // Patterns in a union must be pseudotype-compatible.
                // They must also define the same set of variables
                ptrn_union([+Pattern]);


type TagPtrn  = ptrn_symbol, ptrn_symbol(SymbObj), ptrn_var(var: StdVar, ptrn: ptrn_symbol);

////////////////////////////////////////////////////////////////////////////////

type Clause   = set_clause(var: StdVar, src: Expr),
                rel_clause(vars: StdVar+, src: Expr, args: Maybe[Expr]+),
                relvar_clause(vars: StdVar+, rel_var: AnyRelVar, args: Maybe[Expr]+),
                seq_clause(var: StdVar, src: Expr),
                and_clause(left: Clause, right: Clause),
                or_clause(left: Clause, right: Clause),
                match_clause(ptrn: Pattern, expr: Expr),
                asgnm_clause(var: StdVar, expr: Expr),
                filter_clause(Expr);

////////////////////////////////////////////////////////////////////////////////

type AtomicFnStmt   = assignment_stmt(vars: StdVar+, value: Expr),
                      return_stmt(Expr),
                      break_stmt,
                      fail_stmt,
                      assert_stmt(cond: Expr, env: [<StdVar, ImplArg>], file: String, line: NzNat, text: Maybe[String]),
                      print_stmt(Expr),
                      imp_update_stmt(obj: StdVar, idx: Expr, value: Expr); //## NOT SURE IT BELONGS HERE...

type AtomicUpdateStmt = send_msg_stmt(target: MembDBVar, msg: Expr),
                        try_update_stmt(name: UpdateSymbol, args: Expr*),
                        set_memb_var_stmt(var: PendingStateVar, value: Expr),
                        delete_stmt(var: RelVar, fields: Maybe[Expr]+),
                        insert_stmt(var: RelVar, fields: Expr+, force: Bool);

type AtomicProcStmt = return_stmt,
                      proc_call_stmt(res_var: StdVar?, proc_name: ProcSymbol, params: Expr*);

type AutoOrDBCtrlStmt = set_input_ctrl_stmt(var: LocAutoVar, input: Atom, value: Expr),
                        clear_input_ctrl_stmt(var: LocAutoVar, input: Atom),
                        apply_ctrl_stmt(var: LocAutoVar, elapsed_time: Expr?),
                        send_msg_ctrl_stmt(res_var: StdVar, db_var: LocDBVar, msg: Expr),
                        read_state_ctrl_stmt(res_var: StdVar, db_var: LocDBVar),
                        restore_state_ctrl_stmt(res_var: StdVar, db_var: LocDBVar, state: Expr);

type CompositeStmt[T] = if_stmt(cond: Expr, body: T+, else: T*),
                        loop_stmt(T+),
                        foreach_stmt(vars: StdVar+, idx_var: StdVar?, values: Expr, body: T+),
                        for_stmt(var: StdVar?, start_val: Expr, end_val: Expr, end_val_incl: Bool, body: T+),
                        let_stmt(asgnms: [ImplArg -> Expr], body: T+);

type Statement      = AtomicFnStmt, AtomicUpdateStmt, AtomicProcStmt, AutoOrDBCtrlStmt, CompositeStmt[Statement];

///////////////////////////////////////////////////////////////////////////////

type FormalObjArg = formal_obj_arg(var: StdVar?, type: Type);
type FormalClsArg = formal_cls_arg(var: ClsVar, type: ClsType);
type FormalArg    = FormalObjArg, FormalClsArg;

type Function   = function(
                    name:       FnSymbol,
                    args:       FormalArg*,
                    impl_args:  [ImplArg -> NeType], // Types here should not contain type variables
                    res_type:   Type,
                    expr:       Expr
                  );

type ProcSymbol = proc_symbol(Atom);

type Procedure  = procedure(
                    name:       ProcSymbol,
                    args:       (var: StdVar, type: NeType)*,
                    res_type:   Maybe[NeType],
                    auto_vars:  [LocAutoVar -> AutoSymbol],
                    db_vars:    [LocDBVar -> DBSymbol],
                    body:       Statement*
                  );

///////////////////////////////////////////////////////////////////////////////

type BasicTimeExpr  = at_least(nanosecs: Nat),
                      time_neg(BasicTimeExpr),
                      time_and(left: BasicTimeExpr, right: BasicTimeExpr),
                      time_or(left: BasicTimeExpr, right: BasicTimeExpr);

type CyclicTimeExpr = every(expr: BasicTimeExpr, nanosecs: NzNat);

type TimeExpr       = BasicTimeExpr, CyclicTimeExpr;

type AutoUpdate         = state_update(target: Atom, value: Expr);
type AutoSetDiscrete    = discrete_signal_def(target: Atom, value: Expr);
type AutoMsgSend        = msg_send(target: MembDBVar, message: Expr);

type AutoAtomicAction   = AutoUpdate, AutoSetDiscrete, AutoMsgSend;

type AutoCondAction     = cond_action(cond: Expr, body: [AutoAnyCondAction], else: [AutoAnyCondAction]);
type AutoAnyCondAction  = AutoAtomicAction, AutoCondAction;

type AutoRepAction      = rep_action(cond: Expr, body: [AutoAnyRepAction], else: [AutoAnyRepAction]);
type AutoAnyRepAction   = AutoAtomicAction, AutoRepAction;

type Method   = method(name: MethodSymbol, args: (NeType, Maybe[StdVar])*, ret_type: NeType, expr: Expr);
type Update   = update(name: UpdateSymbol, args: (NeType, StdVar)*, body: Statement*);
type Handler  = handler(type: NeType, body: Statement*);

type TimeVaryingCond  = time_varying_boolean_cond(expr: Expr, time_expr: TimeExpr),
                        time_varying_unchanged_cond(expr: Expr, time_expr: TimeExpr),
                        time_varying_since_cond(signals: [+MembVar], time_expr: TimeExpr, starts_at_time_0: Bool);

type Automaton  = automaton(
                    name:           AutoSymbol,
                    inputs:         [Atom -> (type: NeType,  discrete: Bool)],
                    outputs:        [Atom -> (type: NeType,  discrete: Bool)],
                    state:          [Atom -> (type: NeType,  init_value: Expr)],
                    params:         [Atom -> (type: NeType?, value: Expr)],
                    rules:          [Atom -> Expr],
                    time_rules:     [Atom -> TimeVaryingCond],
                    actions:        [AutoCondAction],
                    rep_actions:    [AutoRepAction],
                    nested_autos:   [Atom -> (type: AutoSymbol, args: [Atom -> Expr])],
                    nested_dbs:     [MembDBVar -> DBSymbol],
                    methods:        [Method]
                  );

type DataBase   = data_base(
                    name:       DBSymbol,
                    state_vars: [MembVar -> (type: NeType, init_value: Expr)],
                    rel_vars:   [RelVar -> (signatures: [+NeType+], keys: [[+Nat]])], //## HOW TO ENFORCE THE FACT THAT ALL SIGNATURE MUST HAVE THE SAME ARITY?
                    nested_dbs: [MembDBVar -> DBSymbol],
                    methods:    [Method],
                    updates:    [Update],
                    handlers:   [Handler]
                  );

///////////////////////////////////////////////////////////////////////////////

type Program    = program(
                    typedefs:     [TypeName -> NeType],
                    fndefs:       [Function],
                    proc_defs:    [Procedure],
                    auto_defs:    [Automaton],
                    data_bases:   [DataBase]
                  );

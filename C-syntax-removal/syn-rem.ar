
Program rem_syntax(SynPrg prg)
{
  decls = set(_obj_(prg));
  
  tdefs         = {d : d <- decls, typedef()        << d};
  par_tdefs     = {d : d <- decls, par_typedef()    << d};
  fndefs        = {d : d <- decls, syn_fn_def()     << d};
  proc_defs     = {d : d <- decls, syn_proc_def()   << d};
  ublocks       = {d : d <- decls, using_block()    << d};
  subtype_decls = {d : d <- decls, subtype_decl()   << d};
  automata      = {d : d <- decls, syn_auto_def()   << d};
  methods       = {d : d <- decls, syn_method_def() << d};

  assert tdefs & par_tdefs & fndefs & proc_defs & ublocks & subtype_decls & automata & methods == decls;

  typedefs = create_type_map(tdefs, par_tdefs);
  fn_arg_arities = get_fn_arg_arities(fndefs, ublocks);

  desugared_fndefs = union({syn_fndef_to_fndefs(fd, {}, typedefs, fn_arg_arities) : fd <- fndefs});
  desugared_block_fndefs = union(
      {syn_fndef_to_fndefs(fd, set(ub.signatures), typedefs, fn_arg_arities) : ub <- ublocks, fd <- set(ub.fn_defs)}
  );

  auto_output_is_disc = (a.name => (d.name => d.discrete : d <- set(a.decls), syn_output() << d) : a <- automata);
  methods_by_automaton = merge_values({(m.automaton => m) : m <- methods});
  let (typedefs=typedefs, fn_arg_arities=fn_arg_arities, auto_output_is_disc=auto_output_is_disc)
    desugared_automata = {syn_auto_def_to_auto_def(a, lookup(methods_by_automaton, a.name, {})) : a <- automata};
  ;

  auto_vars_outputs = (a.name => {(name: n, discrete: o.discrete) : o @ n <- a.outputs} : a <- desugared_automata);
  desugared_proc_defs = {syn_proc_def_to_proc_def(pd, typedefs, fn_arg_arities, auto_vars_outputs) : pd <- proc_defs};

  return program(
    typedefs:       typedefs,
    subtype_decls:  subtype_decls,
    fndefs:         desugared_fndefs & desugared_block_fndefs,
    proc_defs:      desugared_proc_defs,
    auto_defs:      desugared_automata
  );
}


((FnSymbol, Nat) => [Nat]) get_fn_arg_arities(SynFnDef* fndefs, SynUsingBlock* ublocks)
{
  all_fds = fndefs & union({set(ub.fn_defs) : ub <- ublocks});
  arities = merge_values({get_fn_arg_arities(fd) : fd <- all_fds});
  return (sgn => only_element(pas) : pas @ sgn <- arities);

  ((FnSymbol, Nat) => [Nat]) get_fn_arg_arities(SynFnDef fd) = ((fd.name, arity(fd)) => [arity(p) : p <- fd.args]);
}


FnDef* syn_fndef_to_fndefs(SynFnDef fndef, SynSgn* named_args, (TypeName => Type) typedefs, ((FnSymbol, Nat) => [Nat]) fn_arg_arities)
{
  lfns = ((lfd.name, nz_nat(arity(lfd))) => nonempty([arity(p) : p <- lfd.args]) : lfd <- set(fndef.local_fns));
  main_fn = mk_fndef(fndef, fndef.name, fndef.name, named_args, lfns, typedefs, fn_arg_arities);
  loc_fns = [];
  for (fd : fndef.local_fns)
    fn_symb = nested_fn_symbol(fndef.name, fd.name);
    loc_fns = [loc_fns | mk_fndef(fd, fn_symb, fndef.name, named_args, lfns, typedefs, fn_arg_arities)];
  ;
  return {main_fn} & set(loc_fns);


  //## BAD BAD BAD TOO MANY PARAMETERS
  FnDef mk_fndef(SynFnDef fndef, FnSymbol fn_name, FnSymbol outer_fn, SynSgn* named_args,
    ((FnSymbol, NzNat) => [Nat^]) lfns, (TypeName => Type) typedefs, ((FnSymbol, Nat) => [Nat]) fn_arg_arities)
  {
    pars = [desugar_fn_par(p) : p <- fndef.args];
    npars = (np.name => syn_sgn_to_any_expr(np) : np <- named_args);
    maybe_res_type = if fndef.res_type? then just(syn_type_to_type(fndef.res_type, nil)) else nil;
    expr = desugar_expr(
      fndef.expr,
      {var(p.var_name) : p <- set(fndef.args), p.var_name? and (not p.type? or p.type :: SynType)},
      closures          = {cls_var(p.var_name) : p <- set(fndef.args), p.var_name?, p.type?, p.type :: SynClsType},
      named_args        = {np.name : np <- named_args}, //## BAD BAD BAD
      memb_vars         = {},
      method_args       = {},
      auto_vars_outputs = (),
      local_fns         = lfns,
      curr_outer_fn     = just(outer_fn),
      typedefs          = typedefs,
      fn_arg_arities    = fn_arg_arities
    );
    new_fd = fn_def(fn_name, pars, npars, maybe_res_type, expr);
    data = _fetch_(fndef);
    for (obj : rand_sort(data))
      new_fd = attach(new_fd, obj);
    ;
    return new_fd;
  }

  T attach(T obj, Any data) = _attach_(obj, data);  //## BAD BAD BAD: THIS IS A WORKAROUND FOR A BUG IN THE TYPECHECKER

  FnFrmPar desugar_fn_par(SynFnArg arg)
  {
    maybe_var_name = if arg.var_name? then just(arg.var_name) else nil;
    if (arg.type?)
      return desugar_fn_par(maybe_var_name, arg.type);
    else
      return scalar_par(maybe_var_name);
    ;
  }

  ScalarFrmParam desugar_fn_par(Maybe[Atom] maybe_var_name, SynType type) =
    scalar_par(maybe_var_name, syn_type_to_type(type, nil));

  ClsFrmParam desugar_fn_par(Maybe[Atom] maybe_var_name, SynClsType type) =
    non_scalar_par(value(maybe_var_name), syn_type_to_type(type, nil));

  AnyType syn_sgn_to_any_expr(SynSgn signature)
  {
    arg_types = [syn_type_to_type(p, nil) : p <- signature.args];
    ret_type = syn_type_to_type(signature.res_type, nil);
    return if arg_types == [] then ret_type else cls_type(arg_types, ret_type);
  }
}


ProcDef2 syn_proc_def_to_proc_def(SynProcDef pd, (TypeName => Type) typedefs, ((FnSymbol, Nat) => [Nat]) fn_arg_arities,
                                  (AutoSymbol => (name: Atom, discrete: Bool)*) auto_outputs)
{
  args = [(var: p.var, type: syn_type_to_type(p.type, nil)) : p <- pd.args];
  maybe_ret_type = if pd.res_type != nil then just(syn_type_to_type(value(pd.res_type), nil)) else nil;
  auto_vars_types = (v.var => auto_symbol(v.type) : v <- set(pd.auto_vars));
  auto_vars_outputs = (v => auto_outputs[t] : t @ v <- auto_vars_types);
  body = desugar_stmts(
    pd.body,
    set([p.var : p <- pd.args]),
    closures          = {},
    named_args        = {},
    memb_vars         = {},
    method_args       = {},
    auto_vars_outputs = auto_vars_outputs,
    local_fns         = (),
    curr_outer_fn     = nil,
    typedefs          = typedefs,
    fn_arg_arities    = fn_arg_arities
  );
  return proc_def(pd.name, args, maybe_ret_type, auto_vars_types, body);
}

////////////////////////////////////////////////////////////////////////////////

using (TypeName => Type) typedefs, ((FnSymbol, Nat) => [Nat]) fn_arg_arities, (AutoSymbol => (Atom => Bool)) auto_output_is_disc
{
  Automaton syn_auto_def_to_auto_def(SynAutoDef auto_def, SynMethodDef* methods)
  {
    decls = set(auto_def.decls);

    //## NEITHER OF THESE IS AT ALL SAFE, IF I END UP MAKING ANY CHANGES TO AutoDecl
    memb_vars = {
      memb_var(d.name)
      : d <- decls,
        match (d)
          syn_nested_auto() = false,
          _                 = true
    };
    disc_signals = set([d.name : d <- auto_def.decls, d.discrete? and d.discrete]);

    syn_state_vars          = {d : d <- decls, syn_state()              << d};
    syn_plain_rules         = {d : d <- decls, syn_plain_rule()         << d};
    syn_cond_rules          = {d : d <- decls, syn_cond_rule()          << d};
    syn_foreach_rules       = {d : d <- decls, syn_foreach_rule()       << d};
    syn_time_varying_rules  = {d : d <- decls, syn_time_varying_rule()  << d};
    syn_nested_autos        = {d : d <- decls, syn_nested_auto()        << d};

    auto_vars = {memb_auto_var(a.name) : a <- syn_nested_autos};

    auto_vars_types = (memb_auto_var(a.name) => auto_symbol(a.auto_name) : a <- syn_nested_autos);

    state_vars = (
      v.name => (
        type:       syn_type_to_type(v.type, nil),
        init_value: syn_expr_to_expr(v.init_value, memb_vars, auto_vars)
      ) : v <- syn_state_vars
    );

    // Reducing time-varying expressions with a constant time expression to plain rules
    fake_time_varying_rules = {
      syn_plain_rule(
        r.name,
        if initial_value(r.value.time_expr) == true then r.value.cond else object(false),
        false
      ) :
      r <- syn_time_varying_rules,
      is_const(r.value.time_expr)
    };
    syn_plain_rules = syn_plain_rules & fake_time_varying_rules;
    syn_time_varying_rules = {r : r <- syn_time_varying_rules, not is_const(r.value.time_expr)};

    // Desugaring plain rules, which can have implicit repeated conditions
    plain_rules_output = {desugar_plain_rule(r, memb_vars, auto_vars, disc_signals, auto_vars_types) : r <- syn_plain_rules};
    rules = merge({value(r) : o <- plain_rules_output, r = left(o), r != nil});
    rep_actions_1 = {value(a) : o <- plain_rules_output, a = right(o), a != nil};

    // Desugaring conditional rules, which can have additional repeated conditions
    cond_rule_output = {desugar_cond_rule(r, memb_vars, auto_vars, disc_signals) : r <- syn_cond_rules};
    actions = {value(a) : o <- cond_rule_output, a = left(o), a != nil};
    rep_actions_2 = {value(a) : o <- cond_rule_output, a = right(o), a != nil};

    // Foreach rules can only lead to repeated actions
    rep_actions_3 = {foreach_rule_to_repeated_action(r, memb_vars, auto_vars, disc_signals) : r <- syn_foreach_rules};

    // Pulling all repeated actions together
    rep_actions = rep_actions_1 & rep_actions_2 & rep_actions_3;

    // Desugaring time-varying rules
    time_rules = (
      r.name => time_varying_cond(e, r.value.time_expr) :
      r <- syn_time_varying_rules, e = syn_expr_to_expr(r.value.cond, memb_vars, auto_vars)
    );

    // Desugaring nested automata
    nested_autos = (
      na.name => (
        type: auto_symbol(na.auto_name),
        args: merge([(f => syn_expr_to_expr(e, memb_vars, auto_vars)) : f, e <- na.args])
      )
      : na <- syn_nested_autos
    );

    arg_ids = {};
    loop
      next_round = {
        id : e @ id <- rules,
             vids = {unsafe_name(v) : v <- extern_vars(e)},
             subset(vids, arg_ids),
             extern_auto_vars(e) == {}
      };
      break if next_round == arg_ids;
      arg_ids = next_round;
    ;

    args = select_by_key(rules, arg_ids);
    rules = remove_keys(rules, arg_ids);

    return automaton(
      name:         auto_def.name,
      pos_params:   auto_def.pos_args,
      params:       args,
      inputs:       inputs(auto_def),
      outputs:      outputs(auto_def),
      state:        state_vars,
      rules:        rules,
      time_rules:   time_rules,
      actions:      actions,
      rep_actions:  rep_actions,
      nested_autos: nested_autos,
      methods:      {desugar_method(m, memb_vars, auto_vars) : m <- methods}
    );


    Method desugar_method(SynMethodDef syn_method, MembVar* memb_vars, MembAutoVar* auto_vars)
    {
      args = [(syn_type_to_type(t, nil), v) : t, v <- syn_method.args];
      arg_vars = set([v : unused_var, v <- args]);
      asgnms = merge([(a => syn_expr_to_expr(e, memb_vars, auto_vars, arg_vars)) : a, e <- syn_method.assignments]);
      return method(syn_method.name, args, asgnms);
    }


    (Maybe[(Atom => Expr)], Maybe[AutoRepAction]) desugar_plain_rule(SynPlainRule rule, MembVar* memb_vars, MembAutoVar* auto_vars, Atom* disc_signals, (MembAutoVar => AutoSymbol) auto_vars_types)
    {
      expr = syn_expr_to_expr(rule.expr, memb_vars, auto_vars);
      vars = extern_vars(expr);
      input_signals = {match (v) memb_var(id?) = id : v <- vars};
      disc_input_signals = intersection(input_signals, disc_signals);
      disc_nested_output_deps = {
          d
        : d <- nested_auto_output_deps(expr),
          as = memb_auto_var(left(d)),
          o  = right(d),
          at = auto_vars_types[as],
          auto_output_is_disc[at][o]
      };

      // If a plain rule does not contain any discrete signals,
      // then it defines a continuous intermediate signal
      assert not (rule.discrete and (disc_input_signals == {} and disc_nested_output_deps == {}));
      return (just((rule.name => expr)), nil) if disc_input_signals == {} and disc_nested_output_deps == {};

      // Now it's either a discrete signals definition or a state variable update
      cond = and_expr(
        nonempty(
          [is_set(memb_var(ds)) : ds <- rand_sort(disc_input_signals)] &
          [output_is_set(memb_auto_var(a), o) : a, o <- rand_sort(disc_nested_output_deps)]
        )
      );
      action = if rule.discrete then set_discrete(rule.name, expr) else update(rule.name, expr);
      return (nil, just(rep_action(cond, {action}, {})));
    }


    (Maybe[AutoCondAction], Maybe[AutoRepAction]) desugar_cond_rule(SynCondRule rule, MembVar* memb_vars, MembAutoVar* auto_vars, Atom* disc_signals)
    {
      target = rule.name;
      branches = rule.branches;

      if (length(branches) == 1)
        branch = branches[0];
        cond = syn_expr_to_expr(branch.cond, memb_vars, auto_vars);
        expr = syn_expr_to_expr(branch.expr, memb_vars, auto_vars);
        ss = {match (v) memb_var(id?) = id : v <- extern_vars(cond) & extern_vars(expr)};
        dss = [memb_var(s) : s <- rand_sort(intersection(ss, disc_signals))];
        if (dss != [])
          if (rule.discrete)
            action = set_discrete(target, expr);
          else
            action = update(target, expr);
          ;

          outer_cond = or_expr([is_set(s) : s <- dss]);

          if (length(dss) > 1)
            inner_cond = and_expr([is_set(s) : s <- dss]);
            cond = and_expr(inner_cond, cond);
          ;

          return (nil, just(rep_action(outer_cond, {rep_action(cond, {action}, {})}, {})));
        ;
      ;

      return (just(cond_rule_to_action(target, branches, rule.discrete, memb_vars, auto_vars)), nil);
    }


    AutoCondAction cond_rule_to_action(Atom name, [(expr: SynExpr, cond: SynExpr)^] branches, Bool discrete, MembVar* memb_vars, MembAutoVar* auto_vars)
    {
      outer_branch = head(branches);
      inner_branches = tail(branches);

      else_actions = {cond_rule_to_action(name, inner_branches, discrete, memb_vars, auto_vars) if inner_branches != []};

      cond = syn_expr_to_expr(outer_branch.cond, memb_vars, auto_vars);
      expr = syn_expr_to_expr(outer_branch.expr, memb_vars, auto_vars);
      if (discrete)
        action = set_discrete(name, expr);
      else
        action = update(name, expr);
      ;

      return cond_action(cond, {action}, else_actions);
    }


    AutoRepAction foreach_rule_to_repeated_action(SynForeachRule rule, MembVar* memb_vars, MembAutoVar* auto_vars, Atom* disc_signals)
    {
      value = syn_expr_to_expr(rule.value, memb_vars, auto_vars);
      if (rule.discrete)
        action = set_discrete(rule.name, value);
      else
        action = update(rule.name, value);
      ;
      action = rep_action(syn_expr_to_expr(rule.cond, memb_vars, auto_vars), {action}, {}) if rule.cond?;

      change_cond = or_expr([
        if in(s, disc_signals)
          then is_set(memb_var(s))
          else not_expr(eq(memb_var(s), memb_copy_var(s)))
       : s <- rule.signals
      ]);

      return rep_action(change_cond, {action}, {});
    }


    Expr syn_expr_to_expr(SynExpr expr, MembVar* memb_vars, MembAutoVar* auto_vars) =
      syn_expr_to_expr(expr, memb_vars, auto_vars, {});

    Expr syn_expr_to_expr(SynExpr expr, MembVar* memb_vars, MembAutoVar* auto_vars, MethodArg* method_args) =
      desugar_expr(
        expr,
        {},
        closures = {},
        named_args = {},
        memb_vars = memb_vars,
        method_args = method_args,
        auto_vars_outputs = (v => {} : v <- auto_vars), //## BUG BUG BUG: CHEATING HERE...
        local_fns = (),
        curr_outer_fn = nil, //## UGLY UGLY UGLY
        typedefs = typedefs,
        fn_arg_arities = fn_arg_arities
      );
  }
}

Program rem_syntax(SynPrg prg)
{
  decls = set(_obj_(prg));
  
  tdefs               = [d : d <- decls, typedef()                  << d];
  par_tdefs           = [d : d <- decls, par_typedef()              << d];
  fndefs              = [d : d <- decls, syn_fn_def()               << d];
  proc_defs           = [d : d <- decls, syn_proc_def()             << d];
  ublocks             = [d : d <- decls, using_block()              << d];
  subtype_decls       = [d : d <- decls, subtype_decl()             << d];
  automata            = [d : d <- decls, syn_auto_def()             << d];
  read_only_methods   = [d : d <- decls, syn_read_only_method_def() << d];
  update_methods      = [d : d <- decls, syn_update_method_def()    << d];

  assert tdefs & par_tdefs & fndefs & proc_defs & ublocks & subtype_decls & automata & read_only_methods & update_methods == decls;

  typedefs = create_type_map(tdefs, par_tdefs);
  fn_arg_arities = get_fn_arg_arities(fndefs, ublocks);

  desugared_fndefs = union([syn_fndef_to_fndefs(fd, [], typedefs, fn_arg_arities) : fd <- fndefs]);
  desugared_block_fndefs = union(
      [syn_fndef_to_fndefs(fd, set(ub.signatures), typedefs, fn_arg_arities) : ub <- ublocks, fd <- set(ub.fn_defs)]
  );

  no_inheritance_automata = resolve_inheritance(automata);
  desugared_automata = desugar_automata(no_inheritance_automata, read_only_methods, update_methods, typedefs, fn_arg_arities);

  auto_interfaces = [a.name -> interface_info(a) : a <- no_inheritance_automata];
  desugared_proc_defs = [syn_proc_def_to_proc_def(pd, typedefs, fn_arg_arities, auto_interfaces) : pd <- proc_defs];

  return program(
    typedefs:       typedefs,
    subtype_decls:  subtype_decls,
    fndefs:         desugared_fndefs & desugared_block_fndefs,
    proc_defs:      desugared_proc_defs,
    auto_defs:      desugared_automata
  );
}


[Automaton] desugar_automata([SynAutoDef] automata, [SynReadOnlyMethodDef] read_only_methods, [SynUpdateMethodDef] update_methods, [TypeName -> Type] typedefs, [FnSymbol -> [Nat -> Nat*]] fn_arg_arities)
{
  auto_interfaces = [a.name -> interface_info(a) : a <- automata];
  read_only_methods_by_automaton = merge_values([[m.automaton -> m] : m <- read_only_methods]);
  update_methods_by_automaton = merge_values([[m.automaton -> m] : m <- update_methods]);

  let typedefs = typedefs, fn_arg_arities = fn_arg_arities, auto_interfaces = auto_interfaces:
    desugared_automata = [
      syn_auto_def_to_auto_def(a, rms, ums)
      : a <- automata,
        rms = lookup(read_only_methods_by_automaton, a.name, []),
        ums = lookup(update_methods_by_automaton, a.name, [])
    ];
  ;

  return desugared_automata;
}


[FnSymbol -> [Nat -> Nat*]] get_fn_arg_arities([SynFnDef] fndefs, [SynUsingBlock] ublocks)
{
  all_fds = fndefs & union([set(ub.fn_defs) : ub <- ublocks]);
  arities = merge_values([get_fn_arg_arities(fd) : fd <- all_fds]);
  return [sgn -> merge(pas) : pas @ sgn <- arities];

  [FnSymbol -> [Nat -> Nat*]] get_fn_arg_arities(SynFnDef fd) = [fd.name -> [arity(fd) -> (arity(p) : p <- fd.args)]];
}


[FnDef] syn_fndef_to_fndefs(SynFnDef fndef, [SynSgn] named_args, [TypeName -> Type] typedefs, [FnSymbol -> [Nat -> Nat*]] fn_arg_arities)
{
  lfns = [(lfd.name, nz_nat(arity(lfd))) -> nonempty((arity(p) : p <- lfd.args)) : lfd <- set(fndef.local_fns)];
  main_fn = mk_fndef(fndef, fndef.name, fndef.name, named_args, lfns, typedefs, fn_arg_arities);
  loc_fns = ();
  for fd <- fndef.local_fns:
    fn_symb = nested_fn_symbol(fndef.name, fd.name);
    loc_fns = (loc_fns | mk_fndef(fd, fn_symb, fndef.name, named_args, lfns, typedefs, fn_arg_arities));
  ;
  return [main_fn] & set(loc_fns);


  //## BAD BAD BAD TOO MANY PARAMETERS
  FnDef mk_fndef(SynFnDef fndef, FnSymbol fn_name, FnSymbol outer_fn, [SynSgn] named_args,
    [(FnSymbol, NzNat) -> Nat+] lfns, [TypeName -> Type] typedefs, [FnSymbol -> [Nat -> Nat*]] fn_arg_arities)
  {
    pars = (desugar_fn_par(p) : p <- fndef.args);
    npars = [np.name -> syn_sgn_to_any_expr(np) : np <- named_args];
    maybe_res_type = if fndef.res_type? then just(syn_type_to_type(fndef.res_type, nil)) else nil;
    expr = desugar_expr(
      fndef.expr,
      [var(p.var_name) : p <- set(fndef.args), p.var_name? and (not p.type? or p.type :: SynType)],
      closures            = [cls_var(p.var_name) : p <- set(fndef.args), p.var_name?, p.type?, p.type :: SynClsType],
      named_args          = [a.name : a <- named_args], //## BAD BAD BAD
      named_args_arities  = [a.name -> arity(a) : a <- named_args], //## BAD BAD BAD
      memb_vars           = [],
      auto_vars_outputs   = [:],
      local_fns           = lfns,
      curr_outer_fn       = just(outer_fn),
      typedefs            = typedefs,
      fn_arg_arities      = fn_arg_arities
    );
    new_fd = fn_def(fn_name, pars, npars, maybe_res_type, expr);
    return transfer_attachments(new_fd, fndef);
  }

  T attach(T obj, Any data) = _attach_(obj, data);  //## BAD BAD BAD: THIS IS A WORKAROUND FOR A BUG IN THE TYPECHECKER

  FnFrmPar desugar_fn_par(SynFnArg arg)
  {
    maybe_var_name = if arg.var_name? then just(arg.var_name) else nil;
    if arg.type?:
      return desugar_fn_par(maybe_var_name, arg.type);
    else
      return scalar_par(maybe_var_name);
    ;
  }

  ScalarFrmParam desugar_fn_par(Maybe[Atom] maybe_var_name, SynType type) =
    scalar_par(maybe_var_name, syn_type_to_type(type, nil));

  ClsFrmParam desugar_fn_par(Maybe[Atom] maybe_var_name, SynClsType type) =
    non_scalar_par(value(maybe_var_name), syn_type_to_type(type, nil));

  AnyType syn_sgn_to_any_expr(SynSgn signature)
  {
    arg_types = (syn_type_to_type(p, nil) : p <- signature.args);
    ret_type = syn_type_to_type(signature.res_type, nil);
    return if arg_types == () then ret_type else cls_type(arg_types, ret_type);
  }
}


ProcDef2 syn_proc_def_to_proc_def(
  SynProcDef                    pd,
  [TypeName -> Type]            typedefs,
  [FnSymbol -> [Nat -> Nat*]]   fn_arg_arities,
  [AutoSymbol -> AutoInterface] auto_interfaces
)
{
  args = ([var: p.var, type: syn_type_to_type(p.type, nil)] : p <- pd.args);
  maybe_ret_type = if pd.res_type != nil then just(syn_type_to_type(value(pd.res_type), nil)) else nil;
  auto_vars_types = [v.var -> auto_symbol(v.type) : v <- set(pd.auto_vars)];
  auto_vars_outputs = [
    v -> [[name: n, discrete: info.discrete, default: interface.default_output] : info @ n <- interface.outputs]
    : t @ v <- auto_vars_types, interface = auto_interfaces[t]
  ];
  body = desugar_stmts(
    pd.body,
    set((p.var : p <- pd.args)),
    closures            = [],
    named_args          = [],
    named_args_arities  = [:],
    memb_vars           = [],
    auto_vars_outputs   = auto_vars_outputs,
    local_fns           = [:],
    curr_outer_fn       = nil,
    typedefs            = typedefs,
    fn_arg_arities      = fn_arg_arities
  );
  return proc_def(pd.name, args, maybe_ret_type, auto_vars_types, body);
}

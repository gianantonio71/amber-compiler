using
{
  [ClsVar]                        closures,
  [NamedArg]                      named_args,
  [NamedArg -> Nat]               named_args_arities,
  [MembVar]                       memb_vars,
  [(FnSymbol, NzNat) -> Nat+]     local_fns,
  Maybe[FnSymbol]                 curr_outer_fn, //## BUG: THIS IS NOT ENOUGH TO IDENTIFY THE OUTER FUNCTION...
  [TypeName -> Type]              typedefs,
  [FnSymbol -> [Nat -> Nat*]]     fn_arg_arities,
  [AnyAutoVar -> [[name: Atom, discrete: Bool, default: Bool]]] auto_vars_outputs;


  Expr desugar_expr(SynExpr syn_expr, [Var] def_vars) =
    transfer_attachments(desugar_expr_plain(syn_expr, def_vars), syn_expr);


  Expr desugar_expr_plain(SynExpr expr, [Var] def_vars):
    object()            = expr,
    float_lit()         = expr,
    seq_expr(ses?)      = desugar_seq_expr(ses, def_vars),
    seq_tail_expr()     = seq_tail_expr(desugar_expr(expr.seq, def_vars), (desugar_expr(e, def_vars) : e <- expr.tail)),
    set_expr(es?)       = set_expr([desugar_expr(e, def_vars) : e <- es]),
    map_expr(es?)       = desugar_map_expr(es, def_vars),
    tag_obj_expr()      = tag_obj_expr(desugar_expr(expr.tag, def_vars), desugar_expr(expr.obj, def_vars)),
    FnPar               = expr,
    memb_copy_var()     = expr,
    cls_par(n?)         = fn_par(n),
    const_or_var(a?)    = desugar_const_or_var_expr(a, def_vars),
    fn_call()           = desugar_fn_call_expr(expr.name, expr.args, expr.named_args, def_vars),
    builtin_call()      = builtin_call(expr.name, (desugar_expr(e, def_vars) : e <- expr.args)),
    unary_pseudo_call() = incl_test_or_lookup(desugar_expr(expr.target, def_vars), desugar_expr(expr.param, def_vars)),
    map_search()        = map_search(desugar_expr(expr.map, def_vars), desugar_expr(expr.key, def_vars), desugar_expr(expr.value, def_vars)),
    key_search()        = key_search(desugar_expr(expr.map, def_vars), desugar_expr(expr.key, def_vars)),
    singl_only_elem()   = singl_only_elem(desugar_expr(expr.set, def_vars)),
    and()               = and_expr(desugar_expr(expr.left, def_vars), desugar_expr(expr.right, def_vars)),
    or()                = or_expr(desugar_expr(expr.left, def_vars), desugar_expr(expr.right, def_vars)),
    not(e?)             = not_expr(desugar_expr(e, def_vars)),
    eq()                = eq(desugar_expr(expr.left, def_vars), desugar_expr(expr.right, def_vars)),
    neq()               = not_expr(eq(desugar_expr(expr.left, def_vars), desugar_expr(expr.right, def_vars))),
    membership()        = membership(desugar_expr(expr.obj, def_vars), syn_type_to_type(expr.type, nil)),
    cast_expr()         = cast_expr(desugar_expr(expr.expr, def_vars), syn_type_to_type(expr.type, nil)),
    accessor()          = desugar_accessor(expr.expr, expr.field, def_vars),
    accessor_test()     = desugar_accessor_test(expr.expr, expr.field, def_vars),
    ex_qual()           = desugar_ex_qual_expr(expr.source, expr.cond, def_vars),
    set_comp()          = desugar_set_comp_expr(expr.expr, expr.source, def_vars),
    map_comp()          = desugar_map_comp_expr(expr.key_expr, expr.value_expr, expr.source, def_vars),
    seq_comp()          = desugar_seq_comp_expr(expr, def_vars),
    range_comp()        = desugar_range_comp_expr(expr, def_vars),
    if_expr()           = desugar_if_expr(expr, def_vars),
    match_expr()        = desugar_match_expr(expr.exprs, expr.cases, def_vars),
    do_expr(ss?)        = do_expr(desugar_stmts(ss, def_vars)),
    let_expr()          = do_expr(desugar_stmts(nonempty(expr.stmts & (syn_ret_stmt(expr.expr))), def_vars)),
    is_set()            = expr,
    output_is_def()     = expr,
    method_call_expr()  = desugar_method_call_expr(expr.var, expr.name, expr.args, def_vars);


  Expr desugar_seq_expr(SynSubExpr* entries, [Var] def_vars)
  {
    es = (desugar_expr(e, def_vars) : e <- entries);
    return if es :: Expr+ then tuple_expr(es) else seq_expr(es);
  }


  Expr desugar_method_call_expr(Atom var_id, ReadOnlyMethodSymb name, SynExpr* syn_args, [Var] def_vars)
  {
    args = (desugar_expr(e, def_vars) : e <- syn_args);
    return method_call_expr(name, args) if var_id == :self;
    loc_var = loc_auto_var(var_id);
    memb_var = memb_auto_var(var_id);
    assert has_key(auto_vars_outputs, loc_var) != has_key(auto_vars_outputs, memb_var);
    auto_var = if has_key(auto_vars_outputs, loc_var) then loc_var else memb_var;
    return method_call_expr(auto_var, name, args);
  }


  Expr desugar_map_expr([SynMapExprEntry] entries, [Var] def_vars) =
    map_expr([[
        key:   desugar_expr(e.key, def_vars),
        value: desugar_expr(e.value, def_vars),
        cond:  desugar_expr(e.cond, def_vars) if e.cond?
      ] : e <- entries
    ]);


  Expr desugar_const_or_var_expr(Atom var_symb, [Var] def_vars)
  {
    assert not in(cls_var(var_symb), closures);

    return var(var_symb)        if in(var(var_symb), def_vars);
    return named_arg(var_symb)  if in(named_arg(var_symb), named_args);
    return memb_var(var_symb)   if in(memb_var(var_symb), memb_vars);

    loc_auto_var = loc_auto_var(var_symb);
    memb_auto_var = memb_auto_var(var_symb);

    is_loc_auto_var = has_key(auto_vars_outputs, loc_auto_var);
    is_memb_auto_var = has_key(auto_vars_outputs, memb_auto_var);
    assert not is_loc_auto_var or not is_memb_auto_var;

    if is_loc_auto_var or is_memb_auto_var:
      auto_var = if is_loc_auto_var then loc_auto_var else memb_auto_var;
      outputs = auto_vars_outputs[auto_var];
      assert outputs != [];
      assert size(outputs) == 1 or not (? o <- outputs : o.default);

      if size(outputs) == 1:
        only_output = only_element(outputs);
        return get_output(auto_var, only_output.name) if only_output.default;
      ;
    ;

    if is_loc_auto_var:
      entries = [[
        key:    object(output.name),
        value:  get_output(loc_auto_var, output.name),
        cond:   if output.discrete
                  then and_expr(output_is_def(loc_auto_var, output.name), output_is_set(loc_auto_var, output.name))
                  else output_is_def(loc_auto_var, output.name)
      ] : output <- auto_vars_outputs[loc_auto_var]];
      return map_expr(entries);
    ;

    return fn_call(fn_symbol(var_symb), (), [:]);
  }


  Expr desugar_fn_call_expr(FnSymbol name, SynExpr* args, (NamedArg, <var(Atom)>*, SynExpr)* expl_named_args, [Var] def_vars)
  {
    //## BAD (BUG?): THIS IS NOT VALID IF THE PARAMETER IS A CLOSURE
    //## VARIABLE OR IF IT'S THE NAME OF A FUNCTION. RIGHT NOW IT
    //## SHOULD NOT FAIL, BUT ONLY BECAUSE THE const_or_var() DOESN'T
    //## DO ANY CHECKING AT THE MOMENT
    arity = length(args);
    fn_id = (name, arity);
    nps = merge(([n -> desugar_named_arg_expr(e, def_vars, ps)] : n, ps, e <- expl_named_args));

    if name :: <fn_symbol(Atom)> and (arity == 1 or arity == 2) and expl_named_args == ():
      bare_name = match (name) fn_symbol(a?) = a;
      target_is_local_var = already_def(bare_name, def_vars);
      target_is_named_par = already_def(bare_name, named_args) and named_args_arities[named_arg(bare_name)] == 0;
      if target_is_local_var or target_is_named_par:
        coll_var = if target_is_local_var then var(bare_name) else named_arg(bare_name);
        if arity == 1:
          par = desugar_expr(only_item(args), def_vars);
          res = incl_test_or_lookup(coll_var, par);
        else
          assert arity == 2;
          key = desugar_expr(args[0], def_vars);
          value = desugar_expr(args[1], def_vars);
          res = map_search(coll_var, key, value);
        ;
        return res;
      ;
    ;

    // Closures first
    if name :: <fn_symbol(Atom)> and args != ():
      cls_var = cls_var(_obj_(name));
      if in(cls_var, closures):
        assert nps == [:];
        ps = (desugar_expr(e, def_vars) : e <- args);
        return cls_call(cls_var, ps);
      ;
    ;

    // Then local functions. Here we have to deal with closure parameters.
    if has_key(local_fns, fn_id):
      fs = nested_fn_symbol(value(curr_outer_fn), name);
      pas = local_fns[fn_id];
      eps = (desugar_fn_arg(p, a, def_vars) : p, a <- zip(args, pas));
      return fn_call(fs, eps, nps);
    ;

    // Then named parameters
    if name :: <fn_symbol(Atom)> and args != ():
      np  = named_arg(_obj_(name));
      if in(np, named_args):
        assert nps == [:];
        ps = (desugar_expr(e, def_vars) : e <- args);
        return cls_call(np, ps);
      ;
    ;

    // And last global functions. Here too we have to deal with closures.
    pas = fn_arg_arities[name][arity];
    eps = (desugar_fn_arg(p, a, def_vars) : p, a <- zip(args, pas));
    return fn_call(name, eps, nps);


    AnyExpr desugar_named_arg_expr(SynExpr syn_expr, [Var] outside_vars, <var(Atom)>* cls_pars)
    {
      vars = outside_vars - [v : v <- outside_vars, fn_par() << v] & set(cls_pars) & set((fn_par(i) : i < length(cls_pars)));
      expr = desugar_expr(syn_expr, vars);
      return if cls_pars == () then expr else cls_expr(cls_pars, expr);
    }


    AnyExpr desugar_fn_arg(SynExpr syn_arg, Nat exp_arity, [Var] def_vars)
    {
      if exp_arity == 0 or not syn_arg :: ConstOrVar:
        arg = desugar_expr(syn_arg, def_vars);
        return if exp_arity == 0 then arg else cls_expr(exp_arity, arg);
      ;

      symb = _obj_(syn_arg);

      is_loc_var = in(var(symb), def_vars);
      is_named_arg = in(named_arg(symb), named_args);
      fn_symb = fn_symbol(symb);
      is_glob_const = has_key(fn_arg_arities, fn_symb) and has_key(fn_arg_arities[fn_symb], 0);

      //## BUG? IS THIS RIGHT? SHOULDN'T GLOBAL CONSTANTS HAVE MINIMUM PRIORITY?
      if is_loc_var or is_named_arg or is_glob_const:
        return cls_expr(exp_arity, desugar_expr(syn_arg, def_vars));
      else
        cls_var = cls_var(symb);
        return cls_var if in(cls_var, closures);
        fn_symb = nested_fn_symbol(value(curr_outer_fn), fn_symb) if has_key(local_fns, (fn_symb, exp_arity));
        return fn_ptr(fn_symb, exp_arity);
      ;
    }
  }


  Expr desugar_accessor(SynExpr expr, SymbObj field, [Var] def_vars):
    const_or_var(n?)  = { for v <- (loc_auto_var(n), memb_auto_var(n)):
                            if has_key(auto_vars_outputs, v):
                              outputs = auto_vars_outputs[v];
                              if size(outputs) != 1 or not only_element(outputs).default:
                                return get_output(v, bare_obj(field));
                              ;
                            ;
                          ;
                          return accessor(desugar_expr(expr, def_vars), field);
                        },
    _                 = accessor(desugar_expr(expr, def_vars), field);


  Expr desugar_accessor_test(SynExpr expr, SymbObj field, [Var] def_vars):
    const_or_var(n?)  = { //## BAD: THIS CODE IS ALMOST THE SAME AS IN THE METHOD ABOVE
                          for v <- (loc_auto_var(n), memb_auto_var(n)):
                            if has_key(auto_vars_outputs, v):
                              outputs = auto_vars_outputs[v];
                              if size(outputs) != 1 or not only_element(outputs).default:
                                return output_is_set(v, bare_obj(field));
                              ;
                            ;
                          ;
                          return accessor_test(desugar_expr(expr, def_vars), field);
                        },
    _                 = accessor_test(desugar_expr(expr, def_vars), field);


  Expr desugar_ex_qual_expr(SynClause+ source, SynExpr cond, [Var] def_vars)
  {
    vs = def_vars & syn_new_vars(source);
    c  = desugar_expr(cond, vs);
    return ex_qual(mk_and_clause(source, def_vars), c);
  }


  Expr desugar_set_comp_expr(SynExpr expr, SynClause+ source, [Var] def_vars)
  {
    vs = def_vars & syn_new_vars(source);
    return set_comp(desugar_expr(expr, vs), mk_and_clause(source, def_vars));
  }


  Expr desugar_map_comp_expr(SynExpr key_expr, SynExpr value_expr, SynClause+ source, [Var] def_vars)
  {
    vs = def_vars & syn_new_vars(source);
    return map_comp(desugar_expr(key_expr, vs), desugar_expr(value_expr, vs), mk_and_clause(source, def_vars));
  }


  Expr desugar_seq_comp_expr(SynLCExpr expr, [Var] def_vars)
  {
    vs = def_vars & set(expr.vars) & [expr.idx_var if expr.idx_var?];
    return seq_comp(
      expr:          desugar_expr(expr.expr, vs),
      vars:          expr.vars,
      idx_var:       expr.idx_var if expr.idx_var?,
      src_expr:      desugar_expr(expr.src_expr, def_vars),
      sel_expr:      desugar_expr(expr.sel_expr, vs) if expr.sel_expr?
    );
  }


  Expr desugar_range_comp_expr(SynRCExpr expr, [Var] def_vars)
  {
    vs = def_vars & [expr.var];
    return range_comp(
      expr:         desugar_expr(expr.expr, vs),
      var:          expr.var,
      bound_expr:   desugar_expr(expr.bound_expr, def_vars),
      inclusive:    expr.inclusive,
      sel_expr:     desugar_expr(expr.sel_expr, vs) if expr.sel_expr?
    );
  }


  Expr desugar_if_expr(SynIfExpr expr, [Var] def_vars)
  {
    res = desugar_expr(expr.else, def_vars);
    for b <- reverse(expr.branches):
      res = if_expr(desugar_expr(b.cond, def_vars), desugar_expr(b.expr, def_vars), res);
    ;
    return res;
  }


  Expr desugar_match_expr(SynExpr+ exprs, SynCase+ cases, [Var] def_vars)
  {
    n  = length(cases[0].patterns);
    es = nonempty((desugar_expr(e, def_vars) : e <- subseq(exprs, 0, n)));
    cs = ({
      ps = (desugar_ptrn(p) : p <- c.patterns);
      vs = def_vars & seq_union((new_vars(p) : p <- ps));
      return [ptrns: ps, expr: desugar_expr(c.expr, vs)];
    } : c <- cases);
    return match_expr(es, cs);
  }

  ////////////////////////////////////////////////////////////////////////////////

  CondExpr desugar_expr(SynCondExpr cexpr, [Var] def_vars) =
    cond_expr(
      desugar_expr(cexpr.expr, def_vars),
      desugar_expr(cexpr.cond, def_vars)
    );

  
  Expr mk_and_expr(Expr+ exprs)  // REMOVE DUPLICATES?
  {
    rev_exprs = reverse(exprs);
    expr      = rev_exprs[0];
    for i = 1..length(exprs):
      expr = and_expr(rev_exprs[i], expr);
    ;
    return expr;  
  }

  ////////////////////////////////////////////////////////////////////////////////

  Clause mk_and_clause(SynClause+ clauses, [Var] def_vars)
  {
    vs = def_vars;
    cs = ();
    for c <- clauses:
      cs = cs & (desugar_clause(c, vs));
      vs = vs & syn_new_vars(c);
    ;

    rev_cs = reverse(cs);
    clause = rev_cs[0];
    for i = 1..length(clauses):
      clause = and_clause(rev_cs[i], clause);
    ;

    return clause;
  }

  //## REMEMBER TO CHECK THAT ALL VAR_PTRN() WITH A "BOUND" VARIABLE
  //## DON'T HAVE A PATTERN ASSOCIATED WITH THAT VARIABLE


  Clause desugar_clause(SynClause cls, [Var] def_vars)
  {
    return transfer_attachments(desugar(cls, def_vars), cls);

    Clause desugar(SynClause cls, [Var] def_vars):
      set_elem_clause()   = set_elem_clause(cls.var, desugar_expr(cls.src, def_vars)),
      map_entry_clause()  = map_entry_clause(cls.key_var, cls.value_var, desugar_expr(cls.src, def_vars)),
      seq_elem_clause()   = seq_elem_clause(cls.var, desugar_expr(cls.src, def_vars)),
      and_clause(cs?)     = mk_and_clause(cs, def_vars),
      or_clause()         = or_clause(desugar_clause(cls.left, def_vars), desugar_clause(cls.right, def_vars)),
      match_clause()      = match_clause(desugar_ptrn(cls.ptrn), desugar_expr(cls.expr, def_vars)),
      asgnm_clause()      = asgnm_clause(cls.var, desugar_expr(cls.expr, def_vars)),
      filter_clause()     = filter_clause(desugar_expr(cls.cond, def_vars));
  }

  ////////////////////////////////////////////////////////////////////////////////

  //## BAD: THIS SHOULD BE REPLACED BY A COUPLE OF SUBSIGNATURES.
  () desugar_stmts((), [Var]) = ();

  Statement+ desugar_stmts(SynStmt+ stmts, [Var] def_vars)
  {
    vs = def_vars;
    ss = ();
    for s <- stmts:
      ss = ss & (desugar_stmt(s, vs));
      vs = vs & syn_new_vars(s);
    ;
    return nonempty(ss);
  }


  Statement desugar_stmt(SynStmt stmt, [Var] def_vars) =
    transfer_attachments(desugar_stmt_plain(stmt, def_vars), stmt);


  Statement desugar_stmt_plain(SynStmt stmt, [Var] def_vars):
    assignment_stmt()         = assignment_stmt(stmt.vars, desugar_expr(stmt.value, def_vars)),
    imp_update_stmt()         = imp_update_stmt(stmt.obj, desugar_expr(stmt.idx, def_vars), desugar_expr(stmt.value, def_vars)),
    return_stmt(e?)           = return_stmt(desugar_expr(e, def_vars)),
    break_stmt                = break_stmt,
    fail_stmt                 = fail_stmt,
    assert_stmt()             = desugar_assert_stmt(stmt, def_vars),
    print_stmt(e?)            = print_stmt(desugar_expr(e, def_vars)),
    inf_loop_stmt(ss?)        = loop_stmt(desugar_stmts(ss, def_vars)),
    if_stmt()                 = desugar_if_stmt(stmt, def_vars),
    let_stmt()                = desugar_let_stmt(stmt, def_vars),
    loop_stmt()               = desugar_loop_stmt(stmt, def_vars),
    for_stmt()                = desugar_for_stmt(stmt.loops, stmt.body, def_vars),
    return_stmt               = return_stmt,
    set_memb_var_stmt()       = set_memb_var_stmt(stmt.var, desugar_expr(stmt.value, def_vars)),
    method_call_stmt()        = desugar_method_call_stmt(stmt, def_vars),
    proc_call()               = proc_call(
                                  res_var:    stmt.res_var if stmt.res_var?,
                                  proc_name:  stmt.proc_name,
                                  params:     (desugar_expr(p, def_vars) : p <- stmt.args)
                                ),
    auto_set_input_stmt()     = auto_set_input_stmt(
                                  stmt.var,
                                  stmt.input,
                                  match (stmt.value)
                                    nil       = nil,
                                    just(e?)  = just(desugar_expr(e, def_vars))
                                ),
    auto_update_stmt()        = auto_update_stmt(
                                  var:          stmt.var,
                                  elapsed_time: desugar_expr(stmt.elapsed_time, def_vars) if stmt.elapsed_time?
                                );


  MethodCallStmt desugar_method_call_stmt(SynMethodCallStmt stmt, [Var] def_vars) =
    method_call_stmt(
      var:      { var_id = stmt.var;
                  loc_var = loc_auto_var(var_id);
                  memb_var = memb_auto_var(var_id);
                  assert has_key(auto_vars_outputs, loc_var) != has_key(auto_vars_outputs, memb_var);
                  return if has_key(auto_vars_outputs, loc_var) then loc_var else memb_var;
                } if stmt.var?,
      name:     update_method_symb(stmt.name),
      args:     (desugar_expr(a, def_vars) : a <- stmt.args)
    );


  Statement desugar_if_stmt(SynIfStmt stmt, [Var] def_vars)
  {
    else_stmts = stmt.else; //## THIS IS HERE JUST TO SHUT UP THE TYPECHECKER
    res = if else_stmts != () then desugar_stmts(else_stmts, def_vars) else ();
    for b <- reverse(stmt.branches):
      cond = desugar_expr(b.cond, def_vars);
      body = desugar_stmts(b.body, def_vars);
      res  = (if_stmt(cond, body, res));
    ;
    assert res :: Seq and length(res) == 1;
    return res[0]; //## BAD BAD BAD
  }


  Statement desugar_let_stmt(SynLetStmt stmt, [Var] def_vars)
  {
    asgnms = merge(([var -> desugar_expr(val, def_vars)] : var, val <- stmt.asgnms));
    body   = desugar_stmts(stmt.body, def_vars, named_args = named_args & keys(asgnms));
    return let_stmt(asgnms, body);
  }


  Statement desugar_loop_stmt(SynLoopStmt stmt, [Var] def_vars)
  {
    cond      = desugar_expr(stmt.cond, def_vars);
    exit_stmt = if_stmt(not_expr(cond), (break_stmt), ());
    body      = desugar_stmts(stmt.body, def_vars);
    if stmt.skip_first:
      body = body & (exit_stmt);
    else
      body = (exit_stmt) & body;
    ;
    return loop_stmt(nonempty(body));
  }


  Statement desugar_for_stmt(SynIter+ loops, SynStmt+ body, [Var] def_vars)
  {
    //## ALSO MAKE SURE SYNTAX CHECK GETS IT RIGHT
    iters  = loops;
    vs     = def_vars;
    for_vs = ();
    for it <- iters:
      ivs  = match (it)
        seq_iter()   = set(it.vars),
        range_iter() = [it.var if it.var?];
      vs     = vs & ivs & [it.idx_var if it.idx_var?];
      for_vs = for_vs & (vs);
    ;
    res = desugar_stmts(body, vs);
    for it @ i <- reverse(iters):
      vs = rev_at(for_vs, i);
      if it :: SynSeqIter: //## BAD BAD BAD
        vals = desugar_expr(it.values, vs);
        res  = (foreach_stmt(it.vars, if it.idx_var? then just(it.idx_var) else nil, vals, res));
      elif it :: SynRangeIter: //## BAD BAD BAD
        start_val = desugar_expr(it.start_val, vs);
        end_val   = desugar_expr(it.end_val, vs);
        res = (for_stmt(if it.var? then just(it.var) else nil, start_val, end_val, it.end_val_incl, res));
      else
        fail; // We should never get here
      ;
    ;
    assert res :: Seq and length(res) == 1;
    return res[0]; //## BAD BAD BAD
  }


  Statement desugar_assert_stmt(SynAssertStmt stmt, [Var] def_vars)
  {
    expr = desugar_expr(stmt.cond, def_vars);
    loc_vars = [v : v <- def_vars, v :: StdVar];
    scalar_named_args = [arg : arity @ arg <- named_args_arities, arity == 0];
    return assert_stmt(expr, loc_vars & scalar_named_args, stmt.file, stmt.line, stmt.text);
  }

  ////////////////////////////////////////////////////////////////////////////////

  Pattern desugar_ptrn(SynPtrn ptrn)
  {
    return transfer_attachments(desugar(ptrn), ptrn);

    Pattern desugar(SynPtrn ptrn):
      ptrn_symbol             = ptrn,
      ptrn_float              = ptrn,
      ptrn_any                = ptrn,
      ptrn_seq                = ptrn_seq,
      ptrn_set                = ptrn_set,
      ptrn_map                = ptrn_map,
      ptrn_symbol()           = ptrn,
      ptrn_integer(integer)   = ptrn_integer,
      ptrn_integer(int_obj?)  = ptrn_integer(int_obj),
      ptrn_tuple(ps?)         = ptrn_tuple((desugar_ptrn(p) : p <- ps)),
      ptrn_tag_obj            = ptrn_tag_obj(ptrn_symbol, ptrn_any),
      ptrn_tag_obj()          = ptrn_tag_obj(ptrn.tag, desugar_ptrn(ptrn.obj)),
      ptrn_var()              = ptrn_var(ptrn.var, desugar_ptrn(ptrn.ptrn)),
      ptrn_type(type?)        = type_to_pattern(syn_type_to_type(type, nil), typedefs),
      ptrn_union(ps?)         = ptrn_union(set((desugar_ptrn(p) : p <- ps)));
  }
}

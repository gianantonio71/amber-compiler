using
{
  ClsVar*                       closures,
  NamedArg*                     named_args,
  MembVar*                      memb_vars,
  (AutoVar => Atom*)            auto_vars_outputs,
  ((FnSymbol, NzNat) => [Nat^]) local_fns,
  Maybe[FnSymbol]               curr_outer_fn, //## BUG: THIS IS NOT ENOUGH TO IDENTIFY THE OUTER FUNCTION...
  (TypeName => Type)            typedefs,
  ((FnSymbol, Nat) => [Nat])    fn_arg_arities;


  Expr desugar_expr(SynExpr expr, Var* def_vars):
    object()          = expr,
    float_lit()       = expr,
    seq_expr(es?)     = seq_expr([desugar_expr(e, def_vars) : e <- es]),
    seq_tail_expr()   = seq_tail_expr(desugar_expr(expr.seq, def_vars), [desugar_expr(e, def_vars) : e <- expr.tail]),
    tuple_expr(es?)   = tuple_expr([desugar_expr(e, def_vars) : e <- es]),
    set_expr(es?)     = set_expr({desugar_expr(e, def_vars) : e <- es}),
    map_expr(es?)     = desugar_map_expr(es, def_vars),
    tag_obj_expr()    = tag_obj_expr(desugar_expr(expr.tag, def_vars), desugar_expr(expr.obj, def_vars)),
    FnPar             = expr,
    cls_par(n?)       = fn_par(n),
    const_or_var(a?)  = desugar_const_or_var_expr(a, def_vars),
    fn_call()         = desugar_fn_call_expr(expr.name, expr.args, expr.named_args, def_vars),
    builtin_call()    = builtin_call(expr.name, [desugar_expr(e, def_vars) : e <- expr.args]),
    and()             = and_expr(desugar_expr(expr.left, def_vars), desugar_expr(expr.right, def_vars)),
    or()              = or_expr(desugar_expr(expr.left, def_vars), desugar_expr(expr.right, def_vars)),
    not(e?)           = not_expr(desugar_expr(e, def_vars)),
    eq()              = eq(desugar_expr(expr.left, def_vars), desugar_expr(expr.right, def_vars)),
    neq()             = not_expr(eq(desugar_expr(expr.left, def_vars), desugar_expr(expr.right, def_vars))),
    membership()      = membership(desugar_expr(expr.obj, def_vars), syn_type_to_type(expr.type, nil)),
    cast_expr()       = cast_expr(desugar_expr(expr.expr, def_vars), syn_type_to_type(expr.type, nil)),
    accessor()        = desugar_accessor(expr.expr, expr.field, def_vars),
    accessor_test()   = desugar_accessor_test(expr.expr, expr.field, def_vars),
    ex_qual()         = desugar_ex_qual_expr(expr.source, expr.cond, def_vars),
    set_comp()        = desugar_set_comp_expr(expr.expr, expr.source, def_vars),
    map_comp()        = desugar_map_comp_expr(expr.key_expr, expr.value_expr, expr.source, def_vars),
    seq_comp()        = desugar_seq_comp_expr(expr, def_vars),
    range_comp()      = desugar_range_comp_expr(expr, def_vars),
    if_expr()         = desugar_if_expr(expr, def_vars),
    match_expr()      = desugar_match_expr(expr.exprs, expr.cases, def_vars),
    do_expr(ss?)      = do_expr(desugar_stmts(ss, def_vars)),
    let_expr()        = do_expr(desugar_stmts(nonempty(expr.stmts & [syn_ret_stmt(expr.expr)]), def_vars));


  Expr desugar_map_expr(SynMapExprEntry* entries, Var* def_vars) =
    map_expr({(
        key:   desugar_expr(e.key, def_vars),
        value: desugar_expr(e.value, def_vars),
        cond:  desugar_expr(e.cond, def_vars) if e.cond?
      ) : e <- entries
    });


  Expr desugar_const_or_var_expr(Atom var_symb, Var* def_vars)
  {
    assert not in(cls_var(var_symb), closures);

    return var(var_symb) if in(var(var_symb), def_vars);
    return named_arg(var_symb) if in(named_arg(var_symb), named_args);
    return memb_var(var_symb) if in(memb_var(var_symb), memb_vars);

    auto_var = auto_var(var_symb);
    if (has_key(auto_vars_outputs, auto_var))
      entries = {(
        key:    object(output),
        value:  get_output(auto_var, output),
        cond:   test_output(auto_var, output)
      ) : output <- auto_vars_outputs[auto_var]};
      return map_expr(entries);
    ;

    return fn_call(fn_symbol(var_symb), [], ());
  }


  Expr desugar_fn_call_expr(FnSymbol name, [SynExpr^] args, [(NamedArg, [<var(Atom)>], SynExpr)] expl_named_args, Var* def_vars)
  {
    //## BAD (BUG?): THIS IS NOT VALID IF THE PARAMETER IS A CLOSURE
    //## VARIABLE OR IF IT'S THE NAME OF A FUNCTION. RIGHT NOW IT
    //## SHOULD NOT FAIL, BUT ONLY BECAUSE THE const_or_var() DOESN'T
    //## DO ANY CHECKING AT THE MOMENT
    fn_id = (name, length(args));
    nps = merge([(n => desugar_named_arg_expr(e, def_vars, ps)) : n, ps, e <- expl_named_args]);

    // Closures first
    if (name :: <fn_symbol(Atom)>)
      cls_var = cls_var(_obj_(name));
      if (in(cls_var, closures))
        assert nps == ();
        ps = [desugar_expr(e, def_vars) : e <- args];
        return cls_call(cls_var, ps);
      ;
    ;

    // Then local functions. Here we have to deal with closure parameters.
    if (has_key(local_fns, fn_id))
      fs = nested_fn_symbol(value(curr_outer_fn), name);
      pas = local_fns[fn_id];
      eps = [desugar_fn_arg(p, a, def_vars) : p, a <- zip(args, pas)];
      return fn_call(fs, eps, nps);
    ;

    // Then named parameters
    if (name :: <fn_symbol(Atom)>)
      np  = named_arg(_obj_(name));
      if (in(np, named_args))
        assert nps == ();
        ps = [desugar_expr(e, def_vars) : e <- args];
        return cls_call(np, ps);
      ;
    ;

    // And last global functions. Here too we have to deal with closures.
    pas = fn_arg_arities[fn_id];
    eps = [desugar_fn_arg(p, a, def_vars) : p, a <- zip(args, pas)];
    return fn_call(name, eps, nps);


    AnyExpr desugar_named_arg_expr(SynExpr syn_expr, Var* outside_vars, [<var(Atom)>] cls_pars)
    {
      vars = outside_vars - {v : v <- outside_vars, fn_par() << v} & set(cls_pars) & set([fn_par(i) : i < length(cls_pars)]);
      expr = desugar_expr(syn_expr, vars);
      return if cls_pars == [] then expr else cls_expr(cls_pars, expr);
    }


    AnyExpr desugar_fn_arg(SynExpr syn_arg, Nat exp_arity, Var* def_vars)
    {
      if (exp_arity == 0 or not syn_arg :: ConstOrVar)
        arg = desugar_expr(syn_arg, def_vars);
        return if exp_arity == 0 then arg else cls_expr(exp_arity, arg);
      ;

      symb = _obj_(syn_arg);

      is_loc_var = in(var(symb), def_vars);
      is_named_arg = in(named_arg(symb), named_args);
      is_glob_const = has_key(fn_arg_arities, (fn_symbol(symb), 0));

      //## BUG? IS THIS RIGHT? SHOULDN'T GLOBAL CONSTANTS HAVE MINIMUM PRIORITY?
      if (is_loc_var or is_named_arg or is_glob_const)
        return cls_expr(exp_arity, desugar_expr(syn_arg, def_vars));
      else
        cls_var = cls_var(symb);
        return cls_var if in(cls_var, closures);
        fn_symb = fn_symbol(symb);
        fn_symb = nested_fn_symbol(value(curr_outer_fn), fn_symb) if has_key(local_fns, (fn_symb, exp_arity));
        return fn_ptr(fn_symb, exp_arity);
      ;
    }
  }


  Expr desugar_accessor(SynExpr expr, SymbObj field, Var* def_vars):
    const_or_var(n?)  = if has_key(auto_vars_outputs, auto_var(n))
                          then get_output(auto_var(n), match (field) object(f?) = f)
                          else accessor(desugar_expr(expr, def_vars), field),
    _                 = accessor(desugar_expr(expr, def_vars), field);


  Expr desugar_accessor_test(SynExpr expr, SymbObj field, Var* def_vars):
    const_or_var(n?)  = if has_key(auto_vars_outputs, auto_var(n))
                          then test_output(auto_var(n), match (field) object(f?) = f)
                          else accessor_test(desugar_expr(expr, def_vars), field),
    _                 = accessor_test(desugar_expr(expr, def_vars), field);


  Expr desugar_ex_qual_expr([SynClause^] source, SynExpr cond, Var* def_vars)
  {
    vs = def_vars & syn_new_vars(source);
    c  = desugar_expr(cond, vs);
    return ex_qual(mk_and_clause(source, def_vars), c);
  }


  Expr desugar_set_comp_expr(SynExpr expr, [SynClause^] source, Var* def_vars)
  {
    vs = def_vars & syn_new_vars(source);
    return set_comp(desugar_expr(expr, vs), mk_and_clause(source, def_vars));
  }


  Expr desugar_map_comp_expr(SynExpr key_expr, SynExpr value_expr, [SynClause^] source, Var* def_vars)
  {
    vs = def_vars & syn_new_vars(source);
    return map_comp(desugar_expr(key_expr, vs), desugar_expr(value_expr, vs), mk_and_clause(source, def_vars));
  }


  Expr desugar_seq_comp_expr(SynLCExpr expr, Var* def_vars)
  {
    vs = def_vars & set(expr.vars) & {expr.idx_var if expr.idx_var?};
    return seq_comp(
      expr:          desugar_expr(expr.expr, vs),
      vars:          expr.vars,
      idx_var:       expr.idx_var if expr.idx_var?,
      src_expr:      desugar_expr(expr.src_expr, def_vars),
      sel_expr:      desugar_expr(expr.sel_expr, vs) if expr.sel_expr?
    );
  }


  Expr desugar_range_comp_expr(SynRCExpr expr, Var* def_vars)
  {
    vs = def_vars & {expr.var};
    return range_comp(
      expr:         desugar_expr(expr.expr, vs),
      var:          expr.var,
      bound_expr:   desugar_expr(expr.bound_expr, def_vars),
      inclusive:    expr.inclusive,
      sel_expr:     desugar_expr(expr.sel_expr, vs) if expr.sel_expr?
    );
  }


  Expr desugar_if_expr(SynIfExpr expr, Var* def_vars)
  {
    res = desugar_expr(expr.else, def_vars);
    for (b : reverse(expr.branches))
      res = if_expr(desugar_expr(b.cond, def_vars), desugar_expr(b.expr, def_vars), res);
    ;
    return res;
  }


  Expr desugar_match_expr([SynExpr^] exprs, [SynCase^] cases, Var* def_vars)
  {
    n  = length(cases[0].patterns);
    es = nonempty([desugar_expr(e, def_vars) : e <- subseq(exprs, 0, n)]);
    cs = [{
      ps = [desugar_ptrn(p) : p <- c.patterns];
      vs = def_vars & seq_union([new_vars(p) : p <- ps]);
      return (ptrns: ps, expr: desugar_expr(c.expr, vs));
    } : c <- cases];
    return match_expr(es, cs);
  }

  ////////////////////////////////////////////////////////////////////////////////

  CondExpr desugar_expr(SynCondExpr cexpr, Var* def_vars) =
    cond_expr(
      desugar_expr(cexpr.expr, def_vars),
      desugar_expr(cexpr.cond, def_vars)
    );

  
  Expr mk_and_expr([Expr^] exprs)  // REMOVE DUPLICATES?
  {
    rev_exprs = reverse(exprs);
    expr      = rev_exprs[0];
    for (i = 1..length(exprs))
      expr = and_expr(rev_exprs[i], expr);
    ;
    return expr;  
  }

  ////////////////////////////////////////////////////////////////////////////////

  Clause mk_and_clause([SynClause^] clauses, Var* def_vars)
  {
    vs = def_vars;
    cs = [];
    for (c : clauses)
      cs = cs & [desugar_clause(c, vs)];
      vs = vs & syn_new_vars(c);
    ;

    rev_cs = reverse(cs);
    clause = rev_cs[0];
    for (i = 1..length(clauses))
      clause = and_clause(rev_cs[i], clause);
    ;

    return clause;
  }

  //## REMEMBER TO CHECK THAT ALL VAR_PTRN() WITH A "BOUND" VARIABLE
  //## DON'T HAVE A PATTERN ASSOCIATED WITH THAT VARIABLE
  
  Clause desugar_clause(SynClause cls, Var* def_vars):
    set_elem_clause()   = set_elem_clause(cls.var, desugar_expr(cls.src, def_vars)),
    map_entry_clause()  = map_entry_clause(cls.key_var, cls.value_var, desugar_expr(cls.src, def_vars)),
    seq_elem_clause()   = seq_elem_clause(cls.var, desugar_expr(cls.src, def_vars)),
    and_clause(cs?)     = mk_and_clause(cs, def_vars),
    or_clause()         = or_clause(desugar_clause(cls.left, def_vars), desugar_clause(cls.right, def_vars)),
    match_clause()      = match_clause(desugar_ptrn(cls.ptrn), desugar_expr(cls.expr, def_vars)),
    asgnm_clause()      = asgnm_clause(cls.var, desugar_expr(cls.expr, def_vars)),
    filter_clause()     = filter_clause(desugar_expr(cls.cond, def_vars));

  ////////////////////////////////////////////////////////////////////////////////

  //## BAD: THIS SHOULD BE REPLACED BY A COUPLE OF SUBSIGNATURES.
  <[]> desugar_stmts(<[]>, Var*) = [];

  [Statement^] desugar_stmts([SynStmt^] stmts, Var* def_vars)
  {
    vs = def_vars;
    ss = [];
    for (s : stmts)
      ss = ss & [desugar_stmt(s, vs)];
      vs = vs & syn_new_vars(s);
    ;
    return nonempty(ss);
  }


  Statement desugar_stmt(SynStmt stmt, Var* def_vars):
    assignment_stmt()         = assignment_stmt(stmt.vars, desugar_expr(stmt.value, def_vars)),
    imp_update_stmt()         = imp_update_stmt(stmt.obj, desugar_expr(stmt.idx, def_vars), desugar_expr(stmt.value, def_vars)),
    return_stmt(e?)           = return_stmt(desugar_expr(e, def_vars)),
    break_stmt                = break_stmt,
    fail_stmt                 = fail_stmt,
    assert_stmt(e?)           = assert_stmt(desugar_expr(e, def_vars)),
    print_stmt(e?)            = print_stmt(desugar_expr(e, def_vars)),
    inf_loop_stmt(ss?)        = loop_stmt(desugar_stmts(ss, def_vars)),
    if_stmt()                 = desugar_if_stmt(stmt, def_vars),
    let_stmt()                = desugar_let_stmt(stmt, def_vars),
    loop_stmt()               = desugar_loop_stmt(stmt, def_vars),
    for_stmt()                = desugar_for_stmt(stmt.loops, stmt.body, def_vars),
    return_stmt               = return_stmt,
    proc_call()               = proc_call(
                                  res_var:    stmt.res_var if stmt.res_var?,
                                  proc_name:  stmt.proc_name,
                                  params:     [desugar_expr(p, def_vars) : p <- stmt.args]
                                ),
    auto_input_update_stmt()  = auto_input_update_stmt(stmt.var, (i.input => desugar_expr(i.value, def_vars) : i <- set(stmt.inputs)));


  Statement desugar_if_stmt(SynIfStmt stmt, Var* def_vars)
  {
    else_stmts = stmt.else; //## THIS IS HERE JUST TO SHUT UP THE TYPECHECKER
    res = if else_stmts != [] then desugar_stmts(else_stmts, def_vars) else [];
    for (b : reverse(stmt.branches))
      cond = desugar_expr(b.cond, def_vars);
      body = desugar_stmts(b.body, def_vars);
      res  = [if_stmt(cond, body, res)];
    ;
    assert res :: Seq and length(res) == 1;
    return res[0]; //## BAD BAD BAD
  }


  Statement desugar_let_stmt(SynLetStmt stmt, Var* def_vars)
  {
    asgnms = merge([(var => desugar_expr(val, def_vars)) : var, val <- stmt.asgnms]);
    body   = desugar_stmts(stmt.body, def_vars, named_args = named_args & keys(asgnms));
    return let_stmt(asgnms, body);
  }


  Statement desugar_loop_stmt(SynLoopStmt stmt, Var* def_vars)
  {
    cond      = desugar_expr(stmt.cond, def_vars);
    exit_stmt = if_stmt(not_expr(cond), [break_stmt], []);
    body      = desugar_stmts(stmt.body, def_vars);
    if (stmt.skip_first)
      body = body & [exit_stmt];
    else
      body = [exit_stmt] & body;
    ;
    return loop_stmt(nonempty(body));
  }


  Statement desugar_for_stmt([SynIter^] loops, [SynStmt^] body, Var* def_vars)
  {
    //## ALSO MAKE SURE SYNTAX CHECK GETS IT RIGHT
    iters  = loops;
    vs     = def_vars;
    for_vs = [];
    for (it : iters)
      ivs  = match (it)
        seq_iter()   = set(it.vars),
        range_iter() = {it.var if it.var?};
      vs     = vs & ivs & {it.idx_var if it.idx_var?};
      for_vs = for_vs & [vs];
    ;
    res = desugar_stmts(body, vs);
    for (it @ i : reverse(iters))
      vs = rev_at(for_vs, i);
      if (it :: SynSeqIter) //## BAD BAD BAD
        vals = desugar_expr(it.values, vs);
        res  = [foreach_stmt(it.vars, if it.idx_var? then just(it.idx_var) else nil, vals, res)];
      elif (it :: SynRangeIter) //## BAD BAD BAD
        start_val = desugar_expr(it.start_val, vs);
        end_val   = desugar_expr(it.end_val, vs);
        res = [for_stmt(if it.var? then just(it.var) else nil, start_val, end_val, it.end_val_incl, res)];
      else
        fail; // We should never get here
      ;
    ;
    assert res :: Seq and length(res) == 1;
    return res[0]; //## BAD BAD BAD
  }

  ////////////////////////////////////////////////////////////////////////////////

  Pattern desugar_ptrn(SynPtrn ptrn):
    ptrn_symbol             = ptrn,
    ptrn_float              = ptrn,
    ptrn_any                = ptrn,
    ptrn_seq                = ptrn_seq,
    ptrn_set                = ptrn_set,
    ptrn_map                = ptrn_map,
    ptrn_symbol()           = ptrn,
    ptrn_integer(integer)   = ptrn_integer,
    ptrn_integer(int_obj?)  = ptrn_integer(int_obj),
    ptrn_tag_obj            = ptrn_tag_obj(ptrn_symbol, ptrn_any),
    ptrn_tag_obj()          = ptrn_tag_obj(ptrn.tag, desugar_ptrn(ptrn.obj)),
    ptrn_var()              = ptrn_var(ptrn.var, desugar_ptrn(ptrn.ptrn)),
    ptrn_type(type?)        = type_to_pattern(syn_type_to_type(type, nil), typedefs);
}

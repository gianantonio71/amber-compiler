using
{
  [TypeName -> Type]              typedefs,
  [FnSymbol -> [Nat -> Nat*]]     fn_arg_arities,
  [AutoSymbol -> AutoInterface]   auto_interfaces;


  Automaton syn_auto_def_to_auto_def(SynAutoDef auto_def, [SynReadOnlyMethodDef] read_only_methods, [SynUpdateMethodDef] update_methods)
  {
    decls = set(auto_def.decls);

    syn_inputs                  = [d : d <- decls, syn_input()                        << d];
    syn_outputs                 = [d : d <- decls, syn_output()                       << d];
    syn_state_vars              = [d : d <- decls, syn_state()                        << d];
    syn_plain_rules_lookalikes  = [d : d <- decls, syn_plain_rule()                   << d];
    syn_cond_rules              = [d : d <- decls, syn_cond_rule()                    << d];
    syn_foreach_rules           = [d : d <- decls, syn_foreach_rule()                 << d];
    syn_time_varying_rules      = [d : d <- decls, syn_time_varying_boolean_rule()    << d] &
                                  [d : d <- decls, syn_time_varying_unchanged_rule()  << d] &
                                  [d : d <- decls, syn_time_varying_inactive_rule()   << d];
    syn_nested_autos            = [d : d <- decls, syn_nested_auto()                  << d];
    syn_method_calls            = [d : d <- decls, syn_method_call()                  << d];

    assert decls == syn_inputs & syn_outputs & syn_state_vars & syn_plain_rules_lookalikes & syn_cond_rules &
                    syn_foreach_rules & syn_time_varying_rules & syn_nested_autos & syn_method_calls;

    syn_plain_rules, syn_disguised_autos = rewrite_disguised_nested_autos(syn_plain_rules_lookalikes);
    syn_nested_autos = syn_nested_autos & syn_disguised_autos;

    memb_vars = [memb_var(d.name) : d <- syn_inputs & syn_outputs & syn_state_vars & syn_plain_rules &
                                         syn_cond_rules & syn_foreach_rules & syn_time_varying_rules];

    disc_signals = [d.name : d <- syn_inputs & syn_outputs & syn_plain_rules & syn_cond_rules & syn_foreach_rules, d.discrete];

    auto_vars_types = [memb_auto_var(a.name) -> auto_symbol(a.auto_name) : a <- syn_nested_autos];

    auto_vars_outputs = [
      v -> [
        [name: n, discrete: info.discrete, default: interface.default_output] : info @ n <- interface.outputs
      ] : t @ v <- auto_vars_types, interface = auto_interfaces[t]
    ];

    state_vars = [
      v.name -> [
        type:       syn_type_to_type(v.type, nil),
        init_value: syn_expr_to_expr(v.init_value, memb_vars, auto_vars_outputs, [])
      ] : v <- syn_state_vars
    ];

    // Reducing time-varying expressions with a constant time expression to plain rules
    fake_time_varying_rules = [rewrite_fake_time_rule(r) : r <- syn_time_varying_rules, is_fake(r)];
    syn_plain_rules = syn_plain_rules & fake_time_varying_rules;
    syn_time_varying_rules = [r : r <- syn_time_varying_rules, not is_const(r.time_expr)];

    // Desugaring plain rules, which can have implicit repeated conditions
    plain_rules_output = [desugar_plain_rule(r, memb_vars, auto_vars_outputs, disc_signals, auto_vars_types) : r <- syn_plain_rules];
    rules = merge([value(r) : o <- plain_rules_output, r = left(o), r != nil]);
    rep_actions_1 = [value(a) : o <- plain_rules_output, a = right(o), a != nil];

    // Desugaring conditional rules, which can have additional repeated conditions
    cond_rule_output = [desugar_cond_rule(r, memb_vars, auto_vars_outputs, disc_signals) : r <- syn_cond_rules];
    actions = [value(a) : o <- cond_rule_output, a = left(o), a != nil];
    rep_actions_2 = [value(a) : o <- cond_rule_output, a = right(o), a != nil];

    // Foreach rules can only lead to repeated actions
    rep_actions_3 = [foreach_rule_to_repeated_action(r, memb_vars, auto_vars_outputs, disc_signals) : r <- syn_foreach_rules];

    // Pulling all repeated actions together
    rep_actions = rep_actions_1 & rep_actions_2 & rep_actions_3;

    // Desugaring time-varying rules
    time_rules = [r.name -> syn_time_varying_rule_to_cond(r, memb_vars, auto_vars_outputs) : r <- syn_time_varying_rules];

    // Desugaring nested automata
    nested_autos = [
      na.name -> [
        type: auto_symbol(na.auto_name),
        args: merge(([f -> syn_expr_to_expr(e, memb_vars, auto_vars_outputs, [])] : f, e <- na.args))
      ]
      : na <- syn_nested_autos
    ];

    // Desugaring method calls on nested automata
    all_method_call_actions = [method_call_to_action(c, memb_vars, auto_vars_outputs, disc_signals) : c <- syn_method_calls];
    cond_method_calls = [value(ca) : a <- all_method_call_actions, ca = left(a), ca != nil];
    actions = actions & cond_method_calls;
    rep_method_calls = [value(ra) : a <- all_method_call_actions, ra = right(a), ra != nil];
    rep_actions = rep_actions & rep_method_calls;

    // Identifying constant rules
    arg_ids = [];
    loop
      next_round = [
        id : e @ id <- rules,
             vids = [unsafe_name(v) : v <- extern_vars(e)],
             subset(vids, arg_ids),
             extern_auto_vars(e) == []
      ];
      break if next_round == arg_ids;
      arg_ids = next_round;
    ;

    args = select_by_key(rules, arg_ids);
    rules = remove_keys(rules, arg_ids);

    return automaton(
      name:               auto_def.name,
      params:             args,
      inputs:             inputs(auto_def),
      outputs:            outputs(auto_def),
      state:              state_vars,
      rules:              rules,
      time_rules:         time_rules,
      actions:            actions,
      rep_actions:        rep_actions,
      nested_autos:       nested_autos,
      read_only_methods:  [desugar_read_only_method(m, memb_vars, auto_vars_outputs) : m <- read_only_methods],
      update_methods:     [desugar_update_method(m, memb_vars, auto_vars_outputs) : m <- update_methods]
    );
  }


  Bool is_fake(SynTimeVaryingRule rule):
    syn_time_varying_boolean_rule()   |
    syn_time_varying_unchanged_rule() = is_const(rule.time_expr),
    syn_time_varying_inactive_rule()  = is_const(rule.time_expr) and
                                        (initial_value(rule.time_expr) == false or rule.starts_at_time_0);


  SynPlainRule rewrite_fake_time_rule(SynTimeVaryingRule rule)
  {
    assert is_fake(rule);

    value = match (rule)
      syn_time_varying_boolean_rule()   = if initial_value(rule.time_expr) == true then rule.cond else object(false),
      syn_time_varying_unchanged_rule() = object(initial_value(rule.time_expr)),
      syn_time_varying_inactive_rule()  = object(initial_value(rule.time_expr));

    return syn_plain_rule(rule.name, value, false);
  }


  ([SynPlainRule], [SynNestedAuto]) rewrite_disguised_nested_autos([SynPlainRule] rules)
  {
    plain_rules = [];
    nested_autos = [];
    for r <- rand_sort(rules):
      new_rule = rewrite_if_need_be(r);
      plain_rules, nested_autos = match (new_rule)
        syn_plain_rule()  = (plain_rules & [new_rule], nested_autos),
        syn_nested_auto() = (plain_rules, nested_autos & [new_rule]);
    ;
    return (plain_rules, nested_autos);


    <SynPlainRule, SynNestedAuto> rewrite_if_need_be(SynPlainRule rule)
    {
      expr = rule.expr;
      if expr :: SynFnCall:
        fn_name = expr.name;
        if fn_name :: <fn_symbol(Atom)>:
          id = bare_id(fn_name);
          arity = length(expr.args);
          auto_name = auto_symbol(id);

          if is_disguised_auto(fn_name, auto_name, arity):
            auto_interface = auto_interfaces[auto_name];
            assert expr.args == () or length(auto_interface.pos_inputs) == length(expr.args);
            pos_inputs = if expr.args != () then zip(auto_interface.pos_inputs, expr.args) else ();
            named_inputs = ((name(a), e) : a, unused_var, e <- expr.named_args);
            return syn_nested_auto(rule.name, id, pos_inputs & named_inputs);
          ;
        ;
      ;
      return rule;
    }


    Bool is_disguised_auto(FnSymbol fn_name, AutoSymbol auto_name, Nat arity)
    {
      return false if not has_key(auto_interfaces, auto_name);
      return true if not has_key(fn_arg_arities, fn_name);

      // Here we have a conflict...

      auto_interface = auto_interfaces[auto_name];
      auto_arity = length(auto_interface.pos_inputs);
      fn_arities = fn_arg_arities[fn_name];

      auto_arity_ok = arity == auto_arity or arity == 0;
      fn_arity_ok = has_key(fn_arities, arity);

      return true if auto_arity_ok and not fn_arity_ok;
      return false if not auto_arity_ok and fn_arity_ok;

      fail;
    }
  }


  (Maybe[AutoCondAction], Maybe[AutoRepAction]) method_call_to_action(SynMethodCall syn_call, [MembVar] memb_vars, [MembAutoVar -> [[name: Atom, discrete: Bool, default: Bool]]] auto_vars_outputs, [Atom] disc_signals)
  {
    target  = memb_auto_var(syn_call.target);
    method  = update_method_symb(syn_call.method);
    message = syn_expr_to_expr(syn_call.message, memb_vars, auto_vars_outputs, []);
    call = method_call(target, method, message);

    maybe_syn_cond = syn_call.cond;
    maybe_cond = if maybe_syn_cond != nil
                   then just(syn_expr_to_expr(value(maybe_syn_cond), memb_vars, auto_vars_outputs, []))
                   else nil;

    // If the list of discrete signals is not given explicitly, we search
    // the parameter list and the condition for discrete signals
    if syn_call.signals != ():
      signals = syn_call.signals;
    else
      exprs = [message, value(maybe_cond) if maybe_cond != nil];
      all_signals = [match (v) memb_var(id?) = id : v <- union([extern_vars(e) : e <- exprs])];
      signals = rand_sort(intersection(all_signals, disc_signals));
    ;
    signals_set_conds = (is_set(memb_var(s)) : s <- signals);

    if maybe_cond != nil:
      cond = value(maybe_cond);
      // If no discrete signals are involved, this is a (non-repeated) conditional action
      return (just(cond_action(cond, [call], [])), nil) if signals_set_conds == ();
      cond = and_expr((signals_set_conds | cond));
    else
      cond = and_expr(nonempty(signals_set_conds));
    ;

    return (nil, just(rep_action(cond, [call], [])));
  }


  ReadOnlyMethod desugar_read_only_method(SynReadOnlyMethodDef syn_method, [MembVar] memb_vars, [MembAutoVar -> [[name: Atom, discrete: Bool, default: Bool]]] auto_vars_outputs)
  {
    args = ((syn_type_to_type(t, nil), v) : t, v <- syn_method.args);
    ret_type = syn_type_to_type(syn_method.ret_type, nil);
    expr = syn_expr_to_expr(syn_method.expr, memb_vars, auto_vars_outputs, set((v : unused_var, v <- syn_method.args)));
    return read_only_method(syn_method.name, args, ret_type, expr);
  }


  UpdateMethod desugar_update_method(SynUpdateMethodDef syn_method, [MembVar] memb_vars, [MembAutoVar -> [[name: Atom, discrete: Bool, default: Bool]]] auto_vars_outputs)
  {
    args = ((syn_type_to_type(t, nil), v) : t, v <- syn_method.args);
    body = syn_stmts_to_stmts(syn_method.body, memb_vars, auto_vars_outputs, set((v : unused_var, v <- syn_method.args)));
    return update_method(syn_method.name, args, body);
  }


  (Maybe[[Atom -> Expr]], Maybe[AutoRepAction]) desugar_plain_rule(SynPlainRule rule, [MembVar] memb_vars, [MembAutoVar -> [[name: Atom, discrete: Bool, default: Bool]]] auto_vars_outputs, [Atom] disc_signals, [MembAutoVar -> AutoSymbol] auto_vars_types)
  {
    expr = syn_expr_to_expr(rule.expr, memb_vars, auto_vars_outputs, []);
    vars = extern_vars(expr);
    input_signals = [match (v) memb_var(id?) = id : v <- vars];
    disc_input_signals = intersection(input_signals, disc_signals);
    disc_nested_output_deps = [
        d
      : d <- possibly_discrete_nested_auto_output_deps_copy_1(expr),
        as = memb_auto_var(left(d)),
        o  = right(d),
        at = auto_vars_types[as],
        auto_interfaces[at].outputs[o].discrete
    ];

    // If a plain rule does not contain any discrete signals,
    // then it defines a continuous intermediate signal
    assert not (rule.discrete and (disc_input_signals == [] and disc_nested_output_deps == []));
    return (just([rule.name -> expr]), nil) if disc_input_signals == [] and disc_nested_output_deps == [];

    // Now it's either a discrete signals definition or a state variable update
    cond = and_expr(
      nonempty(
        (is_set(memb_var(ds)) : ds <- rand_sort(disc_input_signals)) &
        (output_is_set(memb_auto_var(a), o) : a, o <- rand_sort(disc_nested_output_deps))
      )
    );
    action = if rule.discrete then set_discrete(rule.name, expr) else update(rule.name, expr);
    return (nil, just(rep_action(cond, [action], [])));
  }


  (Maybe[AutoCondAction], Maybe[AutoRepAction]) desugar_cond_rule(SynCondRule rule, [MembVar] memb_vars, [MembAutoVar -> [[name: Atom, discrete: Bool, default: Bool]]] auto_vars_outputs, [Atom] disc_signals)
  {
    target = rule.name;
    branches = rule.branches;

    if length(branches) == 1:
      branch = branches[0];
      cond = syn_expr_to_expr(branch.cond, memb_vars, auto_vars_outputs, []);
      expr = syn_expr_to_expr(branch.expr, memb_vars, auto_vars_outputs, []);
      ss = [match (v) memb_var(id?) = id : v <- extern_vars(cond) & extern_vars(expr)];
      dss = (memb_var(s) : s <- rand_sort(intersection(ss, disc_signals)));
      if dss != ():
        if rule.discrete:
          action = set_discrete(target, expr);
        else
          action = update(target, expr);
        ;

        outer_cond = or_expr((is_set(s) : s <- dss));

        if length(dss) > 1:
          inner_cond = and_expr((is_set(s) : s <- dss));
          cond = and_expr(inner_cond, cond);
        ;

        return (nil, just(rep_action(outer_cond, [rep_action(cond, [action], [])], [])));
      ;
    ;

    return (just(cond_rule_to_action(target, branches, rule.discrete, memb_vars, auto_vars_outputs)), nil);
  }


  AutoCondAction cond_rule_to_action(Atom name, [expr: SynExpr, cond: SynExpr]+ branches, Bool discrete, [MembVar] memb_vars, [MembAutoVar -> [[name: Atom, discrete: Bool, default: Bool]]] auto_vars_outputs)
  {
    outer_branch = head(branches);
    inner_branches = tail(branches);

    else_actions = [cond_rule_to_action(name, inner_branches, discrete, memb_vars, auto_vars_outputs) if inner_branches != ()];

    cond = syn_expr_to_expr(outer_branch.cond, memb_vars, auto_vars_outputs, []);
    expr = syn_expr_to_expr(outer_branch.expr, memb_vars, auto_vars_outputs, []);
    if discrete:
      action = set_discrete(name, expr);
    else
      action = update(name, expr);
    ;

    return cond_action(cond, [action], else_actions);
  }


  AutoRepAction foreach_rule_to_repeated_action(SynForeachRule rule, [MembVar] memb_vars, [MembAutoVar -> [[name: Atom, discrete: Bool, default: Bool]]] auto_vars_outputs, [Atom] disc_signals)
  {
    value = syn_expr_to_expr(rule.value, memb_vars, auto_vars_outputs, []);
    if rule.discrete:
      action = set_discrete(rule.name, value);
    else
      action = update(rule.name, value);
    ;
    action = rep_action(syn_expr_to_expr(rule.cond, memb_vars, auto_vars_outputs, []), [action], []) if rule.cond?;

    change_cond = or_expr((
      if in(s, disc_signals)
        then is_set(memb_var(s))
        else not_expr(eq(memb_var(s), memb_copy_var(s)))
     : s <- rule.signals
    ));

    return rep_action(change_cond, [action], []);
  }


  TimeVaryingCond syn_time_varying_rule_to_cond(SynTimeVaryingRule rule, [MembVar] memb_vars, [MembAutoVar -> [[name: Atom, discrete: Bool, default: Bool]]] auto_vars_outputs):
    syn_time_varying_boolean_rule()   = time_varying_boolean_cond(syn_expr_to_expr(rule.cond, memb_vars, auto_vars_outputs, []), rule.time_expr),
    syn_time_varying_unchanged_rule() = time_varying_unchanged_cond(syn_expr_to_expr(rule.cond, memb_vars, auto_vars_outputs, []), rule.time_expr),
    syn_time_varying_inactive_rule()  = time_varying_since_cond([memb_var(s) : s <- set(rule.signals)], rule.time_expr, rule.starts_at_time_0);


  Expr syn_expr_to_expr(SynExpr expr, [MembVar] memb_vars, [MembAutoVar -> [[name: Atom, discrete: Bool, default: Bool]]] auto_vars_outputs, [StdVar] def_vars) =
    desugar_expr(
      expr,
      def_vars,
      closures = [],
      named_args = [],
      named_args_arities = [:],
      memb_vars = memb_vars,
      auto_vars_outputs = auto_vars_outputs,
      local_fns = [:],
      curr_outer_fn = nil, //## UGLY UGLY UGLY
      typedefs = typedefs,
      fn_arg_arities = fn_arg_arities
    );


  Statement* syn_stmts_to_stmts(SynStmt* stmts, [MembVar] memb_vars, [MembAutoVar -> [[name: Atom, discrete: Bool, default: Bool]]] auto_vars_outputs, [StdVar] def_vars) =
    desugar_stmts(
      stmts,
      def_vars,
      closures = [],
      named_args = [],
      named_args_arities = [:],
      memb_vars = memb_vars,
      auto_vars_outputs = auto_vars_outputs,
      local_fns = [:],
      curr_outer_fn = nil, //## UGLY UGLY UGLY
      typedefs = typedefs,
      fn_arg_arities = fn_arg_arities
    );
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//## THIS FUNCTION HAS TWO COPIES (ONE HERE AND ONE IN AUTOMATA CODE GENERATION)
//## BECAUSE IT SEEMS WAY TOO SPECIAL PURPOSE TO PUT IN A SHARED FILE.
[(Atom, Atom)] possibly_discrete_nested_auto_output_deps_copy_1(Expr expr):
  get_output()        = [(name(expr.var), expr.output)],
  // This one is not relevant here because we only care about dependencies
  // that could potentially be discrete, and this signal is always continuous
  output_is_set()     = [],
  // This one should never appear outside the body of a procedure
  output_is_def()     = {fail;},
  // Not relevant either, because this is always a "continuous" signal
  method_call_expr()  = [],
  _                   = retrieve_from_nested_exprs(expr, possibly_discrete_nested_auto_output_deps_copy_1);

implicit syn_prg : SynPrg, auto_def : SynAutoDef
{
  Automaton desugar_automaton
  {
    // Desugaring state variables
    state_vars = [
      v.name -> (
        type:       desugar_type(v.type),
        init_value: desugar_auto_expr(v.init_value, [])
      ) : v <~ auto_def.state_vars
    ];

    // Desugaring plain rules, which can have implicit repeated conditions
    plain_rules_output = [desugar_plain_rule(r) : r <- syn_plain_rules];
    rules = merge([value(r) : o <- plain_rules_output, r = left(o), r != nothing]);
    rep_actions_1 = [value(a) : o <- plain_rules_output, a = right(o), a != nothing];

    // Desugaring conditional rules, which can have additional repeated conditions
    cond_rule_output = [desugar_cond_rule(r) : r <- syn_cond_rules];
    actions = [value(a) : o <- cond_rule_output, a = left(o), a != nothing];
    rep_actions_2 = [value(a) : o <- cond_rule_output, a = right(o), a != nothing];

    // Foreach rules can only lead to repeated actions
    rep_actions_3 = [foreach_rule_to_repeated_action(r) : r <- syn_foreach_rules];

    // Pulling all repeated actions together
    rep_actions = rep_actions_1 & rep_actions_2 & rep_actions_3;

    // Desugaring time-varying rules
    time_rules = [r.name -> syn_time_varying_rule_to_cond(r) : r <- syn_time_varying_rules];

    // Desugaring nested automata
    nested_autos = [
      na.name -> (
        type: auto_symbol(na.auto_name),
        args: merge(([f -> desugar_auto_expr(e, [])] : f, e <- na.args))
      )
      : na <- syn_nested_autos
    ];

    // Creating shadow member variables for automata with default output
    def_output_rules = [
      na.name -> qual_auto_memb_var(memb_auto_var(na.name), memb_var(value(intf.default_output)))
      : na <- syn_nested_autos, intf = auto_interfaces[auto_symbol(na.auto_name)], intf.default_output != nothing
    ];

    // Desugaring method calls on nested automata
    all_msg_send_actions = [msg_send_to_action(c) : c <- syn_msg_sends];
    cond_method_calls = [value(ca) : a <- all_msg_send_actions, ca = left(a), ca != nothing];
    actions = actions & cond_method_calls;
    rep_method_calls = [value(ra) : a <- all_msg_send_actions, ra = right(a), ra != nothing];
    rep_actions = rep_actions & rep_method_calls;

    // // Identifying and separating constant rules
    // const_rules_ids = [];
    // loop
    //   const_rules_vars = [memb_var(id) : id <- const_rules_ids];
    //   next_round = [id : e @ id <- rules, subset(extern_vars(e), const_rules_vars)];
    //   break if next_round == const_rules_ids;
    //   const_rules_ids = next_round;
    // ;
    // const_rules = select_by_key(rules, const_rules_ids);
    // rules = remove_keys(rules, const_rules_ids);

    // Desugaring constants
    params = [
      c.name -> (
        type:  desugar_type(c.type) if c.type?,
        value: desugar_auto_expr(c.value, [])
      ) : c <~ auto_def.consts
    ];

    return automaton(
      name:           auto_def.name,
      params:         params,
      inputs:         inputs(auto_def),
      outputs:        outputs(auto_def),
      state:          state_vars,
      rules:          rules & def_output_rules,
      time_rules:     time_rules,
      actions:        actions,
      rep_actions:    rep_actions,
      nested_autos:   nested_autos,
      nested_dbs:     db_in_auto_vars_types,
      methods:        [desugar_method(m) : m <- lookup(methods_by_automaton, bare_id(auto_def.name), [])]
    );
  }


  Bool is_fake(SynTimeVaryingRule rule) =
    syn_time_varying_boolean_rule()   |
    syn_time_varying_unchanged_rule() = is_const(rule.time_expr),
    syn_time_varying_inactive_rule()  = is_const(rule.time_expr) and
                                        (initial_value(rule.time_expr) == false or rule.starts_at_time_0);


  SynPlainRule rewrite_fake_time_rule(SynTimeVaryingRule rule)
  {
    assert is_fake(rule);

    value = match (rule)
      syn_time_varying_boolean_rule()   = if initial_value(rule.time_expr) == true then rule.cond else object(false),
      syn_time_varying_unchanged_rule() = object(initial_value(rule.time_expr)),
      syn_time_varying_inactive_rule()  = object(initial_value(rule.time_expr));

    return syn_plain_rule(rule.name, value, false);
  }


  (Maybe[AutoCondAction], Maybe[AutoRepAction]) msg_send_to_action(SynMsgSend syn_msg_send)
  {
    target  = memb_db_var(syn_msg_send.target);
    message = desugar_auto_expr(syn_msg_send.message, []);
    msg_send = msg_send(target, message);

    maybe_syn_cond = syn_msg_send.cond;
    maybe_cond = if maybe_syn_cond != nothing
                   then just(desugar_auto_expr(value(maybe_syn_cond), []))
                   else nothing;

    // If the list of discrete signals is not given explicitly, we search
    // the parameter list and the condition for discrete signals
    if syn_msg_send.signals != ():
      signals = (memb_var(a) : a <- syn_msg_send.signals);
    else
      all_signals = union([auto_expr_extern_vars(e) : e <- [message, value(maybe_cond) if maybe_cond != nothing]]);
      signals = rand_sort([s : s <- all_signals, s :: <MembVar, QualAutoMembVar>, signal_is_discrete(s)]);
    ;
    signals_set_conds = (is_set(s) : s <- signals);

    if maybe_cond != nothing:
      cond = value(maybe_cond);
      // If no discrete signals are involved, this is a (non-repeated) conditional action
      return (just(cond_action(cond, [msg_send], [])), nothing) if signals_set_conds == ();
      cond = and_expr((signals_set_conds | cond));
    else
      cond = and_expr(nonempty(signals_set_conds));
    ;

    return (nothing, just(rep_action(cond, [msg_send], [])));
  }


  Method desugar_method(AutoMethodDef method_def)
  {
    args = ((desugar_type(t), just(v)) : t, v <- method_def.args);
    ret_type = desugar_type(method_def.ret_type);
    arg_vars = [v : _, v <~ method_def.args];
    expr = desugar_expr(method_def.expr, arg_vars, syn_artifact = method_def, impl_args = []);
    return method(method_symbol(method_def.name), args, ret_type, expr);
  }


  (Maybe[[Atom -> Expr]], Maybe[AutoRepAction]) desugar_plain_rule(SynPlainRule rule)
  {
    expr = desugar_auto_expr(rule.expr, []);

    //## BY DOING THIS WE ARE ALSO INCLUDING THE VARIABLES IN THE is_set() EXPRESSIONS,
    //## WHICH SHOULD BE FINE AS THOSE VARIABLES SHOULD NEVER APPEAR IN A PLAIN RULE.
    //## REMEMBER TO CHECK THIS IN THE WELL-FORMEDNESS CHECKING LAYER.
    //## WOULD BE NICE TO ADD AN ASSERT HERE, AS WELL.
    //## WE ARE ALSO IGNORING THE output_is_def() EXPRESSION, WHICH SHOULD BE ALLOWED
    //## ONLY INSIDE THE BODY OF A PROCEDURE
    discrete_signals = [v : v <- auto_expr_extern_vars(expr), v :: <MembVar, QualAutoMembVar>, signal_is_discrete(v)];

    // If a plain rule does not contain any discrete signals,
    // then it defines a continuous intermediate signal
    assert not rule.discrete or discrete_signals != [];
    return (just([rule.name -> expr]), nothing) if discrete_signals == [];

    // Now it's either a discrete signals definition or a state variable update
    cond = and_expr((is_set(v) : v <- rand_sort(discrete_signals)));
    action = if rule.discrete then discrete_signal_def(rule.name, expr) else state_update(rule.name, expr);
    return (nothing, just(rep_action(cond, [action], [])));
  }


  (Maybe[AutoCondAction], Maybe[AutoRepAction]) desugar_cond_rule(SynCondRule rule)
  {
    target = rule.name;
    branches = rule.branches;

    if length(branches) == 1:
      branch = branches[0];
      cond = desugar_auto_expr(branch.cond, []);
      expr = desugar_auto_expr(branch.expr, []);
      ss = auto_expr_extern_vars(cond) & auto_expr_extern_vars(expr);
      dss = (s : s <- rand_sort(ss), s :: <MembVar, QualAutoMembVar> and signal_is_discrete(s));

      if dss != ():
        if rule.discrete:
          action = discrete_signal_def(target, expr);
        else
          action = state_update(target, expr);
        ;
        outer_cond = or_expr((is_set(s) : s <- dss));
        if length(dss) > 1:
          inner_cond = and_expr((is_set(s) : s <- dss));
          cond = and_expr(inner_cond, cond);
        ;
        return (nothing, just(rep_action(outer_cond, [rep_action(cond, [action], [])], [])));
      ;
    ;

    return (just(cond_rule_to_action(target, branches, rule.discrete)), nothing);
  }


  AutoCondAction cond_rule_to_action(Atom name, (expr: SynExpr, cond: SynExpr)+ branches, Bool discrete)
  {
    outer_branch = head(branches);
    inner_branches = tail(branches);

    else_actions = [cond_rule_to_action(name, inner_branches, discrete) if inner_branches != ()];

    cond = desugar_auto_expr(outer_branch.cond, []);
    expr = desugar_auto_expr(outer_branch.expr, []);
    if discrete:
      action = discrete_signal_def(name, expr);
    else
      action = state_update(name, expr);
    ;

    return cond_action(cond, [action], else_actions);
  }


  AutoRepAction foreach_rule_to_repeated_action(SynForeachRule rule)
  {
    value = desugar_auto_expr(rule.value, []);
    if rule.discrete:
      action = discrete_signal_def(rule.name, value);
    else
      action = state_update(rule.name, value);
    ;
    action = rep_action(desugar_auto_expr(rule.cond, []), [action], []) if rule.cond?;

    signals = (memb_var(a) : a <- rule.signals);
    change_cond = or_expr((
      if signal_is_discrete(s)
        then is_set(s)
        else not_expr(eq(s, memb_copy_var(bare_id(s))))
     : s <- signals
    ));

    return rep_action(change_cond, [action], []);
  }


  TimeVaryingCond syn_time_varying_rule_to_cond(SynTimeVaryingRule rule) =
    syn_time_varying_boolean_rule()   = time_varying_boolean_cond(desugar_auto_expr(rule.cond, []), rule.time_expr),
    syn_time_varying_unchanged_rule() = time_varying_unchanged_cond(desugar_auto_expr(rule.cond, []), rule.time_expr),
    syn_time_varying_inactive_rule()  = time_varying_since_cond([memb_var(s) : s <~ rule.signals], rule.time_expr, rule.starts_at_time_0);


  Expr desugar_auto_expr(SynExpr expr, [StdVar] def_vars) =
    desugar_expr(expr, def_vars, syn_artifact = auto_def, impl_args = []);

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  SynNestedAuto rewrite_disguised_auto(SynPlainRule rule)
  {
    expr = rule.expr;
    fail if not expr :: <SynImplArgsCall, call_lookalike(target: ConstOrVar, args: SynExpr+)>;

    id = match (expr)
      impl_args_call()  = expr.name,
      call_lookalike()  = {match (expr.target) const_or_var(a?) = a};

    fn_name = fn_symbol(id);
    auto_name = auto_symbol(id);

    args = expr.args;
    impl_args = match (expr)
      impl_args_call()  = expr.impl_args,
      call_lookalike()  = ();

    auto_interface = auto_interfaces[auto_name];
    assert args == () or length(auto_interface.pos_inputs) == length(args);
    pos_inputs = if args != () then zip(auto_interface.pos_inputs, args) else ();
    named_inputs = ((bare_id(a), e) : a, e <- impl_args);
    return syn_nested_auto(rule.name, id, pos_inputs & named_inputs);
  }

  //## ALL THIS LOGIC SHOULD BE MOVED TO resolution.ar AND REFACTORED TO FIT THERE
  Bool is_disguised_auto(SynPlainRule rule)
  {
    expr = rule.expr;
    return false if not expr :: <SynImplArgsCall, call_lookalike(target: ConstOrVar, args: SynExpr+)>;

    id = match (expr)
      impl_args_call()  = expr.name,
      call_lookalike()  = {match (expr.target) const_or_var(a?) = a};

    arity = length(expr.args);
    fn_name = fn_symbol(id);
    auto_name = auto_symbol(id);

    // If there's no automaton with the specified name, we decide it's a function,
    // even if there's no such function.
    return false if not auto_defs_by_id(auto_name, ?);

    // If the automaton exists and the function does not, then we go for the automaton
    return true if not non_nested_function_exists(fn_name);

    auto_arity = length(auto_defs_by_id[auto_name].pos_inputs);

    auto_arity_ok = arity == auto_arity or arity == 0;
    fn_arity_ok = non_nested_function_exists(fn_name, arity);

    return true if auto_arity_ok and not fn_arity_ok;
    return false if not auto_arity_ok and fn_arity_ok;

    //## WE ARE NOT SUPPOSED TO GET HERE, I THINK...
    return false;
  }
}

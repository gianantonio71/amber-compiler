using
{
  SynPrg                        syn_prg,
  SynArtifact                   syn_artifact,

  [ClsVar]                      closures,
  [NamedArg]                    named_args, //## THIS IS REDUNDANT. SEE ALSO THE BUG IN desugar_let_stmt()
  [NamedArg -> Nat]             named_args_arities,
  [MembVar]                     memb_vars, //## THIS COULD BE INCLUDED IN def_vars, TOGETHER MAYBE WITH named_args
  [AnyAutoVar -> AutoSymbol]    auto_vars_types,
  [AnyDBVar -> DBSymbol]        db_vars_types,
  [(FnSymbol, NzNat) -> Nat+]   local_fns,
  Maybe[FnSymbol]               curr_outer_fn; //## BUG: THIS IS NOT ENOUGH TO IDENTIFY THE OUTER FUNCTION...


  Expr desugar_expr(SynExpr syn_expr, [Var] def_vars) =
    transfer_attachments(desugar_expr_plain(syn_expr, def_vars), syn_expr);


  Expr desugar_expr_plain(SynExpr expr, [Var] def_vars):
    object()            = expr,
    float_lit()         = expr,
    seq_expr(ses?)      = desugar_seq_expr(ses, def_vars),
    seq_tail_expr()     = seq_tail_expr(desugar_expr(expr.seq, def_vars), (desugar_expr(e, def_vars) : e <- expr.tail)),
    set_expr(es?)       = set_expr([desugar_expr(e, def_vars) : e <- es]),
    map_expr(es?)       = desugar_map_expr(es, def_vars),
    tag_obj_expr()      = tag_obj_expr(desugar_expr(expr.tag, def_vars), desugar_expr(expr.obj, def_vars)),
    FnPar               = expr,
    memb_copy_var()     = expr,
    cls_par(n?)         = fn_par(n),
    const_or_var(a?)    = desugar_const_or_var_expr(a, def_vars),
    fn_call()           = desugar_fn_call_expr(expr.name, expr.args, expr.named_args, def_vars),
    builtin_call()      = builtin_call(expr.name, (desugar_expr(e, def_vars) : e <- expr.args)),
    unary_pseudo_call() = unary_pseudo_call(desugar_expr(expr.target, def_vars), desugar_expr(expr.param, def_vars)),
    map_search()        = map_search(desugar_expr(expr.map, def_vars), desugar_expr(expr.key, def_vars), desugar_expr(expr.value, def_vars)),
    key_search()        = key_search(desugar_expr(expr.map, def_vars), desugar_expr(expr.key, def_vars)),
    singl_only_elem()   = singl_only_elem(desugar_expr(expr.set, def_vars)),
    and()               = and_expr(desugar_expr(expr.left, def_vars), desugar_expr(expr.right, def_vars)),
    or()                = or_expr(desugar_expr(expr.left, def_vars), desugar_expr(expr.right, def_vars)),
    not(e?)             = not_expr(desugar_expr(e, def_vars)),
    eq()                = eq(desugar_expr(expr.left, def_vars), desugar_expr(expr.right, def_vars)),
    neq()               = not_expr(eq(desugar_expr(expr.left, def_vars), desugar_expr(expr.right, def_vars))),
    membership()        = membership(desugar_expr(expr.obj, def_vars), syn_type_to_type(expr.type, nil)),
    cast_expr()         = cast_expr(desugar_expr(expr.expr, def_vars), syn_type_to_type(expr.type, nil)),
    accessor()          = desugar_accessor(expr, def_vars),
    accessor_test()     = desugar_accessor_test(expr.expr, expr.field, def_vars),
    ex_qual()           = desugar_ex_qual_expr(expr.source, expr.cond, def_vars),
    set_comp()          = desugar_set_comp_expr(expr.expr, expr.source, def_vars),
    map_comp()          = desugar_map_comp_expr(expr.key_expr, expr.value_expr, expr.source, def_vars),
    seq_comp()          = desugar_seq_comp_expr(expr, def_vars),
    range_comp()        = desugar_range_comp_expr(expr, def_vars),
    if_expr()           = desugar_if_expr(expr, def_vars),
    match_expr()        = desugar_match_expr(expr.exprs, expr.cases, def_vars),
    do_expr(ss?)        = do_expr(desugar_stmts(ss, def_vars)),
    let_expr()          = do_expr(desugar_stmts(nonempty(expr.stmts & (syn_ret_stmt(expr.expr))), def_vars)),
    is_set()            = expr,
    output_is_def()     = expr,
    method_call_expr()  = desugar_method_call_expr(expr.var, expr.name, expr.args, def_vars);


  Expr desugar_seq_expr(SynSubExpr* entries, [Var] def_vars)
  {
    es = (desugar_expr(e, def_vars) : e <- entries);
    return if es :: Expr+ then tuple_expr(es) else seq_expr(es);
  }


  Expr desugar_method_call_expr(Atom var_id, MethodSymbol name, SynExpr* syn_args, [Var] def_vars)
  {
    args = (desugar_expr(e, def_vars) : e <- syn_args);
    return if var_id == :self
      then self_method_call_expr(self_type, name, args)
      else method_call_expr(resolve_target(var_id), name, args);

    Expr self_method_call_expr(AutoSymbol, MethodSymbol name, Expr* args) = auto_method_call_expr(name, args);

    Expr self_method_call_expr(DBSymbol, MethodSymbol name, Expr* args) = db_method_call_expr(name, args);

    Expr method_call_expr(<AnyAutoVar, AnyDBVar> var, MethodSymbol name, Expr* args):
      AnyAutoVar  = auto_method_call_expr(var, name, args),
      AnyDBVar    = db_method_call_expr(var, name, args);

    <AnyAutoVar, AnyDBVar> resolve_target(Atom var_id)
    {
      var = loc_auto_var(var_id);
      return var if has_key(auto_vars_types, var);

      var = memb_auto_var(var_id);
      return var if has_key(auto_vars_types, var);

      var = loc_db_var(var_id);
      return var if has_key(db_vars_types, var);

      var = memb_db_var(var_id);
      return var if has_key(db_vars_types, var);

      fail;
    }
  }


  Expr desugar_map_expr([SynMapExprEntry] entries, [Var] def_vars) =
    map_expr([[
        key:   desugar_expr(e.key, def_vars),
        value: desugar_expr(e.value, def_vars),
        cond:  desugar_expr(e.cond, def_vars) if e.cond?
      ] : e <- entries
    ]);


  Expr desugar_const_or_var_expr(Atom var_symb, [Var] def_vars)
  {
    assert not in(cls_var(var_symb), closures);

    return var(var_symb)        if in(var(var_symb), def_vars);
    return named_arg(var_symb)  if in(named_arg(var_symb), named_args);
    return memb_var(var_symb)   if in(memb_var(var_symb), memb_vars);

    for v <- (loc_auto_var(var_symb), memb_auto_var(var_symb)):
      if has_key(auto_vars_types, v):
        interface = auto_interfaces[auto_vars_types[v]];
        if interface.default_output:
          default_output = only_element(keys(interface.outputs));
          return qual_auto_memb_var(v, memb_var(default_output));
        ;
      ;
    ;

    return fn_call(fn_symbol(var_symb), (), [:]);
  }


  Expr desugar_fn_call_expr(FnSymbol name, SynExpr* args, (NamedArg, <var(Atom)>*, SynExpr)* expl_named_args, [Var] def_vars)
  {
    //## BAD (BUG?): THIS IS NOT VALID IF THE PARAMETER IS A CLOSURE
    //## VARIABLE OR IF IT'S THE NAME OF A FUNCTION. RIGHT NOW IT
    //## SHOULD NOT FAIL, BUT ONLY BECAUSE THE const_or_var() DOESN'T
    //## DO ANY CHECKING AT THE MOMENT
    arity = length(args);
    fn_id = (name, arity);
    nps = merge(([n -> desugar_named_arg_expr(e, def_vars, ps)] : n, ps, e <- expl_named_args));

    if name :: <fn_symbol(Atom)> and (arity == 1 or arity == 2) and expl_named_args == ():
      bare_name = match (name) fn_symbol(a?) = a;
      target_is_local_var = already_def(bare_name, def_vars);
      target_is_named_par = already_def(bare_name, named_args) and named_args_arities[named_arg(bare_name)] == 0;
      if target_is_local_var or target_is_named_par:
        coll_var = if target_is_local_var then var(bare_name) else named_arg(bare_name);
        if arity == 1:
          par = desugar_expr(only_item(args), def_vars);
          res = unary_pseudo_call(coll_var, par);
        else
          assert arity == 2;
          key = desugar_expr(args[0], def_vars);
          value = desugar_expr(args[1], def_vars);
          res = map_search(coll_var, key, value);
        ;
        return res;
      ;
    ;

    // Closures first
    if name :: <fn_symbol(Atom)> and args != ():
      cls_var = cls_var(_obj_(name));
      if in(cls_var, closures):
        assert nps == [:];
        ps = (desugar_expr(e, def_vars) : e <- args);
        return cls_call(cls_var, ps);
      ;
    ;

    // Then local functions. Here we have to deal with closure parameters.
    if has_key(local_fns, fn_id):
      fs = nested_fn_symbol(value(curr_outer_fn), name);
      pas = local_fns[fn_id];
      eps = (desugar_fn_arg(p, a, def_vars) : p, a <- zip(args, pas));
      return fn_call(fs, eps, nps);
    ;

    // Then named parameters
    if name :: <fn_symbol(Atom)> and args != ():
      np  = named_arg(_obj_(name));
      if in(np, named_args):
        assert nps == [:];
        ps = (desugar_expr(e, def_vars) : e <- args);
        return cls_call(np, ps);
      ;
    ;

    // And last global functions. Here too we have to deal with closures.
    pas = fn_arg_arities[name][arity];
    eps = (desugar_fn_arg(p, a, def_vars) : p, a <- zip(args, pas));
    return fn_call(name, eps, nps);


    AnyExpr desugar_named_arg_expr(SynExpr syn_expr, [Var] outside_vars, <var(Atom)>* cls_pars)
    {
      vars = outside_vars - [v : v <- outside_vars, fn_par() << v] & set(cls_pars) & set((fn_par(i) : i < length(cls_pars)));
      expr = desugar_expr(syn_expr, vars);
      return if cls_pars == () then expr else cls_expr(cls_pars, expr);
    }


    AnyExpr desugar_fn_arg(SynExpr syn_arg, Nat exp_arity, [Var] def_vars)
    {
      if exp_arity == 0 or not syn_arg :: ConstOrVar:
        arg = desugar_expr(syn_arg, def_vars);
        return if exp_arity == 0 then arg else cls_expr(exp_arity, arg);
      ;

      symb = _obj_(syn_arg);

      is_loc_var = in(var(symb), def_vars);
      is_named_arg = in(named_arg(symb), named_args);
      fn_symb = fn_symbol(symb);
      is_glob_const = has_key(fn_arg_arities, fn_symb) and has_key(fn_arg_arities[fn_symb], 0);

      //## BUG? IS THIS RIGHT? SHOULDN'T GLOBAL CONSTANTS HAVE MINIMUM PRIORITY?
      if is_loc_var or is_named_arg or is_glob_const:
        return cls_expr(exp_arity, desugar_expr(syn_arg, def_vars));
      else
        cls_var = cls_var(symb);
        return cls_var if in(cls_var, closures);
        fn_symb = nested_fn_symbol(value(curr_outer_fn), fn_symb) if has_key(local_fns, (fn_symb, exp_arity));
        return fn_ptr(fn_symb, exp_arity);
      ;
    }
  }


  Expr desugar_accessor(SynAccExpr syn_expr, [Var] def_vars)
  {
    if syn_expr :: AccessorChain:
      symbols = destructure_accessor_chain(syn_expr);
      target = head(symbols);
      fields = nonempty(tail(symbols));

      for v <- (loc_auto_var(target), memb_auto_var(target)):
        if has_key(auto_vars_types, v):
          interface = auto_interfaces[auto_vars_types[v]];
          if not interface.default_output:
            field = head(fields);
            rem_fields = tail(fields);
            expr = qual_auto_memb_var(v, memb_var(head(fields)));
            for f <- tail(fields):
              expr = accessor(expr, object(f));
            ;
            return expr;
          ;
        ;
      ;

      for v <- (loc_db_var(target), memb_db_var(target)):
        if has_key(db_vars_types, v):
          db_var = v;
          db_type = db_vars_types[v];
          rem_fields = fields;
          loop
            interface = db_interfaces[db_type];
            field = head(rem_fields);
            break if in(field, interface.memb_vars);
            db_var = nested_db_var(db_var, memb_db_var(field));
            db_type = db_symbol(interface.nested_dbs[field]);
            rem_fields = tail(rem_fields);
            fail if rem_fields == ();
          ;
          expr = qual_db_memb_var(db_var, memb_var(head(rem_fields)));
          for f <- tail(rem_fields):
            expr = accessor(expr, object(f));
          ;
          return expr;
        ;
      ;
    ;

    return accessor(desugar_expr(syn_expr.expr, def_vars), object(syn_expr.field));
  }


  Expr desugar_accessor_test(SynExpr expr, Atom field, [Var] def_vars):
    const_or_var(n?)  = desugar_accessor_test(n, field, def_vars),
    _                 = accessor_test(desugar_expr(expr, def_vars), object(field));


  Expr desugar_accessor_test(Atom target, Atom field, [Var] def_vars)
  {
    for v <- (loc_auto_var(target), memb_auto_var(target)):
      if has_key(auto_vars_types, v):
        interface = auto_interfaces[auto_vars_types[v]];
        return is_set(qual_auto_memb_var(v, memb_var(field))) if not interface.default_output;
      ;
    ;
    return accessor_test(desugar_const_or_var_expr(target, def_vars), object(field));
  }


  Expr desugar_ex_qual_expr(SynClause+ source, SynExpr cond, [Var] def_vars)
  {
    vs = def_vars & syn_new_vars(source);
    c  = desugar_expr(cond, vs);
    return ex_qual(mk_and_clause(source, def_vars), c);
  }


  Expr desugar_set_comp_expr(SynExpr expr, SynClause+ source, [Var] def_vars)
  {
    vs = def_vars & syn_new_vars(source);
    return set_comp(desugar_expr(expr, vs), mk_and_clause(source, def_vars));
  }


  Expr desugar_map_comp_expr(SynExpr key_expr, SynExpr value_expr, SynClause+ source, [Var] def_vars)
  {
    vs = def_vars & syn_new_vars(source);
    return map_comp(desugar_expr(key_expr, vs), desugar_expr(value_expr, vs), mk_and_clause(source, def_vars));
  }


  Expr desugar_seq_comp_expr(SynLCExpr expr, [Var] def_vars)
  {
    vs = def_vars & set(expr.vars) & [expr.idx_var if expr.idx_var?];
    return seq_comp(
      expr:          desugar_expr(expr.expr, vs),
      vars:          expr.vars,
      idx_var:       expr.idx_var if expr.idx_var?,
      src_expr:      desugar_expr(expr.src_expr, def_vars),
      sel_expr:      desugar_expr(expr.sel_expr, vs) if expr.sel_expr?
    );
  }


  Expr desugar_range_comp_expr(SynRCExpr expr, [Var] def_vars)
  {
    vs = def_vars & [expr.var];
    return range_comp(
      expr:         desugar_expr(expr.expr, vs),
      var:          expr.var,
      bound_expr:   desugar_expr(expr.bound_expr, def_vars),
      inclusive:    expr.inclusive,
      sel_expr:     desugar_expr(expr.sel_expr, vs) if expr.sel_expr?
    );
  }


  Expr desugar_if_expr(SynIfExpr expr, [Var] def_vars)
  {
    res = desugar_expr(expr.else, def_vars);
    for b <- reverse(expr.branches):
      res = if_expr(desugar_expr(b.cond, def_vars), desugar_expr(b.expr, def_vars), res);
    ;
    return res;
  }


  Expr desugar_match_expr(SynExpr+ exprs, SynCase+ cases, [Var] def_vars)
  {
    n  = length(cases[0].patterns);
    es = nonempty((desugar_expr(e, def_vars) : e <- subseq(exprs, 0, n)));
    cs = ({
      ps = (desugar_ptrn(p) : p <- c.patterns);
      vs = def_vars & seq_union((new_vars(p) : p <- ps));
      return [ptrns: ps, expr: desugar_expr(c.expr, vs)];
    } : c <- cases);
    return match_expr(es, cs);
  }

  ////////////////////////////////////////////////////////////////////////////////

  CondExpr desugar_expr(SynCondExpr cexpr, [Var] def_vars) =
    cond_expr(
      desugar_expr(cexpr.expr, def_vars),
      desugar_expr(cexpr.cond, def_vars)
    );


  Expr mk_and_expr(Expr+ exprs)  // REMOVE DUPLICATES?
  {
    rev_exprs = reverse(exprs);
    expr      = rev_exprs[0];
    for i = 1..length(exprs):
      expr = and_expr(rev_exprs[i], expr);
    ;
    return expr;
  }

  ////////////////////////////////////////////////////////////////////////////////

  Clause mk_and_clause(SynClause+ clauses, [Var] def_vars)
  {
    vs = def_vars;
    cs = ();
    for c <- clauses:
      cs = cs & (desugar_clause(c, vs));
      vs = vs & syn_new_vars(c);
    ;

    rev_cs = reverse(cs);
    clause = rev_cs[0];
    for i = 1..length(clauses):
      clause = and_clause(rev_cs[i], clause);
    ;

    return clause;
  }

  //## REMEMBER TO CHECK THAT ALL VAR_PTRN() WITH A "BOUND" VARIABLE
  //## DON'T HAVE A PATTERN ASSOCIATED WITH THAT VARIABLE


  Clause desugar_clause(SynClause cls, [Var] def_vars)
  {
    return transfer_attachments(desugar(cls, def_vars), cls);

    Clause desugar(SynClause cls, [Var] def_vars):
      set_elem_clause()   = set_elem_clause(cls.var, desugar_expr(cls.src, def_vars)),
      map_entry_clause()  = map_entry_clause(cls.key_var, cls.value_var, desugar_expr(cls.src, def_vars)),
      seq_elem_clause()   = seq_elem_clause(cls.var, desugar_expr(cls.src, def_vars)),
      and_clause(cs?)     = mk_and_clause(cs, def_vars),
      or_clause()         = or_clause(desugar_clause(cls.left, def_vars), desugar_clause(cls.right, def_vars)),
      match_clause()      = match_clause(desugar_ptrn(cls.ptrn), desugar_expr(cls.expr, def_vars)),
      asgnm_clause()      = asgnm_clause(cls.var, desugar_expr(cls.expr, def_vars)),
      filter_clause()     = filter_clause(desugar_expr(cls.cond, def_vars));
  }

  ////////////////////////////////////////////////////////////////////////////////

  //## BAD: THIS SHOULD BE REPLACED BY A COUPLE OF SUBSIGNATURES.
  () desugar_stmts((), [Var]) = ();

  Statement+ desugar_stmts(SynStmt+ stmts, [Var] def_vars)
  {
    vs = def_vars;
    ss = ();
    for s <- stmts:
      ss = ss & (desugar_stmt(s, vs));
      vs = vs & syn_new_vars(s);
    ;
    return nonempty(ss);
  }


  Statement desugar_stmt(SynStmt stmt, [Var] def_vars) =
    transfer_attachments(desugar_stmt_plain(stmt, def_vars), stmt);


  Statement desugar_stmt_plain(SynStmt stmt, [Var] def_vars):
    assignment_stmt()         = assignment_stmt(stmt.vars, desugar_expr(stmt.value, def_vars)),
    imp_update_stmt()         = imp_update_stmt(stmt.obj, desugar_expr(stmt.idx, def_vars), desugar_expr(stmt.value, def_vars)),
    return_stmt(e?)           = return_stmt(desugar_expr(e, def_vars)),
    break_stmt                = break_stmt,
    fail_stmt                 = fail_stmt,
    assert_stmt()             = desugar_assert_stmt(stmt, def_vars),
    print_stmt(e?)            = print_stmt(desugar_expr(e, def_vars)),
    inf_loop_stmt(ss?)        = loop_stmt(desugar_stmts(ss, def_vars)),
    if_stmt()                 = desugar_if_stmt(stmt, def_vars),
    let_stmt()                = desugar_let_stmt(stmt, def_vars),
    loop_stmt()               = desugar_loop_stmt(stmt, def_vars),
    for_stmt()                = desugar_for_stmt(stmt.loops, stmt.body, def_vars),
    return_stmt               = return_stmt,
    proc_call_stmt()          = proc_call_stmt(
                                  res_var:    stmt.res_var if stmt.res_var?,
                                  proc_name:  stmt.proc_name,
                                  params:     (desugar_expr(p, def_vars) : p <- stmt.args)
                                ),

    send_msg_stmt()           = send_msg_stmt(memb_db_var(stmt.var), desugar_expr(stmt.msg, def_vars)),
    try_update_stmt()         = try_update_stmt(update_symbol(stmt.name), (desugar_expr(e, def_vars) : e <- stmt.args)),
    set_memb_var_stmt()       = set_memb_var_stmt(pending_state_var(stmt.var), desugar_expr(stmt.value, def_vars)),

    set_input_ctrl_stmt()     = set_input_ctrl_stmt(loc_auto_var(stmt.var), stmt.input, desugar_expr(stmt.value, def_vars)),
    clear_input_ctrl_stmt()   = clear_input_ctrl_stmt(loc_auto_var(stmt.var), stmt.input),
    apply_ctrl_stmt()         = if stmt.elapsed_time?
                                  then apply_ctrl_stmt(loc_auto_var(stmt.var), desugar_expr(stmt.elapsed_time, def_vars))
                                  else apply_ctrl_stmt(loc_auto_var(stmt.var)),
    send_msg_ctrl_stmt()      = send_msg_ctrl_stmt(var(stmt.res_var), loc_db_var(stmt.db_var), desugar_expr(stmt.msg, def_vars));


  Statement desugar_if_stmt(SynIfStmt[SynStmt] stmt, [Var] def_vars)
  {
    else_stmts = stmt.else; //## THIS IS HERE JUST TO SHUT UP THE TYPECHECKER
    res = if else_stmts != () then desugar_stmts(else_stmts, def_vars) else ();
    for b <- reverse(stmt.branches):
      cond = desugar_expr(b.cond, def_vars);
      body = desugar_stmts(b.body, def_vars);
      res  = (if_stmt(cond, body, res));
      fail if not res :: (Statement); //## BAD BAD BAD: LOOP DOESN'T TYPECHECK ON ITS OWN
    ;
    assert res :: Seq and length(res) == 1;
    return res[0]; //## BAD BAD BAD
  }


  Statement desugar_let_stmt(SynLetStmt[SynStmt] stmt, [Var] def_vars)
  {
    asgnms = merge(([var -> desugar_expr(val, def_vars)] : var, val <- stmt.asgnms));
    //## BUG BUG BUG: WHAT ABOUT named_args_arities? THAT'S NOT SET!
    body   = desugar_stmts(stmt.body, def_vars, named_args = named_args & keys(asgnms));
    return let_stmt(asgnms, body);
  }


  Statement desugar_loop_stmt(SynLoopStmt[SynStmt] stmt, [Var] def_vars)
  {
    cond      = desugar_expr(stmt.cond, def_vars);
    exit_stmt = if_stmt(not_expr(cond), (break_stmt), ());
    body      = desugar_stmts(stmt.body, def_vars);
    if stmt.skip_first:
      body = body & (exit_stmt);
    else
      body = (exit_stmt) & body;
    ;
    return loop_stmt(nonempty(body));
  }


  Statement desugar_for_stmt(SynIter+ loops, SynStmt+ body, [Var] def_vars)
  {
    //## ALSO MAKE SURE SYNTAX CHECK GETS IT RIGHT
    iters  = loops;
    vs     = def_vars;
    for_vs = ();
    for it <- iters:
      ivs  = match (it)
        seq_iter()   = set(it.vars),
        range_iter() = [it.var if it.var?];
      vs     = vs & ivs & [it.idx_var if it.idx_var?];
      for_vs = for_vs & (vs);
    ;
    res = desugar_stmts(body, vs);
    for it @ i <- reverse(iters):
      vs = rev_at(for_vs, i);
      if it :: SynSeqIter: //## BAD BAD BAD
        vals = desugar_expr(it.values, vs);
        res  = (foreach_stmt(it.vars, if it.idx_var? then just(it.idx_var) else nil, vals, res));
      elif it :: SynRangeIter: //## BAD BAD BAD
        start_val = desugar_expr(it.start_val, vs);
        end_val   = desugar_expr(it.end_val, vs);
        res = (for_stmt(if it.var? then just(it.var) else nil, start_val, end_val, it.end_val_incl, res));
      else
        fail; // We should never get here
      ;
      fail if not res :: (Statement); //## BAD BAD BAD: LOOP DOESN'T TYPECHECK ON ITS OWN
    ;
    assert res :: Seq and length(res) == 1;
    return res[0]; //## BAD BAD BAD
  }


  Statement desugar_assert_stmt(SynAssertStmt stmt, [Var] def_vars)
  {
    expr = desugar_expr(stmt.cond, def_vars);
    loc_vars = [v : v <- def_vars, v :: StdVar];
    scalar_named_args = [arg : arity @ arg <- named_args_arities, arity == 0];
    return assert_stmt(expr, loc_vars & scalar_named_args, stmt.file, stmt.line, stmt.text);
  }

  ////////////////////////////////////////////////////////////////////////////////

  Pattern desugar_ptrn(SynPtrn ptrn)
  {
    return transfer_attachments(desugar(ptrn), ptrn);

    Pattern desugar(SynPtrn ptrn):
      ptrn_symbol             = ptrn,
      ptrn_float              = ptrn,
      ptrn_any                = ptrn,
      ptrn_seq                = ptrn_seq,
      ptrn_set                = ptrn_set,
      ptrn_map                = ptrn_map,
      ptrn_symbol()           = ptrn,
      ptrn_integer(integer)   = ptrn_integer,
      ptrn_integer(int_obj?)  = ptrn_integer(int_obj),
      ptrn_tuple(ps?)         = ptrn_tuple((desugar_ptrn(p) : p <- ps)),
      ptrn_tag_obj            = ptrn_tag_obj(ptrn_symbol, ptrn_any),
      ptrn_tag_obj()          = ptrn_tag_obj(ptrn.tag, desugar_ptrn(ptrn.obj)),
      ptrn_var()              = ptrn_var(ptrn.var, desugar_ptrn(ptrn.ptrn)),
      ptrn_type(type?)        = type_to_pattern(syn_type_to_type(type, nil), typedefs),
      ptrn_union(ps?)         = ptrn_union(set((desugar_ptrn(p) : p <- ps)));
  }
}

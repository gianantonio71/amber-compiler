
Program rem_syntax(SynPrg prg)
{
  decls = set(_obj_(prg));
  
  tdefs         = {d : typedef()       d <- decls};
  par_tdefs     = {d : par_typedef()   d <- decls};
  fndefs        = {d : syn_fn_def()    d <- decls};
  proc_defs     = {d : proc_def()      d <- decls};
  ublocks       = {d : using_block()   d <- decls};
  subtype_decls = {d : subtype_decl()  d <- decls};

  assert tdefs & par_tdefs & fndefs & proc_defs & ublocks & subtype_decls == decls;

  typedefs = create_type_map(tdefs, par_tdefs);
  fn_param_arities = get_fn_param_arities(fndefs, ublocks);
  desugared_fndefs = union({syn_fndef_to_fndefs(fd, {}, typedefs, fn_param_arities) : fd <- fndefs});
  desugared_proc_defs = {syn_proc_def_to_proc_def(pd, typedefs, fn_param_arities) : pd <- proc_defs};
  desugared_block_fndefs = union(
    for (ub <- ublocks, fd <- set(ub.fn_defs)) {
      syn_fndef_to_fndefs(fd, set(ub.signatures), typedefs, fn_param_arities)
    }
  );

  return program(
    typedefs:       typedefs,
    subtype_decls:  subtype_decls,
    fndefs:         desugared_fndefs & desugared_block_fndefs,
    proc_defs:      desugared_proc_defs
  );
}


((FnSymbol, Nat) => [Nat]) get_fn_param_arities(SynFnDef* fndefs, SynUsingBlock* ublocks)
{
  all_fds = fndefs & union({set(ub.fn_defs) : ub <- ublocks});
  arities = merge_values({get_fn_param_arities(fd) : fd <- all_fds});
  return (sgn => only_element(pas) : sgn => pas <- arities);

  ((FnSymbol, Nat) => [Nat]) get_fn_param_arities(SynFnDef fd) = ((fd.name, arity(fd)) => [arity(p) : p <- fd.params]);
}


FnDef* syn_fndef_to_fndefs(SynFnDef fndef, SynSgn* named_params, (TypeName => Type) typedefs, ((FnSymbol, Nat) => [Nat]) fn_param_arities)
{
  lfns = ((lfd.name, nz_nat(arity(lfd))) => nonempty([arity(p) : p <- lfd.params]) : lfd <- set(fndef.local_fns));
  main_fn = mk_fndef(fndef, fndef.name, fndef.name, named_params, lfns, typedefs, fn_param_arities);
  loc_fns = [];
  for (fd : fndef.local_fns)
    fn_symb = nested_fn_symbol(fndef.name, fd.name);
    loc_fns = [loc_fns | mk_fndef(fd, fn_symb, fndef.name, named_params, lfns, typedefs, fn_param_arities)];
  ;
  return {main_fn} & set(loc_fns);


  //## BAD BAD BAD TOO MANY PARAMETERS
  FnDef mk_fndef(SynFnDef fndef, FnSymbol fn_name, FnSymbol outer_fn, SynSgn* named_params,
    ((FnSymbol, NzNat) => [Nat^]) lfns, (TypeName => Type) typedefs, ((FnSymbol, Nat) => [Nat]) fn_param_arities)
  {
    pars = [desugar_fn_par(p) : p <- fndef.params];
    npars = (np.name => syn_sgn_to_any_expr(np) : np <- named_params);
    maybe_res_type = if fndef.res_type? then just(syn_type_to_type(fndef.res_type, nil)) else nil;
    expr = desugar_expr(
      fndef.expr,
      {var(p.var_name) : p <- set(fndef.params), p.var_name? and (not p.type? or p.type :: SynType)},
      closures          = {cls_var(p.var_name) : p <- set(fndef.params), p.var_name?, p.type?, p.type :: SynClsType},
      named_params      = {np.name : np <- named_params}, //## BAD BAD BAD
      local_fns         = lfns,
      curr_outer_fn     = just(outer_fn),
      typedefs          = typedefs,
      fn_param_arities  = fn_param_arities
    );
    return fn_def(fn_name, pars, npars, maybe_res_type, expr);
  }

  FnFrmPar desugar_fn_par(SynFnArg arg)
  {
    maybe_var_name = if arg.var_name? then just(arg.var_name) else nil;
    if (arg.type?)
      return desugar_fn_par(maybe_var_name, arg.type);
    else
      return scalar_par(maybe_var_name);
    ;
  }

  ScalarFrmParam desugar_fn_par(Maybe[Atom] maybe_var_name, SynType type) =
    scalar_par(maybe_var_name, syn_type_to_type(type, nil));

  ClsFrmParam desugar_fn_par(Maybe[Atom] maybe_var_name, SynClsType type) =
    non_scalar_par(value(maybe_var_name), syn_type_to_type(type, nil));

  AnyType syn_sgn_to_any_expr(SynSgn signature)
  {
    param_types = [syn_type_to_type(p, nil) : p <- signature.params];
    ret_type = syn_type_to_type(signature.res_type, nil);
    return if param_types == [] then ret_type else cls_type(param_types, ret_type);
  }
}


ProcDef2 syn_proc_def_to_proc_def(SynProcDef pd, (TypeName => Type) typedefs, ((FnSymbol, Nat) => [Nat]) fn_param_arities)
{
  params = [(var: p.var, type: syn_type_to_type(p.type, nil)) : p <- pd.params];
  maybe_ret_type = if pd.res_type /= nil then just(syn_type_to_type(value(pd.res_type), nil)) else nil;
  body = desugar_stmts(
    pd.body,
    set([p.var : p <- pd.params]),
    closures = {},
    named_params = {},
    local_fns = (),
    curr_outer_fn = nil,
    typedefs = typedefs,
    fn_param_arities = fn_param_arities
  );
  return proc_def(pd.name, params, maybe_ret_type, body);
}


(TypeName => Type) create_type_map(SynTypedef* tdefs, SynParTypedef* par_tdefs)
{
  type_map = (type_name(td.name, 0) => syn_type_to_type(td.type, just([])) : td <- tdefs);
  par_type_map = (type_name(td.name, length(td.params)) => syn_type_to_type(td.type, just(td.params)) : td <- par_tdefs);
  return type_map & par_type_map;
}


SymbObj object(Atom a) = :object(a);
IntObj  object(Int n)  = :object(n);

////////////////////////////////////////////////////////////////////////////////

BasicTypeSymbol type_symbol(Atom a) = :type_symbol(a);

ParTypeSymbol par_type_symbol(BasicTypeSymbol s, [UserType^] ps) = par_type_symbol(symbol: s, params: ps);

TypeName type_name(BasicTypeSymbol ts, Nat arity) = type_name(symbol: ts, arity: arity);

////////////////////////////////////////////////////////////////////////////////

<void_type> void_type = :void_type;

<atom_type> atom_type = :atom_type;

<float_type> float_type = :float_type;

SymbType symb_type(SymbObj obj) = :symb_type(obj);
SymbType symb_type(Atom symbol) = :symb_type(:object(symbol));

IntType integer = :integer;
IntType low_ints(Int max) = low_ints(max: max);
IntType high_ints(Int min) = high_ints(min: min);
IntType int_range(Int min, Int max) = int_range(min: min, size: nz_nat(max-min+1)); //## BUG: WHAT HAPPENS IF max IS LOWER THAN min?

TypeRef type_ref(TypeSymbol s) = :type_ref(s);

TypeVar type_var(<Atom, Nat> n) = :type_var(n);

<empty_seq_type> empty_seq_type = :empty_seq_type;
<empty_set_type> empty_set_type = :empty_set_type;
<empty_map_type> empty_map_type = :empty_map_type;

NeSeqType ne_seq_type(Type elem_type) = ne_seq_type(elem_type: elem_type);

NeSetType ne_set_type(Type elem_type) = ne_set_type(elem_type: elem_type);

NeMapType ne_map_type(Type key_type, Type value_type) = ne_map_type(key_type: key_type, value_type: value_type);

RecordType record_type((SymbObj => (type: Type, optional: Bool)) fs) = :record_type(fs);

TupleType tuple_type([Type^] ts)
{
  assert length(ts) > 1;
  return :tuple_type(ts);
}

TagObjType tag_obj_type(TagType tag_type, Type obj_type) = tag_obj_type(tag_type: tag_type, obj_type: obj_type);

Type map_type(Type key_type, Type value_type, Bool may_be_empty)
{
  type = ne_map_type(key_type, value_type);
  return if may_be_empty then union_type({type, empty_map_type}) else type;
}

Type union_type(Type+ types) //## BAD: HERE I SHOULD CONSTRAIN THE TYPE OF T SO THAT IT IS A SUBTYPE OF Type, SelfRecPretype or MutRecPretype
{
  norm_types = union({expand_union_types(t) : t <- types});
  assert not (? union_type() <- norm_types);
  return if size(norm_types) > 1 then :union_type(nonempty(norm_types)) else only_element(norm_types);

  Type* expand_union_types(Type type):
		union_type(ts?) = union({expand_union_types(t) : t <- ts}),
		_								= {type};
}

SelfPretype self        = :self;
SelfPretype self(Nat n) = :self(n);

SelfRecType self_rec_type(Type pretype)              = :self_rec_type(pretype);

MutRecType mut_rec_type(Nat index, [Type^] pretypes) = mut_rec_type(index: index, types: pretypes);

////////////////////////////////////////////////////////////////////////////////

ClsType cls_type([Type^] its, Type ot)          = cls_type(in_types: its, out_type: ot);

UserClsType user_cls_type([UserType^] its, UserType ot) = cls_type(in_types: its, out_type: ot);

FnType fn_type([ExtType] ps, Type rt) = fn_type(ps, (), rt);
FnType fn_type([ExtType] ps, (NamedPar => ExtType) nps, Type rt) = fn_type(params: ps, named_params: nps, ret_type: rt);

////////////////////////////////////////////////////////////////////////////////

TagPtrn ptrn_symbol                             = :ptrn_symbol;
Pattern ptrn_integer                            = :ptrn_integer(:integer);
Pattern ptrn_float                              = :ptrn_float;

Pattern ptrn_empty_set                          = :ptrn_empty_set;
Pattern ptrn_ne_set                             = :ptrn_ne_set;
Pattern ptrn_empty_seq                          = :ptrn_empty_seq;
Pattern ptrn_ne_seq                             = :ptrn_ne_seq;
Pattern ptrn_empty_map                          = :ptrn_empty_map;
Pattern ptrn_ne_map                             = :ptrn_ne_map;

Pattern ptrn_seq                                = ptrn_union({ptrn_empty_seq, ptrn_ne_seq});
Pattern ptrn_set                                = ptrn_union({ptrn_empty_set, ptrn_ne_set});
Pattern ptrn_map                                = ptrn_union({ptrn_empty_map, ptrn_ne_map});

Pattern ptrn_any                                = :ptrn_any;
TagPtrn ptrn_symbol(Atom a)                     = :ptrn_symbol(:object(a));
TagPtrn ptrn_symbol(SymbObj s)                  = :ptrn_symbol(s);
Pattern ptrn_integer(Int n)                     = ptrn_integer(int_range(n, n));
Pattern ptrn_integer(IntObj n)                  = ptrn_integer(_obj_(n));
Pattern ptrn_integer(IntType type)              = :ptrn_integer(type);
Pattern ptrn_tag_obj(TagPtrn tag, Pattern obj)  = ptrn_tag_obj(tag: tag, obj: obj);
Pattern ptrn_var(Var v, Pattern p)              = ptrn_var(var: v, ptrn: p);
Pattern ptrn_union(Pattern+ ps)                 = :ptrn_union(ps);

////////////////////////////////////////////////////////////////////////////////

FnSymbol fn_symbol(Atom a)                        = :fn_symbol(a);
FnSymbol op_symbol(Operator op)                   = :op_symbol(op);
FnSymbol nested_fn_symbol(FnSymbol o, FnSymbol i) = nested_fn_symbol(outer: o, inner: i);
FnSymbol unique_fn_symbol(FnSymbol s, Nat id)     = unique_fn_symbol(symbol: s, id: id);

Var var(Atom a)       = :var(a);
Var fn_par(Nat n)     = :fn_par(n);
Var named_par(Atom a) = :named_par(a);

ClsVar cls_var(Atom a)  = :cls_var(a);

FnFrmPar non_scalar_par(ClsVar v, UserClsType t) = non_scalar_par(var: v, arity: arity(t), type: t);
FnFrmPar non_scalar_par(ClsVar v, NzNat a)       = non_scalar_par(var: v, arity: a);
FnFrmPar non_scalar_par(NzNat a)                 = non_scalar_par(arity: a);

Expr float_lit(Int m, Int e)  = float_lit(mantissa: m, dec_exp: e);

Expr seq_expr([SubExpr] es)           = :seq_expr(es);
Expr seq_tail_expr(Expr s, [Expr^] t) = seq_tail_expr(seq: s, tail: t);

Expr tuple_expr([Expr^] es) = :tuple_expr(es);

Expr set_expr(SubExpr* ses) = :set_expr(ses);

Expr map_expr((key: Expr, value: Expr, cond: Expr?)* es) = :map_expr(es);

Expr tag_obj_expr(Expr t, Expr o)   = tag_obj_expr(tag: t, obj: o);

Expr fn_call(FnSymbol name, [ExtExpr] params) = fn_call(name, params, ());
Expr fn_call(FnSymbol name, [ExtExpr] params, (NamedPar => ExtExpr) named_params) = fn_call(name: name, params: params, named_params: named_params);

Expr builtin_call(BuiltIn n, [Expr^] ps) = builtin_call(name: n, params: ps);
Expr cls_call(<ClsVar, NamedPar> n, [Expr^] ps) = cls_call(name: n, params: ps);

Expr and_expr(Expr l, Expr r) = and_expr(left: l, right: r);
Expr or_expr(Expr l, Expr r) = or_expr(left: l, right: r);
Expr not_expr(Expr e) = :not_expr(e);

Expr eq(Expr l, Expr r) = eq(left: l, right: r);

Expr accessor(Expr e, SymbObj f) = accessor(expr: e, field: f);
Expr accessor_test(Expr e, SymbObj f) = accessor_test(expr: e, field: f);

Expr cast_expr(Expr e, UserType t) = cast_expr(expr: e, type: t);
Expr membership(Expr obj, UserType type) = membership(obj: obj, type: type);

Expr if_expr(Expr cond, Expr true_expr, Expr false_expr) = if_expr(cond: cond, then: true_expr, else: false_expr);

Expr do_expr([Statement^] ss) = :do_expr(ss);

////////////////////////////////////////////////////////////////////////////////

ClsExpr fn_ptr(FnSymbol s, NzNat a)              = fn_ptr(name: s, arity: a);
ClsExpr cls_expr(Nat a, Expr e)                  = cls_expr(a * [nil], e);
ClsExpr cls_expr([<var(Atom), nil>] ps, Expr e)  = cls_expr(params: nonempty(ps), expr: e);

////////////////////////////////////////////////////////////////////////////////

Clause in_clause(Pattern p, Expr e) = in_clause(ptrn: p, src: e);
Clause map_in_clause(Pattern kp, Pattern vp, Expr e) = map_in_clause(key_ptrn: kp, value_ptrn: vp, src: e);
Clause and_clause(Clause l, Clause r) = and_clause(left: l, right: r);
Clause or_clause(Clause l, Clause r) = or_clause(left: l, right: r);

////////////////////////////////////////////////////////////////////////////////

Statement assignment_stmt([Var^] vs, Expr v) = assignment_stmt(vars: vs, value: v);
Statement return_stmt(Expr e) = :return_stmt(e);
Statement return_stmt = :return_stmt;
Statement loop_stmt([Statement^] ss) = :loop_stmt(ss);
Statement assert_stmt(Expr e) = :assert_stmt(e);
Statement print_stmt(Expr e) = :print_stmt(e);
Statement break_stmt = :break_stmt;
Statement fail_stmt  = :fail_stmt;

Statement imp_update_stmt(Var o, Expr i, Expr v)  = imp_update_stmt(obj: o, idx: i, value: v);

////////////////////////////////////////////////////////////////////////////////

ProcSymbol proc_symbol(Atom a) = :proc_symbol(a);

////////////////////////////////////////////////////////////////////////////////

FnDef fn_def(FnSymbol n, [FnFrmPar] ps, (NamedPar => UserExtType) nps, Maybe[UserType] mrt, Expr e) =
  fn_def(name: n, params: ps, named_params: nps, res_type: value(mrt) if mrt /= nil, expr: e);

ProcDef2 proc_def(ProcSymbol n, [(var: Var, type: UserType)] ps, Maybe[UserType] rt, [Statement] b) =
  proc_def(name: n, params: ps, res_type: rt, body: b);

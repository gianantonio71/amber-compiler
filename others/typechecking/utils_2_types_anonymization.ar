//## WILL THIS WORK EVEN WITH STRANGE TEMPLATE TYPES?
//## FOR EXAMPLE, PARAMETRIC TYPES THAT CONTAIN ISTANTIATED VERSIONS OF THEMSELVES?
//## IS THAT EVEN POSSIBLE? TRY TO WORK OUT SOUND RULES FOR RECURSIVE PARAMETRIC TYPES

(TypeName => Type) normalize_and_anonymize_types((TypeSymbol => UserType) inst_types)
{
  all_anon_types = anonymize_types(inst_types);
  non_par_or_non_inst_anon_types = (ts => t : ts => t <- all_anon_types, ts :: <BasicTypeSymbol, par_type_symbol(symbol: BasicTypeSymbol, params: [TypeVar^])>);
  pre_res = merge_values({(type_symb_to_name(s) => replace_named_type_vars(t, type_var_params(s))) : s => t <- non_par_or_non_inst_anon_types});
  return (s => only_element(ts) : s => ts <- pre_res);

  //## BAD: THIS SHOULD ONLY BE AN ADDITIONAL SIGNATURE TO THE params() METHOD IN methods_2.ar
  [TypeVar] type_var_params(<BasicTypeSymbol, par_type_symbol(symbol: BasicTypeSymbol, params: [TypeVar^])> ts):
    BasicTypeSymbol     = [],
    par_type_symbol()   = ts.params;

  Type replace_named_type_vars(Type type, [TypeVar] type_params):
    LeafType          = type,
    type_var(+)       = type_var(index_first(type, type_params)),
    type_var(*)       = type,
    SelfPretype       = type,
    ne_seq_type()     = ne_seq_type(replace_named_type_vars(type.elem_type, type_params)),
    ne_set_type()     = ne_set_type(replace_named_type_vars(type.elem_type, type_params)),
    ne_map_type()     = ne_map_type(replace_named_type_vars(type.key_type, type_params), replace_named_type_vars(type.value_type, type_params)),
    record_type(fs?)  = record_type((l => (type: replace_named_type_vars(f.type, type_params), optional: f.optional) : l => f <- fs)),
    tuple_type(ts?)   = tuple_type([replace_named_type_vars(t, type_params) : t <- ts]),
    tag_obj_type()    = tag_obj_type(type.tag_type, replace_named_type_vars(type.obj_type, type_params)),
    union_type(ts?)   = union_type({replace_named_type_vars(t, type_params) : t <- ts}),
    self_rec_type(t?) = self_rec_type(replace_named_type_vars(t, type_params)),
    mut_rec_type()    = mut_rec_type(type.index, [replace_named_type_vars(t, type_params) : t <- type.types]);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

(TypeSymbol => Type) anonymize_types((TypeSymbol => UserType) types)
{
  anon_types  = ();
  types_to_do = types;

  while (types_to_do /= ())
    // Identifying clusters of type to expand. We can have three cases. Clusters can contain:
    //    one type that doesn't reference any other
    //    one type that only references itself
    //    a group of types, each of which references (generally indirectly) all other types in the cluster and only those.
    clusters = type_clusters_to_expand(types_to_do, keys(anon_types));

    // Expanding the types in each cluster, and merging the clusters together
    exp_types = merge({expand(c, types_to_do, anon_types) : c <- clusters});
    assert exp_types :: (TypeSymbol => Type);

    // Updating anon_types and types_to_do. All references to the types
    // that have just been expanded are replaces with the types themselves
    anon_types  = anon_types & exp_types;
    types_to_do = remove_keys(types_to_do, keys(exp_types));

    assert types_to_do :: (TypeSymbol => UserType);
    assert anon_types :: (TypeSymbol => Type);
  ;

  assert size(anon_types) == size(types);
  assert anon_types :: (TypeSymbol => Type);

  return anon_types;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

TypeSymbol** type_clusters_to_expand((TypeSymbol => UserType) types, TypeSymbol* already_norm)
{
  ref_map        = (s => ref_type_symbols(t) - already_norm : s => t <- types);
  deep_ref_map   = transitive_closure(ref_map);
  conn_comps     = {{s} & rs : s => rs <- deep_ref_map};
  min_conn_comps = {c1 : c1 <- conn_comps, not (? c2 <- conn_comps : c2 /= c1, subset(c2, c1))};
  return min_conn_comps;
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// Type expansion ////////////////////////////////

(TypeSymbol => Type) expand(TypeSymbol* type_symbs, (TypeSymbol => UserType) types, (TypeSymbol => Type) anon_types)
{
  anon_type_names = keys(anon_types);
  exp_types = ();
  rem_symbs = type_symbs;
  while (rem_symbs /= {})
    rem_types = select_by_key(types, rem_symbs);
    ref_map = (s => ref_type_symbols(t) - anon_type_names : s => t <- rem_types);
    exp_type_symbs = {s : s <- rem_symbs, is_expandable(s, ref_map)};
    if (exp_type_symbs /= {})
      newly_exp_types = (s => expand_type(s, rem_types, exp_types & anon_types) : s <- exp_type_symbs);
    else
      newly_exp_types = expand_mutually_rec_types(rem_types, exp_types & anon_types);
      exp_type_symbs  = rem_symbs;
      assert keys(newly_exp_types) == rem_symbs;
    ;
    //assert not (? ts => t <- newly_exp_types : not anon_type_is_wf(t));
    exp_types = exp_types & newly_exp_types;
    rem_symbs = rem_symbs - exp_type_symbs;
  ;
  return exp_types;

  Bool is_expandable(T node, (T => T*) edges)
  {
    reach = {node};
    for (size(edges) + 1)
      reach = union({edges[n] : n <- reach, has_key(edges, n)}) - {node};
    ;
    return reach == {};
  }

  Type expand_type(TypeSymbol type_name, (TypeSymbol => UserType) types, (TypeSymbol => Type) anon_types)
  {
    type = replace_type_refs(types[type_name], types, anon_types, (type_name => self));
    type = self_rec_type(type) if has_rec_branches(type);
    // assert anon_type_is_wf(type);
    return type;
  }

  (TypeSymbol => Type) expand_mutually_rec_types((TypeSymbol => UserType) types, (TypeSymbol => Type) anon_types)
  {
    type_names = rand_sort(keys(types));
    idxs = index_set(type_names);
    rec_subst_map  = (type_names[i] => self(i) : i <- idxs);
    mut_rec_anon_types = [replace_type_refs(types[tn], types, anon_types, rec_subst_map) : tn <- type_names];
    mut_rec_anon_types = nonempty(mut_rec_anon_types); //## BAD: THE TYPE SYSTEM SHOULD BE ABLE TO FIGURE THIS OUT, WITH THE HELP OF SUBSIGNATURES
    return (type_names[i] => mut_rec_type(i, mut_rec_anon_types) : i <- idxs);
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Type replace_type_refs(UserType type, (TypeSymbol => UserType) in_progress_type_map, (TypeSymbol => Type) subst_map, (TypeSymbol => SelfPretype) rec_subst_map) =
  replace_type_refs(type, in_progress_type_map=in_progress_type_map, subst_map=subst_map, rec_subst_map=rec_subst_map);

using (TypeSymbol => UserType) in_progress_type_map, (TypeSymbol => Type) subst_map, (TypeSymbol => SelfPretype) rec_subst_map
{
  Type replace_type_refs(UserType type):
    LeafType          = type,
    type_ref(ts?)     = replace_type_ref(ts, in_progress_type_map, subst_map, rec_subst_map),
    TypeVar           = type,
    ne_seq_type()     = ne_seq_type(replace_type_refs(type.elem_type)),
    ne_set_type()     = ne_set_type(replace_type_refs(type.elem_type)),
    ne_map_type()     = ne_map_type(replace_type_refs(type.key_type), replace_type_refs(type.value_type)),
    record_type(fs?)  = record_type((l => (type: replace_type_refs(f.type), optional: f.optional) : l => f <- fs)),
    tuple_type(ts?)   = tuple_type([replace_type_refs(t) : t <- ts]),
    tag_obj_type()    = tag_obj_type(type.tag_type, replace_type_refs(type.obj_type)),
    union_type(ts?)   = union_type({replace_type_refs(t) : t <- ts});
}


Type replace_type_ref(TypeSymbol target_type_symbol, (TypeSymbol => UserType) in_progress_type_map, (TypeSymbol => Type) subst_map, (TypeSymbol => SelfPretype) rec_subst_map)
{
  assert disjoint(keys(in_progress_type_map), keys(subst_map));
  assert subset(keys(rec_subst_map), keys(in_progress_type_map));

  // If this is a self reference, then we return the self/self(Nat) object
  return rec_subst_map[target_type_symbol] if has_key(rec_subst_map, target_type_symbol);

  // We lookup the target type, and recursively replace all type references if it hasn't been done yet
  if (has_key(subst_map, target_type_symbol))
    return subst_map[target_type_symbol];
  else
    return replace_type_refs(in_progress_type_map[target_type_symbol], in_progress_type_map, subst_map, rec_subst_map);
  ;
}


TypeSymbol* ref_type_symbols(UserType type):
  LeafType          = {},
  type_ref(ts?)     = {ts},
  TypeVar           = {},
  ne_seq_type()     = ref_type_symbols(type.elem_type),
  ne_set_type()     = ref_type_symbols(type.elem_type),
  ne_map_type()     = ref_type_symbols(type.key_type) & ref_type_symbols(type.value_type),
  record_type(fs?)  = union({ref_type_symbols(f.type) : l => f <- fs}),
  tuple_type(ts?)   = seq_union([ref_type_symbols(t) : t <- ts]),
  tag_obj_type()    = ref_type_symbols(type.tag_type) & ref_type_symbols(type.obj_type), // To search in the tag is pointless right now, but if I were to allow type references in the tag at some point...
  union_type(ts?)   = union({ref_type_symbols(t) : t <- ts});

//## BUG: I ALSO HAVE TO CHECK THAT FOR ALL FUNCTIONS WITH THE SAME
//## NAME AND ARITY ALL NAMED PARAMETERS HAVE THE SAME TYPE, AND
//## THAT ALL CLOSURE PARAMETERS HAVE EXACTLY THE SAME TYPE.


((FnSymbol, [FnFrmPar]) => TypeCheckingError+) typecheck(Program prg)
{
  typedefs = prg.anon_tdefs;
  signatures = merge_values({((fd.name, arity(fd)) => signature(fd, typedefs)) : fd <- prg.fndefs});
  aggregated_signatures = (n => build_aggregated_signatures(ss) : n => ss <- signatures);
  errors = ((fd.name, fd.params) => typecheck(fd, typedefs, signatures, aggregated_signatures) : fd <- prg.fndefs);
  return (f => es : f => es <- errors, es /= {});
}


FnType* build_aggregated_signatures(FnType+ signatures)
{
  a_sgn = an_elem(signatures);
  sgns = signatures;
  for (i < arity(a_sgn))
    sgns = merge_comp_sgns(sgns, i);
  ;
  return sgns - signatures;

  FnType+ merge_comp_sgns(FnType+ signatures, Nat par_idx)
  {
    new_sgns = {};
    sgns = signatures;
    while (sgns /= {})
      sgn = an_elem(sgns);
      comp_sgns = {s : s <- sgns, other_params_are_eq(sgn, s, par_idx)};
      new_sgn = if size(comp_sgns) > 1 then merge_all_sgns(comp_sgns, par_idx) else only_element(comp_sgns);
      new_sgns = new_sgns & {new_sgn};
      sgns = sgns - comp_sgns;
    ;
    return new_sgns;
  }

  FnType merge_all_sgns(FnType+ signatures, Nat par_idx)
  {
    merged_par_type = union_type({s.params[par_idx] : s <- signatures});
    merged_ret_type = union_superset({s.ret_type : s <- signatures});
    a_sgn = an_elem(signatures);
    params = [if i == par_idx then merged_par_type else p : p @ i <- an_elem(signatures).params];
    return fn_type(params, a_sgn.named_params, merged_ret_type);
  }

  Bool other_params_are_eq(FnType sgn1, FnType sgn2, Nat par_idx) =
    all([is_eq(p1, p2) : p1, p2 @ i <- zip(sgn1.params, sgn2.params), i /= par_idx]);
}


TypeCheckingError* typecheck(FnDef fn_def, (TypeName => Type) typedefs, ((FnSymbol, Nat) => FnType+) signatures, (FnSymbol => FnType) aggregated_signatures)
{
  errs = set([missing_param_type(p, i) : p @ i <- fn_def.params, not p.type?]) & {missing_res_type if not fn_def.res_type?};
  return errs if errs /= {};

  var_aliases=set([{fn_par(i), p.var} : p @ i <- fn_def.params, p.var?]);
  let (typedefs=typedefs, signatures=signatures, aggregated_signatures=aggregated_signatures, var_aliases=var_aliases)
    scalar_vars = (p.var => user_type_to_anon_type(p.type) : p <- set(fn_def.params), p.var?, p.type :: UserType) &
                  (fn_par(i) => user_type_to_anon_type(fn_def.params[i].type) : i <- index_set(fn_def.params), fn_def.params[i].type :: UserType) &
                  (v => user_type_to_anon_type(t) : v => t <- fn_def.named_params, t :: UserType);

    assert scalar_vars :: (Var => Type);

    cls_vars = (p.var => user_type_to_anon_type(p.type) : p <- set(fn_def.params), p.var?, p.type :: UserClsType) &
               (v => user_type_to_anon_type(t) : v => t <- fn_def.named_params, t :: UserClsType);

    assert cls_vars :: (ClsVar => ClsType);

    // return typecheck(fn_def.expr, user_type_to_anon_type(fn_def.res_type), environment=scalar_vars, closures=cls_vars);
    //## THIS IS A TEMPORARY HACK TO WORK AROUND AN UNIMPLEMENTED FEATURE IN THE CODE GENERATION CODE
    errs = typecheck(fn_def.expr, user_type_to_anon_type(fn_def.res_type), environment=scalar_vars, closures=cls_vars);
  ;
  return errs;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

using
{
  (TypeName => Type)            typedefs,
  ((FnSymbol, Nat) => FnType+)  signatures,
  ((FnSymbol, Nat) => FnType*)  aggregated_signatures,
  (Var => Type)                 environment,
  (ClsVar => ClsType)           closures,
  Var**                         var_aliases;

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  TypeCheckingError* typecheck(Expr expr, ClosedType exp_type)
  {
    errs = typecheck_without_annotations(expr, exp_type);
    return {annotate(err, expr) : err <- errs};


    TypeCheckingError annotate(TypeCheckingError err, Expr expr):
      annotated_expr_error()  = err,
      _                       = annotated_expr_error(err, expr);


    TypeCheckingError* typecheck_without_annotations(Expr expr, ClosedType exp_type):
      object(obj?)          = {obj_does_not_belong_to_type(obj, exp_type) if not type_contains_obj(exp_type, obj)},
      set_expr(ses?)        = typecheck_set_expr(ses, exp_type),
      seq_expr(ses?)        = typecheck_seq_expr(ses, exp_type),
      seq_tail_expr()       = typecheck_seq_tail_expr(expr.seq, expr.tail, exp_type),
      tuple_expr(es?)       = typecheck_tuple_expr(es, exp_type),
      map_expr(es?)         = typecheck_map_expr(es, exp_type),
      tag_obj_expr()        = typecheck_tag_obj_expr(expr.tag, expr.obj, exp_type),
      Var                   = {invalid_var_type(environment[expr], exp_type) if not is_subset(environment[expr], exp_type)},
      fn_call()             = typecheck_fn_call(expr.name, expr.params, expr.named_params, exp_type),
      cls_call()            = typecheck_cls_call(expr.params, closures[expr.name], exp_type),
      builtin_call()        = typecheck_builtin_call(expr.name, expr.params, exp_type),
      and_expr()            = typecheck_and_expr(expr.left, expr.right, exp_type),
      or_expr()             = typecheck_or_expr(expr.left, expr.right, exp_type),
      not_expr(e?)          = typecheck_bool_op(e, exp_type),
      eq()                  = typecheck_eq_expr(expr.left, expr.right, exp_type),
      membership()          = invalid_type_if_not_subset(type_bool, exp_type) & typecheck(expr.obj, type_any),
      //## TODO: CHECK THAT THE TWO TYPES ARE NOT DISJOINT?
      cast_expr()           = invalid_type_if_not_subset(user_type_to_anon_type(expr.type), exp_type) & typecheck(expr.expr, type_any),
      accessor()            = typecheck_accessor_expr(expr.expr, expr.field, exp_type),
      accessor_test()       = typecheck_accessor_test_expr(expr.expr, expr.field, exp_type),
      if_expr()             = typecheck_if_expr(expr.cond, expr.then, expr.else, exp_type),
      match_expr()          = typecheck_match_expr(expr.exprs, expr.cases, exp_type),
      do_expr(ss?)          = typecheck(ss, exp_type),
      ex_qual()             = typecheck_ex_qual_expr(expr.source, if expr.sel_expr? then just(expr.sel_expr) else nil, exp_type),
      set_comp()            = typecheck_set_comp_expr(expr.expr, expr.source, if expr.sel_expr? then just(expr.sel_expr) else nil, exp_type),
      map_comp()            = typecheck_map_comp_expr(expr.key_expr, expr.value_expr, expr.source, if expr.sel_expr? then just(expr.sel_expr) else nil, exp_type),
      seq_comp()            = {
        maybe_idx_var = if expr.idx_var? then just(expr.idx_var) else nil;
        maybe_sel_expr = if expr.sel_expr? then just(expr.sel_expr) else nil;
        return if expr.src_expr_type == :sequence
          then typecheck_seq_comp(expr.expr, expr.vars, maybe_idx_var, expr.src_expr, maybe_sel_expr, exp_type)
          else typecheck_int_range_seq_comp(expr.expr, expr.vars[0], expr.src_expr, expr.src_expr_type.included, maybe_sel_expr, exp_type);
      };
  }


  TypeCheckingError* typecheck(CondExpr expr, ClosedType exp_type)
  {
    errs = typecheck(expr.cond, type_bool);
    return errs if errs /= {};
    new_env = left(refine_environment(expr.cond));
    return typecheck(expr.expr, exp_type, environment=new_env);
  }


  TypeCheckingError* typecheck_set_expr(SubExpr* subexprs, ClosedType exp_type)
  {
    may_be_empty = subexprs == {} or not (? se <- subexprs : not is_cond_expr(se));
    errs = {obj_does_not_belong_to_type({}, exp_type) if may_be_empty and not type_contains_obj(exp_type, {})};
    return errs if subexprs == {};
    elem_type = set_elem_type(exp_type);
    return errs & {not_a_set_type} if elem_type == void_type;
    return errs & union({typecheck(se, elem_type) : se <- subexprs});
  }


  TypeCheckingError* typecheck_seq_expr([SubExpr] subexprs, ClosedType exp_type)
  {
    may_be_empty = subexprs == [] or all([is_cond_expr(se) : se <- subexprs]);
    errs = {obj_does_not_belong_to_type([], exp_type) if may_be_empty and not type_contains_obj(exp_type, [])};
    return errs if subexprs == [];
    exp_elem_type = seq_elem_type(exp_type);
    return errs & {not_a_seq_type} if exp_elem_type == void_type;
    return errs & seq_union([typecheck(es, exp_elem_type) : es <- subexprs]);
  }


  TypeCheckingError* typecheck_seq_tail_expr(Expr seq, [Expr^] tail, ClosedType exp_type)
  {
    exp_elem_type = seq_elem_type(exp_type);
    return {not_a_seq_type} if exp_elem_type == void_type;
    return typecheck(seq, type_seq(exp_elem_type)) & seq_union([typecheck(e, exp_elem_type) : e <- tail]);
  }


  TypeCheckingError* typecheck_tuple_expr([Expr^] exprs, ClosedType exp_type)
  {
    if (has_tuple_type(exp_type))
      types = tuple_field_types(exp_type);
      return {wrong_tuple_type_length(length(exprs), length(types))} if length(exprs) /= length(types);
      return seq_union([typecheck(e, t) : e, t <- zip(exprs, types)]);
    else
      elem_type = seq_elem_type(exp_type);
      return {not_a_tuple_or_seq_type} if elem_type == void_type;
      return seq_union([typecheck(e, elem_type) : e <- exprs]);
    ;
  }

  //## TRY TO REWRITE THIS IN PROLOG-LIKE PSEUDOCODE
  TypeCheckingError* typecheck_map_expr(<(key: Expr, value: Expr, cond: Expr?)*> entries, ClosedType exp_type)
  {
    // If the expression may evaluate to the empty map, we check that the empty map is included in the expected type
    may_be_empty = not (? e <- entries : not e.cond?);
    errs = {obj_does_not_belong_to_type((), exp_type) if may_be_empty and not type_contains_obj(exp_type, ())};
    return errs if entries == {};
    // Inclusion conditions, if they exist, must typecheck as booleans
    errs = errs & union({typecheck(e.cond, type_bool) : e <- entries, e.cond?});
    // The expected type could contain either a map or a record type (or none at all).
    // Here we check to see if there's a map type
    exp_key_type = map_key_type(exp_type);
    exp_value_type = map_value_type(exp_type);
    assert (exp_key_type == void_type) == (exp_value_type == void_type);
    if (exp_key_type /= void_type and exp_value_type /= void_type) // A DOUBLE CHECK SHOULD HELP THE TYPE CHECKER
      // If the expected type includes a map type, we go for it
      return errs & union({typecheck(e.key, exp_key_type) & typecheck(e.value, exp_value_type) : e <- entries});
    ;
    // There wasn't a map type. Now we check to see if there is a record type
    exp_record_type = record_type(exp_type);
    // If there is no record type we are done, the expression does not typecheck
    return errs & {not_a_map_or_record_type} if exp_record_type == void_type;
    // Since we are now left with a record type, we must first make sure that all the keys in the expression are symbols
    //## IN THEORY WE SHOULD CHECK THAT ALL EXPRESSIONS EVALUATE TO A SYMBOL, BUT WOULD THAT BE ANY USE?
    expr_keys = {e.key : e <- entries};
    non_symbol_keys = {k : k <- expr_keys, not k :: SymbObj};
    return errs & {non_symbol_keys_with_record_type(non_symbol_keys)} if non_symbol_keys /= {};
    // Now we make sure that the resulting record will always have all the required fields
    // and that all fields are allowed by the type.
    fields = _obj_(exp_record_type);
    req_labels = {l : l => f <- fields, not f.optional};
    allowed_labels = keys(fields);
    sure_labels = {e.key : e <- entries, not e.cond?};
    all_labels = {e.key : e <- entries};
    errs = errs & {missing_rec_fields(req_labels - sure_labels)} if not subset(req_labels, sure_labels);
    errs = errs & {invalid_rec_fields(all_labels - allowed_labels)} if not subset(all_labels, allowed_labels);
    return errs if errs /= {};
    // Finally checking that the corresponding types all typecheck to the respective types.
    return union({typecheck(e.value, fields[e.key].type) : e <- entries});
  }


  TypeCheckingError* typecheck_tag_obj_expr(Expr tag_expr, Expr obj_expr, ClosedType exp_type)
  {
    tag_errs = typecheck(tag_expr, atom_type);
    return {tag_not_a_symbol(tag_errs)} if tag_errs /= {};

    tag_types = tagged_obj_types(exp_type);
    return {not_a_tag_type} if tag_types == {};

    expr_tag_type = expr_type(tag_expr);

    if (expr_tag_type :: <union_type(SymbType+)>)
      //## THIS IS THE TRICKY PART
      fail;
    ;

    if (expr_tag_type == atom_type)
      sel_tag_types = {t : t <- tag_types, t.tag_type == atom_type};
      return {not_a_tag_type_with_any_tag} if sel_tag_types == {};
      sel_tag_type = only_element(sel_tag_types);
      return typecheck(obj_expr, sel_tag_type.obj_type);
    ;

    assert expr_tag_type :: SymbType;

    sel_tag_types = {t : t <- tag_types, is_subset(expr_tag_type, t.tag_type)};
    return {unexpected_actual_type(expr_tag_type, exp_type)} if sel_tag_types == {};
    sel_tag_type = only_element(sel_tag_types);
    return typecheck(obj_expr, sel_tag_type.obj_type);
  }


  TypeCheckingError* typecheck_fn_call(FnSymbol name, [ExtExpr] params, (NamedPar => ExtExpr) named_params, ClosedType exp_type)
  {
    // First I check that all scalar positional parameters typecheck. This is something that
    // I need to do before trying to determine the functions this call may dispatch to.
    errs = seq_union([typecheck(p, type_any) : p <- params, p :: Expr]);
    return errs if errs /= {};

    //## BUG: FROM NOW ON IT'S ALL BROKEN, OF COURSE...

    fn_key = (name, length(params));
    candidate_signatures = {s : s <- signatures[fn_key], will_dispatch_to(s, params)};
    if (candidate_signatures == {})
      candidate_signatures = {s : s <- aggregated_signatures[fn_key], will_dispatch_to(s, params)};
      if (candidate_signatures == {})
        par_types = [if p :: Expr then just(expr_type(p)) else nil : p <- params];
        return {no_suitable_function_found(signatures[fn_key], par_types)};
      ;
    ;
    target_signature = only_element(candidate_signatures);

    // We first check that all scalar positional parameters (and those parameters only) match
    // the type of the corresponding formal parameter (we already know they typecheck)
    invalid_params = {};
    for (p, t @ i : zip(params, target_signature.params))
      if (p :: Expr and t :: Type)
        actual_type = expr_type(p);
        if (not is_subset(actual_type, replace_type_vars_with_type_any(t))) //## BAD: HERE I SHOULD JUST CALL typecheck()
          invalid_params = invalid_params & {(i, p, actual_type)};
        ;
      ;
    ;
    return invalid_param_types(target_signature, invalid_params) if invalid_params /= {};

    // Now we can instantiate the concrete type for type variables
    actual_types = [];
    formal_types = [];
    for (p, t : zip(params, target_signature.params))
      if (p :: Expr and t :: Type)
        actual_types = [actual_types | expr_type(p)];
        formal_types = [formal_types | t];
      ;
    ;
    type_var_insts = type_var_instantiations_for_subset(actual_types, formal_types);

    // With the type variables instantiated, we can "instantiate" the formal type
    // of the other parameters and verify the corresponding actual parameters typecheck

    // Let's start with positional closure parameters
    cls_errs = {};
    for (p, t : zip(params, target_signature.params))
      if (p :: ClsExpr and t :: ClsType)
        cls_errs = cls_errs & typecheck(p, replace_type_vars(t, type_var_insts)); //## BUG: I THINK THIS IS BROKEN...
      ;
    ;

    // Now named parameters
    named_par_errs = {};
    invalid_pos_params = {};
    for (n, t : rand_sort_pairs(target_signature.named_params))
      inst_type = replace_type_vars(t, type_var_insts);
      if (has_key(named_params, n))
        named_par_errs = named_par_errs & typecheck(named_params[n], inst_type);
      elif (has_key(environment, n))
        actual_type = environment[n];
        if (not is_subset(actual_type, inst_type))
          invalid_pos_params = invalid_pos_params & {(n, t, inst_type)};
        ;
      else
        actual_cls_type = environment[n];
        if (not is_subset(actual_cls_type, inst_type))
          invalid_pos_params = invalid_pos_params & {(n, t, inst_type)};
        ;
      ;
    ;
    named_par_errs = named_par_errs & {invalid_named_par_type(target_signature, invalid_pos_params)} if invalid_pos_params /= {};

    // Now let's see if the type of the result is OK.
    actual_ret_type = replace_type_vars_with_void_default(target_signature.ret_type, type_var_insts);
    ret_type_errs = {invalid_return_type(actual_ret_type, exp_type) if not is_subset(actual_ret_type, exp_type)};

    //## BAD: HERE I SHOULD PROVIDE MORE INFORMATION ABOUT THESE ERRORS
    return cls_errs & named_par_errs & ret_type_errs;
  }


  TypeCheckingError* typecheck_cls_call([Expr] params, ClsType signature, ClosedType exp_type)
  {
    assert length(params) == length(signature.in_types);

    errs = seq_union([typecheck(e, replace_type_vars_with_type_any(t)) : e, t <- zip(params, signature.in_types)]);
    res_type = cls_call_type(signature, [expr_type(p) : p <- params]);
    errs = errs & invalid_type_if_not_subset(res_type, exp_type);
    return errs;
  }


  TypeCheckingError* typecheck_builtin_call(BuiltIn name, [Expr] params, ClosedType exp_type)
  {
    sgn = builtin_signature(name);
    errs = seq_union([typecheck(p, t) : p, t <- zip(params, sgn.params)]);
    res_type = builtin_call_expr_type(name, params);
    errs = errs & invalid_type_if_not_subset(res_type, exp_type);
    return errs;
  }


  TypeCheckingError* typecheck_bool_op(Expr expr, ClosedType exp_type) =
    invalid_type_if_not_subset(type_bool, exp_type) & typecheck(expr, type_bool);


  TypeCheckingError* typecheck_and_expr(Expr left_expr, Expr right_expr, ClosedType exp_type)
  {
    errs = typecheck_bool_op(left_expr, exp_type);
    right_expr_env = left(refine_environment(left_expr));
    return errs & typecheck(right_expr, exp_type, environment=right_expr_env);
  }


  TypeCheckingError* typecheck_or_expr(Expr left_expr, Expr right_expr, ClosedType exp_type)
  {
    errs = typecheck_bool_op(left_expr, exp_type);
    right_expr_env = right(refine_environment(left_expr));
    return errs & typecheck(right_expr, exp_type, environment=right_expr_env);
  }


  TypeCheckingError* typecheck_eq_expr(Expr left_expr, Expr right_expr, ClosedType exp_type) =
    invalid_type_if_not_subset(type_bool, exp_type) &
    typecheck(left_expr, type_any) &
    typecheck(right_expr, type_any);


  TypeCheckingError* typecheck_accessor_expr(Expr expr, SymbObj field, ClosedType exp_type)
  {
    errs = typecheck(expr, type_any);
    return errs if errs /= {};
    for (t : rand_sort(split_type(expr_type(expr)))) //## UGLY UGLY
      errs = errs & errors(follow_type(t), field, exp_type);
    ;
    return errs;

    Type follow_type(Type type):
      tag_obj_type()  = type.obj_type,
      _               = type;

    TypeCheckingError* errors(Type type, SymbObj field, ClosedType exp_type):
      record_type()   = {
        field_type = mandatory_record_field_type(type, field);
        return if field_type == void_type
          then {may_not_have_field(type, field)}
          else invalid_type_if_not_subset(field_type, exp_type);
      },
      _               = {not_a_record_type(type)};
  }


  TypeCheckingError* typecheck_accessor_test_expr(Expr expr, SymbObj field, ClosedType exp_type)
  {
    errs = typecheck(expr, type_any);
    return errs if errs /= {};
    errs = invalid_type_if_not_subset(type_bool, exp_type);
    type = split_type(expr_type(expr));
    for (t : rand_sort(type)) //## UGLY UGLY
      return errs if may_have_field(follow_type(t), field);
    ;
    return errs & {never_has_field(type, field)};

    Type follow_type(Type type):
      tag_obj_type()  = type.obj_type,
      _               = type;

    Bool may_have_field(Type type, SymbObj field):
      record_type(fs?)  = has_key(fs, field),
      ne_map_type()     = type_contains_obj(type.key_type, _obj_(field)),
      _                 = false;
  }


  TypeCheckingError* typecheck_if_expr(Expr cond, Expr then_expr, Expr else_expr, ClosedType exp_type)
  {
    cond_errs = typecheck(cond, type_bool);
    if_true_env, if_false_env = if cond_errs == {} then refine_environment(cond) else (environment, environment);
    then_errs = typecheck(then_expr, exp_type, environment=if_true_env);
    else_errs = typecheck(else_expr, exp_type, environment=if_false_env);
    return cond_errs & then_errs & else_errs;
  }


  TypeCheckingError* typecheck_match_expr([Expr^] exprs, [(ptrns: [Pattern^], expr: Expr)^] cases, ClosedType exp_type)
  {
    //## HERE I SHOULD ALSO CHECK THAT THE PATTERNS WILL EVENTUALLY COVER ALL THE POSSIBILITIES...
    errs = seq_union([typecheck(e, type_any) : e <- exprs]);
    return errs if errs /= {};
    ts = [expr_type(e) : e <- exprs];
    for (c : cases)
      case_errs = seq_union([{ptrn_cannot_match_type(p, t) if not may_match(p, t)} : p, t <- zip(c.ptrns, ts)]);
      errs = errs & case_errs;
      if (case_errs == {})
        new_env = update_environment(exprs, c.ptrns);
        errs = errs & typecheck(c.expr, exp_type, environment=new_env);
      ;
    ;
    return errs;
  }


  TypeCheckingError* typecheck_ex_qual_expr(Clause source, Maybe[Expr] maybe_sel_expr, ClosedType exp_type)
  {
    errs = typecheck(source);
    return errs if errs /= {};
    return {} if maybe_sel_expr == nil;
    new_env = update(environment, generated_environment(source));
    return typecheck(value(maybe_sel_expr), type_bool, environment=new_env);
  }


  TypeCheckingError* typecheck_set_comp_expr(Expr expr, Clause source, Maybe[Expr] maybe_sel_expr, ClosedType exp_type)
  {
    errs = typecheck(source);
    return errs if errs /= {};
    new_env = refine_environment(source);
    if (maybe_sel_expr /= nil)
      sel_expr = value(maybe_sel_expr);
      errs = typecheck(sel_expr, type_bool, environment=new_env);
      new_env = left(refine_environment(sel_expr, environment=new_env));
    ;
    exp_elem_type = set_elem_type(exp_type);
    return errs & if exp_elem_type /= void_type
      then typecheck(expr, exp_elem_type, environment=new_env)
      else {not_a_set_type};
  }


  TypeCheckingError* typecheck_map_comp_expr(Expr key_expr, Expr value_expr, Clause source, Maybe[Expr] maybe_sel_expr, ClosedType exp_type)
  {
    errs = typecheck(source);
    return errs if errs /= {};
    new_env = refine_environment(source);
    if (maybe_sel_expr /= nil)
      sel_expr = value(maybe_sel_expr);
      errs = typecheck(sel_expr, type_bool, environment=new_env);
      new_env = left(refine_environment(sel_expr, environment=new_env));
    ;
    exp_key_type = map_key_type(exp_type);
    exp_value_type = map_value_type(exp_type);
    if (exp_key_type /= void_type and exp_value_type /= void_type)
      errs = errs & typecheck(key_expr, exp_key_type, environment=new_env);
      errs = errs & typecheck(value_expr, exp_value_type, environment=new_env);
    else
      errs = errs & {not_a_map_type}; //## BUG: IT COULD ACTUALLY BE A RECORD TYPE, COULDN'T IT?
    ;
    return errs;
  }


  TypeCheckingError* typecheck_seq_comp(Expr expr, [Var^] vars, Maybe[Var] maybe_idx_var, Expr src_expr, Maybe[Expr] maybe_sel_expr, ClosedType exp_type)
  {
    exp_elem_type = seq_elem_type(exp_type);
    errs = {not_a_seq_type if exp_elem_type == void_type} & typecheck(src_expr, type_seq);
    return errs if errs /= {};
    src_type = expr_type(src_expr);
    elem_type = seq_elem_type(src_type);
    assert elem_type /= void_type; //## BUG: WHAT IF src_type IS THE EMPTY SEQUENCE TYPE?
    env_delta = asgnm_env_updates(vars, elem_type) & (value(maybe_idx_var) => type_nat if maybe_idx_var /= nil);
    new_env = update(environment, env_delta);
    if (maybe_sel_expr /= nil)
      sel_expr = value(maybe_sel_expr);
      errs = typecheck(sel_expr, type_bool, environment=new_env);
      new_env = left(refine_environment(sel_expr, environment=new_env));
    ;
    return errs & typecheck(expr, exp_elem_type, environment=new_env);
  }


  TypeCheckingError* typecheck_int_range_seq_comp(Expr expr, Var var, Expr upper_bound_expr, Bool includes_upper_bound, Maybe[Expr] maybe_sel_expr, ClosedType exp_type)
  {
    exp_elem_type = seq_elem_type(exp_type);
    errs = {not_a_seq_type if exp_elem_type == void_type} & typecheck(upper_bound_expr, integer);
    new_env = update(environment, (var => type_nat)); //## BAD: HERE WE COULD TAKE ADVANTAGE OF THE KNOWLEDGE ON THE TYPE OF THE UPPER BOUND
    errs = errs & typecheck(value(maybe_sel_expr), type_bool, environment=new_env) if maybe_sel_expr /= nil;
    errs = errs & {obj_does_not_belong_to_type([], exp_type)} if not type_contains_obj(exp_type, []); //## BAD: HERE TOO WE COULD TAKE ADVANTAGE OF THE INFORMATION WE HAVE ABOUT THE UPPER BOUND TYPE
    return errs & typecheck(expr, exp_elem_type, environment=new_env);
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  TypeCheckingError* typecheck(ClsExpr expr, ClsType exp_type):
    ClsVar = {
      var_type = closures[expr];
      return {unexpected_actual_cls_type(var_type, exp_type) if not is_subset(var_type, exp_type)};
    },
    fn_ptr() = {
      sgns = {s : s <- signatures[expr.name], expr.arity == arity(s)};
      assert size(sgns) == 1;
      sgn = only_element(sgns);
      assert sgn.named_params == ();
      assert not (? p <- sgn.params : not p :: Type);
      sgn_cls = cls_type(sgn.params, sgn.ret_type);
      return {unexpected_actual_cls_type(sgn_cls, exp_type) if not is_subset(sgn_cls, exp_type)};
    },
    cls_expr() = {
      assert all([p == nil : p <- expr.params]); //## FOR NOW ALL VARIABLES SHOULD BE ANONYMOUS...
      delta_env = merge(set([(fn_par(i) => t, v => t if v /= nil) : v, t @ i <- zip(expr.params, exp_type.in_types)]));
      new_env = update(environment, delta_env);
      return typecheck(expr.expr, exp_type.out_type, environment=new_env); //## BAD: HERE I SHOULD PROVIDE MORE INFORMATION
    };

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  TypeCheckingError* typecheck([Statement] stmts, ClosedType exp_type)
  {
    env = environment;
    for (s : stmts)
      errs = typecheck(s, exp_type, environment=env);
      return errs if errs /= {};
      env = update_environment(s, environment=env);
    ;
    return {};
  }


  TypeCheckingError* typecheck(Statement stmt, ClosedType exp_type):
    assignment_stmt()   = typecheck(stmt.value, type_any),
    return_stmt(e?)     = typecheck(e, exp_type),
    if_stmt()           = typecheck_if_stmt(stmt.cond, stmt.body, stmt.else, exp_type),
    loop_stmt(ss?)      = typecheck_loop_stmt(ss, exp_type),
    foreach_stmt()      = { maybe_idx_var = if stmt.idx_var? then just(stmt.idx_var) else nil;
                            return typecheck_foreach_stmt(stmt.vars, maybe_idx_var, stmt.values, stmt.body, exp_type);
                          },
    for_stmt()          = { maybe_var = if stmt.var? then just(stmt.var) else nil;
                            maybe_idx_var = if stmt.idx_var? then just(stmt.idx_var) else nil;
                            return typecheck_for_stmt(maybe_var, maybe_idx_var, stmt.start_val,
                              stmt.end_val, stmt.end_val_incl, stmt.body, exp_type);
                          },
    let_stmt()          = typecheck_let_stmt(stmt.asgnms, stmt.body, exp_type),
    break_stmt          = {},
    fail_stmt           = {},
    assert_stmt(e?)     = typecheck(e, type_bool),
    print_stmt(e?)      = typecheck(e, type_any);


  TypeCheckingError* typecheck_if_stmt(Expr cond, [Statement^] body, [Statement] else_body, ClosedType exp_type)
  {
    errs = typecheck(cond, type_bool);
    return errs if errs /= {};
    if_true_env, if_false_env = refine_environment(cond);
    return typecheck(body, exp_type, environment=if_true_env) &
           typecheck(else_body, exp_type, environment=if_false_env);
  }


  TypeCheckingError* typecheck_loop_stmt([Statement^] stmts, ClosedType exp_type)
  {
    errs = {}; //## BAD: THIS SHOULD NOT BE NECESSARY, AS THE BODY OF THE LOOP IS ALWAYS GOING TO BE EXECUTED AT LEAST ONCE
    env = environment;
    for (5) //## BAD: THIS IS A TOTALLY ARBITRARY NUMBER...
      errs = typecheck(stmts, exp_type, environment=env);
      return errs if errs /= {};
      new_env = update_environment(stmts, environment=env);
      return {} if new_env == env;
      env = new_env;
    ;
    return {loop_did_not_converge(5, errs)};
  }


  TypeCheckingError* typecheck_foreach_stmt([Var^] vars, Maybe[Var] maybe_idx_var, Expr values, [Statement^] body, ClosedType exp_type)
  {
    errs = typecheck(values, type_seq);
    return errs if errs /= {};
    elem_type = seq_elem_type(expr_type(values));
    return {not_a_seq_type} if elem_type == void_type; //## COULD I ACCEPT A TUPLE TYPE HERE ALSO?
    num_vars = length(vars);
    if (num_vars == 1)
      loop_vars = (vars[0] => elem_type, value(maybe_idx_var) => type_nat if maybe_idx_var /= nil);
    else
      return {not_a_seq_of_tuples} if not is_subset(elem_type, type_tuple(num_vars));
      field_types = tuple_field_types(elem_type);
      loop_vars = merge(set([(v => t) : v, t <- zip(vars, field_types)]));
    ;
    env = update(environment, loop_vars);
    for (5)
      errs = typecheck(body, exp_type, environment=env);
      return errs if errs /= {};
      new_env = update_environment(body, environment=env);
      return {} if new_env == env;
      env = new_env;
    ;
    return {loop_did_not_converge(5, errs)};
  }


  TypeCheckingError* typecheck_for_stmt(Maybe[Var] maybe_var, Maybe[Var] maybe_idx_var, Expr start_val,
    Expr end_val, Bool end_val_incl, [Statement^] body, ClosedType exp_type)
  {
    errs = typecheck(start_val, integer) & typecheck(end_val, integer);
    return errs if errs /= {};
    env = environment & (
      value(maybe_var) => loop_var_type(expr_type(start_val), expr_type(end_val), end_val_incl) if maybe_var /= nil,
      value(maybe_idx_var) => type_nat if maybe_idx_var /= nil
    );
    for (5)
      errs = typecheck(body, exp_type, environment=env);
      return errs if errs /= {};
      new_env = update_environment(body, environment=env);
      return {} if new_env == env;
      env = new_env;
    ;
    return {loop_did_not_converge(5, errs)};
  }


  TypeCheckingError* typecheck_let_stmt((NamedPar => Expr) asgnms, [Statement^] body, ClosedType exp_type)
  {
    errs = union({typecheck(e, type_any) : v => e <- asgnms});
    return errs if errs /= {};
    env_delta = (v => expr_type(e) : v => e <- asgnms);
    new_env = update(environment, env_delta);
    return typecheck(body, exp_type, environment=new_env); //## BUG BUG BUG (WHY?)
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  TypeCheckingError* typecheck(Clause clause):
    in_clause()           = typecheck(clause.src, type_set),
    map_in_clause()       = typecheck(clause.src, type_map),
    and_clause()          = typecheck(clause.left) & typecheck(clause.right, environment=update(environment, generated_environment(clause.left))),
    or_clause()           = typecheck(clause.left) & typecheck(clause.right);


  // TypeCheckingError* typecheck(Clause clause, Expr sel_expr)
  // {
  //   errs = typecheck(clause);
  //   return errs if errs /= {};
  //   new_env = update(environment, generated_environment(clause));
  //   return typecheck(sel_expr, type_bool, environment=new_env);
  // }
}





Type loop_var_type(Type lower_bound_type, Type upper_bound_type, Bool upper_bound_included)
{
  upper_bound_adj = bit(not upper_bound_included);

  // lower_bound = match (lower_bound_type)
  //   integer     = nil,
  //   low_ints()  = nil,
  //   high_ints() = just(lower_bound_type.min),
  //   int_range() = just(lower_bound_type.min);
  // ;

  // upper_bound = match (upper_bound_type)
  //   integer     = nil,
  //   low_ints()  = upper_bound_type.max,
  //   high_ints() = nil,
  //   int_range() = max(upper_bound_type);
  // ;

  dummy_int_range = int_range(1, 1); // BUG BUG BUG: HERE I SHOULD BE USING THE VOID TYPE...

  loop_var_type = match (lower_bound_type, upper_bound_type)
    integer,      integer       = integer,
    integer,      low_ints()    = low_ints(upper_bound_type.max - upper_bound_adj),
    integer,      high_ints()   = integer,
    integer,      int_range()   = low_ints(max(upper_bound_type) - upper_bound_adj),
    low_ints(),   integer       = integer,
    low_ints(),   low_ints()    = low_ints(upper_bound_type.max - upper_bound_adj),
    low_ints(),   high_ints()   = integer,
    low_ints(),   int_range()   = low_ints(max(upper_bound_type) - upper_bound_adj),
    high_ints(),  integer       = lower_bound_type,
    high_ints(),  low_ints()    = { min = lower_bound_type.min;
                                    max = upper_bound_type.max - upper_bound_adj;
                                    return if min <= max then int_range(min, max) else dummy_int_range;
                                  },
    high_ints(),  high_ints()   = lower_bound_type,
    high_ints(),  int_range()   = { min = lower_bound_type.min;
                                    max = max(upper_bound_type) - upper_bound_adj;
                                    return if min <= max then int_range(min, max) else dummy_int_range;
                                  },
    int_range(),  integer       = high_ints(lower_bound_type.min),
    int_range(),  low_ints()    = { min = lower_bound_type.min;
                                    max = upper_bound_type.max - upper_bound_adj;
                                    return if min <= max then int_range(min, max) else dummy_int_range;
                                  },
    int_range(),  high_ints()   = high_ints(lower_bound_type.min),
    int_range(),  int_range()   = { min = lower_bound_type.min;
                                    max = max(upper_bound_type) - upper_bound_adj;
                                    return if min <= max then int_range(min, max) else dummy_int_range;
                                  };
  ;

  return loop_var_type;
}


// //## THIS IS ALL A TEMPORARY HACK TO WORK AROUND AN UNFINISHED FEATURE IN CODE GENERATION
// Bool matches_signature(FnType signature, [ExtExpr] params, (NamedPar => ExtExpr) named_params) =
//   matches_signature_impl(signature, params, named_params, halt_on_failure_to_typecheck=false);

// Bool matches_signature_impl(FnType signature, [ExtExpr] params, (NamedPar => ExtExpr) named_params)
// {
//   // let (halt_on_failure_to_typecheck=false)
//     return false if length(params) /= length(signature.params);
//     for (e, t : zip(params, signature.params))
//       return false if not is_subset(expr_type(e), replace_type_vars_with_type_any(t));
//     ;

//     for (p : rand_sort(keys(signature.named_params))) //## WOULD BE GOOD TO USE A ZIP (BY KEY) FUNCION HERE
//       formal_type = signature.named_params[p];
//       if (formal_type :: Type)
//         formal_type = replace_type_vars_with_type_any(formal_type);
//         if (has_key(named_params, p))
//           expr = named_params[p];
//           assert expr :: Expr;
//           return false if not is_subset(expr_type(expr), formal_type);
//         else
//           actual_type = environment[p];
//           assert actual_type :: Type;
//           return false if not is_subset(actual_type, formal_type);
//         ;
//       else
//         assert formal_type :: ClsType;
//         if (has_key(named_params, p))
//           cls_expr = named_params[p];
//           assert cls_expr :: ClsExpr;
//           return false if not is_subset(expr_type(cls_expr), formal_type);
//         else
//           actual_type = closures[p];
//           assert actual_type :: ClsType;
//           return false if not is_subset(actual_type, formal_type);
//         ;
//       ;
//     ;
//   // ;
//   return true;
// }

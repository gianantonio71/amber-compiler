// using (TypeName => Type) typedefs
// {
  // Type union_superset(Type t1, Type t2) = union_superset({t1, t2});

  // Type union_superset(Type+ types) = union_type(types);


  // Type union_superset(Type+ types)
  // {
  //   non_empty_types = types - {empty_type};
  //   return empty_type if non_empty_types == {};
  //   return union_type(union({types(t) : t <- non_empty_types}));

  //   Type+ types(Type type):
  //     union_type(ts?) = ts,
  //     _               = {type};
  // }


  // Type union_superset_impl(Type t1, Type t2):
  //   type_var(),             _                   = if t1 == t2 then t1 else type_any,
  //   _,                      type_var()          = type_any,

  //   //## WHAT ABOUT TYPE REFERENCES?
  //   // type_ref(ts1?),         _                   = ???
  //   // _,                      type_ref(ts2?)      = ???

  //   union_type(ts1?),       union_type(ts2?)    = union_superset_impl(ts1 & ts2),
  //   union_type(ts?),        _                   = union_superset_impl(ts & {t2}),
  //   _,                      union_type(ts?)     = union_superset_impl({t1} & ts),

  //   symb_type(),            atom_type           = atom_type,

  //   IntType,                IntType             = int_type_union(t1, t2),

  //   ne_set_type(),          ne_set_type()       = ne_set_type(union_superset_impl(t1.elem_type, t2.elem_type)),

  //   ne_seq_type(),          ne_seq_type()       = ne_seq_type(union_superset_impl(t1.elem_type, t2.elem_type)),
  //   ne_seq_type(),          tuple_type(ts?)     = ne_seq_type(union_superset_impl({t1.elem_type} & set(ts))),
  //   tuple_type(),           ne_seq_type()       = union_superset_impl(t2, t1),
  //   tuple_type(ts1?),       tuple_type(ts2?)    = if length(ts1) /= length(ts2)
  //                                                   then ne_seq_type(union_superset_impl(set(ts1 & ts2)))
  //                                                   else tuple_type([union_superset_impl(ft1, ft2) : ft1, ft2 <- zip(ts1, ts2)]),

  //   empty_map_type,         record_type()       = if type_contains_obj(t2, ()) then t2 else union_type({t1, t2}),
  //   record_type(fs?),       empty_map_type      = union_superset_impl(t2, t1),
  //   ne_map_type(),          ne_map_type()       = ne_map_type(
  //                                                   union_superset_impl(t1.key_type, t2.key_type),
  //                                                   union_superset_impl(t1.value_type, t2.value_type)
  //                                                 ),
  //   ne_map_type(),          record_type(fs?)    = map_record_types_union_superset(t1.key_type, t1.value_type, fs),
  //   record_type(fs?),       ne_map_type()       = map_record_types_union_superset(t2.key_type, t2.value_type, fs),
  //   record_type(fs1?),      record_type(fs2?)   = record_types_union_superset(fs1, fs2),

  //   tag_obj_type(),         tag_obj_type()      = tag_obj_types_union_superset(t1, t2),

  //   _,                      _                   = union_type({t1, t2});
// }

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// IntType int_type_union(IntType t1, IntType t2):
//   integer,      _             = integer,
//   low_ints(),   low_ints()    = low_ints(max(t1.max, t2.max)),
//   low_ints(),   high_ints()   = integer,
//   low_ints(),   int_range()   = low_ints(max(t1.max, max(t2))),
//   high_ints(),  high_ints()   = high_ints(min(t1.min, t2.min)),
//   high_ints(),  int_range()   = high_ints(min(t1.min, t2.min)),
//   int_range(),  int_range()   = int_range(min(t1.min, t2.min), max(max(t1), max(t2))),
//   _,            _             = int_type_union(t2, t1);

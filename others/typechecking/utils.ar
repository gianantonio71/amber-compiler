Type unfold(Type type, (SelfPretype => Type) sub_map):
  LeafType          = type,
  TypeVar           = type,
  SelfPretype       = sub_map[type],
  ne_seq_type()     = ne_seq_type(unfold(type.elem_type, sub_map)),
  ne_set_type()     = ne_set_type(unfold(type.elem_type, sub_map)),
  ne_map_type()     = ne_map_type(unfold(type.key_type, sub_map), unfold(type.value_type, sub_map)),
  record_type(fs?)  = record_type((l => (type: unfold(f.type, sub_map), optional: f.optional) : l => f <- fs)),
  tuple_type(ts?)   = tuple_type([unfold(t, sub_map) : t <- ts]),
  tag_obj_type()    = tag_obj_type(type.tag_type, unfold(type.obj_type, sub_map)),
  union_type(ts?)   = union_type({unfold(t, sub_map) : t <- ts}),
  self_rec_type()   = type,
  mut_rec_type()    = type;


Type unfold(Type type):
  self_rec_type(t?) = unfold(t, (self => type)),
  mut_rec_type()    = unfold(type.types[type.index], (self(i) => mut_rec_type(i, type.types) : i <- index_set(type.types))),
  _                 = type;


Bool has_rec_branches(Type type):
  LeafType              = false,
  self                  = true,
  self()                = true,
  type_var(a?)          = false,
  ne_seq_type()         = has_rec_branches(type.elem_type),
  ne_set_type()         = has_rec_branches(type.elem_type),
  ne_map_type()         = has_rec_branches(type.key_type) or has_rec_branches(type.value_type),
  record_type(fs?)      = (? l => f <- fs : has_rec_branches(f.type)), //## WHAT IF THAT PARTICULAR FIELD IS OPTIONAL?
  tuple_type(ts?)       = at_least_one([has_rec_branches(t) : t <- ts]),
  tag_obj_type()        = has_rec_branches(type.obj_type),
  union_type(ts?)       = (? t <- ts : has_rec_branches(t)),
  self_rec_type(t?)     = false, //## NOT SURE HERE...
  mut_rec_type()        = false; //## DITTO

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

PseudoType pseudotype(Type type) = pretype_pseudotype(type, ());

PseudoType pretype_pseudotype(Type type, (SelfPretype => PseudoType) self_pseudotypes):
  self                  = self_pseudotypes[type],
  self()                = self_pseudotypes[type],
  atom_type             = pseudotype_symbols,
  symb_type(object(a?)) = pseudotype_symbol(a),
  IntType               = pseudotype_integers,
  float_type            = pseudotype_floats,
  TypeVar               = pseudotype_any,
  empty_set_type        = pseudotype_empty_set,
  ne_set_type()         = pseudotype_ne_sets,
  empty_seq_type        = pseudotype_empty_seq,
  ne_seq_type()         = pseudotype_ne_seqs,
  empty_map_type        = pseudotype_empty_map,
  ne_map_type()         = pseudotype_ne_maps,
  record_type(fs?)      = pseudotype_union({pseudotype_ne_maps, pseudotype_empty_map if (? l => f <- fs : not f.optional)}),
  tuple_type()          = pseudotype_ne_seqs,
  union_type(ts?)       = pseudotype_union({pretype_pseudotype(t, self_pseudotypes) : t <- ts}),
  tag_obj_type()        = match (type.tag_type)
                            symb_type(object(a?)) = pseudotype_tag_obj(a),
                            atom_type             = pseudotype_tag_objs;
                          ,
  self_rec_type(t?)     = pretype_pseudotype(t, ()), //## NOT ENTIRELY SURE
  // mut_rec_type()        = pseudotypes[self(type.index)] let pseudotypes = mut_rec_type_pseudotype(type);;
  // mut_rec_type()        = (mut_rec_type_pseudotype(type))[self(type.index)];
  mut_rec_type()        = {pts = mut_rec_type_pseudotype(type); return pts[self(type.index)];};


(SelfPretype => PseudoType) mut_rec_type_pseudotype(MutRecType type)
{
  refs = [{s : s <- top_level_rec_refs(t)} : t <- type.types];
  pseudotypes = ();
  loop
    next_type_idxs = {i : i <- index_set(type.types), not has_key(pseudotypes, self(i)) and subset(refs[i], keys(pseudotypes))};
    assert next_type_idxs /= {} or keys(pseudotypes) == {self(i) : i <- index_set(type.types)};
    return pseudotypes if next_type_idxs == {};
    pseudotypes = pseudotypes & (self(i) => pretype_pseudotype(type.types[i], pseudotypes) : i <- next_type_idxs);
  ;
}


SelfPretype* top_level_rec_refs(Type type): //## THIS IS NOT THE RIGHT PLACE FOR THIS FUNCTION
  SelfPretype     = {type},
  union_type(ts?) = union({top_level_rec_refs(t) : t <- ts}),
  _               = {};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Bool anon_types_are_compatible(Type t1, Type t2) = anon_types_are_compatible(t1, t2, ());

//## BAD: I REALLY DON'T LIKE THIS FUNCTION. ISN'T THERE A WAY NOT TO USE IT?
Bool anon_types_are_compatible(Type t1, Type t2, (SelfPretype => PseudoType) self_pseudotypes) =
  are_disjoint(pretype_pseudotype(t1, self_pseudotypes), pretype_pseudotype(t2, self_pseudotypes));


Type inner_pretype(RecType type): //## BAD: FIND BETTER NAME
  self_rec_type(t?)   = t,
  mut_rec_type()      = type.types[type.index];



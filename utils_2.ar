// Type replace_type_vars_with_type_any(ExtType type) = replace_type_vars_computed(type, type_any);

Type replace_type_vars(ExtType type, (TypeVar => Type) substitutions) = replace_type_vars_computed(type, substitutions[$]);

// Type replace_known_type_vars(ExtType type, (TypeVar => Type) substitutions) =
//   replace_type_vars_computed(type, if has_key(substitutions, $) then substitutions[$] else $);


//## BAD: FIND DECENT NAME, OR EVEN BETTER, REMOVE THE RESTRICTIONS ABOUT CLOSURE PARAMETERS FOR FUNCTIONS WITH SAME NAME AND ARITY
Type replace_type_vars_computed(Type type, (TypeVar -> Type) replace):
  LeafType          = type,
  TypeVar           = replace(type),
  type_ref(ts?)     = type_ref(replace_type_vars_computed(ts, replace)),
  ne_seq_type()     = ne_seq_type(replace_type_vars_computed(type.elem_type, replace)),
  ne_set_type()     = ne_set_type(replace_type_vars_computed(type.elem_type, replace)),
  ne_map_type()     = ne_map_type(replace_type_vars_computed(type.key_type, replace), replace_type_vars_computed(type.value_type, replace)),
  record_type(fs?)  = record_type((l => (type: replace_type_vars_computed(f.type, replace), optional: f.optional) : l => f <- fs)), //## BAD: WOULD BE GOOD TO HAVE A "DECLARATIVE" UPDATE OPERATION
  tuple_type(ts?)   = tuple_type([replace_type_vars_computed(t, replace) : t <- ts]),
  tag_obj_type()    = tag_obj_type(type.tag_type, replace_type_vars_computed(type.obj_type, replace)),
  union_type(ts?)   = union_type({replace_type_vars_computed(t, replace) : t <- ts});


// ClsType replace_type_vars_computed(ClsType type, (TypeVar -> Type) replace) =
//   cls_type(
//     [replace_type_vars_computed(t, replace) : t <- type.in_types],
//     replace_type_vars_computed(type.out_type, replace)
//   );

TypeSymbol replace_type_vars_computed(TypeSymbol type_symb, (TypeVar -> Type) replace):
  type_symbol()     = type_symb,
  par_type_symbol() = par_type_symbol(
                        type_symb.symbol,
                        [replace_type_vars_computed(t, replace) : t <- type_symb.params]
                      );

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

T* retrieve_from_nested_types(Type type, (Type -> T*) retrieve):
  LeafType          = {},
  type_res(ts?)     = retrieve_from_nested_types(ts, retrieve),
  TypeVar           = {},
  ne_seq_type()     = retrieve(type.elem_type),
  ne_set_type()     = retrieve(type.elem_type),
  ne_map_type()     = retrieve(type.key_type) & retrieve(type.value_type),
  record_type(fs?)  = union({retrieve(f.type) : _ => f <- fs}),
  tuple_type(ts?)   = seq_union([retrieve(t) : t <- ts]),
  tag_obj_type()    = retrieve(type.tag_type) & retrieve(type.obj_type),
  union_type(ts?)   = union({retrieve(t) : t <- ts});


T* retrieve_from_nested_types(TypeSymbol type_symb, (Type -> T*) retrieve):
  type_symbol()       = {},
  par_type_symbol()   = seq_union([retrieve(t) : t <- type_symb.params]);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Type expand_type_ref(TypeSymbol type_symb, (TypeName => Type) typedefs)
{
  type_name = type_symb_to_name(type_symb);
  raw_type = typedefs[type_name];
  return raw_type if type_name.arity == 0;
  subst_map = merge(set([(type_var(i) => p) : p @ i <- params(type_symb)]));
  return replace_type_vars(raw_type, subst_map);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

T* retrieve_from_nested_exprs(Expr expr, (Expr -> T*) retrieve):
  LeafObj           = {},
  FloatLit          = {},
  set_expr(ses?)    = union({retrieve_from_nested_exprs(se, retrieve) : se <- ses}),
  seq_expr(ses?)    = seq_union([retrieve_from_nested_exprs(se, retrieve) : se <- ses]),
  tuple_expr(es?)   = seq_union([retrieve(e) : e <- es]),
  seq_tail_expr()   = retrieve(expr.seq) & seq_union([retrieve(e) : e <- expr.tail]),
  map_expr(es?)     = union({retrieve(e.key) & retrieve(e.value) & if e.cond? then retrieve(e.cond) else {} : e <- es}),
  tag_obj_expr()    = retrieve(expr.tag) & retrieve(expr.obj),
  Var               = {},
  fn_call()         = union({retrieve_from_nested_exprs(p, retrieve) : p <- set(expr.params) & values(expr.named_params)}),
  cls_call()        = seq_union([retrieve(p) : p <- expr.params]),
  builtin_call()    = seq_union([retrieve(p) : p <- expr.params]),
  and_expr()        = retrieve(expr.left) & retrieve(expr.right),
  or_expr()         = retrieve(expr.left) & retrieve(expr.right),
  not_expr(e?)      = retrieve(e),
  eq()              = retrieve(expr.left) & retrieve(expr.right),
  membership()      = retrieve(expr.obj),
  cast_expr()       = retrieve(expr.expr),
  accessor()        = retrieve(expr.expr),
  accessor_test()   = retrieve(expr.expr),
  if_expr()         = retrieve(expr.cond) & retrieve(expr.then) & retrieve(expr.else),
  match_expr()      = seq_union([retrieve(e) : e <- expr.exprs]) &
                      seq_union([retrieve(c.expr) : c <- expr.cases]),
  do_expr(ss?)      = retrieve_from_nested_exprs(ss, retrieve),
  ex_qual()         = retrieve_from_nested_exprs(expr.source, retrieve) &
                      if expr.sel_expr? then retrieve(expr.sel_expr) else {},
  set_comp()        = retrieve_from_nested_exprs(expr.source, retrieve) &
                      retrieve(expr.expr) &
                      if expr.sel_expr? then retrieve(expr.sel_expr) else {},
  map_comp()        = retrieve_from_nested_exprs(expr.source, retrieve) &
                      retrieve(expr.key_expr) &
                      retrieve(expr.value_expr) &
                      if expr.sel_expr? then retrieve(expr.sel_expr) else {},
  seq_comp()        = retrieve(expr.expr) &
                      retrieve(expr.src_expr) &
                      if expr.sel_expr? then retrieve(expr.sel_expr) else {};


T* retrieve_from_nested_exprs(CondExpr expr, (Expr -> T*) retrieve) = retrieve(expr.expr) & retrieve(expr.cond);


T* retrieve_from_nested_exprs(ClsExpr expr, (Expr -> T*) retrieve):
  ClsVar      = {},
  fn_ptr()    = {},
  cls_expr()  = retrieve(expr.expr);


T* retrieve_from_nested_exprs(Statement stmt, (Expr -> T*) retrieve):
  assignment_stmt()   = retrieve(stmt.value),
  return_stmt(e?)     = retrieve(e),
  if_stmt()           = retrieve(stmt.cond) & retrieve_from_nested_exprs(stmt.body, retrieve) & retrieve_from_nested_exprs(stmt.else, retrieve),
  loop_stmt(ss?)      = retrieve_from_nested_exprs(ss, retrieve),
  foreach_stmt()      = retrieve(stmt.values) & retrieve_from_nested_exprs(stmt.body, retrieve),
  for_stmt()          = retrieve(stmt.start_val) & retrieve(stmt.end_val) & retrieve_from_nested_exprs(stmt.body, retrieve),
  let_stmt()          = union({retrieve(e) : _ => e <- stmt.asgnms}) & retrieve_from_nested_exprs(stmt.body, retrieve),
  break_stmt          = {},
  fail_stmt           = {},
  assert_stmt(e?)     = retrieve(e),
  print_stmt(e?)      = retrieve(e),
  imp_update_stmt()   = retrieve(stmt.idx) & retrieve(stmt.value),
  return_stmt         = {},
  proc_call()         = seq_union([retrieve(p) : p <- stmt.params]);


T* retrieve_from_nested_exprs([Statement] stmts, (Expr -> T*) retrieve) = seq_union([retrieve_from_nested_exprs(s, retrieve) : s <- stmts]);


T* retrieve_from_nested_exprs(Clause cls, (Expr -> T*) retrieve):
  in_clause()       = retrieve(cls.src),
  map_in_clause()   = retrieve(cls.src),
  and_clause()      = retrieve_from_nested_exprs(cls.left, retrieve) & retrieve_from_nested_exprs(cls.right, retrieve),
  or_clause()       = retrieve_from_nested_exprs(cls.left, retrieve) & retrieve_from_nested_exprs(cls.right, retrieve);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Expr* ordinary_subexprs(Expr expr):
  object()        = {},
  seq_expr(ses?)  = union({subexprs(e) : e <- set(ses)}),
  tuple_expr(es?) = set(es),
  seq_tail_expr() = {expr.seq} & union({subexprs(e) : e <- set(expr.tail)}),
  set_expr(ses?)  = union({subexprs(e) : e <- ses}),
  map_expr(es?)   = union({{e.key, e.value, e.cond if e.cond?} : e <- es}),
  tag_obj_expr()  = {expr.tag, expr.obj},
  Var             = {},
  fn_call()       = {},
  cls_call()      = set(expr.params), //## BAD
  builtin_call()  = set(expr.params), //## BAD
  and_expr()      = {expr.left, expr.right},
  or_expr()       = {expr.left, expr.right}, //## BAD
  not_expr(e?)    = {e},
  eq()            = {expr.left, expr.right}, //## BAD
  membership()    = {expr.obj},
  cast_expr()     = {expr.expr},
  accessor()      = {expr.expr},
  accessor_test() = {expr.expr},
  if_expr()       = {expr.cond, expr.then, expr.else},
  // Expression that contain "special" subexpressions
  ex_qual()       = {},
  set_comp()      = {},
  map_comp()      = {},
  seq_comp()      = {expr.src_expr},
  // Expression that require special treatment
  match_expr()    = set(expr.exprs),
  do_expr()       = {};

//## FIND BETTER NAME
Expr* subexprs(Expr expr)     = {expr};
Expr* subexprs(CondExpr expr) = {expr.expr, expr.cond};

Expr* special_subexprs(Expr expr):
  ex_qual()       = {expr.sel_expr if expr.sel_expr?},
  set_comp()      = {expr.expr, expr.sel_expr if expr.sel_expr?},
  map_comp()      = {expr.key_expr, expr.value_expr, expr.sel_expr if expr.sel_expr?},
  seq_comp()      = {expr.expr, expr.sel_expr if expr.sel_expr?}, //## BAD
  _               = {};

Var* gen_vars(Expr expr):
  ex_qual()       = new_vars(expr.source),
  set_comp()      = new_vars(expr.source), //## BAD
  map_comp()      = new_vars(expr.source), //## BAD
  seq_comp()      = set(expr.vars) & {expr.idx_var if expr.idx_var?},
  _               = {};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//## IS THIS CODE OK? IN CALCULATING THE NEW VARS, IT DOESN'T
//## CONSIDER THE VARIABLES THAT ARE ALREADY DEFINED

Var* new_vars(Pattern ptrn):
  ptrn_var()      = new_vars(ptrn.ptrn) & {ptrn.var},
  ptrn_tag_obj()  = new_vars(ptrn.tag) & new_vars(ptrn.obj),
  ptrn_union(ps?) = union({new_vars(p) : p <- ps}),
  _               = {};

Var* new_vars(Clause clause):
  in_clause()         = new_vars(clause.ptrn),
  map_in_clause()     = new_vars(clause.key_ptrn) & new_vars(clause.value_ptrn),
  and_clause()        = new_vars(clause.left) & new_vars(clause.right),
  or_clause()         = intersection(new_vars(clause.left), new_vars(clause.right));

Var* new_vars(Statement stmt):
  assignment_stmt() = set(stmt.vars),
  if_stmt()         = intersection({new_vars(stmt.body) if may_fall_through(stmt.body), new_vars(stmt.else) if may_fall_through(stmt.else)}),
  let_stmt()        = new_vars(stmt.body),
  _                 = {};

Var* new_vars([Statement] stmts) = seq_union([new_vars(s) : s <- stmts]);

///////////////////////////////////////////////////////////////////////////////

Var* extern_vars(Expr expr)
{
  ord_expr_evs  = union({extern_vars(e) : e <- ordinary_subexprs(expr)});
  spec_expr_evs = union({extern_vars(e) : e <- special_subexprs(expr)}) - gen_vars(expr);
  spec_case_evs = special_cases(expr);

  return ord_expr_evs & spec_expr_evs & spec_case_evs;

  Var* special_cases(Expr expr):
      Var            = {expr},
      fn_call()      = union({extern_vars(e) : e <- set(expr.params)} & {extern_vars(e) : k => e <- expr.named_params}),
      ex_qual()      = extern_vars(expr.source),
      set_comp()     = extern_vars(expr.source), //## BAD
      map_comp()     = extern_vars(expr.source), //## BAD
      do_expr(ss?)   = extern_vars(ss),
      match_expr()   = { vs = {};
                         for (c : expr.cases)
                           pvs = seq_union([new_vars(p) : p <- c.ptrns]);
                           vs  = vs & (extern_vars(c.expr) - pvs);
                         ;
                         return vs;
                       },

      _              = {};
}


Var* extern_vars(Clause clause):
  in_clause()         = extern_vars(clause.src),
  map_in_clause()     = extern_vars(clause.src),
  and_clause()        = extern_vars(clause.left) & (extern_vars(clause.right) - new_vars(clause.left)),
  or_clause()         = extern_vars(clause.left) & extern_vars(clause.right);


Var* extern_vars([Statement] stmts)
{
  //## BUG BUG WHY IS THIS FUNCTION NEVER CALLED?
  def_vs = {};
  ext_vs = {};
  for (s : stmts)
    ext_vs = ext_vs & (extern_vars(s) - def_vs);
    def_vs = def_vs & new_vars(s);
  ;
  return ext_vs;
}


Var* extern_vars(Statement s):
  assignment_stmt() = extern_vars(s.value),
  return_stmt       = {},
  return_stmt(e?)   = extern_vars(e),
  if_stmt()         = extern_vars(s.cond) & extern_vars(s.body) & extern_vars(s.else),
  loop_stmt(ss?)    = extern_vars(ss),
  foreach_stmt()    = extern_vars(s.values) & (extern_vars(s.body) - (set(s.vars) & {s.idx_var if s.idx_var?})),
  for_stmt()        = extern_vars(s.start_val) & extern_vars(s.end_val) & (extern_vars(s.body) - {s.var if s.var?}),
  break_stmt        = {},
  fail_stmt         = {},
  assert_stmt(e?)   = extern_vars(e),
  print_stmt(e?)    = extern_vars(e),
  imp_update_stmt() = {s.obj} & extern_vars(s.idx) & extern_vars(s.value),
  proc_call()       = seq_union([extern_vars(p) : p <- s.params]);


Var* extern_vars(ClsExpr expr):
  ClsVar      = {},
  fn_ptr()    = {},
  cls_expr()  = extern_vars(expr.expr) - set([v : v <- expr.params, v /= nil] & [fn_par(i) : i < length(expr.params)]);

////////////////////////////////////////////////////////////////////////////////

type StmtOutcome = fails, returns, breaks, falls_through;


StmtOutcome+ outcomes([Statement] stmts)
{
  outcomes = {:falls_through};
  for (s : stmts)
    outcomes = (outcomes - {:falls_through}) & outcomes(s);
    break if not in(:falls_through, outcomes);
  ;
  return nonempty(outcomes);
}


StmtOutcome+ outcomes(Statement stmt):
  assignment_stmt() = {:fails, :falls_through},
  return_stmt       = {:returns},
  return_stmt()     = {:fails, :returns},
  if_stmt()         = nonempty({:fails} & outcomes(stmt.body) & outcomes(stmt.else)), // Shutting up the type checker
  loop_stmt(body?)  = {
    outcomes = outcomes(body);
    // Failures and returns in the body are transferred to the loop.
    // Fall throughs in the body are neutralized by the loop, but they
    // create the possibility of an infinite loop, which counts as failure.
    outcomes = (outcomes - {:falls_through}) & {:fails} if in(:falls_through, outcomes);
    // A break in the body becomes a fall through for the loop itself
    outcomes = (outcomes - {:breaks}) & {:falls_through} if in(:breaks, outcomes);
    return nonempty(outcomes); // Shutting up the type checker
  },
  foreach_stmt()    = nonempty({:fails, :falls_through} & outcomes(stmt.body) - {:breaks}), // Shutting up the type checker
  for_stmt()        = nonempty({:fails, :falls_through} & outcomes(stmt.body) - {:breaks}), // Shutting up the type checker //## BAD: SAME AS ABOVE
  let_stmt()        = nonempty({:fails} & outcomes(stmt.body)), // Shutting up the type checker
  break_stmt        = {:breaks},
  fail_stmt         = {:fails},
  assert_stmt()     = {:falls_through, :fails},
  print_stmt()      = {:falls_through, :fails},
  imp_update_stmt() = {:falls_through, :fails},
  proc_call()       = {:falls_through, :fails};

////////////////////////////////////////////////////////////////////////////////

Bool may_fall_through(Statement stmt) = in(:falls_through, outcomes(stmt));

Bool may_fall_through([Statement] stmts) = in(:falls_through, outcomes(stmts));

////////////////////////////////////////////////////////////////////////////////

Bool arity_is_correct(BuiltIn name, NzNat arity) = arity == builtin_arity_map[name];

(BuiltIn => NzNat) builtin_arity_map = (
  neg:         1,
  add:         2,
  sub:         2,
  mult:        2,
  div:         2,
  mod:         2,
  lt:          2,
  le:          2,
  gt:          2,
  ge:          2,
  str:         1,
  symb:        1,
  at:          2,
  len:         1,
  slice:       3,
  cat:         2,
  mcat:        1,
  rev:         1,
  set:         1,
  mset:        1,
  isort:       1,
  list_to_seq: 1,
  tag:         1,
  obj:         1,
  in:          2,
  has_key:     2,
  lookup:      2,
  union:       1,
  merge:       1,
  fneg:        1,
  fadd:        2,
  fsub:        2,
  fmult:       2,
  fdiv:        2,
  fsqrt:       1,
  floor:       1,
  ceiling:     1,
  float:       1,
  mantissa:    1,
  dec_exp:     1,
  rand_nat:    1,
  rand_elem:   1,
  counter:     1,
  ticks:       1
);

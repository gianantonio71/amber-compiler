using
{
  Program             program,
  Artifact            artifact,
  CompilationOptions  options,
  Nat                 next_obj_var_id,
  Nat                 next_int_var_id,
  Nat                 next_bool_var_id,
  Nat                 next_set_it_var_id,
  Nat                 next_seq_it_var_id,
  Nat                 next_map_it_var_id,
  Nat                 next_vector_var_id,
  Nat                 next_stream_var_id;


  () gen_code((), EvalDestVar) = ();  //## BAD BAD: SHOULD BE A SUBSIGNATURE

  Instr+ gen_code(Statement+ stmts, EvalDestVar res_var)
  {
    code = ();
    for s <- stmts:
      code = code & gen_code(s, res_var);
    ;
    return nonempty(code);
  }


  Instr+ gen_code(Statement stmt, EvalDestVar res_var):
    break_stmt                = (break_loop),
    fail_stmt                 = (terminate),
    loop_stmt(ss?)            = (repeat(gen_code(ss, res_var))),
    print_stmt(e?)            = {info = gen_eval_info(e); return nonempty(info.eval_code & (print_obj(info.expr)));},
    return_stmt(e?)           = nonempty(gen_eval_code(e, res_var) & (exit_block)),
    assert_stmt()             = gen_code_for_assert_stmt(stmt.cond, stmt.env, stmt.file, stmt.line, stmt.text),
    let_stmt()                = gen_code_for_let_stmt(stmt.asgnms, stmt.body, res_var),
    assignment_stmt()         = gen_code_for_assignment_stmt(stmt.vars, stmt.value, res_var),
    imp_update_stmt()         = gen_code_for_imp_update_stmt(stmt.obj, stmt.idx, stmt.value, res_var),
    if_stmt()                 = gen_code_for_if_stmt(stmt.cond, stmt.body, stmt.else, res_var),
    for_stmt()                = gen_code_for_for_stmt(if stmt.var? then just(stmt.var) else nil, stmt.start_val, stmt.end_val, stmt.end_val_incl, stmt.body, res_var),
    foreach_stmt()            = gen_code_for_foreach_stmt(stmt.vars, if stmt.idx_var? then just(stmt.idx_var) else nil, stmt.values, stmt.body, res_var),
    return_stmt               = (exit_block),
    proc_call_stmt()          = gen_code_for_proc_call_stmt(if stmt.res_var? then just(stmt.res_var) else nil, stmt.proc_name, stmt.params),

    send_msg_stmt()           = gen_code_for_send_msg_stmt(stmt.target, stmt.msg),
    try_update_stmt()         = gen_code_for_try_update_stmt(stmt.name, stmt.args),
    set_memb_var_stmt()       = gen_code_for_set_memb_var_stmt(stmt.var, stmt.value),

    set_input_ctrl_stmt()     = gen_code_for_set_input_ctrl_stmt(stmt.var, stmt.input, stmt.value),
    clear_input_ctrl_stmt()   = gen_code_for_clear_input_ctrl_stmt(stmt.var, stmt.input),
    apply_ctrl_stmt()         = gen_code_for_apply_ctrl_stmt(stmt.var, if stmt.elapsed_time? then just(stmt.elapsed_time) else nil),
    send_msg_ctrl_stmt()      = gen_code_for_send_msg_ctrl_stmt(stmt.res_var, stmt.db_var, stmt.msg);


  Instr+ gen_code_for_send_msg_stmt(MembDBVar target, Expr msg)
  {
    eval_info = gen_eval_info(msg);
    return (eval_info.eval_code | send_msg(target, var_type(target), eval_info.expr, false));
  }


  Instr+ gen_code_for_try_update_stmt(UpdateSymbol name, Expr* args)
  {
    eval_info = gen_eval_info(args);
    call_instr = try_update(this_db_symbol, update_id(name, length(args)), eval_info.exprs);
    return (eval_info.eval_code | call_instr);
  }


  Instr+ gen_code_for_set_memb_var_stmt(PendingStateVar var, Expr value)
  {
    eval_info = gen_eval_info(value);
    return (eval_info.eval_code | set_var(var, eval_info.expr));
  }


  Instr+ gen_code_for_set_input_ctrl_stmt(LocAutoVar var, Atom input, Expr value)
  {
    auto_type = var_type(var);
    val_info = gen_eval_info(value);
    return nonempty(val_info.eval_code & (set_input(var, auto_type, input, val_info.expr)));
  }


  Instr+ gen_code_for_clear_input_ctrl_stmt(LocAutoVar var, Atom input)
  {
    auto_type = var_type(var);
    return (clear_input(var, auto_type, input));
  }


  Instr+ gen_code_for_apply_ctrl_stmt(LocAutoVar var, Maybe[Expr] maybe_elapsed_time)
  {
    type = var_type(var);
    if maybe_elapsed_time != nil:
      time_eval_info = gen_eval_info(value(maybe_elapsed_time));
      code = time_eval_info.eval_code;
      time = get_int_val(time_eval_info.expr);
    else
      code = ();
      time = 0;
    ;
    return (code | auto_apply(var, type, time));
  }


  Instr+ gen_code_for_send_msg_ctrl_stmt(StdVar res_var, LocDBVar db_var, Expr msg)
  {
    eval_info = gen_eval_info(msg);
    type = var_type(db_var);
    send_msg_instr = send_msg(db_var, type, eval_info.expr, true, res_var);
    return (eval_info.eval_code | send_msg_instr);
  }


  Instr+ gen_code_for_assert_stmt(Expr cond, [<StdVar, NamedArg>] env, String file, NzNat line, Maybe[String] text)
  {
    return (no_op) if options.ignore_assertions; //## WHY RETURNING (no_op) INSTEAD OF JUST []?
    info = gen_eval_info(cond);
    // vs = [v : v <- extern_vars(cond), v :: <StdVar, NamedArg>]; //## BUG BUG BUG: WHAT HAPPENS IF THE ASSERTION CONTAINS A NAMED ARGUMENT THAT IS ALSO A CLOSURE?
    expr_vars = extern_vars(cond);
    vars = rand_sort([v : v <- env, in(v, expr_vars)]) & rand_sort([v : v <- env, not in(v, expr_vars)]);
    return (info.eval_code | runtime_check(info.expr, file, line, text, vars));
  }


  Instr+ gen_code_for_let_stmt([NamedArg -> Expr] asgnms, Statement+ body, EvalDestVar res_var)
  {
    //## THIS SHOULD BE CHECKED IN THE PROPER PLACE, BOTH IN LAYER 1 AND 2
    //## IT'S A TEMPORARY LIMITATION THAT SHOULD BE REMOVED
    assert subset(outcomes(body), [:fails, :falls_through]);

    if asgnms != [:]:
      //## BUG BUG BUG. THE ASSIGNMENTS ARE DONE IN RANDOM ORDER. FIX THIS
      var = an_elem(nonempty(keys(asgnms)));
      expr = asgnms[var];
      rem_asgnms = [v -> e : e @ v <- asgnms, v != var];

      backup_var = lvar(next_obj_var_id);

      let next_obj_var_id = nat(next_obj_var_id + 1):
        info = gen_eval_info(expr);
        inner_body = gen_code_for_let_stmt(rem_asgnms, body, res_var, next_obj_var_id = info.next_var_id);
      ;

      set_up_code = (set_var(backup_var, var), set_var(var, info.expr));
      tear_down_code = (set_var(var, backup_var));

      return nonempty(info.eval_code & set_up_code & inner_body & tear_down_code);
    ;

    return gen_code(body, res_var);
  }


  Instr+ gen_code_for_assignment_stmt(StdVar+ vars, Expr value, EvalDestVar res_var)
  {
    if length(vars) == 1:
      var = vars[0];
      if in(var, extern_vars(value)):
        tmp_var = lvar(next_obj_var_id);
        code    = gen_eval_code(value, tmp_var, next_obj_var_id = nat(next_obj_var_id + 1)) & (set_var(var, tmp_var));
      else
        code = gen_eval_code(value, var);
      ;
    else
      tmp_var = lvar(next_obj_var_id);
      code = gen_eval_code(value, tmp_var, next_obj_var_id = nat(next_obj_var_id + 1));
      code = code & join(((set_var(v, at(tmp_var, i))) : v @ i <- vars));
    ;
    return nonempty(code);
  }


  Instr+ gen_code_for_imp_update_stmt(StdVar obj, Expr idx, Expr value, EvalDestVar res_var)
  {
    idx_var = lvar(next_obj_var_id);
    value_var = lvar(nat(next_obj_var_id + 1));

    idx_info = gen_eval_info(idx, idx_var, next_obj_var_id = nat(next_obj_var_id + 1));
    val_info = gen_eval_info(value, value_var, next_obj_var_id = nat(next_obj_var_id + 2));

    //## SINCE THE INDEX VARIABLE IS AN INTEGER, THERE'S NO NEED TO WORRY ABOUT
    //## ABOUT MEMORY ALLOCATION AND DEALLOCATION. BUT IF WE EXTEND THE CONSTRUCT
    //## TO MAPS AS WELL, THE CODE WILL HAVE TO BE CHANGED...
    return nonempty(
      idx_info.eval_code & val_info.eval_code &
      (set_at(obj, get_int_val(idx_info.expr), val_info.expr))
    );
  }


  Instr+ gen_code_for_if_stmt(Expr cond, Statement+ body, Statement* else, EvalDestVar res_var)
  {
    cond_info = gen_eval_info(cond);
    // The variable used to store the value of the condition is not
    // needed anymore here, so there's no need to update next_obj_var_id
    if_code   = gen_code(body, res_var);
    else_code = gen_code(else, res_var);
    branch_code = (branch(is_true(cond_info.expr), if_code, else_code));
    return nonempty(cond_info.eval_code & branch_code);
  }


  Instr+ gen_code_for_for_stmt(Maybe[StdVar] maybe_var, Expr start_val, Expr end_val, Bool end_val_incl, Statement+ body, EvalDestVar res_var)
  {
    tmp_var   = lvar(next_obj_var_id);
    start_var = ivar(next_int_var_id);
    end_var   = ivar(nat(next_int_var_id + 1));
    idx_var   = ivar(nat(next_int_var_id + 2));

    let next_obj_var_id = nat(next_obj_var_id + 1):
      start_eval_code = gen_eval_code(start_val, tmp_var);
      end_eval_code   = gen_eval_code(end_val, tmp_var);
      body_code       = gen_code(body, res_var, next_int_var_id = nat(next_int_var_id + 3));
    ;

    loop_code = (
      repeat(
        nonempty(
          ( break_if(if end_val_incl then is_gt(idx_var, end_var) else is_ge(idx_var, end_var)),
            set_var(value(maybe_var), to_obj(idx_var)) if maybe_var != nil
          ) & body_code &
          (increment(idx_var))
        )
      )
    );

    return nonempty(
      start_eval_code & (set_ivar(idx_var, get_int_val(tmp_var))) &
      end_eval_code   & (set_ivar(end_var, get_int_val(tmp_var))) &
      loop_code
    );
  }


  Instr+ gen_code_for_foreach_stmt(StdVar+ vars, Maybe[StdVar] maybe_idx_var, Expr values, Statement+ body, EvalDestVar res_var)
  {
    src_var = lvar(next_obj_var_id);
    tmp_var = lvar(nat(next_obj_var_id + 1)); // Only used for destructuring assignments, remains free for the body to use
    idx_var = ivar(next_int_var_id);
    it_var  = seq_it_var(next_seq_it_var_id);

    has_idx_var = maybe_idx_var != nil;

    src_eval_code = gen_eval_code(values, src_var, next_obj_var_id = nat(next_obj_var_id + 1));

    body_code = gen_code(
      body,
      res_var,
      next_obj_var_id    = nat(next_obj_var_id + 1),
      next_int_var_id    = nat(next_int_var_id + if has_idx_var then 1 else 0),
      next_seq_it_var_id = nat(next_seq_it_var_id + 1)
    );

    if length(vars) == 1:
      var_set_code = (set_var(vars[0], get_curr_obj(it_var)));
    else
      var_set_code = (set_var(tmp_var, get_curr_obj(it_var)));
      var_set_code = var_set_code & (set_var(v, at(tmp_var, i)) : v @ i <- vars);
    ;
    var_set_code = var_set_code & (set_var(value(maybe_idx_var), to_obj(idx_var))) if has_idx_var;

    loop_code = (
      get_iter(it_var, src_var),
      if has_idx_var then set_ivar(idx_var, 0) else no_op,
      repeat(
        nonempty(
          (break_if(is_out_of_range(it_var))) &
          var_set_code &
          body_code &
          ( move_forward(it_var),
            if has_idx_var then increment(idx_var) else no_op
          )
        )
      )
    );

    return nonempty(src_eval_code & loop_code);
  }


  Instr+ gen_code_for_proc_call_stmt(Maybe[StdVar] maybe_res_var, ProcSymbol proc_name, Expr* params)
  {
    pars_info = gen_eval_info(params);
    call_code = (call_proc(var: value(maybe_res_var) if maybe_res_var != nil, name: proc_name, params: pars_info.exprs));
    return nonempty(pars_info.eval_code & call_code);
  }
}

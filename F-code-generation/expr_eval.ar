
//  gen_eval_code(expr, var)
//    Generates code that evaluates <expr> and stores the result in <var>, reference counted

//  gen_eval_info(expr, var)
//    Generates code needed to evaluate expr, and to cleanup after it's not used anymore
//    If need be, the code stores the result in variable var, but it doesn't have to
//    It also generates an expression that is used to access the result
//    The expression may not be valid anymore if a variable used in the expression
//    is updated or goes out of scope

//  gen_eval_info(expr)
//    Like above, but automatically choses the name of the variable, if one is needed.
//    Also returns the id of the first free object variable.


using
{
  Nat next_obj_var_id,
  Nat next_int_var_id,
  Nat next_bool_var_id,
  Nat next_set_it_var_id,
  Nat next_seq_it_var_id,
  Nat next_map_it_var_id,
  Nat next_vector_var_id,
  Nat next_stream_var_id;


  [Instr^] gen_fn_body(Expr expr)
  {
    fn_res_var = lvar(next_obj_var_id);
    code = gen_eval_code(expr, fn_res_var, next_obj_var_id = nat(next_obj_var_id + 1));
    return nonempty(code & [ret_val(fn_res_var)]);
  }


  ( eval_code:         [Instr],
    cleanup_code:      [Instr],
    add_ref_eval_code: [Instr],
    expr:              AtomicExpr,
    var_used:          Bool
  )
  gen_eval_info(Expr expr, ObjVar var):
    LeafObj   = ( eval_code:         [],
                  cleanup_code:      [],
                  add_ref_eval_code: [],
                  expr:              expr,
                  var_used:          false
                ),

    Var       = ( eval_code:         [],
                  cleanup_code:      [],
                  add_ref_eval_code: [add_ref(expr)],
                  expr:              expr,
                  var_used:          false
                ),

    _         = { eval_code    = gen_eval_code(expr, var);

                  return (
                    eval_code:         eval_code,
                    cleanup_code:      [release(var)],
                    add_ref_eval_code: eval_code,
                    expr:              var,
                    var_used:          true
                  );
                };


  ( eval_code:         [Instr],
    cleanup_code:      [Instr],
    add_ref_eval_code: [Instr],
    expr:              AtomicExpr,
    var_used:          Bool,
    next_var_id:       Nat
  )
  gen_eval_info(Expr expr)
  {
    var    = lvar(next_obj_var_id);
    info   = gen_eval_info(expr, var, next_obj_var_id = nat(next_obj_var_id + 1)); //## BUG? BUG? BUG?
    // return info & (next_var_id: next_obj_var_id + if info.var_used then 1 else 0);
    //## BAD BAD BAD: SHOULD BE SOMETHING LIKE:
    //## return (info | next_var_id: next_obj_var_id + if info.var_used then 1 else 0)
    return (
      eval_code:          info.eval_code,
      cleanup_code:       info.cleanup_code,
      add_ref_eval_code:  info.add_ref_eval_code,
      expr:               info.expr,
      var_used:           info.var_used,
      next_var_id:        nat(next_obj_var_id + if info.var_used then 1 else 0)
    );
  }


  ( eval_code:         [Instr],
    cleanup_code:      [Instr],
    add_ref_eval_code: [Instr],
    exprs:             [AtomicExpr],
    next_var_id:       Nat
  )
  gen_eval_info([Expr] exprs)
  {
    eval_code         = [];
    cleanup_code      = [];
    add_ref_eval_code = [];
    res_exprs         = [];
    next_var_id       = next_obj_var_id;

    for (e : exprs)
      info = gen_eval_info(e, next_obj_var_id = next_var_id);
      eval_code         = eval_code & info.eval_code;
      cleanup_code      = info.cleanup_code & cleanup_code;
      add_ref_eval_code = add_ref_eval_code & info.add_ref_eval_code;
      res_exprs         = res_exprs & [info.expr];
      next_var_id       = info.next_var_id;
    ;

    return (
      eval_code:            eval_code,
      cleanup_code:         cleanup_code,
      add_ref_eval_code:    add_ref_eval_code,
      exprs:                res_exprs,
      next_var_id:          next_var_id
    );
  }


  //## THIS IS ALL WRONG (WHY?)
  (code: [Instr], vect_var: VecVar, count_var: IntVar)
  gen_vector_eval_info([SubExpr^] exprs)
  {
    elems_var = vvar(next_vector_var_id, nz_nat(length(exprs)));
    count_var = ivar(next_int_var_id);

    code = gen_vector_eval_code(
              exprs,
              elems_var,
              count_var,
              next_vector_var_id = nat(next_vector_var_id + 1),
              next_int_var_id    = nat(next_int_var_id + 1)
            );

    return (code: code, vect_var: elems_var, count_var: count_var);


    [Instr] gen_vector_eval_code([SubExpr] exprs, VecVar elems_var, IntVar count_var)
    {
      curr_slot_var = evar(elems_var.id, count_var);
      cond_var      = lvar(next_obj_var_id);

      code = [set_ivar(count_var, 0)];

      for (e : exprs)
        new_code = match (e)
          Expr      = gen_eval_code(e, curr_slot_var) & [increment(count_var)],
          CondExpr  = {
            cond_eval_info = gen_eval_info(e.cond, cond_var, next_obj_var_id = nat(next_obj_var_id + 1));

            // No need to change next_obj_var_id, as cond_var is not used anymore when running this code
            expr_eval_code = gen_eval_code(e.expr, curr_slot_var);

            return cond_eval_info.eval_code & [
              check(is_bool(cond_eval_info.expr)),
              do_if(is_true(cond_eval_info.expr), expr_eval_code & [increment(count_var)])
            ];
          };
        ;
        code = code & new_code;
      ;

      return code;
    }
  }


  [Instr^] gen_eval_code(Expr expr, ObjVar res_var):
    object()        = [set_var(res_var, expr)],
    float_lit()     = [mk_float(res_var, expr.mantissa, expr.dec_exp)],
    Var             = [set_var(res_var, expr), add_ref(res_var)],

    set_expr(es?)   = gen_eval_code_for_set_expr(es, res_var),
    seq_expr(es?)   = gen_eval_code_for_seq_expr(es, res_var),
    seq_tail_expr() = gen_eval_code_for_seq_tail_expr(expr.seq, expr.tail, res_var),
    tuple_expr(es?) = gen_eval_code_for_tuple_expr(es, res_var),
    map_expr(es?)   = gen_eval_code_for_map_expr(es, res_var),
    tag_obj_expr()  = gen_eval_code_for_tag_obj_expr(expr.tag, expr.obj, res_var),

    fn_call()       = gen_eval_code_for_fn_call_expr(expr.name, expr.params, expr.named_params, res_var),
    cls_call()      = gen_eval_code_for_cls_call(expr.name, expr.params, res_var),
    builtin_call()  = gen_eval_code_for_builtin_call(expr.name, expr.params, res_var),

    and_expr()      = gen_eval_code_for_and_expr(expr.left, expr.right, res_var),
    or_expr()       = gen_eval_code_for_or_expr(expr.left, expr.right, res_var),
    not_expr(e?)    = nonempty(gen_eval_code(e, res_var) & [set_var(res_var, obj_neg(res_var))]),

    eq()            = gen_eval_code_for_eq_expr(expr.left, expr.right, res_var),

    membership()    = gen_eval_code_for_membership_expr(expr.obj, expr.type, res_var),

    accessor()      = gen_eval_code_for_accessor_expr(expr.expr, expr.field, res_var),
    accessor_test() = gen_eval_code_for_accessor_test_expr(expr.expr, expr.field, res_var),

    if_expr()       = gen_eval_code_for_if_expr(expr.cond, expr.then, expr.else, res_var),
    match_expr()    = gen_eval_code_for_match_expr(expr.exprs, expr.cases, res_var),
    do_expr(ss?)    = [execute_block(gen_code(ss, res_var))],

    ex_qual()       = gen_eval_code_for_ex_qual_expr(expr.source, maybe_sel_expr(expr), res_var),
    set_comp()      = gen_eval_code_for_set_comp_expr(expr.expr, expr.source, maybe_sel_expr(expr), res_var),
    map_comp()      = gen_eval_code_for_map_comp_expr(expr.key_expr, expr.value_expr, expr.source, maybe_sel_expr(expr), res_var),

    seq_comp()      = gen_eval_code_for_seq_comp_expr(expr, res_var);


  Maybe[Expr] maybe_sel_expr(Expr expr) = if expr.sel_expr? then just(expr.sel_expr) else nil;



  [Instr^] gen_eval_code_for_set_expr(SubExpr* subexprs, ObjVar res_var)
  {
    return [set_var(res_var, empty_set)] if subexprs == {};
    non_cond_exprs = {e : e <- subexprs, e :: Expr};
    cond_exprs = subexprs - non_cond_exprs;
    sorted_subexprs = rand_sort(non_cond_exprs) & rand_sort(cond_exprs);
    info = gen_vector_eval_info(nonempty(sorted_subexprs));
    return nonempty(info.code & [mk_set(res_var, info.vect_var, info.count_var)]);
  }


  [Instr^] gen_eval_code_for_seq_expr([SubExpr] subexprs, ObjVar res_var)
  {
    return [set_var(res_var, empty_seq)] if subexprs == [];
    info = gen_vector_eval_info(subexprs);
    return nonempty(info.code & [mk_seq(res_var, info.vect_var, info.count_var)]);
  }


  [Instr^] gen_eval_code_for_seq_tail_expr(Expr seq, [Expr^] tail, ObjVar res_var)
  {
    code = gen_eval_code(seq, res_var);
    for (e : tail)
      info = gen_eval_info(e);
      code = code & info.add_ref_eval_code & [append_to_seq(res_var, res_var, info.expr)];
    ;
    return nonempty(code);
  }


  [Instr^] gen_eval_code_for_tuple_expr([Expr^] exprs, ObjVar res_var)
  {
    info = gen_vector_eval_info(exprs);
    return nonempty(info.code & [mk_seq(res_var, info.vect_var, info.count_var)]);
  }


  [Instr^] gen_eval_code_for_map_expr((key: Expr, value: Expr, cond: Expr?)* entries, ObjVar res_var)
  {
    return [set_var(res_var, empty_map)] if entries == {};

    cond_var   = lvar(next_obj_var_id);
    keys_var   = vvar(next_vector_var_id, nz_nat(size(entries)));
    values_var = vvar(nat(next_vector_var_id + 1), nz_nat(size(entries)));
    count_var  = ivar(next_int_var_id);

    curr_key_slot_var   = evar(keys_var.id, count_var);
    curr_value_slot_var = evar(values_var.id, count_var);

    code = [set_ivar(count_var, 0)];

    let (next_int_var_id = nat(next_int_var_id + 1), next_vector_var_id = nat(next_vector_var_id + 2))
      for (e : rand_sort(entries))
        key_code   = gen_eval_code(e.key, curr_key_slot_var);
        value_code = gen_eval_code(e.value, curr_value_slot_var);
        entry_code = key_code & value_code & [increment(count_var)];

        if (e.cond?)
          cond_info = gen_eval_info(e.cond, cond_var, next_obj_var_id = nat(next_obj_var_id + 1));

          entry_code = cond_info.eval_code &
                        [ check(is_bool(cond_info.expr)),
                          do_if(is_true(cond_info.expr), entry_code)
                        ];
        ;

        code = code & entry_code;
      ;
    ;

    return nonempty(code & [mk_map(res_var, keys_var, values_var, count_var)]);
  }


  [Instr^] gen_eval_code_for_tag_obj_expr(Expr tag_expr, Expr obj_expr, ObjVar res_var)
  {
    info = gen_eval_info([tag_expr, obj_expr]);
    return nonempty(info.add_ref_eval_code & [mk_tagged_obj(res_var, info.exprs[0], info.exprs[1])]);
  }


  [Instr^] gen_eval_code_for_fn_call_expr(FnSymbol name, [AnyExpr] params, (NamedPar => AnyExpr) named_params, ObjVar res_var)
  {
    if (named_params /= ())
      //## BUG BUG BUG. THE ASSIGNMENTS ARE DONE IN RANDOM ORDER. FIX THIS
      var = an_elem(nonempty(keys(named_params)));
      expr = named_params[var];
      rem_named_pars = (v => e : v => e <- named_params, v /= var);

      if (expr :: Expr)
        info = gen_eval_info(expr);
        body = gen_eval_code_for_fn_call_expr(name, params, rem_named_pars, res_var, next_obj_var_id=info.next_var_id);
        return nonempty(info.eval_code & [var_scope(var, info.expr, body)] & info.cleanup_code);
      else
        bound_cls = gen_non_scalar_par_code(cast_as_cls_expr(expr));
        body = gen_eval_code_for_fn_call_expr(name, params, rem_named_pars, res_var);
        return [cls_scope(var, bound_cls, body)];
      ;

    else
      pars_are_first_order = [is_expr(p) : p <- params];
      par_packed_idxs = packed_indexes(pars_are_first_order);
      pars_info = gen_eval_info([cast_as_expr(p) : p @ i <- params, pars_are_first_order[i]]);
      all_params = [
        if pars_are_first_order[i]
          then pars_info.exprs[value(par_packed_idxs[i])]
          else gen_non_scalar_par_code(cast_as_cls_expr(p))
      : p @ i <- params];
      core_call_code = [call_proc(res_var, name, all_params)];
      return nonempty(pars_info.eval_code & core_call_code & pars_info.cleanup_code);
    ;
  }


  [Instr^] gen_eval_code_for_cls_call(<ClsVar, NamedPar> name, [Expr] params, ObjVar res_var)
  {
    pars_info = gen_eval_info(params);
    call_code = [call_cls(res_var, name, pars_info.exprs)];
    return nonempty(pars_info.eval_code & call_code & pars_info.cleanup_code);
  }


  [Instr^] gen_eval_code_for_builtin_call(BuiltIn name, [Expr] params, ObjVar res_var)
  {
    pars_info = gen_eval_info(params);
    call_code = gen_call_code(name, pars_info.exprs, res_var);
    return nonempty(pars_info.eval_code & call_code & pars_info.cleanup_code);


    [Instr^] gen_call_code(BuiltIn name, [AtomicExpr] params, ObjVar res_var):
      obj         = [set_var(res_var, get_inner_obj(params[0])), add_ref(res_var)],
      has_key     = { bvar = bvar(next_bool_var_id);
                      return [lookup(bvar, res_var, params[0], params[1]), set_var(res_var, to_obj(bvar))];
                    },
      lookup      = [lookup(res_var, params[0], params[1]), add_ref(res_var)],
      at          = [set_var(res_var, at(params[0], get_int_val(params[1]))), add_ref(res_var)],
      rand_elem   = [set_var(res_var, rand_elem(params[0])), add_ref(res_var)],
      _           = [gen_eval_instr(name, params, res_var)];


    Instr gen_eval_instr(BuiltIn name, [AtomicExpr] ps, ObjVar res_var):
      slice         = get_seq_slice(res_var, ps[0], get_int_val(ps[1]), get_int_val(ps[2])),
      cat           = join_seqs(res_var, ps[0], ps[1]),
      mcat          = join_mult_seqs(res_var, ps[0]),
      rev           = rev_seq(res_var, ps[0]),
      set           = seq_to_set(res_var, ps[0]),
      // at            = get_at(res_var, ps[0], get_int_val(ps[1])),
      mset          = seq_to_mset(res_var, ps[0]),
      isort         = internal_sort(res_var, ps[0]),
      union         = merge_sets(res_var, ps[0]),
      merge         = merge_maps(res_var, ps[0]),
      list_to_seq   = list_to_seq(res_var, ps[0]),
      fneg          = neg_float(res_var, ps[0]),
      fadd          = add_floats(res_var, ps[0], ps[1]),
      fsub          = sub_floats(res_var, ps[0], ps[1]),
      fmult         = mult_floats(res_var, ps[0], ps[1]),
      fdiv          = div_floats(res_var, ps[0], ps[1]),
      fsqrt         = square_root(res_var, ps[0]),
      floor         = floor_op(res_var, ps[0]),
      ceiling       = ceiling_op(res_var, ps[0]),
      float         = int_to_float(res_var, ps[0]),
      _             = set_var(res_var, gen_eval_expr(name, ps));


    ObjExpr gen_eval_expr(BuiltIn name, [AtomicExpr] ps):
      str         = to_str(ps[0]),
      symb        = to_symb(ps[0]),
      neg         = to_obj(minus(get_int_val(ps[0]))),
      add         = to_obj(add(get_int_val(ps[0]), get_int_val(ps[1]))),
      sub         = to_obj(sub(get_int_val(ps[0]), get_int_val(ps[1]))),
      mult        = to_obj(mult(get_int_val(ps[0]), get_int_val(ps[1]))),
      div         = to_obj(div(get_int_val(ps[0]), get_int_val(ps[1]))),
      mod         = to_obj(mod_op(get_int_val(ps[0]), get_int_val(ps[1]))),
      lt          = to_obj(is_lt(get_int_val(ps[0]), get_int_val(ps[1]))),
      le          = to_obj(is_le(get_int_val(ps[0]), get_int_val(ps[1]))),
      gt          = to_obj(is_gt(get_int_val(ps[0]), get_int_val(ps[1]))),
      ge          = to_obj(is_ge(get_int_val(ps[0]), get_int_val(ps[1]))),
      len         = to_obj(get_seq_len(ps[0])),
      tag         = get_tag(ps[0]),
      in          = to_obj(has_elem(ps[1], ps[0])),
      mantissa    = to_obj(mantissa(ps[0])),
      dec_exp     = to_obj(dec_exp(ps[0])),
      rand_nat    = to_obj(rand_nat(ps[0])),
      counter     = to_obj(unique_nat),
      ticks       = to_obj(ticks);
  }


  [Instr^] gen_eval_code_for_and_expr(Expr left_expr, Expr right_expr, ObjVar res_var) =
    //## HERE WE CAN SLIGHTLY IMPROVE PERFORMANCE BY USING GEN_EVAL_INFO FOR THE FIRST EXPRESSION
    nonempty(
      gen_eval_code(left_expr, res_var) &
      [ check(is_bool(res_var)),
        do_if(
          is_true(res_var),
          gen_eval_code(right_expr, res_var) & [check_is_bool(res_var)]
        )
      ]
    );


  [Instr^] gen_eval_code_for_or_expr(Expr left_expr, Expr right_expr, ObjVar res_var) =
    //## HERE WE CAN SLIGHTLY IMPROVE PERFORMANCE BY USING GEN_EVAL_INFO FOR THE FIRST EXPRESSION
    nonempty(
      gen_eval_code(left_expr, res_var) &
      [ check(is_bool(res_var)),
        do_if(
          is_false(res_var),
          gen_eval_code(right_expr, res_var) & [check(is_bool(res_var))]
        )
      ]
    );


  [Instr^] gen_eval_code_for_eq_expr(Expr left_expr, Expr right_expr, ObjVar res_var)
  {
    info = gen_eval_info([left_expr, right_expr]);
    return nonempty(
      info.eval_code &
      [set_var(res_var, to_obj(is_eq(info.exprs[0], info.exprs[1])))] &
      info.cleanup_code
    );
  }


  [Instr^] gen_eval_code_for_membership_expr(Expr expr, Type type, ObjVar res_var)
  {
    //bool_var_id = next_bool_var_id;
    bool_var = bvar(next_bool_var_id);
    info = gen_eval_info(expr);
    code = gen_type_checking_code(
      type,
      info.expr,
      bool_var,
      next_obj_var_id  = info.next_var_id,
      next_bool_var_id = nat(next_bool_var_id + 1)
    );
    return nonempty(info.eval_code & code & [set_var(res_var, to_obj(bool_var))] & info.cleanup_code);
  }


  [Instr^] gen_eval_code_for_accessor_expr(Expr expr, SymbObj field, ObjVar res_var)
  {
    info = gen_eval_info(expr);
    code = [ext_lookup(res_var, info.expr, field), add_ref(res_var)];
    return nonempty(info.eval_code & code & info.cleanup_code);
  }


  [Instr^] gen_eval_code_for_accessor_test_expr(Expr expr, SymbObj field, ObjVar res_var)
  {
    info = gen_eval_info(expr);
    bvar = bvar(next_bool_var_id);
    // Here I use res_var to store a temporary value
    // that has nothing to do with the actual result
    code = [ext_lookup(bvar, res_var, info.expr, field), set_var(res_var, to_obj(bvar))];
    return nonempty(info.eval_code & code & info.cleanup_code);
  }


  [Instr^] gen_eval_code_for_if_expr(Expr cond, Expr then_expr, Expr else_expr, ObjVar res_var)
  {
    info = gen_eval_info(cond);
    code = [
      check(is_bool(info.expr)),
      branch(
        is_true(info.expr),
        gen_eval_code(then_expr, res_var),
        gen_eval_code(else_expr, res_var)
      )
    ];
    return nonempty(info.eval_code & code); // No need to cleanup the condition object
  }


  [Instr^] gen_eval_code_for_match_expr([Expr^] exprs, [(ptrns: [Pattern^], expr: Expr)^] cases, ObjVar res_var)
  {
    info = gen_eval_info(exprs);

    code = [terminate];
    for (c : reverse(cases))
      let (next_obj_var_id = info.next_var_id)
        case_code = gen_eval_code(c.expr, res_var) & [exit_block];
        for (p @ i : reverse(c.ptrns))
          case_code = gen_ptrn_matching_code(p, rev_at(info.exprs, i), {}, case_code);
        ;
      ;
      code = case_code & code;
    ;
    code = [execute_block(nonempty(code))];

    return nonempty(info.eval_code & code & info.cleanup_code);
  }


  [Instr^] gen_eval_code_for_ex_qual_expr(Clause source, Maybe[Expr] maybe_sel_expr, ObjVar res_var)
  {
    action = set_found_var_and_leave(res_var);
    action = action(value(maybe_sel_expr), action) if maybe_sel_expr /= nil;
    code = gen_iter_code(source, {}, action);
    return [set_var(res_var, obj_false), execute_block(code)];
  }


  [Instr^] gen_eval_code_for_set_comp_expr(Expr expr, Clause source, Maybe[Expr] maybe_sel_expr, ObjVar res_var)
  {
    strm_var = svar(next_stream_var_id);
    action = eval_expr_and_add_to_set(expr, strm_var);
    action = action(value(maybe_sel_expr), action) if maybe_sel_expr /= nil;
    code = gen_iter_code(source, {}, action, next_stream_var_id = nat(next_stream_var_id + 1));
    return nonempty([init_stream(strm_var)] & code & [mk_set_from_stream(res_var, strm_var)]);
  }


  [Instr^] gen_eval_code_for_map_comp_expr(Expr key_expr, Expr value_expr, Clause source, Maybe[Expr] maybe_sel_expr, ObjVar res_var)
  {
    key_strm_var   = svar(next_stream_var_id);
    value_strm_var = svar(nat(next_stream_var_id + 1));

    action = eval_exprs_and_add_to_map(key_expr, value_expr, key_strm_var, value_strm_var);
    action = action(value(maybe_sel_expr), action) if maybe_sel_expr /= nil;

    code = gen_iter_code(source, {}, action, next_stream_var_id = nat(next_stream_var_id + 2));

    return nonempty(
      [init_stream(key_strm_var), init_stream(value_strm_var)] & code &
      [mk_map_from_streams(res_var, key_strm_var, value_strm_var)]
    );
  }


  [Instr^] gen_eval_code_for_seq_comp_expr(<seq_comp(expr: Expr, vars: [Var^], idx_var: Var?, src_expr: Expr, src_expr_type: <sequence, upper_bound(included: Bool)>, sel_expr: Expr?)> expr, ObjVar res_var)
  {
    src_var   = lvar(next_obj_var_id);
    item_var  = lvar(nat(next_obj_var_id + 1));
    sel_var   = lvar(nat(next_obj_var_id + 2));
    tmp_var   = lvar(nat(next_obj_var_id + 3)); // This is only needed during a destructuring assignment, it can be safely reused elsewhere
    it_var    = seq_it_var(next_seq_it_var_id);
    strm_var  = svar(next_stream_var_id);
    idx_var   = ivar(next_int_var_id);      //## BAD USED EVEN WHEN NOT REQUIRED
    bound_var = ivar(nat(next_int_var_id + 1));  //## BAD USED EVEN WHEN NOT REQUIRED

    let ( next_obj_var_id    = nat(next_obj_var_id    + 3),
          next_seq_it_var_id = nat(next_seq_it_var_id + 1),
          next_stream_var_id = nat(next_stream_var_id + 1),
          next_int_var_id    = nat(next_int_var_id    + 2))

      src_info  = gen_eval_info(expr.src_expr, src_var);
      item_info = gen_eval_info(expr.expr, item_var);
      maybe_sel_info  = if expr.sel_expr? then just(gen_eval_info(expr.sel_expr, sel_var)) else nil; //## BUG BUG BUG
    ;

    knows_size = not expr.sel_expr?;

    eval_and_assign_code = item_info.add_ref_eval_code &
                            if knows_size
                              then [set_at(res_var, idx_var, item_info.expr)]
                              else [append(strm_var, item_info.expr)];

    core_loop_code = eval_and_assign_code;
    if (maybe_sel_info /= nil)
      sel_info = value(maybe_sel_info);
      core_loop_code = sel_info.eval_code & [
        check(is_bool(sel_info.expr)),
        do_if(is_true(sel_info.expr), core_loop_code)
      ];
    ;

    src_expr_type = expr.src_expr_type;
    if (src_expr_type == :sequence)
      needs_idx_var = not expr.sel_expr? or expr.idx_var?;

      if (length(expr.vars) == 1)
        var_set_code = [set_var(expr.vars[0], get_curr_obj(it_var))];
      else
        var_set_code = [set_var(tmp_var, get_curr_obj(it_var))];
        var_set_code = var_set_code & [set_var(v, at(tmp_var, i)) : v @ i <- expr.vars];
      ;
      var_set_code = var_set_code & [set_var(expr.idx_var, to_obj(idx_var))] if expr.idx_var?;

      loop_code = [
        if knows_size
          then mk_array(res_var, get_seq_len(src_info.expr), obj_nil)
          else init_stream(strm_var),
        get_iter(it_var, src_info.expr),
        maybe_op(set_ivar(idx_var, 0), needs_idx_var),
        repeat(
          nonempty(
            [break_if(is_out_of_range(it_var))] &
            var_set_code &
            core_loop_code &
            [move_forward(it_var), maybe_op(increment(idx_var), needs_idx_var)]
          )
        ),
        maybe_op(mk_seq_from_stream(res_var, strm_var), not knows_size)
      ];
    else
      assert length(expr.vars) == 1 and not expr.idx_var?;
      var = expr.vars[0];
      bound_included = src_expr_type.included;
      iter_count = get_int_val(src_info.expr);
      iter_count = add(iter_count, 1) if bound_included;
      loop_code = [
        if knows_size then mk_array(res_var, iter_count, obj_nil) else init_stream(strm_var),
        set_ivar(bound_var, get_int_val(src_info.expr)),
        set_ivar(idx_var, 0),
        repeat(
          nonempty(
            [ break_if(if bound_included then is_gt(idx_var, bound_var) else is_ge(idx_var, bound_var)),
              set_var(expr.vars[0], to_obj(idx_var))
            ] &
            core_loop_code &
            [increment(idx_var)]
          )
        ),
        maybe_op(mk_seq_from_stream(res_var, strm_var), not knows_size)
      ];
    ;

    return nonempty(src_info.eval_code & loop_code & src_info.cleanup_code);
  }


  BoundCls gen_non_scalar_par_code(ClsExpr expr):
    ClsVar      = expr,
    fn_ptr()    = {
      var = lvar(0);
      ps = [fn_par(i) : i < expr.arity];
      body = [call_proc(var, expr.name, ps), ret_val(var)];
      cls = cls_def(expr.arity, body);
      return bound_cls(cls, []);
    },
    cls_expr()  = {
      //###################################################################################
      //## BUG BUG BUG: WHAT HAPPENS HERE IF THE CLOSURE ITSELF USES A CLOSURE VARIABLE? ##
      //###################################################################################
      loc_vs = seq_union([{v if v /= nil, fn_par(i)} : v @ i <- expr.params]);
      ext_vs = rand_sort(extern_vars(expr.expr) - loc_vs);
      cls_body = [set_var(v, fn_par(i)) : v @ i <- expr.params, v /= nil] &
                 [set_var(v, cls_ext_par(i)) : v @ i <- ext_vs] &
                 gen_fn_body(expr.expr);
      return bound_cls(cls_def(nz_nat(length(expr.params)), nonempty(cls_body)), ext_vs);
    };


  <[]> gen_code(<[]>, ObjVar) = []; //## BAD BAD: SHOULD BE A SUBSIGNATURE

  [Instr^] gen_code([Statement^] stmts, ObjVar res_var) = gen_code(stmts, res_var, {}, {}, {});


  // all_rel_vars:  Vars that have been defined in an upper scope and that have to
  //                be released before assigning them or issuing a return statement
  //
  // break_vars:    Vars that have been defined in an upper scope and that have to be
  //                released before issuing a break statement. It is a subset of all_rel_vars
  //
  // surv_vars:     Vars that are defined in the current scope, but that survive to it.
  //                Disjoint from both all_rel_vars and break_vars

  <[]> gen_code(<[]>, ObjVar, ObjVar*, ObjVar*, ObjVar*) = [];  //## BAD BAD: SHOULD BE A SUBSIGNATURE

  [Instr^] gen_code([Statement^] stmts, ObjVar res_var, ObjVar* all_rel_vars, ObjVar* break_vars, ObjVar* surv_vars)
  {
    assert subset(break_vars, all_rel_vars);
    assert not in(res_var, all_rel_vars); //## THINK ABOUT THIS ONE
    assert disjoint(all_rel_vars, surv_vars);

    vs   = {};
    code = [];
    for (s : stmts)
      code = code & gen_code(s, res_var, all_rel_vars & vs, break_vars & vs);
      vs   = vs & (new_vars(s) - all_rel_vars); //## BUG? BUG? BUG?
    ;

    if (may_fall_through(stmts))
      code = code & [release(v) : v <- rand_sort(vs - surv_vars)];
    //## Try to reenable it if there are memory leaks
    //## else
    //##   code = code & [terminate];
    ;

    return nonempty(code);
  }

  // all_rel_vars:  Vars that are in scope and that were defined in the current procedural expression.
  //                They have to be released before a return statement, or before being reassigned.
  //
  // break_vars:    Vars that have to be released before a break statement. It's a subset of all_rel_vars

  [Instr^] gen_code(Statement stmt, ObjVar res_var, ObjVar* all_rel_vars, ObjVar* break_vars):
    break_stmt        = nonempty([release(v) : v <- rand_sort(break_vars)] & [break_loop]),
    fail_stmt         = [terminate],
    loop_stmt(ss?)    = [repeat(gen_code(ss, res_var, all_rel_vars, {}, {}))],
    assert_stmt(e?)   = {info = gen_eval_info(e); return nonempty(info.eval_code & [runtime_check(info.expr)]);},
    // assert_stmt(e?) = [no_op],
    print_stmt(e?)    = {info = gen_eval_info(e); return nonempty(info.eval_code & [print_obj(info.expr)] & info.cleanup_code);},
    return_stmt       = nonempty([release(v) : v <- rand_sort(all_rel_vars)] & [exit_block]),
    return_stmt(e?)   = gen_code_for_ret_stmt(e, res_var, all_rel_vars, break_vars),
    let_stmt()        = gen_code_for_let_stmt(stmt.asgnms, stmt.body, res_var, all_rel_vars, break_vars),
    assignment_stmt() = gen_code_for_assignment_stmt(stmt.vars, stmt.value, res_var, all_rel_vars, break_vars),
    imp_update_stmt() = gen_code_for_imp_update_stmt(stmt.obj, stmt.idx, stmt.value, res_var, all_rel_vars, break_vars),
    if_stmt()         = gen_code_for_if_stmt(stmt.cond, stmt.body, stmt.else, res_var, all_rel_vars, break_vars),
    for_stmt()        = gen_code_for_for_stmt(if stmt.var? then just(stmt.var) else nil, stmt.start_val, stmt.end_val, stmt.end_val_incl, stmt.body, res_var, all_rel_vars, break_vars),
    foreach_stmt()    = gen_code_for_foreach_stmt(stmt.vars, if stmt.idx_var? then just(stmt.idx_var) else nil, stmt.values, stmt.body, res_var, all_rel_vars, break_vars),
    proc_call()       = gen_code_for_proc_call_stmt(if stmt.res_var? then just(stmt.res_var) else nil, stmt.proc_name, stmt.params, res_var, all_rel_vars, break_vars);



  [Instr^] gen_code_for_ret_stmt(Expr expr, ObjVar res_var, ObjVar* all_rel_vars, ObjVar* break_vars)
  {
    assert not in(res_var, all_rel_vars);
    return nonempty(gen_eval_code(expr, res_var) & [release(v) : v <- rand_sort(all_rel_vars)] & [exit_block]);
  }


  [Instr^] gen_code_for_let_stmt((NamedPar => Expr) asgnms, [Statement^] body, ObjVar res_var, ObjVar* all_rel_vars, ObjVar* break_vars)
  {
    //## THIS SHOULD BE CHECKED IN THE PROPER PLACE, BOTH IN LAYER 1 AND 2
    //## IT'S A TEMPORARY LIMITATION THAT SHOULD BE REMOVED
    assert subset(outcomes(body), {:fails, :falls_through});

    if (asgnms /= ())
      //## BUG BUG BUG. THE ASSIGNMENTS ARE DONE IN RANDOM ORDER. FIX THIS
      var = an_elem(nonempty(keys(asgnms)));
      expr = asgnms[var];
      rem_asgnms = (v => e : v => e <- asgnms, v /= var);

      info = gen_eval_info(expr);
      inner_body = gen_code_for_let_stmt(rem_asgnms, body, res_var, all_rel_vars, break_vars, next_obj_var_id = info.next_var_id);
      return nonempty(info.eval_code & [var_scope(var, info.expr, inner_body)] & info.cleanup_code);
    ;

    surv_vars = new_vars(body) - all_rel_vars;
    return gen_code(body, res_var, all_rel_vars, break_vars, surv_vars);
  }


  [Instr^] gen_code_for_assignment_stmt([Var^] vars, Expr value, ObjVar res_var, ObjVar* all_rel_vars, ObjVar* break_vars)
  {
    if (length(vars) == 1)
      var = vars[0];
      if (in(var, all_rel_vars))
        if (in(var, extern_vars(value)))
          tmp_var = lvar(next_obj_var_id);
          code    = gen_eval_code(value, tmp_var, next_obj_var_id = nat(next_obj_var_id + 1)) &
                     [release(var), set_var(var, tmp_var)];
        else
          code = [release(var)] & gen_eval_code(value, var);
        ;
      else
        code = gen_eval_code(value, var);
      ;
    else
      tmp_var = lvar(next_obj_var_id);
      code = gen_eval_code(value, tmp_var, next_obj_var_id = nat(next_obj_var_id + 1));
      //## THIS CHECK MIGHT BE REDUNDANT WITH STATIC TYPE CHECKING
      code = code & [check(and_then(is_ne_seq(tmp_var), is_eq(get_seq_len(tmp_var), length(vars))))];
      code = code & [release(v) : v <- vars, in(v, all_rel_vars)];
      code = code & join([[set_var(v, at(tmp_var, i)), add_ref(v)] : v @ i <- vars]);
      code = code & [release(tmp_var)]; //## BAD: HERE FIRST I DO AN ADD REF AND THEN A RELEASE FOR EACH ELEMENT OF THE TUPLE
    ;
    return nonempty(code);
  }


  [Instr^] gen_code_for_imp_update_stmt(Var obj, Expr idx, Expr value, ObjVar res_var, ObjVar* all_rel_vars, ObjVar* break_vars)
  {
    idx_var = lvar(next_obj_var_id);
    value_var = lvar(nat(next_obj_var_id + 1));

    idx_info = gen_eval_info(idx, idx_var, next_obj_var_id = nat(next_obj_var_id + 1));
    val_info = gen_eval_info(value, value_var, next_obj_var_id = nat(next_obj_var_id + 2));

    //## SINCE THE INDEX VARIABLE IS AN INTEGER, THERE'S NO NEED TO WORRY ABOUT
    //## ABOUT MEMORY ALLOCATION AND DEALLOCATION. BUT WE EXTEND THE CONSTRUCT
    //## TO MAPS AS WELL, THE CODE WILL HAVE TO BE CHANGED...
    return nonempty(
      idx_info.eval_code & val_info.add_ref_eval_code &
      [set_at(obj, get_int_val(idx_info.expr), val_info.expr)]
    );
  }


  [Instr^] gen_code_for_if_stmt(Expr cond, [Statement^] body, [Statement] else, ObjVar res_var, ObjVar* all_rel_vars, ObjVar* break_vars)
  {
    cond_info = gen_eval_info(cond);

    surv_vars = new_vars(if_stmt(cond, body, else)) - all_rel_vars; //## BAD BAD BAD: RECONSTRUCTING THE IF STATEMENT...

    // The variable used to store the value of the condition is not
    // needed anymore here, so there's no need to update next_obj_var_id
    if_code   = gen_code(body, res_var, all_rel_vars, break_vars, surv_vars);
    else_code = gen_code(else, res_var, all_rel_vars, break_vars, surv_vars);

    branch_code = [ check(is_bool(cond_info.expr)),
                    branch(is_true(cond_info.expr), if_code, else_code)
                  ];

    return nonempty(cond_info.eval_code & branch_code);
  }


  [Instr^] gen_code_for_for_stmt(Maybe[Var] maybe_var, Expr start_val, Expr end_val, Bool end_val_incl, [Statement^] body, ObjVar res_var, ObjVar* all_rel_vars, ObjVar* break_vars)
  {
    tmp_var   = lvar(next_obj_var_id);
    start_var = ivar(next_int_var_id);
    end_var   = ivar(nat(next_int_var_id + 1));
    idx_var   = ivar(nat(next_int_var_id + 2));

    let (next_obj_var_id = nat(next_obj_var_id + 1))
      start_eval_code = gen_eval_code(start_val, tmp_var);
      end_eval_code   = gen_eval_code(end_val, tmp_var);
      body_code       = gen_code(body, res_var, all_rel_vars, {}, {}, next_int_var_id = nat(next_int_var_id + 3));
    ;

    loop_code = [
      repeat(
        nonempty(
          [ break_if(if end_val_incl then is_gt(idx_var, end_var) else is_ge(idx_var, end_var)),
            set_var(value(maybe_var), to_obj(idx_var)) if maybe_var /= nil
          ] & body_code &
          [increment(idx_var)]
        )
      )
    ];

    return nonempty(
      start_eval_code & [set_ivar(idx_var, get_int_val(tmp_var))] &
      end_eval_code   & [set_ivar(end_var, get_int_val(tmp_var))] &
      loop_code
    );
  }


  [Instr^] gen_code_for_foreach_stmt([Var^] vars, Maybe[Var] maybe_idx_var, Expr values, [Statement^] body, ObjVar res_var, ObjVar* all_rel_vars, ObjVar* break_vars)
  {
    src_var = lvar(next_obj_var_id);
    tmp_var = lvar(nat(next_obj_var_id + 1)); // Only used for destructuring assignments, remains free for the body to use
    idx_var = ivar(next_int_var_id);
    it_var  = seq_it_var(next_seq_it_var_id);

    has_idx_var = maybe_idx_var /= nil;

    src_info = gen_eval_info(values, src_var, next_obj_var_id = nat(next_obj_var_id + 1));

    body_code = gen_code(
      body,
      res_var,
      all_rel_vars & {src_var if src_info.var_used},
      {},
      {},
      next_obj_var_id    = nat(next_obj_var_id + if src_info.var_used then 1 else 0),
      next_int_var_id    = nat(next_int_var_id + if has_idx_var then 1 else 0),
      next_seq_it_var_id = nat(next_seq_it_var_id + 1)
    );

    if (length(vars) == 1)
      var_set_code = [set_var(vars[0], get_curr_obj(it_var))];
    else
      var_set_code = [set_var(tmp_var, get_curr_obj(it_var))];
      var_set_code = var_set_code & [set_var(v, at(tmp_var, i)) : v @ i <- vars];
    ;
    var_set_code = var_set_code & [set_var(value(maybe_idx_var), to_obj(idx_var))] if has_idx_var;

    loop_code = [
      get_iter(it_var, src_info.expr),
      if has_idx_var then set_ivar(idx_var, 0) else no_op,
      repeat(
        nonempty(
          [break_if(is_out_of_range(it_var))] &
          var_set_code &
          body_code &
          [ move_forward(it_var),
            if has_idx_var then increment(idx_var) else no_op
          ]
        )
      )
    ];

    return nonempty(src_info.eval_code & loop_code & src_info.cleanup_code);
  }


  [Instr^] gen_code_for_proc_call_stmt(Maybe[Var] maybe_res_var, ProcSymbol proc_name, [Expr] params, ObjVar res_var, ObjVar* all_rel_vars, ObjVar* break_vars)
  {
    pars_info = gen_eval_info(params);
    call_code = [call_proc(var: value(maybe_res_var) if maybe_res_var /= nil, name: proc_name, params: pars_info.exprs)];
    return nonempty(pars_info.eval_code & call_code & pars_info.cleanup_code);
  }
}

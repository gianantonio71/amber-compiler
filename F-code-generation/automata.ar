Block gen_auto_code(Automaton automaton, CompilationOptions options)
{
  nodes = gen_auto_nodes(automaton);
  fail if nodes == []; //## BUG BUG BUG

  nodes_idxs = merge([(n.id => i) : n @ i <- nodes]);
  nodes_levels = merge([(n.id => n.level) : n <- nodes]);
  nodes_deps = merge([(n.id => dep_nodes_ids(n)) : n <- nodes]);

  levels_sizes = count_vector([n.level : n <- nodes]);
  fail if not levels_sizes :: [NzNat]; //## UGLY UGLY UGLY
  levels_offsets = [0] & partial_sums(levels_sizes);

  param_ids = keys(automaton.params);
  input_ids = keys(automaton.inputs);
  state_var_ids = keys(automaton.state);
  disc_sgns_ids = discrete_signals(automaton);
  rule_ids = keys(automaton.rules);
  time_rule_ids = keys(automaton.time_rules);
  cond_nodes = {t : t <- set(nodes), cond_node() << t}; //## BIT UGLY.
  cond_ids = {c.id : c <- cond_nodes};
  rep_cond_nodes = {t : t <- set(nodes), rep_cond_node() << t};
  rep_cond_ids = {c.id : c <- rep_cond_nodes};
  nested_cond_ids = {c.id : c <- cond_nodes, c.parent != nil};
  disc_inputs_ids = intersection(input_ids, disc_sgns_ids);

  continuous_derived_nodes_ids = (rule_ids & time_rule_ids) - disc_sgns_ids;

  obj_memb_var_ids = param_ids & input_ids & state_var_ids & disc_sgns_ids & rule_ids & time_rule_ids;
  std_memb_vars = {memb_var(id) : id <- obj_memb_var_ids};
  new_input_vars = {new_input(a) : a <- input_ids};
  method_args = {right(a) : m <- automaton.methods, a <- set(m.args)};

  memb_obj_vars       = std_memb_vars & new_input_vars & method_args;

  memb_int_vars       = {update_source_var(a) : a <- state_var_ids & disc_sgns_ids} &
                        set([update_count_var(l) : s @ l <- levels_sizes, s > 2]) &
                        {next_trigger_time_var(id) : id <- time_rule_ids} &
                        {curr_time_slot_var(id) : id <- time_rule_ids};
  // Not adding the arrays used to store the trigger heaps
  // That is done in the target language code generation phase
  memb_int_vars = memb_int_vars & {time_triggers_count_var, last_update_time} if automaton.time_rules != ();

  memb_int_vect_vars  = set([nodes_to_update_vect_var(l, nz_nat(s)) : s @ l <- levels_sizes, s > 2]);

  memb_bool_vars      = {cond_value_var(n) : n <- cond_ids} &
                        {cond_is_def_var(n) : n <- cond_ids} &
                        {cond_expr_value_var(n) : n <- nested_cond_ids & time_rule_ids} &
                        {cond_expr_is_def_var(n) : n <- nested_cond_ids & time_rule_ids} &
                        {cond_expr_up_to_date_var(n) : n <- nested_cond_ids & time_rule_ids} &
                        {marked_for_update_var(id) : id <- obj_memb_var_ids & cond_ids & rep_cond_ids} &
                        {is_new};

  const_data = {time_slots_len(a, ls) : c @ a <- automaton.time_rules, ls = trigger_times_table(c.time_expr), ls != []};

  // Generating code for initialization, update and methods
  let ( automaton                 = automaton,
        options                   = options,

        memb_vars_and_method_args = std_memb_vars & method_args,
        disc_sgns_ids             = disc_sgns_ids,

        cont_inputs_ids           = input_ids - disc_sgns_ids,
        disc_inputs_ids           = intersection(input_ids, disc_sgns_ids),
        state_vars_ids            = state_var_ids,
        cont_derived_vars_ids     = continuous_derived_nodes_ids,
        disc_derived_vars_ids     = disc_sgns_ids - disc_inputs_ids,

        nodes_by_id               = merge(set([(n.id => n) : n <- nodes])),
        nodes_ids_by_level        = [set(l) : l <- nodes_ids_by_level(nodes)],

        time_varying_node_idxs    = merge([(a => i) : a @ i <- rand_sort(time_rule_ids)]),

        nodes_idxs                = nodes_idxs,
        nodes_levels              = nodes_levels,
        levels_offsets            = levels_offsets,
        levels_sizes              = levels_sizes)

    init_code     = gen_init_method_body(memb_bool_vars, memb_int_vars, (id => sv.init_value : sv @ id <- automaton.state));
    update_code   = gen_update_method_body(nodes, nested_cond_ids, nodes_deps);
    methods_code  = ((m.name, length(m.args)) => gen_method_code(m) : m <- automaton.methods);
  ;

  // Generating cleanup code
  memb_vars_to_rel = param_ids & input_ids & state_var_ids & disc_sgns_ids & rule_ids & time_rule_ids;
  vars_to_rel = {memb_var(id) : id <- memb_vars_to_rel} & {new_input(id) : id <- input_ids};
  cleanup_code = join([[release(v), init_memb_var(v, :blank)] : v <- rand_sort(vars_to_rel)]);

  // Generating methods for queuing updates
  node_ids = [n.id : n <- nodes];
  let (nodes_idxs = nodes_idxs, nodes_levels = nodes_levels, levels_sizes = levels_sizes,
       nested_cond_ids = nested_cond_ids, time_rules_ids = time_rule_ids, next_int_var_id = 0)
    queue_update_code = (
        id => (
          body:             queue_update_method_body(id),
          two_level_update: in(id, nested_cond_ids) or in(id, time_rule_ids)
        )
      : id <- set(node_ids)
    );
  ;

  assert {
    inputs_count = size(automaton.inputs);
    for (n @ i : nodes)
      is_input = match (n)
        input()  = true,
        _        = false;
      if (i < inputs_count)
        return false if n.level != 0 or not is_input;
      else
        return false if n.level == 0 or is_input;
      ;
    ;
    return true;
  };
  sorted_input_ids = subseq(node_ids, 0, size(automaton.inputs));
  fail if not sorted_input_ids :: [Atom]; //## BAD: RUNTIME TYPE CHECKING SHOULD NOT BE NEEDED HERE


  return block(
    name:               automaton.name,
    inputs:             sorted_input_ids,
    outputs:            keys(automaton.outputs),
    memb_vars:          memb_obj_vars & memb_int_vars & memb_int_vect_vars & memb_bool_vars,
    init_code:          init_code,
    update_code:        update_code,
    cleanup_code:       cleanup_code,
    queue_update_code:  queue_update_code,
    methods_code:       methods_code,
    const_data:         const_data,
    time_rules_count:   size(automaton.time_rules)
  );


  [[<Atom, Nat>^]] nodes_ids_by_level([AutoNode] nodes)
  {
    curr_level = 0;
    curr_level_ids = [];
    node_ids_by_level = [];
    for (n @ i : nodes)
      if (n.level != curr_level)
        assert n.level == curr_level + 1;
        node_ids_by_level = [node_ids_by_level | nonempty(curr_level_ids)];
        curr_level = curr_level + 1;
        curr_level_ids = [];
      ;
      curr_level_ids = [curr_level_ids | n.id];
    ;
    node_ids_by_level = [node_ids_by_level | nonempty(curr_level_ids)] if nodes != [];
    return node_ids_by_level;
  }
}

////////////////////////////////////////////////////////////////////////////////

using
{
  Automaton                   automaton,
  CompilationOptions          options,


  <MembVar, MethodArg>*       memb_vars_and_method_args,
  Atom*                       disc_sgns_ids,

  Atom*                       cont_inputs_ids,
  Atom*                       disc_inputs_ids,
  Atom*                       state_vars_ids,
  Atom*                       cont_derived_vars_ids,
  Atom*                       disc_derived_vars_ids,

  (<Atom, Nat> => AutoNode)   nodes_by_id,
  [<Atom, Nat>+]              nodes_ids_by_level,

  (Atom => Nat)               time_varying_node_idxs,

  (<Atom, Nat> => Nat)        nodes_levels,
  (<Atom, Nat> => Nat)        nodes_idxs,
  [Nat]                       levels_offsets,
  [NzNat]                     levels_sizes;


  [Instr] gen_method_code(Method method)
  {
    // If the automaton has never been updated before, we do it now
    // init_code = [do_if(is_new, [update_inputs(automaton.name)])];

    // First step is copying the method parameters (if there are any)
    // where they can be accessed by the update procedure
    par_copy_code = [set_var(v, fn_par(i)) : unused_var, v @ i <- method.args];

    // Then we mark for update all the state relevant state variables
    queue_update_code = join(rand_sort({gen_queue_update_code(a, e) : e @ a <- method.assignments}));

    // Now we call the update procedure
    //## BUG BUG BUG: THIS IS WRONG, I NEED TO "DISABLE" DISCRETE INPUTS
    call_code = [update_inputs(automaton.name, elapsed_time)];

    // We can now clear all copied parameters
    clear_code = [reset_memb_var(v, :blank) : unused_var, v <- method.args];

    return par_copy_code & queue_update_code & call_code & clear_code;


    [Instr] gen_queue_update_code(Atom state_var_id, Expr new_value)
    {
      expr_idx = match (nodes_by_id[state_var_id])
                   state() n? = index_first(new_value, n.exprs);
      return [
        set_ivar(update_source_var(state_var_id), expr_idx),
        queue_update(automaton.name, state_var_id)
      ];
    }
  }



  [Instr] gen_init_method_body(MembBoolVar* memb_bool_vars, MembIntVar* memb_int_vars, (Atom => Expr) state_vars_init_value)
  {
    // Initializing all object member variables (save for new inputs) to blank
    code_0 = [init_memb_var(v, :blank) : v <- rand_sort(memb_vars_and_method_args)];

    // Initializing new inputs to undefined (if countinuous) or blank (if discrete)
    code_1 = [init_memb_var(new_input(a), :undefined) : a <- rand_sort(cont_inputs_ids)] &
             [init_memb_var(new_input(a), :blank) : a <- rand_sort(disc_inputs_ids)];

    // Initializing all boolean member variables
    code_2 = [set_bvar(v, bool_memb_var_init_value(v)) : v <- rand_sort(memb_bool_vars)];

    // Initializing all integer member variables
    code_3 = [set_ivar(v, int_memb_var_init_value(v)) : v <- rand_sort(memb_int_vars)];

    // Initializing the update_source_var()
    code_4 = [
      set_ivar(update_source_var(id), state_var_update_source_idx(id, state_vars_init_value[id]))
      : id <- rand_sort(state_vars_ids)
    ] & [set_ivar(update_source_var(id), -1) : id <- rand_sort(disc_derived_vars_ids)];

    // This is the list of nodes that have to be initialized through the normal mechanism
    // during the first update. It consists of all continous inputs and derived signals,
    // time-varying conditions, state variables and all the conditions, but it does not
    // include discrete signals, which are ignored the first time
    nodes_to_init_by_level = [
      {n : n <- ns, n :: Nat or in(n, cont_inputs_ids) or in(n, cont_derived_vars_ids) or in(n, state_vars_ids)}
      : ns <- nodes_ids_by_level

    ];

    // Initializing variables that keep track of the number of nodes to update
    // For every level that has more than 2 nodes (the threshold for having a switch case)
    // we add all continuous inputs or derived signals to the update list
    code_5 = [set_ivar(update_count_var(l), size(ns)) : ns @ l <- nodes_to_init_by_level, size(nodes_ids_by_level[l]) > 2];

    // Initializing variables that contain the list of nodes that must be updated.
    // Initially only continuous inputs are marked for update
    code_6 = join([
      [set_ivar(nodes_to_update_var(l, i), nodes_idxs[n]) : n @ i <- rand_sort(ns)]
      : ns @ l <- nodes_to_init_by_level, size(nodes_ids_by_level[l]) > 2
    ]);

    // Now initializing all parameters.
    //## THESE VARIABLES HAVE ALREADY BEEN INITIALIZED TO BLANK, AND THAT'S REDUNDANT
    code_7 = gen_params_init_code(automaton, options);

    return join([code_0, code_1, code_2, code_3, code_4, code_5, code_6, code_7]);


    Nat state_var_update_source_idx(Atom id, Expr init_val)
    {
      node = nodes_by_id[id];
      return match (node)
        state() = index_first(init_val, node.exprs);
    }


    Bool bool_memb_var_init_value(MembBoolVar):
      cond_is_def_var()               = true,
      is_new                          = true,
      marked_for_update_var(Nat id?)  = true,
      // Variable type            Initially marked for update
      //   continuous input         true
      //   discrete input           false
      //   state variable           true
      //   continuous derived       true
      //   discrete derived         false
      //   time-varying condition   true
      marked_for_update_var(Atom id?) = in(id, cont_inputs_ids) or
                                        in(id, cont_derived_vars_ids) or
                                        in(id, state_vars_ids),
      cond_expr_is_def_var(Atom id?)  = true,
      // cond_expr_is_def_var(Nat id?)   = false,
      _                               = false;


    Int int_memb_var_init_value(MembIntVar):
      update_source_var()       = -1,
      update_count_var()        =  0,
      // nodes_to_update_var()
      next_trigger_time_var()   = -1,
      curr_time_slot_var()      = -1,
      time_triggers_count_var   =  0,
      // trigger_times_heap_var()
      // time_varying_cond_ids_heap_var()
      last_update_time          =  0;
  }


  [Instr] gen_update_method_body([AutoNode^] nodes, Nat* nested_cond_ids, (<Atom, Nat> => <Atom, Nat>*) nodes_deps)
  {
    memb_copy_vars = memb_copy_vars(automaton);
    memb_copy_var_ids = {name(v) : v <- memb_copy_vars};

    //## BAD: I SHOULD BE USING A UNION PATTERN, JUST LIKE THIS:
    // multivalue_node_expr_count = (t.id => length(t.exprs) : t <- set(node_types), state() | derived_disc() << t);
    multivalue_node_expr_count = (t.id => length(t.exprs) : t <- set(nodes), state() << t) &
                                 (t.id => length(t.exprs) : t <- set(nodes), derived_disc() << t);

    node_idx_var = ivar(0);
    node_count_var = ivar(1);

    let (auto_name                  = automaton.name,
         multivalue_node_expr_count = multivalue_node_expr_count,
         memb_copy_var_ids          = memb_copy_var_ids,
         nested_cond_ids            = nested_cond_ids,
         next_int_var_id            = 2)

      nodes_code_by_id = merge([(n.id => gen_any_node_code(n)) : n <- nodes]);

      queue_memb_copy_updates_code = [
        do_if(
          memb_has_changed(id),
          [mark_for_update(d, false) : d <- rand_sort(nodes_deps[id])]
        ) : id <- rand_sort(memb_copy_var_ids)
      ];
    ;

    levels_code = [gen_level_code(rand_sort(ids), nodes_code_by_id, i, levels_offsets[i], node_idx_var, node_count_var) : ids @ i <- nodes_ids_by_level];

    first_pass_finish_code = [set_bvar(is_new, false)];
    if (disc_inputs_ids != {})
      if (levels_sizes[0] > 2)
        counter_var = ivar(0); //## ivar(0) IS ALREADY USED ELSEWHERE
        first_pass_finish_code = [first_pass_finish_code | set_ivar(counter_var, 0)];
        for (id : rand_sort(disc_inputs_ids))
          first_pass_finish_code = [first_pass_finish_code |
            do_if(
              marked_for_update_var(id),
              [ set_ivar(nodes_to_update_var(0, counter_var), nodes_idxs[id]), // For input nodes, the global index and the level index coincide
                set_ivar(counter_var, add(counter_var, 1))
              ]
            )];
        ;
        first_pass_finish_code = [first_pass_finish_code | set_ivar(update_count_var(0), counter_var)];
      ;
      //## BUG BUG BUG: WHAT HAPPENS IF THE FIRST TIME THE UPDATE PROCEDURE IS CALLED, IT IS CALLED THROUGH A METHOD?
      //## TRY TO FIGURE OUT WHAT MAKES SENSE IN THAT CASE.
      //## MY CURRENT UNDERSTANDING (WHICH MAY WELL BE WRONG) IS THAT THE UPDATE IS FIRST CALLED
      //## THROUGH THE METHOD, BUT IGNORING THE DISCRETE INPUTS, AND THEN THE DISCRETE INPUTS ARE APPLIED,
      //## BUT WITHOUT THE OVERRIDING PROVIDED BY THE METHOD. DOES THAT MAKE SENSE?
      first_pass_finish_code = [first_pass_finish_code | update_inputs(automaton.name, 0)];
    ;

    update_code = [reset_memb_var(memb_var(id), :blank) : id <- rand_sort(disc_sgns_ids)] &
                  [set_var(v, memb_var(name(v))) : v <- rand_sort(memb_copy_vars)] &
                  join(levels_code) & [do_if(is_new, first_pass_finish_code)];

    init_memb_copies_code = [set_bvar(memb_has_changed(id), false) : id <- rand_sort(memb_copy_var_ids)];

    update_code = init_memb_copies_code & update_code & queue_memb_copy_updates_code;

    update_code = add_time_loop(update_code) if automaton.time_rules != ();

    return update_code;


    [Instr] add_time_loop([Instr] core_code)
    {
      i0 = ivar(0); //## NOT SURE ABOUT THIS ONE

      time_varying_nodes_by_idx = merge({(i => a) : i @ a <- time_varying_node_idxs});

      header_code = [
        set_ivar(curr_time, update_time),
        do_if(
          is_gt(time_triggers_count_var, 0),
          [ set_ivar(i0, trigger_times_heap_var(0)),
            do_if(
              is_le(i0, update_time),
              [ set_ivar(curr_time, i0),
                repeat([
                  set_ivar(i0, time_varying_cond_ids_heap_var(0)),
                  switch_on_nat(
                    i0,
                    [ [queue_cond_update(automaton.name, time_varying_nodes_by_idx[i], false)]
                      : i < nz_nat(size(automaton.time_rules))
                    ]
                  ),
                  clear_timer(automaton.name, i0),
                  break_if(
                    or_else([
                      is_eq(time_triggers_count_var, 0),
                      neg(is_eq(trigger_times_heap_var(0), curr_time))
                    ])
                  )
                ])
              ]
            )
          ]
        )
      ];

      return [
        set_ivar(update_time, add(last_update_time, elapsed_time)),
        set_ivar(last_update_time, update_time),
        repeat(nonempty(header_code & core_code & [break_if(is_eq(curr_time, update_time))]))
      ];
    }
  }


  [Instr] gen_level_code([<Atom, Nat>^] nodes_ids, (<Atom, Nat> => [Instr]) nodes_code_by_id, Nat level_idx, Nat level_offset, IntVar node_idx_var, IntVar node_count_var)
  {
    update_count_var = update_count_var(level_idx);
    node_count = length(nodes_ids);

    nodes_code = [
      { code = nodes_code_by_id[id];
        return if level_idx == 0 and in(id, disc_inputs_ids)
          then [do_if(neg(is_new), code)]
          else code;
      }
      : id <- nodes_ids
    ];

    if (node_count > 2)
      switch_expr = sub(nodes_to_update_var(level_idx, node_idx_var), level_offset);
      code = [
        set_ivar(node_idx_var, 0),
        set_ivar(node_count_var, update_count_var),
        repeat([
          break_if(is_eq(node_idx_var, node_count_var)),
          switch_on_nat(switch_expr, nonempty(nodes_code)),
          set_ivar(node_idx_var, add(node_idx_var, 1))
        ]),
        set_ivar(update_count_var, 0)
      ];

    else
      code = [do_if(marked_for_update_var(nodes_ids[i]), nodes_code[i]) : i < node_count];
    ;

    code = [do_if(is_eq(curr_time, update_time), code)] if level_idx == 0 and automaton.time_rules != ();

    return code;
  }
}

////////////////////////////////////////////////////////////////////////////////

[Instr] gen_params_init_code(Automaton automaton, CompilationOptions options)
{
  param_ids = keys(automaton.params);
  dep_map = (a => {unsafe_name(v) : v <- extern_vars(e)} : e @ a <- automaton.params);
  assert not (? ts @ s <- dep_map, t <- ts : not in(t, param_ids));
  sorted_params = topological_sort(dep_map);
  let (next_obj_var_id = 0, next_int_var_id = 0, next_bool_var_id = 0, options = options)
    params_init_code = [
      [gen_safe_eval_code(automaton.params[p], memb_var(p)) : p <- rand_sort(ps)]
      : ps <- sorted_params
    ];
  ;
  return join([join(cfs) : cfs <- params_init_code]);
}

type AutoNodeType = input(Atom),
                    derived(id: Atom, expr: Expr),
                    state(id: Atom, exprs: [Expr]),
                    cond_node(id: Nat, cond: Expr, parent: Maybe[(id: Nat, trigger: Bool)], updates: UpdateInfo*);

type UpdateInfo   = (state: Atom, value_idx: Nat, trigger: Bool);

type CondInfo     = ( cond:         Expr,
                      parent:       Maybe[(id: Nat, trigger: Bool)],
                      nested_conds: (id: Nat, trigger: Bool)*,
                      updates:      (state_id: Atom, new_value: Expr, trigger: Bool)*
                    );

////////////////////////////////////////////////////////////////////////////////

AutoNodeType input(Atom id)             = :input(id);
AutoNodeType derived(Atom id, Expr e)   = derived(id: id, expr: e);
AutoNodeType state(Atom id, [Expr] es)  = state(id: id, exprs: es);
AutoNodeType cond_node(Nat id, Expr c, Maybe[(id: Nat, trigger: Bool)] p, UpdateInfo* us) = cond_node(id: id, cond: c, parent: p, updates: us);

////////////////////////////////////////////////////////////////////////////////

<Atom, Nat> get_id(AutoNodeType node_type):
  input(id?)      = id,
  derived()       = node_type.id,
  state()         = node_type.id,
  cond_node()     = node_type.id;

////////////////////////////////////////////////////////////////////////////////

Block gen_auto_code(Automaton automaton, CompilationOptions options)
{
  nodes = gen_auto_nodes(automaton);
  fail if nodes == []; //## BUG BUG BUG

  nodes_types = [t : unused_var_1, unused_var_2, t <- nodes];

  change_tracked_members = {a : v <- change_tracked_memb_vars(automaton), memb_var(a?) << v};

  nodes_idxs = merge([(get_id(t) => i) : t @ i <- nodes_types]);
  nodes_levels = merge([(get_id(t) => l) : l, unused_var_1, t <- nodes]);

  levels_count = nz_nat(max(nonempty(values(nodes_levels))) + 1);
  max_level_size = nat(max(nonempty(values(bag([l : l, unused_var_1, unused_var_2 <- nodes])))));

  param_ids = keys(automaton.params);
  input_ids = keys(automaton.inputs);
  state_var_ids = keys(automaton.state);
  rule_ids = keys(automaton.rules);
  cond_nodes = {t : t <- set([t : unused_var_1, unused_var_2, t <- nodes]), cond_node() << t}; //## BIT UGLY.
  cond_ids = {c.id : c <- cond_nodes};
  nested_cond_ids = {c.id : c <- cond_nodes, c.parent != nil};

  state_update_expr_count = (t.id => length(t.exprs) : t <- set(nodes_types), state() << t);

  lev_var = ivar(0);
  node_idx_var = ivar(1);
  node_count_var = ivar(2);
  curr_node_var = ivar(3);

  let (auto_name = automaton.name, nodes_idxs = nodes_idxs, nodes_levels = nodes_levels,
       change_tracked_members = change_tracked_members, state_update_expr_count = state_update_expr_count,
       nested_cond_ids = nested_cond_ids, next_int_var_id = 4, options = options)
    nodes_code = [gen_node_code(n, l, ds) : l, ds, n <- nodes];
  ;

  update_code = [
    set_ivar(lev_var, 0),
    repeat([
      break_if(is_eq(lev_var, levels_count)),
      set_ivar(node_idx_var, 0),
      set_ivar(node_count_var, update_count_var(lev_var)),
      repeat([
        break_if(is_eq(node_idx_var, node_count_var)),
        set_ivar(curr_node_var, nodes_to_update_var(lev_var, node_idx_var)),
        switch_on_nat(curr_node_var, nodes_code),
        set_ivar(node_idx_var, add(node_idx_var, 1))
      ]),
      set_ivar(update_count_var(lev_var), 0),
      set_ivar(lev_var, add(lev_var, 1))
    ]),
    set_bvar(auto_is_new, false)
  ];

  update_code = update_code & [set_bvar(has_changed_var(a), false) : a <- rand_sort(change_tracked_members)];
  update_code = update_code & gen_has_changed_reset_code(nodes, options = options);

  memb_obj_vars  = {memb_var(a) : a <- param_ids & input_ids & state_var_ids & rule_ids} & {new_input(a) : a <- input_ids};
  memb_int_vars  = {update_source_var(a) : a <- state_var_ids};
  memb_bool_vars = {cond_value_var(n) : n <- cond_ids} &
                   {cond_is_def_var(n) : n <- cond_ids} &
                   {cond_expr_value_var(n) : n <- nested_cond_ids} &
                   {cond_expr_is_def_var(n) : n <- nested_cond_ids} &
                   {cond_expr_up_to_date_var(n) : n <- nested_cond_ids} &
                   {has_changed_var(a) : a <- change_tracked_members} &
                   {marked_for_update_var(id) : id <- param_ids & input_ids & state_var_ids & rule_ids & cond_ids} &
                   {auto_is_new};

  param_deps = (a => {match (v) var(n?) = n : v <- extern_vars(e)} : e @ a <- automaton.params);
  assert not (? ts @ s <- param_deps, t <- ts : not in(t, param_ids));
  sorted_params = topological_sort(param_deps);
  let (next_obj_var_id = 0, next_int_var_id = 0, next_bool_var_id = 0, options = options)
    params_init_code = [[gen_safe_eval_code(automaton.params[p], memb_var(p)) : p <- rand_sort(ps)] : ps <- sorted_params];
  ;

  state_vars_deps = (a => {match (v) var(n?) = n : v <- extern_vars(s.init_value)} - param_ids : s @ a <- automaton.state);
  assert not (? ts @ s <- state_vars_deps, t <- ts : not in(t, state_var_ids));
  sorted_state_vars = topological_sort(state_vars_deps);
  let (next_obj_var_id = 0, next_int_var_id = 0, next_bool_var_id = 0, options = options)
    state_vars_init_code = [[gen_safe_eval_code(automaton.state[sv].init_value, memb_var(sv)) : sv <- rand_sort(svs)] : svs <- sorted_state_vars];
  ;

  init_code = join([join(cfs) : cfs <- params_init_code & state_vars_init_code]) &
              [init_memb_var(memb_var(a))  : a <- rand_sort(input_ids & rule_ids)] &
              [clear_var(new_input(a)) : a <- rand_sort(input_ids)] &
              [set_ivar(v, -1) : v <- rand_sort(memb_int_vars)] &
              [set_bvar(v, bool_memb_var_init_value(v, input_ids)) : v <- rand_sort(memb_bool_vars)];

  memb_vars_to_rel = param_ids & input_ids & state_var_ids & rule_ids;
  vars_to_rel = {memb_var(id) : id <- memb_vars_to_rel} & {new_input(id) : id <- input_ids};
  cleanup_code = [do_if(memb_is_def(v), [release(v), clear_var(v)]) : v <- rand_sort(vars_to_rel)];

  node_ids = [get_id(t) : unused_var_1, unused_var_2, t <- nodes];
  let (nodes_idxs = nodes_idxs, nodes_levels = nodes_levels, nested_cond_ids = nested_cond_ids, next_int_var_id = 0)
    queue_update_code = (id => queue_update_method_body(id) : id <- set(node_ids));
  ;

  assert {
    inputs_count = size(automaton.inputs);
    for (l, unused_var_2, node_type @ i : nodes)
      is_input = match (node_type)
        input()  = true,
        _        = false;
      if (i < inputs_count)
        return false if l != 0 or not is_input;
      else
        return false if l == 0 or is_input;
      ;
    ;
    return true;
  };
  sorted_input_ids = subseq(node_ids, 0, size(automaton.inputs));
  fail if not sorted_input_ids :: [Atom]; //## BAD: RUNTIME TYPE CHECKING SHOULD NOT BE NEEDED HERE

  return block(
    name:               automaton.name,
    inputs:             sorted_input_ids,
    outputs:            keys(automaton.outputs),
    memb_vars:          memb_obj_vars & memb_int_vars & memb_bool_vars,
    levels:             levels_count,
    max_level_size:     max_level_size,
    init_code:          init_code,
    update_code:        update_code,
    cleanup_code:       cleanup_code,
    queue_update_code:  queue_update_code
  );

  Bool bool_memb_var_init_value(MembBoolVar, Atom* input_ids):
    cond_is_def_var()                 = true,
    auto_is_new                       = true,
    marked_for_update_var(Atom id?)   = in(id, input_ids),
    // cond_expr_is_def_var()            = ???,
    _                                 = false;
}

////////////////////////////////////////////////////////////////////////////////

using CompilationOptions options
{
  [Instr] gen_has_changed_reset_code([(Nat, <Atom, Nat>*, AutoNodeType)] nodes)
  {
    code = [];
    changed_tracked_parent_ids = {};
    for (l, ds, n : nodes)
      if (n :: <cond_node(id: Nat, cond: Expr, parent: Maybe[(id: Nat, trigger: Bool)], updates: UpdateInfo*)>) //## BAD BAD BAD
        parent = n.parent;
        parent_is_change_tracked = parent != nil and in(parent.id, changed_tracked_parent_ids);
        is_change_tracked = parent_is_change_tracked or change_tracked_memb_vars_in_expr(n.cond) != {};
        if (is_change_tracked)
          code = code & gen_has_changed_reset_code(n.id, n.cond, parent);
          changed_tracked_parent_ids = changed_tracked_parent_ids & {n.id};
        ;
      ;
    ;
    return code;
  }


  [Instr] gen_has_changed_reset_code(Nat id, Expr cond, Maybe[(id: Nat, trigger: Bool)] parent)
  {
    l0 = lvar(0);
    id_var = cond_value_var(id);
    cv_var = cond_expr_value_var(id);
    id_is_def_var = cond_is_def_var(id);
    cv_is_def_var = cond_expr_is_def_var(id);

    code = [];

    // If the condition contains has-changed variables, then we refresh it
    is_change_tracked = change_tracked_memb_vars_in_expr(cond) != {};
    if (is_change_tracked)
      eval_expr_code = gen_safe_eval_code(cond, l0, next_obj_var_id = 1, next_int_var_id = 0, next_bool_var_id = 0);
      if (parent != nil)
        pid_var = cond_value_var(parent.id);
        pid_is_def_var = cond_is_def_var(parent.id);

        eval_cond_code = [
          set_bvar(cv_var, inline_is_eq(l0, obj_true)),
          set_bvar(cv_is_def_var, inline_is_eq(l0, obj_true)),
          set_bvar(id_var, and([cv_var, is_eq(pid_var, parent.trigger)])),
          branch(
            pid_is_def_var,
            [set_bvar(cond_is_def_var(id), or([loc_var_is_def(l0), neg(is_eq(pid_var, parent.trigger))]))],
            [set_bvar(cond_is_def_var(id), inline_is_eq(l0, obj_false))]
          )
        ];
      else
        eval_cond_code = [
          set_bvar(id_var, inline_is_eq(l0, obj_true)),
          set_bvar(id_is_def_var, loc_var_is_def(l0))
        ];
      ;
      code = eval_expr_code & eval_cond_code;
    ;
    return code;
  }
}

////////////////////////////////////////////////////////////////////////////////

using
{
  AutoSymbol            auto_name,
  (<Atom, Nat> => Nat)  nodes_idxs,
  (<Atom, Nat> => Nat)  nodes_levels,
  Atom*                 change_tracked_members,
  (Atom => Nat)         state_update_expr_count,
  Nat*                  nested_cond_ids,
  Nat                   next_int_var_id,
  CompilationOptions    options;


  [Instr] gen_node_code(AutoNodeType node_type, Nat level, <Atom, Nat>* dep_nodes)
  {
    code = match (node_type)
      input(id?)  = gen_input_node_code(id, dep_nodes),
      derived()   = gen_derived_node_code(node_type.id, node_type.expr, dep_nodes),
      state()     = gen_state_node_code(node_type.id, node_type.exprs, dep_nodes),
      cond_node() = gen_cond_node_code(node_type.id, node_type.cond, node_type.parent, node_type.updates, dep_nodes);
    return code & [set_bvar(marked_for_update_var(get_id(node_type)), false)];
  }

  // set_var(lvar(0), get_new_input(a))         lvar(0) -> owner
  // clear(new_input(a))
  // set_var(lvar(1), memb_var(a))              lvar(0) -> owner, lvar(1) -> copy_of(memb_var(a))
  // if not(is_eq(lvar(0), lvar(1)))
  //   set_var(memb_var(a), lvar(0))            lvar(1) -> owner
  //   mark dependent nodes as not up-to-date

  [Instr^] gen_input_node_code(Atom id, <Atom, Nat>* dep_nodes)
  {
    l0 = lvar(0);
    l1 = lvar(1);
    memb_var = memb_var(id);
    body = [
      set_var(memb_var, l0),
      set_bvar(has_changed_var(id), true) if in(id, change_tracked_members)
    ];
    body = body & [mark_for_update(n, false) : n <- rand_sort(dep_nodes)];
    return [
      get_new_input(l0, id),
      clear_var(new_input(id)),
      set_var(l1, memb_var),
      do_if_not(is_eq(l0, l1), body)
    ];
  }


  [Instr^] gen_derived_node_code(Atom id, Expr expr, <Atom, Nat>* dep_nodes)
  {
    var = memb_var(id);
    nv_var = lvar(0);
    eval_code = gen_safe_eval_code(expr, nv_var, next_obj_var_id = 1, next_bool_var_id = 0);
    cond = neg(is_eq(var, nv_var));
    body = [
      set_var(var, nv_var),
      set_bvar(has_changed_var(id), true) if in(id, change_tracked_members)
    ];
    body = body & [mark_for_update(n, false) : n <- rand_sort(dep_nodes)];
    return [eval_code | do_if(cond, body)];
  }


  [Instr^] gen_state_node_code(Atom id, [Expr] exprs, <Atom, Nat>* dep_nodes)
  {
    var = memb_var(id);
    nv_var = lvar(0);
    let (next_obj_var_id = 1, next_bool_var_id = 0)
      cases = nonempty([gen_safe_eval_code(e, nv_var) : e <- exprs] & [[clear_loc_var(nv_var)]]);
      eval_instr = switch_on_nat(update_source_var(id), cases);
    ;
    cond = neg(is_eq(var, nv_var));
    body = [
      set_var(var, nv_var),
      set_bvar(has_changed_var(id), true) if in(id, change_tracked_members)
    ];
    body = body & [mark_for_update(n, false) : n <- rand_sort(dep_nodes)];
    return [eval_instr, do_if(cond, body)];
  }


  [Instr] gen_cond_node_code(Nat id, Expr cond, Maybe[(id: Nat, trigger: Bool)] parent, UpdateInfo* updates, <Atom, Nat>* dep_nodes)
  {
    l0 = lvar(0);
    b0 = bvar(0);
    b1 = bvar(1);
    id_var = cond_value_var(id);
    cv_var = cond_expr_value_var(id);
    utd_var = cond_expr_up_to_date_var(id);
    cond_is_def_var = cond_is_def_var(id);

    if (parent != nil)
      cond_expr_is_def_var = cond_expr_is_def_var(id);

      pd_var = cond_is_def_var(parent.id);
      pid_var = cond_value_var(parent.id);

      cond_refresh_body = gen_safe_eval_code(cond, l0, next_obj_var_id = 1, next_bool_var_id = 2) & [
        set_bvar(cv_var, inline_is_eq(l0, obj_true)),
        set_bvar(cond_expr_is_def_var, loc_var_is_def(l0)),
        set_bvar(utd_var, true)
      ];

      cond_refresh_else_body = [
        branch(
          cond_expr_is_def_var,
          [set_var(l0, to_obj(id_var))],
          [clear_loc_var(l0)]
        )
      ];

      cond_refresh_cond = and([pd_var, is_eq(pid_var, parent.trigger), neg(utd_var)]);

      cond_eval_code = [
        branch(cond_refresh_cond, cond_refresh_body, cond_refresh_else_body),
        branch(
          pd_var,
          [do_if_not(is_eq(pid_var, parent.trigger), [set_var(l0, obj_false)])],
          [do_if_not(inline_is_eq(l0, obj_false), [clear_loc_var(l0)])]
        )
      ];

    else
      cond_eval_code = gen_safe_eval_code(cond, l0, next_obj_var_id = 1, next_bool_var_id = 2);
    ;

    state_update_code = branch(
      id_var,
      join(rand_sort({gen_update_code(u.state, u.value_idx) : u <- updates, u.trigger == true})),
      join(rand_sort({gen_update_code(u.state, u.value_idx) : u <- updates, u.trigger == false}))
    );
    queue_dep_nodes_updates_code = [mark_for_update(n, true) : n <- rand_sort(dep_nodes)];
    checked_state_update_code = [do_if(b0, [state_update_code] & queue_dep_nodes_updates_code)];

    on_becoming_undef_code = join(rand_sort({gen_clear_code(u.state) : u <- updates}));
    cond_is_undef_branch = [do_if(cond_is_def_var, [set_bvar(cond_is_def_var, false)] & on_becoming_undef_code)];

    cond_stays_def_branch = [
      set_bvar(b1, inline_is_eq(l0, obj_true)),
      set_bvar(b0, neg(is_eq(id_var, b1))),
      set_bvar(id_var, b1)
    ] & checked_state_update_code;

    cond_becomes_def_branch = [
      set_bvar(id_var, inline_is_eq(l0, obj_true)),
      set_bvar(cond_is_def_var, true)
    ] & queue_dep_nodes_updates_code;

    cond_is_def_branch = [branch(cond_is_def_var, cond_stays_def_branch, cond_becomes_def_branch)];

    return cond_eval_code & [branch(loc_var_is_def(l0), cond_is_def_branch, cond_is_undef_branch)];
  }


  [Instr^] gen_update_code(Atom state, Nat src_idx) = [set_ivar(update_source_var(state), src_idx), mark_for_update(state, false)];


  [Instr^] gen_clear_code(Atom state) = gen_update_code(state, state_update_expr_count[state]);


  Instr mark_for_update(<Atom, Nat> node_id, Bool from_cond):
    +   = queue_update(auto_name, node_id),
    *   = queue_cond_update(auto_name, node_id, not from_cond and in(node_id, nested_cond_ids));
}


using (<Atom, Nat> => Nat) nodes_idxs, (<Atom, Nat> => Nat) nodes_levels, Nat* nested_cond_ids, Nat next_int_var_id
{
  [Instr] queue_update_method_body(<Atom, Nat> node_id)
  {
    index = nodes_idxs[node_id];
    level = nodes_levels[node_id];

    idx_var = ivar(next_int_var_id);
    mark_var = marked_for_update_var(node_id);
    count_var = update_count_var(level);
    nodes_var = nodes_to_update_var(level, idx_var);

    code = [do_if(neg(mark_var), [
      set_bvar(mark_var, true),
      set_ivar(idx_var, count_var),
      set_ivar(nodes_var, index),
      set_ivar(count_var, add(idx_var, 1))
    ])];

    if (node_id :: Nat and in(node_id, nested_cond_ids))
      inv_cache_instr = do_if(invalidate_cond_expr_cache, set_bvar(cond_expr_up_to_date_var(node_id), false));
      code = [code | inv_cache_instr];
    ;

    return code;
  }
}



using Nat next_obj_var_id, Nat next_int_var_id, Nat next_bool_var_id, CompilationOptions options
{
  [Instr^] gen_safe_eval_code(Expr expr, <MembVar, LocVar> res_var):
    and_expr()    = gen_safe_eval_code_for_and_expr(expr.left, expr.right, res_var),
    or_expr()     = gen_safe_eval_code_for_or_expr(expr.left, expr.right, res_var),
    _             = gen_default_safe_eval_code(expr, res_var);


  [Instr^] gen_safe_eval_code_for_and_expr(Expr left_expr, Expr right_expr, <MembVar, LocVar> res_var)
  {
    left_tmp_var = lvar(next_obj_var_id);
    right_tmp_var = lvar(nat(next_obj_var_id + 1));
    let (next_obj_var_id = nat(next_obj_var_id + 2))
      left_eval_code = gen_safe_eval_code(left_expr, left_tmp_var);
      right_eval_code = gen_safe_eval_code(right_expr, right_tmp_var);
    ;
    // If the left term is false, there's no need to compute the right value
    if_false_code = [set_var(res_var, obj_false)];
    // If the left term is true, the right one decides the final value
    if_true_code = [set_var(res_var, right_tmp_var)];
    // If the left term is undefined, then we need to check the value of the right term
    if_undef_code = [branch(is_false(right_tmp_var), [set_var(res_var, obj_false)], [clear_var(res_var)])];
    // true + undefined cases, they both require the evaluation of the right term
    if_not_false_code = [right_eval_code | branch(is_true(left_tmp_var), if_true_code, if_undef_code)];
    // Putting it all together
    return [left_eval_code | branch(is_false(left_tmp_var), if_false_code, if_not_false_code)];
  }


  [Instr^] gen_safe_eval_code_for_or_expr(Expr left_expr, Expr right_expr, <MembVar, LocVar> res_var)
  {
    left_tmp_var = lvar(next_obj_var_id);
    right_tmp_var = lvar(nat(next_obj_var_id + 1));
    let (next_obj_var_id = nat(next_obj_var_id + 2))
      left_eval_code = gen_safe_eval_code(left_expr, left_tmp_var);
      right_eval_code = gen_safe_eval_code(right_expr, right_tmp_var);
    ;
    // If the left term is true, there's no need to compute the right value
    if_true_code = [set_var(res_var, obj_true)];
    // If the left term is false, the right one decides the final value
    if_false_code = [set_var(res_var, right_tmp_var)];
    // If the left term is undefined, then we need to check the value of the right term
    if_undef_code = [branch(is_true(right_tmp_var), [set_var(res_var, obj_true)], [clear_var(res_var)])];
    // false + undefined cases, they both require the evaluation of the right term
    if_not_true_code = [right_eval_code | branch(is_false(left_tmp_var), if_false_code, if_undef_code)];
    // Putting it all together
    return [left_eval_code | branch(is_true(left_tmp_var), if_true_code, if_not_true_code)];
  }


  [Instr^] gen_default_safe_eval_code(Expr expr, <MembVar, LocVar> res_var)
  {
    eval_code = gen_eval_code(
      expr,
      res_var,
      next_set_it_var_id  = 0,
      next_seq_it_var_id  = 0,
      next_map_it_var_id  = 0,
      next_vector_var_id  = 0,
      next_stream_var_id  = 0,
      auto_vars_types     = (),
      ignore_assertions   = options.ignore_assertions
    );

    vars_to_safeguard = non_nullable_vars(expr);
    if (vars_to_safeguard != {})
      cond = and([memb_is_def(v) : v <- rand_sort(vars_to_safeguard)]);
      eval_code = [branch(cond, eval_code, [clear_var(res_var)])];
    ;

    return eval_code;
  }
}


MembVar* non_nullable_vars(Expr expr)
{
  //## BUG BUG BUG: THIS IS WRONG. VARIABLES IN has-changed OR is-def EXPRESSIONS SHOULD NOT BE COUNTED HERE
  vs = extern_vars(expr);
  return {v : v <- vs, v :: MembVar};
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[(Nat, <Atom, Nat>*, AutoNodeType)] gen_auto_nodes(Automaton automaton)
{
  cond_nodes = ();
  next_id = 0;
  for (a : rand_sort(automaton.actions))
    action_conds, next_id = gen_action_nodes(a, next_id, nil);
    cond_nodes = cond_nodes & action_conds;
  ;

  conds_deps = (id => cond_deps(c) : c @ id <- cond_nodes);
  state_trigger_deps = merge_values({(u.state_id => id) : c @ id <- cond_nodes, u <- c.updates});
  state_value_deps = merge_value_sets({(u.state_id => expr_deps(u.new_value)) : c @ id <- cond_nodes, u <- c.updates});
  rules_deps = (a => {unsafe_name(v) : v <- extern_vars(e)} : e @ a <- automaton.rules);

  trigger_dep_map = conds_deps & state_trigger_deps & rules_deps;
  value_dep_map = conds_deps & rules_deps & merge_value_sets({state_trigger_deps, state_value_deps});

  rev_trigger_dep_map = reverse_multi(trigger_dep_map);

  params = keys(automaton.params);
  inputs = keys(automaton.inputs);
  level_0 = params & inputs;

  nodes_by_level = topological_sort((s => new_ts : ts @ s <- value_dep_map, new_ts = ts - level_0 - {s}));

  sorted_nodes = [(0, lookup(rev_trigger_dep_map, i, {}), input(i)) : i <- rand_sort(inputs)];

  update_values = merge_values({(u.state_id => u.new_value) : c @ id <- cond_nodes, u <- c.updates});
  update_values = (s => rand_sort(vs) : vs @ s <- update_values);

  state_vars_ids = keys(automaton.state);

  for (l @ i : nodes_by_level)
    nodes = rand_sort(l);
    for (n : nodes)
      level = nat(i + 1);
      dependent_nodes = lookup(rev_trigger_dep_map, n, {}) - state_vars_ids;
      if (has_key(automaton.rules, n))
        fail if not n :: Atom;
        info = derived(n, automaton.rules[n]);
      elif (has_key(automaton.state, n))
        fail if not n :: Atom;
        info = state(n, update_values[n]);
      elif (has_key(cond_nodes, n))
        fail if not n :: Nat;
        cond_node = cond_nodes[n];
        cond_updates = {(state: u.state_id, value_idx: index_first(u.new_value, update_values[u.state_id]), trigger: u.trigger) : u <- cond_node.updates};
        info = cond_node(n, cond_node.cond, cond_node.parent, cond_updates);
      else
        fail;
      ;
      new_node_info = (level, dependent_nodes, info);
      sorted_nodes = [sorted_nodes | new_node_info];
    ;
  ;

  return sorted_nodes;


  <Atom, Nat>* cond_deps(CondInfo cond)
  {
    parent = cond.parent;
    return expr_deps(cond.cond) & {value(parent).id if parent != nil};
  }

  Atom* expr_deps(Expr e) = {unsafe_name(v) : v <- extern_vars(e)};
}


((Nat => CondInfo), Nat) gen_action_nodes(AutoAction action, Nat root_id, Maybe[(id: Nat, trigger: Bool)] parent)
{
  next_id = nat(root_id + 1);

  updates = {};
  conditions = ();
  nested_conds = {};

  for (a, tv : rand_sort({(a, true) : a <- action.body} & {(a, false) : a <- action.else}))
    if (a :: AutoUpdate)
      updates = updates & {(state_id: a.target, new_value: a.value, trigger: tv)};

    elif (a :: AutoAction) //## BAD BAD: THE TYPECHECKER SHOULD AUTOMATICALLY INFER THE TYPE OF <a> IF WE TAKE THIS BRANCH
      nested_conds = nested_conds & {(id: next_id, trigger: tv)};
      subconds, next_id = gen_action_nodes(a, next_id, just(id: root_id, trigger: tv));
      conditions = conditions & subconds;
    ;
  ;

  return (conditions & (root_id => (cond: action.cond, parent: parent, nested_conds: nested_conds, updates: updates)), next_id);
}

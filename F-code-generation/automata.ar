Block gen_auto_code(Automaton automaton, (AutoSymbol => (Atom => Bool)) auto_input_is_disc, (AutoSymbol => (Atom => Bool)) auto_output_is_disc, AutoSymbol* time_sensitive_autos, (TypeName => Type) typedefs, CompilationOptions options)
{
  nodes = gen_auto_nodes(automaton, auto_input_is_disc, auto_output_is_disc);
  fail if nodes == []; //## BUG BUG BUG

  nodes_idxs = merge([(n.id => i) : n @ i <- nodes]);
  nodes_levels = merge([(n.id => n.level) : n <- nodes]);
  downstream_nodes = merge([(n.id => downstream_nodes_ids(n)) : n <- nodes]);

  levels_sizes = count_vector([n.level : n <- nodes]);
  fail if not levels_sizes :: [NzNat]; //## UGLY UGLY UGLY
  levels_offsets = [0] & partial_sums(levels_sizes);

  input_ids = keys(automaton.inputs);
  disc_sgns_ids = discrete_signals(automaton);
  time_rule_ids = keys(automaton.time_rules);
  nested_cond_ids = {get_inner_id(n.id) : n <- set(nodes), cond_node() << n, n.parent != nil};
  disc_inputs_ids = intersection(input_ids, disc_sgns_ids);

  memb_obj_vars = seq_union([memb_obj_vars(n) : n <- nodes]) &
                  {(memb_var(id), :blank) : id <- keys(automaton.params)} &
                  {(right(a), :blank) : m <- automaton.methods, a <- set(m.args)};

  memb_int_vect_vars  = set([nodes_to_update_vect_var(l, nz_nat(s)) : s @ l <- levels_sizes, s > 2]);

  // Not adding the arrays used to store the trigger heaps
  // That is done in the target language code generation phase
  is_time_sensitive = in(automaton.name, time_sensitive_autos);
  memb_int_vars = seq_union([memb_int_vars(n) : n <- nodes]) &
                  set([(update_count_var(l), s) : s @ l <- levels_sizes, s > 2]) &
                  {(time_triggers_count_var, 0) if is_time_sensitive, (last_update_time, 0) if is_time_sensitive};

  memb_bool_vars = seq_union([memb_bool_vars(n) : n <- nodes]) & {(is_new, true)};

  const_data = {time_slots_len(a, ls) : c @ a <- automaton.time_rules, ls = trigger_times_table(c.time_expr), ls != []};

  time_sensitive_nodes_ids = time_rule_ids & {id : na @ id <- automaton.nested_autos, in(na.type, time_sensitive_autos)};
  time_varying_node_idxs = merge([(std_block_node_id(a) => i) : a @ i <- rand_sort(time_sensitive_nodes_ids)]);

  // Generating code for initialization, update and methods
  let ( automaton                 = automaton,
        time_sensitive_autos      = time_sensitive_autos,

        options                   = options,

        disc_sgns_ids             = disc_sgns_ids,
        disc_inputs_ids           = intersection(input_ids, disc_sgns_ids),

        nodes_by_id               = merge(set([(n.id => n) : n <- nodes])),
        nodes_ids_by_level        = [set(l) : l <- nodes_ids_by_level(nodes)],

        time_varying_node_idxs    = time_varying_node_idxs,

        nodes_idxs                = nodes_idxs,
        nodes_levels              = nodes_levels,
        levels_offsets            = levels_offsets,
        levels_sizes              = levels_sizes)

    init_code     = gen_init_method_body(memb_bool_vars, memb_int_vars, memb_obj_vars);
    update_code   = gen_update_method_body(nodes, nested_cond_ids, downstream_nodes);
    methods_code  = gen_methods_code(automaton.methods, typedefs);
  ;

  // Generating cleanup code
  cleanup_code = join([[release(v), init_memb_var(v, :blank)] : v, unused_var <- rand_sort(memb_obj_vars)]) &
                 rand_sort({auto_cleanup(memb_auto_var(id), auto.type) : auto @ id <- automaton.nested_autos});

  // Generating methods for queuing updates
  queue_update_code = (n.id => gen_queue_update_method(n, nodes_idxs[n.id], levels_sizes[n.level]) : n <- set(nodes));

  assert {
    inputs_count = size(automaton.inputs);
    for (n @ i : nodes)
      is_input = match (n)
        input()  = true,
        _        = false;
      if (i < inputs_count)
        return false if n.level != 0 or not is_input;
      else
        return false if n.level == 0 or is_input;
      ;
    ;
    return true;
  };

  sorted_input_ids = [match (n.id) std_block_node_id(a?) = a : n <- subseq(nodes, 0, size(automaton.inputs))]; //## BAD: RUNTIME TYPE CHECKING SHOULD NOT BE NEEDED HERE

  memb_vars = {left(v) : v <- memb_bool_vars} &
              {left(v) : v <- memb_int_vars} &
              {left(v) : v <- memb_obj_vars} &
              memb_int_vect_vars;

  return block(
    name:               automaton.name,
    inputs:             sorted_input_ids,
    outputs:            keys(automaton.outputs),
    memb_vars:          memb_vars,
    nested_auto_vars:   (memb_auto_var(id) => auto.type : auto @ id <- automaton.nested_autos),
    init_code:          init_code,
    update_code:        update_code,
    cleanup_code:       cleanup_code,
    queue_update_code:  queue_update_code,
    methods_code:       methods_code,
    const_data:         const_data,
    time_rules_count:   size(time_varying_node_idxs)
  );


  [[BlockNodeId^]] nodes_ids_by_level([AutoNode] nodes)
  {
    curr_level = 0;
    curr_level_ids = [];
    node_ids_by_level = [];
    for (n @ i : nodes)
      if (n.level != curr_level)
        assert n.level == curr_level + 1;
        node_ids_by_level = [node_ids_by_level | nonempty(curr_level_ids)];
        curr_level = curr_level + 1;
        curr_level_ids = [];
      ;
      curr_level_ids = [curr_level_ids | n.id];
    ;
    node_ids_by_level = [node_ids_by_level | nonempty(curr_level_ids)] if nodes != [];
    return node_ids_by_level;
  }
}

////////////////////////////////////////////////////////////////////////////////

using
{
  Automaton                   automaton,
  AutoSymbol*                 time_sensitive_autos,

  CompilationOptions          options,

  Atom*                       disc_sgns_ids,
  Atom*                       disc_inputs_ids,

  (BlockNodeId => AutoNode)   nodes_by_id,
  [BlockNodeId+]              nodes_ids_by_level,

  (StdBlockNodeId => Nat)     time_varying_node_idxs,

  (BlockNodeId => Nat)        nodes_levels,
  (BlockNodeId => Nat)        nodes_idxs,
  [Nat]                       levels_offsets,
  [NzNat]                     levels_sizes;


  ((ExMethodSymbol, Nat) => [Instr]) gen_methods_code(Method* methods, (TypeName => Type) typedefs)
  {
    return merge({
      gen_code_for_overloaded_methods(ms, typedefs) : ms @ unused_var <- group_by(methods, ($.name, length($.args)))
    });


    ((ExMethodSymbol, Nat) => [Instr]) gen_code_for_overloaded_methods(Method+ methods, (TypeName => Type) typedefs)
    {
      a_method = an_elem(methods);
      name = a_method.name;
      arity = length(a_method.args);
      return ((name, arity) => gen_method_code(a_method)) if size(methods) == 1;
      sorted_methods = rand_sort(methods);
      comp_methods = merge([((ex_method_symbol(m.name, i), arity) => gen_method_code(m)) : m @ i <- sorted_methods]);
      disp_method_code = gen_dispatch_method_body(automaton.name, sorted_methods, typedefs);
      return comp_methods & ((name, arity) => disp_method_code);
    }
  }


  [Instr] gen_method_code(Method method)
  {
    // If the automaton has never been updated before, we do it now
    // init_code = [do_if(is_new, [update_inputs(automaton.name)])];

    // First step is copying the method parameters (if there are any)
    // where they can be accessed by the update procedure
    par_copy_code = [set_var(v, fn_par(i)) : unused_var, v @ i <- method.args];

    // Then we mark for update all the state relevant state variables
    queue_update_code = join(rand_sort({gen_queue_update_code(a, e) : e @ a <- method.asgnms}));

    // Now we setup all the method calls on nested automata
    method_call_setup_code = join(rand_sort(
      {gen_method_call_setup_code(id, info.method, info.args) : info @ id <- method.calls}
    ));

    // Now we call the update procedure
    //## BUG BUG BUG: THIS IS WRONG, I NEED TO "DISABLE" DISCRETE INPUTS
    call_code = [update_inputs(automaton.name, elapsed_time)];

    // We can now clear all copied parameters
    clear_code = [reset_memb_var(v, :blank) : unused_var, v <- method.args];

    return par_copy_code & queue_update_code & method_call_setup_code & call_code & clear_code;


    [Instr] gen_queue_update_code(Atom bare_state_var_id, Expr new_value)
    {
      state_var_id = std_block_node_id(bare_state_var_id);
      expr_idx = match (nodes_by_id[state_var_id])
                   state() n? = index_first(new_value, n.exprs);
      return [
        set_ivar(update_source_var(bare_state_var_id), expr_idx),
        queue_update(automaton.name, state_var_id)
      ];
    }


    [Instr] gen_method_call_setup_code(Atom bare_auto_id, MethodSymbol method, [Expr] args)
    {
      auto_id = std_block_node_id(bare_auto_id);
      node = nodes_by_id[auto_id];
      node = match (node) nested_auto_node() = node; //## UGLY UGLY UGLY
      call_idx = 1 + index_first((method, args), node.calls);
      return [
        set_ivar(update_source_var(bare_auto_id), call_idx),
        queue_update(automaton.name, auto_id)
      ];
    }
  }


  [Instr] gen_init_method_body((MembBoolVar, Bool)* memb_bool_vars, (MembIntVar, Int)* memb_int_vars, (<MembVar, MembObjVar, MethodArg>, <blank, undefined>)* memb_obj_vars)
  {
    // Initializing all boolean member variables
    code_0 = [set_bvar(var, init_val) : var, init_val <- rand_sort(memb_bool_vars)];

    // Initializing all integer member variables
    code_1 = [set_ivar(var, init_val) : var, init_val <- rand_sort(memb_int_vars)];

    // Initializing all object member variables (save for new inputs) to blank
    code_2 = [init_memb_var(var, init_val) : var, init_val <- rand_sort(memb_obj_vars)];

    // Creating the list of node that are initially marked for update
    marked_nodes = {id : v_iv <- memb_bool_vars, v = left(v_iv), iv = right(v_iv), marked_for_update_var(id?) << v, iv};
    marked_nodes_by_level = [intersection(ns, marked_nodes) : ns @ l <- nodes_ids_by_level];

    // Initializing variables that contain the list of nodes that must be updated.
    code_3 = join([
      [set_ivar(nodes_to_update_var(l, i), nodes_idxs[n]) : n @ i <- rand_sort(marked_nodes_by_level[l])]
      : ns @ l <- nodes_ids_by_level, size(ns) > 2
    ]);

    // Now initializing all parameters.
    //## THESE VARIABLES HAVE ALREADY BEEN INITIALIZED TO BLANK, AND THAT'S REDUNDANT
    code_4 = gen_params_init_code(automaton, options);

    code_5 = rand_sort({auto_init(memb_auto_var(id), auto.type) : auto @ id <- automaton.nested_autos});

    return join([code_0, code_1, code_2, code_3, code_4, code_5]);
  }


  [Instr] gen_update_method_body([AutoNode^] nodes, Nat* nested_cond_ids, (BlockNodeId => BlockNodeId*) downstream_nodes)
  {
    memb_copy_vars = memb_copy_vars(automaton);
    memb_copy_var_ids = {name(v) : v <- memb_copy_vars};

    //## BAD: I SHOULD BE USING A UNION PATTERN, JUST LIKE THIS:
    // multivalue_node_expr_count = (t.id => length(t.exprs) : t <- set(node_types), state() | derived_disc() << t);
    multivalue_node_expr_count = (t.id => length(t.exprs) : t <- set(nodes), state() << t) &
                                 (t.id => length(t.exprs) : t <- set(nodes), derived_disc() << t);

    node_idx_var = ivar(0);
    node_count_var = ivar(1);

    let (auto_name                  = automaton.name,
         auto_vars_types            = (memb_auto_var(id) => auto.type : auto @ id <- automaton.nested_autos),
         multivalue_node_expr_count = multivalue_node_expr_count,
         memb_copy_var_ids          = memb_copy_var_ids,
         nested_cond_ids            = nested_cond_ids,
         next_int_var_id            = 2)

      nodes_code_by_id = merge([(n.id => gen_any_node_code(n)) : n <- nodes]);

      //## WHAT DOES THIS DO? I HAVE NO IDEA...
      //## AND WHAT IS IT DOING INSIDE THE LET STATEMENT?
      queue_memb_copy_updates_code = [
        do_if(
          memb_has_changed(id),
          [mark_for_update(d, false) : d <- rand_sort(downstream_nodes[std_block_node_id(id)])]
        ) : id <- rand_sort(memb_copy_var_ids)
      ];
    ;

    levels_code = [gen_level_code(rand_sort(ids), nodes_code_by_id, i, levels_offsets[i], node_idx_var, node_count_var) : ids @ i <- nodes_ids_by_level];

    first_pass_finish_code = [set_bvar(is_new, false)];
    if (disc_inputs_ids != {})
      if (levels_sizes[0] > 2)
        counter_var = ivar(0); //## ivar(0) IS ALREADY USED ELSEWHERE
        first_pass_finish_code = [first_pass_finish_code | set_ivar(counter_var, 0)];
        for (id : rand_sort(disc_inputs_ids))
          first_pass_finish_code = [first_pass_finish_code |
            do_if(
              marked_for_update_var(std_block_node_id(id)),
              [ set_ivar(nodes_to_update_var(0, counter_var), nodes_idxs[std_block_node_id(id)]), // For input nodes, the global index and the level index coincide
                set_ivar(counter_var, add(counter_var, 1))
              ]
            )];
        ;
        first_pass_finish_code = [first_pass_finish_code | set_ivar(update_count_var(0), counter_var)];
      ;
      //## BUG BUG BUG: WHAT HAPPENS IF THE FIRST TIME THE UPDATE PROCEDURE IS CALLED, IT IS CALLED THROUGH A METHOD?
      //## TRY TO FIGURE OUT WHAT MAKES SENSE IN THAT CASE.
      //## MY CURRENT UNDERSTANDING (WHICH MAY WELL BE WRONG) IS THAT THE UPDATE IS FIRST CALLED
      //## THROUGH THE METHOD, BUT IGNORING THE DISCRETE INPUTS, AND THEN THE DISCRETE INPUTS ARE APPLIED,
      //## BUT WITHOUT THE OVERRIDING PROVIDED BY THE METHOD. DOES THAT MAKE SENSE?
      first_pass_finish_code = [first_pass_finish_code | update_inputs(automaton.name, 0)];
    ;

    update_code = [reset_memb_var(memb_var(id), :blank) : id <- rand_sort(disc_sgns_ids)] &
                  [set_var(v, memb_var(name(v))) : v <- rand_sort(memb_copy_vars)] &
                  join(levels_code) & [do_if(is_new, first_pass_finish_code)];

    init_memb_copies_code = [set_bvar(memb_has_changed(id), false) : id <- rand_sort(memb_copy_var_ids)];

    update_code = init_memb_copies_code & update_code & queue_memb_copy_updates_code;
    update_code = add_time_loop(update_code) if in(automaton.name, time_sensitive_autos);

    return update_code;


    [Instr] add_time_loop([Instr] core_code)
    {
      i0 = ivar(0); //## NOT SURE ABOUT THIS ONE

      time_varying_nodes_by_idx = merge({(i => a) : i @ a <- time_varying_node_idxs});
      assert time_varying_nodes_by_idx == reverse(time_varying_node_idxs);

      header_code = [
        set_ivar(curr_time, update_time),
        do_if(
          is_gt(time_triggers_count_var, 0),
          [ set_ivar(i0, trigger_times_heap_var(0)),
            do_if(
              is_le(i0, update_time),
              [ set_ivar(curr_time, i0),
                repeat([
                  set_ivar(i0, time_varying_cond_ids_heap_var(0)),
                  switch_on_nat(
                    i0,
                    [ { node_id = time_varying_nodes_by_idx[i];
                        if (has_key(automaton.nested_autos, get_inner_id(node_id)))
                          return [queue_update(automaton.name, node_id)];
                        else
                          return [queue_cond_update(automaton.name, node_id, false)];
                        ;
                      } : i < nz_nat(size(time_varying_nodes_by_idx))
                    ]
                  ),
                  clear_timer(automaton.name, i0),
                  break_if(
                    or_else([
                      is_eq(time_triggers_count_var, 0),
                      neg(is_eq(trigger_times_heap_var(0), curr_time))
                    ])
                  )
                ])
              ]
            )
          ]
        )
      ];

      return [
        set_ivar(update_time, add(last_update_time, elapsed_time)),
        set_ivar(last_update_time, update_time),
        repeat(nonempty(header_code & core_code & [break_if(is_eq(curr_time, update_time))]))
      ];
    }
  }



  [Instr] gen_level_code([BlockNodeId^] nodes_ids, (BlockNodeId => [Instr]) nodes_code_by_id, Nat level_idx, Nat level_offset, IntVar node_idx_var, IntVar node_count_var)
  {
    update_count_var = update_count_var(level_idx);
    node_count = length(nodes_ids);

    nodes_code = [
      { code = nodes_code_by_id[id];
        is_disc_input = match (id)
          std_block_node_id(a?) = level_idx == 0 and in(a, disc_inputs_ids),
          _                     = false;
        code = [do_if(neg(is_new), code)] if is_disc_input;
        return code;
      }
      : id <- nodes_ids
    ];

    if (node_count > 2)
      switch_expr = sub(nodes_to_update_var(level_idx, node_idx_var), level_offset);
      code = [
        set_ivar(node_idx_var, 0),
        set_ivar(node_count_var, update_count_var),
        repeat([
          break_if(is_eq(node_idx_var, node_count_var)),
          switch_on_nat(switch_expr, nonempty(nodes_code)),
          set_ivar(node_idx_var, add(node_idx_var, 1))
        ]),
        set_ivar(update_count_var, 0)
      ];

    else
      code = [do_if(marked_for_update_var(nodes_ids[i]), nodes_code[i]) : i < node_count];
    ;

    code = [do_if(is_eq(curr_time, update_time), code)] if level_idx == 0 and in(automaton.name, time_sensitive_autos);

    return code;
  }
}

////////////////////////////////////////////////////////////////////////////////

[Instr] gen_params_init_code(Automaton automaton, CompilationOptions options)
{
  param_ids = keys(automaton.params);
  dep_map = (a => {unsafe_name(v) : v <- extern_vars(e)} : e @ a <- automaton.params);
  assert not (? ts @ s <- dep_map, t <- ts : not in(t, param_ids));
  sorted_params = topological_sort(dep_map);
  auto_vars_types = (memb_auto_var(id) => auto.type : auto @ id <- automaton.nested_autos);
  let (auto_vars_types = auto_vars_types, next_obj_var_id = 0, next_int_var_id = 0, next_bool_var_id = 0, options = options)
    params_init_code = [
      [gen_safe_eval_code(automaton.params[p], memb_var(p)) : p <- rand_sort(ps)]
      : ps <- sorted_params
    ];
  ;
  return join([join(cfs) : cfs <- params_init_code]);
}

////////////////////////////////////////////////////////////////////////////////

[Instr] gen_dispatch_method_body(AutoSymbol auto_type, [Method^] methods, (TypeName => Type) typedefs)
{
  assert length(methods) > 1;
  assert size(set([m.name : m <- methods])) == 1;         // All methods must have the same name
  assert size(set([length(m.args) : m <- methods])) == 1; // All methods have the same arity

  a_method    = head(methods);
  name        = a_method.name;
  some_args   = nonempty(a_method.args);
  arity       = nz_nat(length(a_method.args));

  candidates = [];
  for (i < length(some_args))
    arg_col = [m.args[i] : m <- methods];
    ptypes  = [pseudotype(left(a), typedefs) : a <- arg_col];
    good = all([all([are_disjoint(p1, p2) : p2 <- right_subseq(ptypes, j+1)]) : p1 @ j <- ptypes]); //## BAD: INEFFICIENT. ALSO A BIT UGLY...
    candidates = [candidates | i] if good;
  ;

  //## DO WE NEED TO IMPLEMENT THE CASE IN WHICH THERE'S NO SINGLE ARGUMENT THAT CAN BE USED FOR DISPATCH?
  fail if candidates == [];

  //## IF THERE'S MORE THAN ONE CANDIDATE PARAMETER, WE SHOULD CHOOSE THE ONE
  //## THAT CAN MAKE THE DISPATCH MORE EFFICIENT, NOT JUST THE FIRST ONE
  dispatch_arg = head(candidates);

  cases = [(
      ptrns:  [type_to_pseudotype_pattern(left(m.args[dispatch_arg]), typedefs)],
      code:   [ update_inputs(
                  type:         auto_type,
                  call:         (name: ex_method_symbol(m.name, i), args: [fn_par(j) : j < length(m.args)]),
                  elapsed_time: elapsed_time
                ),
                exit_block
              ]
    ) : m @ i <- methods
  ];
  code = gen_switch_code([fn_par(dispatch_arg)], lvar(0), cases, next_obj_var_id=1);

  return code;
}

Block gen_auto_code(Automaton automaton, CompilationOptions options)
{
  nodes = gen_auto_nodes(automaton);
  fail if nodes == []; //## BUG BUG BUG

  nodes_types = [t : unused_var_1, unused_var_2, t <- nodes];

  nodes_idxs = merge([(get_id(t) => i) : t @ i <- nodes_types]);
  nodes_levels = merge([(get_id(t) => l) : l, unused_var_1, t <- nodes]);
  nodes_deps = merge([(get_id(t) => ds) : unused_var_1, ds, t <- nodes]);

  levels_sizes = count_vector([l : l, unused_var_1, unused_var_2 <- nodes]);
  levels_offsets = [0] & partial_sums(levels_sizes);

  param_ids = keys(automaton.params);
  input_ids = keys(automaton.inputs);
  state_var_ids = keys(automaton.state);
  rule_ids = keys(automaton.rules);
  cond_nodes = {t : t <- set([t : unused_var_1, unused_var_2, t <- nodes]), cond_node() << t}; //## BIT UGLY.
  cond_ids = {c.id : c <- cond_nodes};
  rep_cond_nodes = {t : t <- set([t : unused_var_1, unused_var_2, t <- nodes]), rep_cond_node() << t};
  rep_cond_ids = {c.id : c <- rep_cond_nodes};
  nested_cond_ids = {c.id : c <- cond_nodes, c.parent != nil};

  memb_copy_vars = memb_copy_vars(automaton);
  memb_copy_var_ids = {name(v) : v <- memb_copy_vars};

  state_update_expr_count = (t.id => length(t.exprs) : t <- set(nodes_types), state() << t);

  node_idx_var = ivar(0);
  node_count_var = ivar(1);

  let (auto_name = automaton.name, nodes_idxs = nodes_idxs, nodes_levels = nodes_levels,
       state_update_expr_count = state_update_expr_count, memb_copy_var_ids = memb_copy_var_ids,
       nested_cond_ids = nested_cond_ids, next_int_var_id = 2, options = options)

    nodes_code = [gen_node_code(n, l, ds) : l, ds, n <- nodes];

    queue_memb_copy_updates_code = [
      do_if(
        memb_has_changed(id),
        [mark_for_update(d, false) : d <- rand_sort(nodes_deps[id])]
      ) : id <- rand_sort(memb_copy_var_ids)
    ];
  ;

  params_init_code = gen_params_init_code(automaton, options);
  state_vars_early_init_code, late_state_vars_init_code = gen_state_vars_init_code(automaton, options);

  nodes_code_and_ids_by_level = nodes_code_and_ids_by_level(nodes, nodes_code);

  levels_code = [gen_level_code(node_data, i, levels_offsets[i], node_idx_var, node_count_var) : node_data @ i <- nodes_code_and_ids_by_level];

  init_code = params_init_code & state_vars_early_init_code & late_state_vars_init_code;
  if (init_code != [])
    before_init = [head(levels_code) if levels_code != []];
    after_init = if length(levels_code) > 1 then right_subseq(levels_code, 1) else [];
    levels_code = before_init & [[do_if(is_new, init_code)]] & after_init;
  ;

  update_code = [set_var(v, memb_var(name(v))) : v <- rand_sort(memb_copy_vars)] &
                join(levels_code) & [set_bvar(is_new, false)];

  init_memb_copies_code = [set_bvar(memb_has_changed(id), false) : id <- rand_sort(memb_copy_var_ids)];
  update_code = init_memb_copies_code & update_code & queue_memb_copy_updates_code;

  memb_obj_vars       = {memb_var(a) : a <- param_ids & input_ids & state_var_ids & rule_ids} &
                        {new_input(a) : a <- input_ids};
  memb_int_vars       = {update_source_var(a) : a <- state_var_ids} &
                        set([update_count_var(l) : s @ l <- levels_sizes, s > 2]);
  memb_int_vect_vars  = set([nodes_to_update_vect_var(l, nz_nat(s)) : s @ l <- levels_sizes, s > 2]);
  memb_bool_vars      = {cond_value_var(n) : n <- cond_ids} &
                        {cond_is_def_var(n) : n <- cond_ids} &
                        {cond_expr_value_var(n) : n <- nested_cond_ids} &
                        {cond_expr_is_def_var(n) : n <- nested_cond_ids} &
                        {cond_expr_up_to_date_var(n) : n <- nested_cond_ids} &
                        {marked_for_update_var(id) : id <- param_ids & input_ids & state_var_ids & rule_ids & cond_ids & rep_cond_ids} &
                        {is_new};

  //## SOME INITIALIZATIONS ARE REDUNDANT OR UNNECESSARY
  init_code = [init_memb_var(memb_var(a))  : a <- rand_sort(param_ids & input_ids & state_var_ids & rule_ids)] &
              [clear_var(new_input(a)) : a <- rand_sort(input_ids)] &
              [set_ivar(v, -1) : v <- rand_sort(memb_int_vars)] &
              [set_ivar(update_count_var(l), if l == 0 then s else 0) : s @ l <- levels_sizes, s > 2] &
              [set_bvar(v, bool_memb_var_init_value(v, input_ids)) : v <- rand_sort(memb_bool_vars)] &
              join([[set_ivar(nodes_to_update_var(l, i), if l == 0 then i else -1) : i < s] : s @ l <- levels_sizes, s > 2]);

  memb_vars_to_rel = param_ids & input_ids & state_var_ids & rule_ids;
  vars_to_rel = {memb_var(id) : id <- memb_vars_to_rel} & {new_input(id) : id <- input_ids};
  cleanup_code = [do_if(var_is_def(v), [release(v), clear_var(v)]) : v <- rand_sort(vars_to_rel)];

  node_ids = [get_id(t) : unused_var_1, unused_var_2, t <- nodes];
  let (nodes_idxs = nodes_idxs, nodes_levels = nodes_levels, levels_sizes = levels_sizes,
       nested_cond_ids = nested_cond_ids, next_int_var_id = 0)
    queue_update_code = (id => queue_update_method_body(id) : id <- set(node_ids));
  ;

  assert {
    inputs_count = size(automaton.inputs);
    for (l, unused_var_2, node_type @ i : nodes)
      is_input = match (node_type)
        input()  = true,
        _        = false;
      if (i < inputs_count)
        return false if l != 0 or not is_input;
      else
        return false if l == 0 or is_input;
      ;
    ;
    return true;
  };
  sorted_input_ids = subseq(node_ids, 0, size(automaton.inputs));
  fail if not sorted_input_ids :: [Atom]; //## BAD: RUNTIME TYPE CHECKING SHOULD NOT BE NEEDED HERE

  return block(
    name:               automaton.name,
    inputs:             sorted_input_ids,
    outputs:            keys(automaton.outputs),
    memb_vars:          memb_obj_vars & memb_int_vars & memb_int_vect_vars & memb_bool_vars,
    init_code:          init_code,
    update_code:        update_code,
    cleanup_code:       cleanup_code,
    queue_update_code:  queue_update_code
  );


  Bool bool_memb_var_init_value(MembBoolVar, Atom* input_ids):
    cond_is_def_var()                 = true,
    is_new                            = true,
    marked_for_update_var(Atom id?)   = in(id, input_ids),
    // cond_expr_is_def_var()            = ???,
    _                                 = false;


  [[([Instr], <Atom, Nat>)^]] nodes_code_and_ids_by_level([(Nat, <Atom, Nat>*, AutoNodeType)] nodes, [[Instr]] nodes_code)
  {
    curr_level = 0;
    curr_level_data = [];
    node_data_by_level = [];
    for (l, unused_var_1, t @ i : nodes)
      if (l != curr_level)
        assert l == curr_level + 1;
        node_data_by_level = [node_data_by_level | nonempty(curr_level_data)];
        curr_level = curr_level + 1;
        curr_level_data = [];
      ;
      curr_level_data = [curr_level_data | (nodes_code[i], get_id(t))];
    ;
    node_data_by_level = [node_data_by_level | nonempty(curr_level_data)] if nodes != [];
    return node_data_by_level;
  }


  [Instr] gen_level_code([([Instr], <Atom, Nat>)^] nodes_data, Nat level_idx, Nat level_offset, IntVar node_idx_var, IntVar node_count_var)
  {
    update_count_var = update_count_var(level_idx);
    node_count = length(nodes_data);
    nodes_code, node_ids = unzip(nodes_data);
    assert node_count > 0;

    if (node_count <= 2)
      code = [do_if(marked_for_update_var(node_ids[i]), nodes_code[i]) : i < node_count];

    else
      switch_expr = sub(nodes_to_update_var(level_idx, node_idx_var), level_offset);
      code = [
        set_ivar(node_idx_var, 0),
        set_ivar(node_count_var, update_count_var),
        repeat([
          break_if(is_eq(node_idx_var, node_count_var)),
          switch_on_nat(switch_expr, nonempty(nodes_code)),
          set_ivar(node_idx_var, add(node_idx_var, 1))
        ]),
        set_ivar(update_count_var, 0)
      ];
    ;

    return code;
  }
}

////////////////////////////////////////////////////////////////////////////////

[Instr] gen_params_init_code(Automaton automaton, CompilationOptions options)
{
  param_ids = keys(automaton.params);
  dep_map = (a => {unsafe_name(v) : v <- extern_vars(e)} : e @ a <- automaton.params);
  assert not (? ts @ s <- dep_map, t <- ts : not in(t, param_ids));
  sorted_params = topological_sort(dep_map);
  let (next_obj_var_id = 0, next_int_var_id = 0, next_bool_var_id = 0, options = options)
    params_init_code = [
      [gen_safe_eval_code(automaton.params[p], memb_var(p)) : p <- rand_sort(ps)]
      : ps <- sorted_params
    ];
  ;
  return join([join(cfs) : cfs <- params_init_code]);
}


([Instr], [Instr]) gen_state_vars_init_code(Automaton automaton, CompilationOptions options)
{
  param_ids = keys(automaton.params);
  input_ids = keys(automaton.inputs);
  state_var_ids = keys(automaton.state);

  dep_map = (a => {unsafe_name(v) : v <- extern_vars(s.init_value)} - param_ids : s @ a <- automaton.state);
  assert not (? ts @ s <- dep_map, t <- ts : not in(t, state_var_ids) and not in(t, input_ids));

  shallow_input_dep_map = (s => intersection(ts, input_ids) : ts @ s <- dep_map);
  deep_input_dep_map = (s => intersection(ts, input_ids) : ts @ s <- transitive_closure(shallow_input_dep_map));

  early_init_vars = {s : ts @ s <- deep_input_dep_map, ts == {}};
  late_init_vars = {s : ts @ s <- deep_input_dep_map, ts != {}};

  early_init_vars_dep_map = (v => dep_map[v] : v <- early_init_vars);
  assert not (? ts @ s <- early_init_vars_dep_map : not subset(ts, early_init_vars));
  sorted_early_init_vars = [intersection(ns, state_var_ids) : ns <- topological_sort(early_init_vars_dep_map)];

  late_init_vars_dep_map = (v => dep_map[v] - early_init_vars : v <- late_init_vars);
  sorted_late_init_vars = [intersection(ns, state_var_ids) : ns <- topological_sort(late_init_vars_dep_map)];

  let (next_obj_var_id = 0, next_int_var_id = 0, next_bool_var_id = 0, options = options)
    early_init_code = [
      [gen_safe_eval_code(automaton.state[sv].init_value, memb_var(sv)) : sv <- rand_sort(svs)]
      : svs <- sorted_early_init_vars
    ];

    late_init_code = [
      [gen_safe_eval_code(automaton.state[sv].init_value, memb_var(sv)) : sv <- rand_sort(svs)]
      : svs <- sorted_late_init_vars
    ];
  ;

  return (join([join(cfs) : cfs <- early_init_code]), join([join(cfs) : cfs <- late_init_code]));
}

////////////////////////////////////////////////////////////////////////////////

using
{
  AutoSymbol            auto_name,
  (<Atom, Nat> => Nat)  nodes_idxs,
  (<Atom, Nat> => Nat)  nodes_levels,
  (Atom => Nat)         state_update_expr_count,
  Atom*                 memb_copy_var_ids,
  Nat*                  nested_cond_ids,
  Nat                   next_int_var_id,
  CompilationOptions    options;


  [Instr] gen_node_code(AutoNodeType node_type, Nat level, <Atom, Nat>* dep_nodes)
  {
    code = match (node_type)
      input(id?)      = gen_input_node_code(id, dep_nodes),
      derived()       = gen_derived_node_code(node_type.id, node_type.expr, dep_nodes),
      state()         = gen_state_node_code(node_type.id, node_type.exprs, dep_nodes),
      cond_node()     = gen_cond_node_code(node_type.id, node_type.cond, node_type.parent, node_type.updates, dep_nodes),
      rep_cond_node() = gen_rep_cond_node_code(node_type.id, node_type.cond, node_type.parent, node_type.updates, dep_nodes);
    return code & [set_bvar(marked_for_update_var(get_id(node_type)), false)];
  }


  [Instr^] gen_input_node_code(Atom id, <Atom, Nat>* dep_nodes)
  {
    l0 = lvar(0);
    l1 = lvar(1);
    memb_var = memb_var(id);
    body = [set_var(memb_var, l0), set_bvar(memb_has_changed(id), true) if in(id, memb_copy_var_ids)] &
           [mark_for_update(n, false) : n <- rand_sort(dep_nodes)];
    return [
      get_new_input(l0, id),
      clear_var(new_input(id)),
      set_var(l1, memb_var),
      do_if_not(is_eq(l0, l1), body)
    ];
  }


  [Instr^] gen_derived_node_code(Atom id, Expr expr, <Atom, Nat>* dep_nodes)
  {
    var = memb_var(id);
    nv_var = lvar(0);
    eval_code = gen_safe_eval_code(expr, nv_var, next_obj_var_id = 1, next_bool_var_id = 0);
    cond = neg(is_eq(var, nv_var));
    body = [set_var(var, nv_var), set_bvar(memb_has_changed(id), true) if in(id, memb_copy_var_ids)] &
           [mark_for_update(n, false) : n <- rand_sort(dep_nodes)];
    return [eval_code | do_if(cond, body)];
  }


  [Instr^] gen_state_node_code(Atom id, [Expr] exprs, <Atom, Nat>* dep_nodes)
  {
    var = memb_var(id);
    nv_var = lvar(0);
    let (next_obj_var_id = 1, next_bool_var_id = 0)
      cases = nonempty([gen_safe_eval_code(e, nv_var) : e <- exprs] & [[clear_loc_var(nv_var)]]);
      eval_instr = switch_on_nat(update_source_var(id), cases);
    ;
    cond = neg(is_eq(var, nv_var));
    body = [set_var(var, nv_var), set_bvar(memb_has_changed(id), true) if in(id, memb_copy_var_ids)] &
           [mark_for_update(n, false) : n <- rand_sort(dep_nodes)];
    return [eval_instr, do_if(cond, body)];
  }


  [Instr] gen_cond_node_code(Nat id, Expr cond, Maybe[(id: Nat, trigger: Bool)] parent, UpdateInfo* updates, <Atom, Nat>* dep_nodes)
  {
    l0 = lvar(0);
    b0 = bvar(0);
    b1 = bvar(1);
    id_var = cond_value_var(id);
    cond_is_def_var = cond_is_def_var(id);

    // Evaluating the condition and storing the result in l0
    cond_eval_code = gen_cond_eval_code(id, cond, parent);

    // Propagating the update to dependent conditions
    dep_conds_update_prop_code = [mark_for_update(n, true) : n <- rand_sort(dep_nodes)];

    // Base case, the condition stays defined. b1 holds the value of the condition, b0 whether it has changed
    // If the condition has changed, we queue the updates for the appropriate branch
    cond_stays_def_branch = [
      set_bvar(b1, inline_is_eq(l0, obj_true)),
      set_bvar(b0, neg(is_eq(id_var, b1))),
      set_bvar(id_var, b1),
      do_if(
        and([b0, neg(is_new)]),
        [ branch_or_no_op(
            b1,
            join(rand_sort({gen_update_code(u.state, u.value_idx) : u <- updates, u.trigger == true})),
            join(rand_sort({gen_update_code(u.state, u.value_idx) : u <- updates, u.trigger == false}))
          )
        ]
      )
    ];

    // If the condition is now defined. If it was already defined before, we run the
    // standard code. Otherwise, there's nothing to do, except storing its new value.
    // In either case, we propagate the update to all dependent nodes
    cond_is_def_branch = [
      branch(
        cond_is_def_var,
        cond_stays_def_branch,
        [ set_bvar(id_var, inline_is_eq(l0, obj_true)),
          set_bvar(cond_is_def_var, true)
        ]
      )
    ] & dep_conds_update_prop_code;

    // The condition is undefined. If it already was, there's nothing we need to do.
    // If, on the other hand, it has just become undefined, we need execute all the
    // assignments with a null value. We also propagate the update to all dependent conditions.
    cond_is_undef_branch = [
      do_if(
        cond_is_def_var,
        [ set_bvar(cond_is_def_var, false),
          do_if_not(is_new, join(rand_sort({gen_clear_code(u.state) : u <- updates})))
        ] & dep_conds_update_prop_code
      )
    ];

    return cond_eval_code & [branch(var_is_def(l0), cond_is_def_branch, cond_is_undef_branch)];
  }


  [Instr] gen_rep_cond_node_code(Nat id, Expr cond, Maybe[(id: Nat, trigger: Bool)] parent, UpdateInfo* updates, <Atom, Nat>* dep_nodes)
  {
    l0 = lvar(0);

    // Evaluating the condition and storing the result in l0
    cond_eval_code = gen_rep_cond_eval_code(id, cond, parent, dep_nodes != {});

    // Executing all the actions associated with the condition
    action_exec_code = [
      branch(
        var_is_def(l0),
        // The condition is defined, we run the normal actions
        [ branch_or_no_op(
            inline_is_eq(l0, obj_true),
            // The condition is true, running the 'then' branch
            join(rand_sort({gen_update_code(u.state, u.value_idx) : u <- updates, u.trigger == true})),
            // The condition is false, running the 'else' branch
            join(rand_sort({gen_update_code(u.state, u.value_idx) : u <- updates, u.trigger == false}))
          )
        ],
        // The condition is not defined, we execute all assignments with a null value
        join(rand_sort({gen_clear_code(u.state) : u <- updates}))
      )
    ];

    // Propagating the update to all dependent condition nodes
    update_prop_code = [mark_for_update(n, true) : n <- rand_sort(dep_nodes)];

    return [do_if_not(is_new, cond_eval_code & action_exec_code & update_prop_code)];
  }


  [Instr] gen_cond_eval_code(Nat id, Expr cond, Maybe[(id: Nat, trigger: Bool)] parent)
  {
    l0 = lvar(0);

    // Evaluating the local condition. If there's no parent, that's all we need to do
    loc_cond_eval_code = gen_safe_eval_code(cond, l0, next_obj_var_id = 1, next_bool_var_id = 0);
    return loc_cond_eval_code if parent == nil;

    // Local condition variables
    cv_var = cond_expr_value_var(id);
    cd_var = cond_expr_is_def_var(id);
    utd_var = cond_expr_up_to_date_var(id);

    // Overall condition variables
    id_var = cond_value_var(id);

    // Parent condition variables
    pd_var = cond_is_def_var(parent.id);
    pid_var = cond_value_var(parent.id);

    return [
      // Getting the value of the local condition in l0.
      // The value is not necessarly the correct one,
      // when the and condition is determined by the parent anyway
      branch(
        // No need to refresh the local condition if it's not up-to-date
        // Also, if the parent is defined and not equal to the trigger value,
        // the overall condition is false anyway, so no need to refresh
        and([pd_var, is_eq(pid_var, parent.trigger), neg(utd_var)]),

        // Evaluating the local condition and permanently storing its value
        loc_cond_eval_code & [
          set_bvar(cv_var, inline_is_eq(l0, obj_true)),
          set_bvar(cd_var, var_is_def(l0)),
          set_bvar(utd_var, true)
        ],

        // Pulling the stored, and not necessarly up-to-date, value into l0
        [ branch(
            cd_var,
            [set_var(l0, to_obj(id_var))],
            [clear_loc_var(l0)]
          )
        ]
      ),

      // Evaluating the overall condition by anding the local condition and its parent
      branch(
        pd_var,
        [do_if_not(is_eq(pid_var, parent.trigger), [set_var(l0, obj_false)])],
        [do_if_not(inline_is_eq(l0, obj_false), [clear_loc_var(l0)])]
      )
    ];
  }


  [Instr] gen_rep_cond_eval_code(Nat id, Expr cond, Maybe[(id: Nat, trigger: Bool)] parent, Bool has_deps)
  {
    l0 = lvar(0);

    // Evaluating the local condition.
    cond_eval_code = gen_safe_eval_code(cond, l0, next_obj_var_id = 1, next_bool_var_id = 0);

    // Anding the local condition with the 'parent == trigger' one, if a parent exists
    if (parent != nil)
      pcv_var = rep_cond_value_var(parent.id);
      pcd_var = rep_cond_is_def_var(parent.id);

      cond_eval_code = [
        branch(
          // If the parent variable is defined and different from
          // the trigger value then the overall condition is false
          and([pcd_var, neg(is_eq(pcv_var, parent.trigger))]),
          [set_var(l0, obj_false)],
          // Otherwise, we first calculate the local condition,
          // which is the same as the overall condition unless the
          // parent is undefined and the local condition is true
          [ cond_eval_code |
            do_if(
              and([neg(pcd_var), is_eq(l0, obj_true)]),
              clear_loc_var(l0)
            )
          ]
        )
      ];
    ;

    // Saving the value of the condition for dependent condition, if there are any
    if (has_deps)
      cv_var = rep_cond_value_var(id);
      cd_var = rep_cond_is_def_var(id);

      cond_eval_code = [
        cond_eval_code |
        set_bvar(cv_var, is_eq(l0, obj_true)),
        set_bvar(cd_var, var_is_def(l0))
      ];
    ;

    return cond_eval_code;
  }


  [Instr^] gen_update_code(Atom state, Nat src_idx) = [
      set_ivar(update_source_var(state), src_idx),
      mark_for_update(state, false)
    ];


  [Instr^] gen_clear_code(Atom state) = gen_update_code(state, state_update_expr_count[state]);


  Instr mark_for_update(<Atom, Nat> node_id, Bool from_cond):
    +   = queue_update(auto_name, node_id),
    *   = queue_cond_update(auto_name, node_id, not from_cond and in(node_id, nested_cond_ids));
}


using (<Atom, Nat> => Nat) nodes_idxs, (<Atom, Nat> => Nat) nodes_levels, [Nat] levels_sizes, Nat* nested_cond_ids, Nat next_int_var_id
{
  [Instr] queue_update_method_body(<Atom, Nat> node_id)
  {
    index = nodes_idxs[node_id];
    level = nodes_levels[node_id];
    level_size = levels_sizes[level];

    idx_var = ivar(next_int_var_id);
    mark_var = marked_for_update_var(node_id);
    count_var = update_count_var(level);
    nodes_var = nodes_to_update_var(level, idx_var);

    extra_code = if level_size > 2 then [ set_ivar(idx_var, count_var),
                                          set_ivar(nodes_var, index),
                                          set_ivar(count_var, add(idx_var, 1))
                                        ]
                                   else [];

    code = [do_if(neg(mark_var), [set_bvar(mark_var, true)] & extra_code)];

    if (node_id :: Nat and in(node_id, nested_cond_ids))
      inv_cache_instr = do_if(invalidate_cond_expr_cache, set_bvar(cond_expr_up_to_date_var(node_id), false));
      code = [code | inv_cache_instr];
    ;

    return code;
  }
}

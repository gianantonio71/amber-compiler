type AutoNodeType = input(Atom),
                    derived(id: Atom, expr: Expr),
                    state(id: Atom, exprs: [Expr]),
                    cond_node(id: Nat, cond: Expr, parent: Maybe[(id: Nat, trigger: Bool)], updates: UpdateInfo*);

type UpdateInfo   = (state: Atom, value_idx: Nat, trigger: Bool);

type CondInfo     = ( cond:         Expr,
                      parent:       Maybe[(id: Nat, trigger: Bool)],
                      nested_conds: (id: Nat, trigger: Bool)*,
                      updates:      (state_id: Atom, new_value: Expr, trigger: Bool)*
                    );

////////////////////////////////////////////////////////////////////////////////

AutoNodeType input(Atom id)             = :input(id);
AutoNodeType derived(Atom id, Expr e)   = derived(id: id, expr: e);
AutoNodeType state(Atom id, [Expr] es)  = state(id: id, exprs: es);
AutoNodeType cond_node(Nat id, Expr c, Maybe[(id: Nat, trigger: Bool)] p, UpdateInfo* us) = cond_node(id: id, cond: c, parent: p, updates: us);

////////////////////////////////////////////////////////////////////////////////

<Atom, Nat> get_id(AutoNodeType node_type):
  input(id?)      = id,
  derived()       = node_type.id,
  state()         = node_type.id,
  cond_node()     = node_type.id;

////////////////////////////////////////////////////////////////////////////////

Block gen_auto_code(Automaton automaton, CompilationOptions options)
{
  nodes = gen_auto_nodes(automaton);
  fail if nodes == []; //## BUG BUG BUG

  nodes_types = [t : unused_var_1, unused_var_2, t <- nodes];

  nodes_idxs = merge([(get_id(t) => i) : t @ i <- nodes_types]);
  nodes_levels = merge([(get_id(t) => l) : l, unused_var_1, t <- nodes]);
  nodes_deps = merge([(get_id(t) => ds) : unused_var_1, ds, t <- nodes]);

  levels_sizes = count_vector([l : l, unused_var_1, unused_var_2 <- nodes]);
  levels_offsets = [0] & partial_sums(levels_sizes);

  param_ids = keys(automaton.params);
  input_ids = keys(automaton.inputs);
  state_var_ids = keys(automaton.state);
  rule_ids = keys(automaton.rules);
  cond_nodes = {t : t <- set([t : unused_var_1, unused_var_2, t <- nodes]), cond_node() << t}; //## BIT UGLY.
  cond_ids = {c.id : c <- cond_nodes};
  nested_cond_ids = {c.id : c <- cond_nodes, c.parent != nil};

  memb_copy_vars = memb_copy_vars(automaton);
  memb_copy_var_ids = {name(v) : v <- memb_copy_vars};

  state_update_expr_count = (t.id => length(t.exprs) : t <- set(nodes_types), state() << t);

  node_idx_var = ivar(0);
  node_count_var = ivar(1);

  let (auto_name = automaton.name, nodes_idxs = nodes_idxs, nodes_levels = nodes_levels,
       state_update_expr_count = state_update_expr_count, memb_copy_var_ids = memb_copy_var_ids,
       nested_cond_ids = nested_cond_ids, next_int_var_id = 2, options = options)

    nodes_code = [gen_node_code(n, l, ds) : l, ds, n <- nodes];

    queue_memb_copy_updates_code = [
      do_if(
        memb_has_changed(id),
        [mark_for_update(d, false) : d <- rand_sort(nodes_deps[id])]
      ) : id <- rand_sort(memb_copy_var_ids)
    ];
  ;

  params_init_code = gen_params_init_code(automaton, options);
  state_vars_early_init_code, late_state_vars_init_code = gen_state_vars_init_code(automaton, options);

  nodes_code_and_ids_by_level = nodes_code_and_ids_by_level(nodes, nodes_code);

  levels_code = [gen_level_code(node_data, i, levels_offsets[i], late_state_vars_init_code, node_idx_var, node_count_var) : node_data @ i <- nodes_code_and_ids_by_level];

  update_code = [set_var(v, memb_var(name(v))) : v <- rand_sort(memb_copy_vars)] &
                join(levels_code) & [set_bvar(is_new, false)];

  init_memb_copies_code = [set_bvar(memb_has_changed(id), false) : id <- rand_sort(memb_copy_var_ids)];
  update_code = init_memb_copies_code & update_code & queue_memb_copy_updates_code;

  memb_obj_vars       = {memb_var(a) : a <- param_ids & input_ids & state_var_ids & rule_ids} &
                        {new_input(a) : a <- input_ids};
  memb_int_vars       = {update_source_var(a) : a <- state_var_ids} &
                        set([update_count_var(l) : s @ l <- levels_sizes, s > 2]);
  memb_int_vect_vars  = set([nodes_to_update_vect_var(l, nz_nat(s)) : s @ l <- levels_sizes, s > 2]);
  memb_bool_vars      = {cond_value_var(n) : n <- cond_ids} &
                        {cond_is_def_var(n) : n <- cond_ids} &
                        {cond_expr_value_var(n) : n <- nested_cond_ids} &
                        {cond_expr_is_def_var(n) : n <- nested_cond_ids} &
                        {cond_expr_up_to_date_var(n) : n <- nested_cond_ids} &
                        {marked_for_update_var(id) : id <- param_ids & input_ids & state_var_ids & rule_ids & cond_ids} &
                        {is_new};

  //## SOME INITIALIZATIONS ARE REDUNDANT OR UNNECESSARY
  init_code = params_init_code &
              state_vars_early_init_code &
              [init_memb_var(memb_var(a))  : a <- rand_sort(input_ids & rule_ids)] &
              [clear_var(new_input(a)) : a <- rand_sort(input_ids)] &
              [set_ivar(v, -1) : v <- rand_sort(memb_int_vars)] &
              [set_ivar(update_count_var(l), if l == 0 then s else 0) : s @ l <- levels_sizes, s > 2] &
              [set_bvar(v, bool_memb_var_init_value(v, input_ids)) : v <- rand_sort(memb_bool_vars)] &
              join([[set_ivar(nodes_to_update_var(l, i), if l == 0 then i else -1) : i < s] : s @ l <- levels_sizes, s > 2]);

  memb_vars_to_rel = param_ids & input_ids & state_var_ids & rule_ids;
  vars_to_rel = {memb_var(id) : id <- memb_vars_to_rel} & {new_input(id) : id <- input_ids};
  cleanup_code = [do_if(var_is_def(v), [release(v), clear_var(v)]) : v <- rand_sort(vars_to_rel)];

  node_ids = [get_id(t) : unused_var_1, unused_var_2, t <- nodes];
  let (nodes_idxs = nodes_idxs, nodes_levels = nodes_levels, levels_sizes = levels_sizes,
       nested_cond_ids = nested_cond_ids, next_int_var_id = 0)
    queue_update_code = (id => queue_update_method_body(id) : id <- set(node_ids));
  ;

  assert {
    inputs_count = size(automaton.inputs);
    for (l, unused_var_2, node_type @ i : nodes)
      is_input = match (node_type)
        input()  = true,
        _        = false;
      if (i < inputs_count)
        return false if l != 0 or not is_input;
      else
        return false if l == 0 or is_input;
      ;
    ;
    return true;
  };
  sorted_input_ids = subseq(node_ids, 0, size(automaton.inputs));
  fail if not sorted_input_ids :: [Atom]; //## BAD: RUNTIME TYPE CHECKING SHOULD NOT BE NEEDED HERE

  return block(
    name:               automaton.name,
    inputs:             sorted_input_ids,
    outputs:            keys(automaton.outputs),
    memb_vars:          memb_obj_vars & memb_int_vars & memb_int_vect_vars & memb_bool_vars,
    init_code:          init_code,
    update_code:        update_code,
    cleanup_code:       cleanup_code,
    queue_update_code:  queue_update_code
  );


  Bool bool_memb_var_init_value(MembBoolVar, Atom* input_ids):
    cond_is_def_var()                 = true,
    is_new                            = true,
    marked_for_update_var(Atom id?)   = in(id, input_ids),
    // cond_expr_is_def_var()            = ???,
    _                                 = false;


  [[([Instr], <Atom, Nat>)^]] nodes_code_and_ids_by_level([(Nat, <Atom, Nat>*, AutoNodeType)] nodes, [[Instr]] nodes_code)
  {
    curr_level = 0;
    curr_level_data = [];
    node_data_by_level = [];
    for (l, unused_var_1, t @ i : nodes)
      if (l != curr_level)
        assert l == curr_level + 1;
        node_data_by_level = [node_data_by_level | nonempty(curr_level_data)];
        curr_level = curr_level + 1;
        curr_level_data = [];
      ;
      curr_level_data = [curr_level_data | (nodes_code[i], get_id(t))];
    ;
    node_data_by_level = [node_data_by_level | nonempty(curr_level_data)] if nodes != [];
    return node_data_by_level;
  }


  [Instr] gen_level_code([([Instr], <Atom, Nat>)^] nodes_data, Nat level_idx, Nat level_offset, [Instr] late_state_vars_init_code, IntVar node_idx_var, IntVar node_count_var)
  {
    update_count_var = update_count_var(level_idx);
    node_count = length(nodes_data);
    nodes_code, node_ids = unzip(nodes_data);
    assert node_count > 0;

    if (node_count <= 2)
      code = [do_if(marked_for_update_var(node_ids[i]), nodes_code[i]) : i < node_count];

    else
      switch_expr = sub(nodes_to_update_var(level_idx, node_idx_var), level_offset);
      code = [
        set_ivar(node_idx_var, 0),
        set_ivar(node_count_var, update_count_var),
        repeat([
          break_if(is_eq(node_idx_var, node_count_var)),
          switch_on_nat(switch_expr, nonempty(nodes_code)),
          set_ivar(node_idx_var, add(node_idx_var, 1))
        ]),
        set_ivar(update_count_var, 0)
      ];
    ;

    code = [code | do_if(is_new, late_state_vars_init_code)] if late_state_vars_init_code != [] and level_idx == 0;
    return code;
  }
}

////////////////////////////////////////////////////////////////////////////////

[Instr] gen_params_init_code(Automaton automaton, CompilationOptions options)
{
  param_ids = keys(automaton.params);
  dep_map = (a => {unsafe_name(v) : v <- extern_vars(e)} : e @ a <- automaton.params);
  assert not (? ts @ s <- dep_map, t <- ts : not in(t, param_ids));
  sorted_params = topological_sort(dep_map);
  let (next_obj_var_id = 0, next_int_var_id = 0, next_bool_var_id = 0, options = options)
    params_init_code = [
      [gen_safe_eval_code(automaton.params[p], memb_var(p)) : p <- rand_sort(ps)]
      : ps <- sorted_params
    ];
  ;
  return join([join(cfs) : cfs <- params_init_code]);
}


([Instr], [Instr]) gen_state_vars_init_code(Automaton automaton, CompilationOptions options)
{
  param_ids = keys(automaton.params);
  input_ids = keys(automaton.inputs);
  state_var_ids = keys(automaton.state);

  dep_map = (a => {unsafe_name(v) : v <- extern_vars(s.init_value)} - param_ids : s @ a <- automaton.state);
  assert not (? ts @ s <- dep_map, t <- ts : not in(t, state_var_ids) and not in(t, input_ids));

  shallow_input_dep_map = (s => intersection(ts, input_ids) : ts @ s <- dep_map);
  deep_input_dep_map = (s => intersection(ts, input_ids) : ts @ s <- transitive_closure(shallow_input_dep_map));

  early_init_vars = {s : ts @ s <- deep_input_dep_map, ts == {}};
  late_init_vars = {s : ts @ s <- deep_input_dep_map, ts != {}};

  early_init_vars_dep_map = (v => dep_map[v] : v <- early_init_vars);
  assert not (? ts @ s <- early_init_vars_dep_map : not subset(ts, early_init_vars));
  sorted_early_init_vars = [intersection(ns, state_var_ids) : ns <- topological_sort(early_init_vars_dep_map)];

  late_init_vars_dep_map = (v => dep_map[v] - early_init_vars : v <- late_init_vars);
  sorted_late_init_vars = [intersection(ns, state_var_ids) : ns <- topological_sort(late_init_vars_dep_map)];

  let (next_obj_var_id = 0, next_int_var_id = 0, next_bool_var_id = 0, options = options)
    early_init_code = [
      [gen_safe_eval_code(automaton.state[sv].init_value, memb_var(sv)) : sv <- rand_sort(svs)]
      : svs <- sorted_early_init_vars
    ];

    late_init_code = [
      [gen_safe_eval_code(automaton.state[sv].init_value, memb_var(sv)) : sv <- rand_sort(svs)]
      : svs <- sorted_late_init_vars
    ];
  ;

  return (join([join(cfs) : cfs <- early_init_code]), join([join(cfs) : cfs <- late_init_code]));
}

////////////////////////////////////////////////////////////////////////////////

using
{
  AutoSymbol            auto_name,
  (<Atom, Nat> => Nat)  nodes_idxs,
  (<Atom, Nat> => Nat)  nodes_levels,
  (Atom => Nat)         state_update_expr_count,
  Atom*                 memb_copy_var_ids,
  Nat*                  nested_cond_ids,
  Nat                   next_int_var_id,
  CompilationOptions    options;


  [Instr] gen_node_code(AutoNodeType node_type, Nat level, <Atom, Nat>* dep_nodes)
  {
    code = match (node_type)
      input(id?)  = gen_input_node_code(id, dep_nodes),
      derived()   = gen_derived_node_code(node_type.id, node_type.expr, dep_nodes),
      state()     = gen_state_node_code(node_type.id, node_type.exprs, dep_nodes),
      cond_node() = gen_cond_node_code(node_type.id, node_type.cond, node_type.parent, node_type.updates, dep_nodes);
    return code & [set_bvar(marked_for_update_var(get_id(node_type)), false)];
  }


  [Instr^] gen_input_node_code(Atom id, <Atom, Nat>* dep_nodes)
  {
    l0 = lvar(0);
    l1 = lvar(1);
    memb_var = memb_var(id);
    body = [set_var(memb_var, l0), set_bvar(memb_has_changed(id), true) if in(id, memb_copy_var_ids)] &
           [mark_for_update(n, false) : n <- rand_sort(dep_nodes)];
    return [
      get_new_input(l0, id),
      clear_var(new_input(id)),
      set_var(l1, memb_var),
      do_if_not(is_eq(l0, l1), body)
    ];
  }


  [Instr^] gen_derived_node_code(Atom id, Expr expr, <Atom, Nat>* dep_nodes)
  {
    var = memb_var(id);
    nv_var = lvar(0);
    eval_code = gen_safe_eval_code(expr, nv_var, next_obj_var_id = 1, next_bool_var_id = 0);
    cond = neg(is_eq(var, nv_var));
    body = [set_var(var, nv_var), set_bvar(memb_has_changed(id), true) if in(id, memb_copy_var_ids)] &
           [mark_for_update(n, false) : n <- rand_sort(dep_nodes)];
    return [eval_code | do_if(cond, body)];
  }


  [Instr^] gen_state_node_code(Atom id, [Expr] exprs, <Atom, Nat>* dep_nodes)
  {
    var = memb_var(id);
    nv_var = lvar(0);
    let (next_obj_var_id = 1, next_bool_var_id = 0)
      cases = nonempty([gen_safe_eval_code(e, nv_var) : e <- exprs] & [[clear_loc_var(nv_var)]]);
      eval_instr = switch_on_nat(update_source_var(id), cases);
    ;
    cond = neg(is_eq(var, nv_var));
    body = [set_var(var, nv_var), set_bvar(memb_has_changed(id), true) if in(id, memb_copy_var_ids)] &
           [mark_for_update(n, false) : n <- rand_sort(dep_nodes)];
    return [eval_instr, do_if(cond, body)];
  }


  [Instr] gen_cond_node_code(Nat id, Expr cond, Maybe[(id: Nat, trigger: Bool)] parent, UpdateInfo* updates, <Atom, Nat>* dep_nodes)
  {
    l0 = lvar(0);
    b0 = bvar(0);
    b1 = bvar(1);
    id_var = cond_value_var(id);
    cv_var = cond_expr_value_var(id);
    utd_var = cond_expr_up_to_date_var(id);
    cond_is_def_var = cond_is_def_var(id);

    if (parent != nil)
      cond_expr_is_def_var = cond_expr_is_def_var(id);

      pd_var = cond_is_def_var(parent.id);
      pid_var = cond_value_var(parent.id);

      cond_refresh_body = gen_safe_eval_code(cond, l0, next_obj_var_id = 1, next_bool_var_id = 2) & [
        set_bvar(cv_var, inline_is_eq(l0, obj_true)),
        set_bvar(cond_expr_is_def_var, var_is_def(l0)),
        set_bvar(utd_var, true)
      ];

      cond_refresh_else_body = [
        branch(
          cond_expr_is_def_var,
          [set_var(l0, to_obj(id_var))],
          [clear_loc_var(l0)]
        )
      ];

      cond_refresh_cond = and([pd_var, is_eq(pid_var, parent.trigger), neg(utd_var)]);

      cond_eval_code = [
        branch(cond_refresh_cond, cond_refresh_body, cond_refresh_else_body),
        branch(
          pd_var,
          [do_if_not(is_eq(pid_var, parent.trigger), [set_var(l0, obj_false)])],
          [do_if_not(inline_is_eq(l0, obj_false), [clear_loc_var(l0)])]
        )
      ];

    else
      cond_eval_code = gen_safe_eval_code(cond, l0, next_obj_var_id = 1, next_bool_var_id = 2);
    ;

    state_update_code = branch(
      b1,
      join(rand_sort({gen_update_code(u.state, u.value_idx) : u <- updates, u.trigger == true})),
      join(rand_sort({gen_update_code(u.state, u.value_idx) : u <- updates, u.trigger == false}))
    );
    queue_dep_nodes_updates_code = [mark_for_update(n, true) : n <- rand_sort(dep_nodes)];
    checked_state_update_code = [do_if(and([b0, neg(is_new)]), [state_update_code] & queue_dep_nodes_updates_code)];

    on_becoming_undef_code = [do_if_not(is_new, join(rand_sort({gen_clear_code(u.state) : u <- updates})))];
    cond_is_undef_branch = [do_if(cond_is_def_var, [set_bvar(cond_is_def_var, false)] & on_becoming_undef_code)];

    cond_stays_def_branch = [
      set_bvar(b1, inline_is_eq(l0, obj_true)),
      set_bvar(b0, neg(is_eq(id_var, b1))),
      set_bvar(id_var, b1)
    ] & checked_state_update_code;

    cond_becomes_def_branch = [
      set_bvar(id_var, inline_is_eq(l0, obj_true)),
      set_bvar(cond_is_def_var, true)
    ] & queue_dep_nodes_updates_code;

    cond_is_def_branch = [branch(cond_is_def_var, cond_stays_def_branch, cond_becomes_def_branch)];

    return cond_eval_code & [branch(var_is_def(l0), cond_is_def_branch, cond_is_undef_branch)];
  }


  [Instr^] gen_update_code(Atom state, Nat src_idx) = [
      set_ivar(update_source_var(state), src_idx),
      mark_for_update(state, false)
    ];


  [Instr^] gen_clear_code(Atom state) = gen_update_code(state, state_update_expr_count[state]);


  Instr mark_for_update(<Atom, Nat> node_id, Bool from_cond):
    +   = queue_update(auto_name, node_id),
    *   = queue_cond_update(auto_name, node_id, not from_cond and in(node_id, nested_cond_ids));
}


using (<Atom, Nat> => Nat) nodes_idxs, (<Atom, Nat> => Nat) nodes_levels, [Nat] levels_sizes, Nat* nested_cond_ids, Nat next_int_var_id
{
  [Instr] queue_update_method_body(<Atom, Nat> node_id)
  {
    index = nodes_idxs[node_id];
    level = nodes_levels[node_id];
    level_size = levels_sizes[level];

    idx_var = ivar(next_int_var_id);
    mark_var = marked_for_update_var(node_id);
    count_var = update_count_var(level);
    nodes_var = nodes_to_update_var(level, idx_var);

    extra_code = if level_size > 2 then [ set_ivar(idx_var, count_var),
                                          set_ivar(nodes_var, index),
                                          set_ivar(count_var, add(idx_var, 1))
                                        ]
                                   else [];

    code = [do_if(neg(mark_var), [set_bvar(mark_var, true)] & extra_code)];

    if (node_id :: Nat and in(node_id, nested_cond_ids))
      inv_cache_instr = do_if(invalidate_cond_expr_cache, set_bvar(cond_expr_up_to_date_var(node_id), false));
      code = [code | inv_cache_instr];
    ;

    return code;
  }
}


using Nat next_obj_var_id, Nat next_int_var_id, Nat next_bool_var_id, CompilationOptions options
{
  [Instr^] gen_safe_eval_code(Expr expr, <MembVar, LocVar> res_var):
    and_expr()    = gen_safe_eval_code_for_and_expr(expr.left, expr.right, res_var),
    or_expr()     = gen_safe_eval_code_for_or_expr(expr.left, expr.right, res_var),
    _             = gen_default_safe_eval_code(expr, res_var);


  [Instr^] gen_safe_eval_code_for_and_expr(Expr left_expr, Expr right_expr, <MembVar, LocVar> res_var)
  {
    left_tmp_var = lvar(next_obj_var_id);
    right_tmp_var = lvar(nat(next_obj_var_id + 1));
    let (next_obj_var_id = nat(next_obj_var_id + 2))
      left_eval_code = gen_safe_eval_code(left_expr, left_tmp_var);
      right_eval_code = gen_safe_eval_code(right_expr, right_tmp_var);
    ;
    // If the left term is false, there's no need to compute the right value
    if_false_code = [set_var(res_var, obj_false)];
    // If the left term is true, the right one decides the final value
    if_true_code = [set_var(res_var, right_tmp_var)];
    // If the left term is undefined, then we need to check the value of the right term
    if_undef_code = [branch(is_false(right_tmp_var), [set_var(res_var, obj_false)], [clear_var(res_var)])];
    // true + undefined cases, they both require the evaluation of the right term
    if_not_false_code = [right_eval_code | branch(is_true(left_tmp_var), if_true_code, if_undef_code)];
    // Putting it all together
    return [left_eval_code | branch(is_false(left_tmp_var), if_false_code, if_not_false_code)];
  }


  [Instr^] gen_safe_eval_code_for_or_expr(Expr left_expr, Expr right_expr, <MembVar, LocVar> res_var)
  {
    left_tmp_var = lvar(next_obj_var_id);
    right_tmp_var = lvar(nat(next_obj_var_id + 1));
    let (next_obj_var_id = nat(next_obj_var_id + 2))
      left_eval_code = gen_safe_eval_code(left_expr, left_tmp_var);
      right_eval_code = gen_safe_eval_code(right_expr, right_tmp_var);
    ;
    // If the left term is true, there's no need to compute the right value
    if_true_code = [set_var(res_var, obj_true)];
    // If the left term is false, the right one decides the final value
    if_false_code = [set_var(res_var, right_tmp_var)];
    // If the left term is undefined, then we need to check the value of the right term
    if_undef_code = [branch(is_true(right_tmp_var), [set_var(res_var, obj_true)], [clear_var(res_var)])];
    // false + undefined cases, they both require the evaluation of the right term
    if_not_true_code = [right_eval_code | branch(is_false(left_tmp_var), if_false_code, if_undef_code)];
    // Putting it all together
    return [left_eval_code | branch(is_true(left_tmp_var), if_true_code, if_not_true_code)];
  }


  [Instr^] gen_default_safe_eval_code(Expr expr, <MembVar, LocVar> res_var)
  {
    eval_code = gen_eval_code(
      expr,
      res_var,
      next_set_it_var_id  = 0,
      next_seq_it_var_id  = 0,
      next_map_it_var_id  = 0,
      next_vector_var_id  = 0,
      next_stream_var_id  = 0,
      auto_vars_types     = (),
      ignore_assertions   = options.ignore_assertions
    );

    vars_to_safeguard = non_nullable_vars(expr);
    if (vars_to_safeguard != {})
      cond = and([var_is_def(v) : v <- rand_sort(vars_to_safeguard)]);
      eval_code = [branch(cond, eval_code, [clear_var(res_var)])];
    ;

    return eval_code;
  }
}


<MembVar, MembCopyVar>* non_nullable_vars(Expr expr) //## THIS FUNCTION HAS A REALLY STRANGE NAME. SHOULDN'T IT BE THE OPPOSITE?
{
  //## BUG BUG BUG: THIS IS WRONG. VARIABLES IN is-def EXPRESSIONS SHOULD NOT BE COUNTED HERE
  vs = extern_vars(expr);
  return {v : v <- vs, v :: <MembVar, MembCopyVar>};
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[(Nat, <Atom, Nat>*, AutoNodeType)] gen_auto_nodes(Automaton automaton)
{
  cond_nodes = ();
  next_id = 0;
  for (a : rand_sort(automaton.actions))
    action_conds, next_id = gen_action_nodes(a, next_id, nil);
    cond_nodes = cond_nodes & action_conds;
  ;

  conds_deps = (id => cond_deps(c) : c @ id <- cond_nodes);
  state_trigger_deps = merge_values({(u.state_id => id) : c @ id <- cond_nodes, u <- c.updates});
  state_value_deps = merge_value_sets({(u.state_id => expr_deps(u.new_value)) : c @ id <- cond_nodes, u <- c.updates});
  rules_deps = (a => {unsafe_name(v) : v <- extern_vars(e)} : e @ a <- automaton.rules);

  trigger_dep_map = conds_deps & state_trigger_deps & rules_deps;
  value_dep_map = conds_deps & rules_deps & merge_value_sets({state_trigger_deps, state_value_deps});

  rev_trigger_dep_map = reverse_multi(trigger_dep_map);

  params = keys(automaton.params);
  inputs = keys(automaton.inputs);
  level_0 = params & inputs;

  nodes_by_level = topological_sort((s => new_ts : ts @ s <- value_dep_map, new_ts = ts - level_0 - {s}));

  sorted_nodes = [(0, lookup(rev_trigger_dep_map, i, {}), input(i)) : i <- rand_sort(inputs)];

  update_values = merge_values({(u.state_id => u.new_value) : c @ id <- cond_nodes, u <- c.updates});
  update_values = (s => rand_sort(vs) : vs @ s <- update_values);

  state_vars_ids = keys(automaton.state);

  for (l @ i : nodes_by_level)
    nodes = rand_sort(l);
    for (n : nodes)
      level = nat(i + 1);
      dependent_nodes = lookup(rev_trigger_dep_map, n, {}) - state_vars_ids;
      if (has_key(automaton.rules, n))
        fail if not n :: Atom;
        info = derived(n, automaton.rules[n]);
      elif (has_key(automaton.state, n))
        fail if not n :: Atom;
        info = state(n, update_values[n]);
      elif (has_key(cond_nodes, n))
        fail if not n :: Nat;
        cond_node = cond_nodes[n];
        cond_updates = {(state: u.state_id, value_idx: index_first(u.new_value, update_values[u.state_id]), trigger: u.trigger) : u <- cond_node.updates};
        info = cond_node(n, cond_node.cond, cond_node.parent, cond_updates);
      else
        fail;
      ;
      new_node_info = (level, dependent_nodes, info);
      sorted_nodes = [sorted_nodes | new_node_info];
    ;
  ;

  return sorted_nodes;


  <Atom, Nat>* cond_deps(CondInfo cond)
  {
    parent = cond.parent;
    return expr_deps(cond.cond) & {value(parent).id if parent != nil};
  }

  Atom* expr_deps(Expr e) = {unsafe_name(v) : v <- extern_vars(e)};
}


((Nat => CondInfo), Nat) gen_action_nodes(AutoAction action, Nat root_id, Maybe[(id: Nat, trigger: Bool)] parent)
{
  next_id = nat(root_id + 1);

  updates = {};
  conditions = ();
  nested_conds = {};

  for (a, tv : rand_sort({(a, true) : a <- action.body} & {(a, false) : a <- action.else}))
    if (a :: AutoUpdate)
      updates = updates & {(state_id: a.target, new_value: a.value, trigger: tv)};

    elif (a :: AutoAction) //## BAD BAD: THE TYPECHECKER SHOULD AUTOMATICALLY INFER THE TYPE OF <a> IF WE TAKE THIS BRANCH
      nested_conds = nested_conds & {(id: next_id, trigger: tv)};
      subconds, next_id = gen_action_nodes(a, next_id, just(id: root_id, trigger: tv));
      conditions = conditions & subconds;
    ;
  ;

  return (conditions & (root_id => (cond: action.cond, parent: parent, nested_conds: nested_conds, updates: updates)), next_id);
}

Block gen_auto_code(Automaton automaton, CompilationOptions options)
{
  nodes = gen_auto_nodes(automaton);
  fail if nodes == []; //## BUG BUG BUG

  nodes_idxs = merge([(n.id => i) : n @ i <- nodes]);
  nodes_levels = merge([(n.id => n.level) : n <- nodes]);
  nodes_deps = merge([(n.id => dep_nodes_ids(n)) : n <- nodes]);

  levels_sizes = count_vector([n.level : n <- nodes]);
  fail if not levels_sizes :: [NzNat]; //## UGLY UGLY UGLY
  levels_offsets = [0] & partial_sums(levels_sizes);

  param_ids = keys(automaton.params);
  input_ids = keys(automaton.inputs);
  state_var_ids = keys(automaton.state);
  disc_sgns_ids = discrete_signals(automaton);
  rule_ids = keys(automaton.rules);
  cond_nodes = {t : t <- set(nodes), cond_node() << t}; //## BIT UGLY.
  cond_ids = {c.id : c <- cond_nodes};
  rep_cond_nodes = {t : t <- set(nodes), rep_cond_node() << t};
  rep_cond_ids = {c.id : c <- rep_cond_nodes};
  nested_cond_ids = {c.id : c <- cond_nodes, c.parent != nil};
  disc_inputs_ids = intersection(input_ids, disc_sgns_ids);

  continuous_derived_nodes_ids = rule_ids - disc_sgns_ids;

  obj_memb_var_ids = param_ids & input_ids & state_var_ids & disc_sgns_ids & rule_ids;

  memb_obj_vars       = {memb_var(a) : a <- obj_memb_var_ids} &
                        {new_input(a) : a <- input_ids};
  memb_int_vars       = {update_source_var(a) : a <- state_var_ids & disc_sgns_ids} &
                        set([update_count_var(l) : s @ l <- levels_sizes, s > 2]);
  memb_int_vect_vars  = set([nodes_to_update_vect_var(l, nz_nat(s)) : s @ l <- levels_sizes, s > 2]);
  memb_bool_vars      = {cond_value_var(n) : n <- cond_ids} &
                        {cond_is_def_var(n) : n <- cond_ids} &
                        {cond_expr_value_var(n) : n <- nested_cond_ids} &
                        {cond_expr_is_def_var(n) : n <- nested_cond_ids} &
                        {cond_expr_up_to_date_var(n) : n <- nested_cond_ids} &
                        {marked_for_update_var(id) : id <- obj_memb_var_ids & cond_ids & rep_cond_ids} &
                        {is_new};


  let ( automaton               = automaton,
        options                 = options,

        obj_memb_ids            = obj_memb_var_ids,
        disc_sgns_ids           = disc_sgns_ids,

        cont_inputs_ids         = input_ids - disc_sgns_ids,
        disc_inputs_ids         = intersection(input_ids, disc_sgns_ids),
        state_vars_ids          = state_var_ids,
        cont_derived_vars_ids   = continuous_derived_nodes_ids,
        disc_derived_vars_ids   = disc_sgns_ids - disc_inputs_ids,

        nodes_by_id             = merge(set([(n.id => n) : n <- nodes])),
        nodes_ids_by_level      = [set(l) : l <- nodes_ids_by_level(nodes)],

        nodes_idxs              = nodes_idxs,
        nodes_levels            = nodes_levels,
        levels_offsets          = levels_offsets,
        levels_sizes            = levels_sizes)

    init_code = gen_init_method_body(memb_bool_vars, (id => sv.init_value : sv @ id <- automaton.state));

    update_code = gen_update_method_body(nodes, nested_cond_ids, nodes_deps);
  ;

  memb_vars_to_rel = param_ids & input_ids & state_var_ids & disc_sgns_ids & rule_ids;
  vars_to_rel = {memb_var(id) : id <- memb_vars_to_rel} & {new_input(id) : id <- input_ids};
  cleanup_code = join([[release(v), init_memb_var(v, :blank)] : v <- rand_sort(vars_to_rel)]);

  node_ids = [n.id : n <- nodes];
  let (nodes_idxs = nodes_idxs, nodes_levels = nodes_levels, levels_sizes = levels_sizes,
       nested_cond_ids = nested_cond_ids, next_int_var_id = 0)
    queue_update_code = (id => queue_update_method_body(id) : id <- set(node_ids));
  ;

  assert {
    inputs_count = size(automaton.inputs);
    for (n @ i : nodes)
      is_input = match (n)
        input()  = true,
        _        = false;
      if (i < inputs_count)
        return false if n.level != 0 or not is_input;
      else
        return false if n.level == 0 or is_input;
      ;
    ;
    return true;
  };
  sorted_input_ids = subseq(node_ids, 0, size(automaton.inputs));
  fail if not sorted_input_ids :: [Atom]; //## BAD: RUNTIME TYPE CHECKING SHOULD NOT BE NEEDED HERE

  return block(
    name:               automaton.name,
    inputs:             sorted_input_ids,
    outputs:            keys(automaton.outputs),
    memb_vars:          memb_obj_vars & memb_int_vars & memb_int_vect_vars & memb_bool_vars,
    init_code:          init_code,
    update_code:        update_code,
    cleanup_code:       cleanup_code,
    queue_update_code:  queue_update_code
  );


  [[<Atom, Nat>^]] nodes_ids_by_level([AutoNode] nodes)
  {
    curr_level = 0;
    curr_level_ids = [];
    node_ids_by_level = [];
    for (n @ i : nodes)
      if (n.level != curr_level)
        assert n.level == curr_level + 1;
        node_ids_by_level = [node_ids_by_level | nonempty(curr_level_ids)];
        curr_level = curr_level + 1;
        curr_level_ids = [];
      ;
      curr_level_ids = [curr_level_ids | n.id];
    ;
    node_ids_by_level = [node_ids_by_level | nonempty(curr_level_ids)] if nodes != [];
    return node_ids_by_level;
  }
}

////////////////////////////////////////////////////////////////////////////////

using
{
  Automaton                   automaton,
  CompilationOptions          options,

  Atom*                       obj_memb_ids,
  Atom*                       disc_sgns_ids,

  Atom*                       cont_inputs_ids,
  Atom*                       disc_inputs_ids,
  Atom*                       state_vars_ids,
  Atom*                       cont_derived_vars_ids,
  Atom*                       disc_derived_vars_ids,

  (<Atom, Nat> => AutoNode)   nodes_by_id,
  [<Atom, Nat>+]              nodes_ids_by_level,

  (<Atom, Nat> => Nat)        nodes_levels,
  (<Atom, Nat> => Nat)        nodes_idxs,
  [Nat]                       levels_offsets,
  [NzNat]                     levels_sizes;


  [Instr] gen_init_method_body(MembBoolVar* memb_bool_vars, (Atom => Expr) state_vars_init_value)
  {
    // Initializing all object member variables (save for new inputs) to blank
    code_0 = [init_memb_var(memb_var(a), :blank) : a <- rand_sort(obj_memb_ids)];

    // Initializing new inputs to undefined (if countinuous) or blank (if discrete)
    code_1 = [init_memb_var(new_input(a), :undefined) : a <- rand_sort(cont_inputs_ids)] &
             [init_memb_var(new_input(a), :blank) : a <- rand_sort(disc_inputs_ids)];

    // Initializing all boolean member variables
    code_2 = [set_bvar(v, bool_memb_var_init_value(v)) : v <- rand_sort(memb_bool_vars)];

    // Initializing the update_source_var()
    code_3 = [
      set_ivar(update_source_var(id), state_var_update_source_idx(id, state_vars_init_value[id]))
      : id <- rand_sort(state_vars_ids)
    ] & [set_ivar(update_source_var(id), -1) : id <- rand_sort(disc_derived_vars_ids)];

    // This is the list of nodes that have to be initialized through the normal mechanism
    // during the first update. It consists of all continous inputs and derived signals,
    // state variables and all the coditions, but it does not include discrete signals,
    // which are ignored the first time
    nodes_to_init_by_level = [
      {n : n <- ns, n :: Nat or in(n, cont_inputs_ids) or in(n, cont_derived_vars_ids) or in(n, state_vars_ids)}
      : ns <- nodes_ids_by_level
    ];

    // Initializing variables that keep track of the number of nodes to update
    // For every level that has more than 2 nodes (the threshold for having a switch case)
    // we add all continuous inputs or derived signals to the update list
    code_4 = [set_ivar(update_count_var(l), size(ns)) : ns @ l <- nodes_to_init_by_level, size(nodes_ids_by_level[l]) > 2];

    // Initializing variables that contain the list of nodes that must be updated.
    // Initially only continuous inputs are marked for update
    code_5 = join([
      [set_ivar(nodes_to_update_var(l, i), nodes_idxs[n]) : n @ i <- rand_sort(ns)]
      : ns @ l <- nodes_to_init_by_level, size(nodes_ids_by_level[l]) > 2
    ]);

    // Now initializing all parameters.
    //## THESE VARIABLES HAVE ALREADY BEEN INITIALIZED TO BLANK, AND THAT'S REDUNDANT
    code_6 = gen_params_init_code(automaton, options);

    return join([code_0, code_1, code_2, code_3, code_4, code_5, code_6]);


    Nat state_var_update_source_idx(Atom id, Expr init_val)
    {
      node = nodes_by_id[id];
      return match (node)
        state() = index_first(init_val, node.exprs);
    }


    Bool bool_memb_var_init_value(MembBoolVar):
      cond_is_def_var()               = true,
      is_new                          = true,
      marked_for_update_var(Nat id?)  = true,
      // Variable type            Initially marked for update
      //   continuous input         true
      //   discrete input           false
      //   state variable           true
      //   continuous derived       true
      //   discrete derived         false
      marked_for_update_var(Atom id?) = in(id, cont_inputs_ids) or
                                        in(id, cont_derived_vars_ids) or
                                        in(id, state_vars_ids),
      // cond_expr_is_def_var()          = ???,
      _                               = false;
  }


  [Instr] gen_update_method_body([AutoNode^] nodes, Nat* nested_cond_ids, (<Atom, Nat> => <Atom, Nat>*) nodes_deps)
  {
    memb_copy_vars = memb_copy_vars(automaton);
    memb_copy_var_ids = {name(v) : v <- memb_copy_vars};

    //## BAD: I SHOULD BE USING A UNION PATTERN, JUST LIKE THIS:
    // multivalue_node_expr_count = (t.id => length(t.exprs) : t <- set(node_types), state() | derived_disc() << t);
    multivalue_node_expr_count = (t.id => length(t.exprs) : t <- set(nodes), state() << t) &
                                 (t.id => length(t.exprs) : t <- set(nodes), derived_disc() << t);

    node_idx_var = ivar(0);
    node_count_var = ivar(1);

    let (auto_name                  = automaton.name,
         multivalue_node_expr_count = multivalue_node_expr_count,
         memb_copy_var_ids          = memb_copy_var_ids,
         nested_cond_ids            = nested_cond_ids,
         next_int_var_id            = 2)

      nodes_code_by_id = merge([(n.id => gen_any_node_code(n)) : n <- nodes]);

      queue_memb_copy_updates_code = [
        do_if(
          memb_has_changed(id),
          [mark_for_update(d, false) : d <- rand_sort(nodes_deps[id])]
        ) : id <- rand_sort(memb_copy_var_ids)
      ];
    ;

    levels_code = [gen_level_code(rand_sort(ids), nodes_code_by_id, i, levels_offsets[i], node_idx_var, node_count_var) : ids @ i <- nodes_ids_by_level];

    first_pass_finish_code = [set_bvar(is_new, false)];
    if (disc_inputs_ids != {})
      if (levels_sizes[0] > 2)
        counter_var = ivar(0); //## ivar(0) IS ALREADY USED ELSEWHERE
        first_pass_finish_code = [first_pass_finish_code | set_ivar(counter_var, 0)];
        for (id : rand_sort(disc_inputs_ids))
          first_pass_finish_code = [first_pass_finish_code |
            do_if(
              marked_for_update_var(id),
              [ set_ivar(nodes_to_update_var(0, counter_var), nodes_idxs[id]), // For input nodes, the global index and the level index coincide
                set_ivar(counter_var, add(counter_var, 1))
              ]
            )];
        ;
        first_pass_finish_code = [first_pass_finish_code | set_ivar(update_count_var(0), counter_var)];
      ;
      first_pass_finish_code = [first_pass_finish_code | update_inputs(automaton.name)];
    ;

    update_code = [reset_memb_var(memb_var(id), :blank) : id <- rand_sort(disc_sgns_ids)] &
                  [set_var(v, memb_var(name(v))) : v <- rand_sort(memb_copy_vars)] &
                  join(levels_code) & [do_if(is_new, first_pass_finish_code)];

    init_memb_copies_code = [set_bvar(memb_has_changed(id), false) : id <- rand_sort(memb_copy_var_ids)];

    return init_memb_copies_code & update_code & queue_memb_copy_updates_code;
  }


  [Instr] gen_level_code([<Atom, Nat>^] nodes_ids, (<Atom, Nat> => [Instr]) nodes_code_by_id, Nat level_idx, Nat level_offset, IntVar node_idx_var, IntVar node_count_var)
  {
    update_count_var = update_count_var(level_idx);
    node_count = length(nodes_ids);

    nodes_code = [
      { code = nodes_code_by_id[id];
        return if level_idx == 0 and in(id, disc_inputs_ids)
          then [do_if(neg(is_new), code)]
          else code;
      }
      : id <- nodes_ids
    ];

    if (node_count > 2)
      switch_expr = sub(nodes_to_update_var(level_idx, node_idx_var), level_offset);
      code = [
        set_ivar(node_idx_var, 0),
        set_ivar(node_count_var, update_count_var),
        repeat([
          break_if(is_eq(node_idx_var, node_count_var)),
          switch_on_nat(switch_expr, nonempty(nodes_code)),
          set_ivar(node_idx_var, add(node_idx_var, 1))
        ]),
        set_ivar(update_count_var, 0)
      ];

    else
      code = [do_if(marked_for_update_var(nodes_ids[i]), nodes_code[i]) : i < node_count];
    ;

    return code;
  }
}

////////////////////////////////////////////////////////////////////////////////

[Instr] gen_params_init_code(Automaton automaton, CompilationOptions options)
{
  param_ids = keys(automaton.params);
  dep_map = (a => {unsafe_name(v) : v <- extern_vars(e)} : e @ a <- automaton.params);
  assert not (? ts @ s <- dep_map, t <- ts : not in(t, param_ids));
  sorted_params = topological_sort(dep_map);
  let (next_obj_var_id = 0, next_int_var_id = 0, next_bool_var_id = 0, options = options)
    params_init_code = [
      [gen_safe_eval_code(automaton.params[p], memb_var(p)) : p <- rand_sort(ps)]
      : ps <- sorted_params
    ];
  ;
  return join([join(cfs) : cfs <- params_init_code]);
}

type CondInfo     = [ cond:         Expr,
                      parent:       Maybe[[id: CondNodeId, trigger: Bool]],
                      nested_conds: [[id: CondNodeId, trigger: Bool]],
                      updates:      [[state_id: Atom, new_value: Expr, trigger: Bool]],
                      calls:        [[auto_var: MembAutoVar, method: UpdateMethodSymb, message: Expr, trigger: Bool]]
                    ];

////////////////////////////////////////////////////////////////////////////////

type NestedAutoOutputId = nested_auto_output_id(auto: Atom, output: Atom);
type AutoNodeDependency = BlockNodeId, NestedAutoOutputId;

NestedAutoOutputId nested_auto_output_id(Atom a, Atom o) = nested_auto_output_id(auto: a, output: o);

BlockNodeId dependency_to_node_id(BlockNodeId id)         = id;
BlockNodeId dependency_to_node_id(NestedAutoOutputId id)  = std_block_node_id(id.auto);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[StdBlockNodeId] nested_auto_deps(Expr expr):
  method_call_expr()  = [std_block_node_id(name(expr.var)) if expr.var?],
  _                   = retrieve_from_nested_exprs(expr, nested_auto_deps);


[NestedAutoOutputId] nested_auto_output_deps(Expr expr):
  get_output()        = [nested_auto_output_id(name(expr.var), expr.output)],
  output_is_set()     = [nested_auto_output_id(name(expr.var), expr.output)],
  // This one should never appear outside the body of a procedure
  output_is_def()     = {fail;},
  // This one has an upstream dependency on the entire automaton, not just one
  // (or more) of its outputs. That dependency has to be accounted for through
  // a separate mechanism (see the above nested_auto_deps(...) function)
  // method_call_expr()  = {fail;},
  _                   = retrieve_from_nested_exprs(expr, nested_auto_output_deps);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

using Program program, Automaton automaton
{
  AutoNode* gen_auto_nodes
  {
    input_nodes = (
      input(
        std_block_node_id(i),
        automaton.inputs[i].discrete,
        lookup(trigger_down_nodes_map, std_block_node_id(i), []),
        0
      )
      : i <- rand_sort(keys(automaton.inputs))
    );

    other_nodes = join(((create_auto_node(n, nat(i+1)) : n <- rand_sort(l)) : l @ i <- nodes_by_level));

    return input_nodes & other_nodes;
  }


  [BlockNodeId -> AutoNode] nodes_by_id = merge(set(([n.id -> n] : n <- gen_auto_nodes)));


  [BlockNodeId]* nodes_ids_by_level
  {
    nodes = gen_auto_nodes;
    curr_level = 0;
    curr_level_ids = ();
    res = ();
    for n @ i <- nodes:
      if n.level != curr_level:
        assert n.level == curr_level + 1;
        res = (res | curr_level_ids);
        curr_level = curr_level + 1;
        curr_level_ids = ();
      ;
      curr_level_ids = (curr_level_ids | n.id);
    ;
    res = (res | curr_level_ids) if nodes != ();
    return (set(l) : l <- res);
  }


  [StdBlockNodeId -> Nat] multivalue_node_expr_count =
    [t.id -> length(t.exprs) : t <- set(gen_auto_nodes), state() | derived_disc() << t];


  [BlockNodeId -> Nat] nodes_indexes = merge(([n.id -> i] : n @ i <- gen_auto_nodes));


  Nat* levels_sizes = count_vector((n.level : n <- gen_auto_nodes));


  Nat* levels_offsets = (0) & partial_sums(levels_sizes);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

using Automaton automaton
{
  //////////////////////////////////////////////////////////////////////////////
  /////////////////// Continuous and discrete condition nodes //////////////////

  [CondNodeId -> CondInfo] cond_nodes_by_id
  {
    next_id = 0;
    cond_nodes = [:];
    for a <- rand_sort(automaton.actions):
      nodes, next_id = gen_action_nodes(a, next_id, nil);
      cond_nodes = cond_nodes & nodes;
    ;
    return cond_nodes;
  }


  [CondNodeId -> CondInfo] repeated_cond_nodes_by_id
  {
    already_used_ids = [get_inner_id(id) : unused_var @ id <- cond_nodes_by_id];
    next_id = if already_used_ids != [] then nat(max(already_used_ids) + 1) else 0;
    rep_cond_nodes = [:];
    for a @ i <- rand_sort(automaton.rep_actions):
      nodes, next_id = gen_action_nodes(a, next_id, nil);
      rep_cond_nodes = rep_cond_nodes & nodes;
    ;
    return rep_cond_nodes;
  }

  //////////////////////////////////////////////////////////////////////////////
  ///////////////////// Partial upstream dependency maps ///////////////////////

  [BlockNodeId -> [AutoNodeDependency]] common_up_nodes_map
  {
    // Creating node -> all nodes it depends on mapping
    cond_up_nodes                 = [id -> cond_deps(c) : c @ id <- cond_nodes_by_id];
    rep_cond_up_nodes             = [id -> cond_deps(c) : c @ id <- repeated_cond_nodes_by_id];
    nested_auto_input_up_nodes    = [id -> expr_deps(e) : e @ id <- nested_auto_inputs];
    rules_up_nodes                = [std_block_node_id(a) -> expr_deps(e) : e @ a <- automaton.rules];
    time_rules_up_nodes           = [std_block_node_id(a) -> time_rule_deps(c) : c @ a <- automaton.time_rules];

    // Putting all dependency maps together
    return cond_up_nodes & rep_cond_up_nodes & rules_up_nodes & time_rules_up_nodes & nested_auto_input_up_nodes;
  }


  [StdBlockNodeId -> [BlockNodeId]] state_trigger_up_nodes =
    merge_values(
      //## WHY ARE THE TWO DIFFERENT? A SET COMPREHENSION FOR THE FIRST, AND A MAP COMPREHENSION FOR THE SECOND?
      [[std_block_node_id(u.state_id) -> id] : c @ id <- cond_nodes_by_id, u <- c.updates] &
      [[std_block_node_id(u.state_id) -> id : c @ id <- repeated_cond_nodes_by_id, u <- c.updates]]
    );


  [StdBlockNodeId -> [AutoNodeDependency]] state_value_up_nodes =
    merge_value_sets(
      [[std_block_node_id(u.state_id) -> expr_deps(u.new_value)] : c @ unused_var <- cond_nodes_by_id, u <- c.updates] &
      [[std_block_node_id(u.state_id) -> expr_deps(u.new_value)] : c @ unused_var <- repeated_cond_nodes_by_id, u <- c.updates] &
      [[std_block_node_id(id) -> expr_deps(v.init_value)] : v @ id <- automaton.state]
    );


  [StdBlockNodeId -> [AutoNodeDependency]] nested_autos_trigger_up_nodes
  {
    input_deps = [
      std_block_node_id(auto_id) -> [nested_auto_input_id(auto_id, in_id) : unused_var @ in_id <- auto.args]
      : auto @ auto_id <- automaton.nested_autos
    ];

    cond_deps = merge_values([
      [std_block_node_id(name(c.auto_var)) -> id] : info @ id <- cond_nodes_by_id & repeated_cond_nodes_by_id, c <- info.calls
    ]);

    return merge_value_sets([input_deps, cond_deps]);
  }


  [StdBlockNodeId -> [AutoNodeDependency]] nested_autos_value_up_nodes
  {
    all_args = merge_values([[name(c.target) -> c.message] : a <- all_actions, c <- retrieve_method_calls(a)]);
    return [std_block_node_id(a) -> union([expr_deps(e) : e <- es]) : es @ a <- all_args];
  }

  //////////////////////////////////////////////////////////////////////////////
  /////// Complete upstream dependency maps, for both triggers and values //////

  [BlockNodeId -> [AutoNodeDependency]] trigger_up_nodes_map =
    common_up_nodes_map & state_trigger_up_nodes & nested_autos_trigger_up_nodes;


  [BlockNodeId -> [AutoNodeDependency]] value_up_nodes_map
  {
    all_state_up_nodes = merge_value_sets([state_trigger_up_nodes, state_value_up_nodes]);
    all_nested_autos_up_nodes = merge_value_sets([nested_autos_trigger_up_nodes, nested_autos_value_up_nodes]);
    return common_up_nodes_map & all_state_up_nodes & all_nested_autos_up_nodes;
  }

  //////////////////////////////////////////////////////////////////////////////
  /////////////// Nodes (node ids, actually) sorted into layers ////////////////

  [+BlockNodeId]* nodes_by_level
  {
    level_0 = [std_block_node_id(a) : a <- keys(automaton.params) & keys(automaton.inputs)];
    coalesced_value_down_nodes_map = [s -> [dependency_to_node_id(t) : t <- ts] : ts @ s <- value_up_nodes_map];
    return topological_sort([s -> new_ts : ts @ s <- coalesced_value_down_nodes_map, new_ts = ts - level_0 - [s]]);
  }

  //////////////////////////////////////////////////////////////////////////////
  /////// Downstream dependency maps, again for both triggers and values ///////

  //## TYPECHECKING BUG TYPECHECKING BUG TYPECHECKING BUG
  // [+BlockNodeId -> [+BlockNodeId]] trigger_down_nodes_map
  [BlockNodeId -> [BlockNodeId]] trigger_down_nodes_map
  {
    // Reversing the dependency mapping: node -> all nodes that depend on it
    fat_trigger_down_nodes_map = reverse_multi(trigger_up_nodes_map);
    //## BAD BAD BAD: THIS IS SUPER SUPER UGLY
    return [s -> ts : ts @ s <- fat_trigger_down_nodes_map, s :: BlockNodeId];
  }


  //## TYPECHECKING BUG TYPECHECKING BUG TYPECHECKING BUG
  // [+StdBlockNodeId -> [+Atom -> [BlockNodeId]]] output_trigger_down_nodes_map
  [StdBlockNodeId -> [Atom -> [BlockNodeId]]] output_trigger_down_nodes_map
  {
    // Reversing the dependency mapping: node -> all nodes that depend on it
    fat_trigger_down_nodes_map = reverse_multi(trigger_up_nodes_map);
    // Coalescing all the (automaton, output -> ...) into (automaton -> ...) entries
    pre_output_trigger_down_nodes_map = merge_values(
      [[std_block_node_id(s.auto) -> [s.output -> ts]] : ts @ s <- fat_trigger_down_nodes_map, nested_auto_output_id() << s]
    );
    return [s -> merge_value_sets(ms) : ms @ s <- pre_output_trigger_down_nodes_map];
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

using Program program, Automaton automaton
{
  AutoNode create_auto_node(StdBlockNodeId node_id, Nat level)
  {
    core_id = get_inner_id(node_id);

    if has_key(automaton.nested_autos, core_id):
      msg_disp = if has_key(nested_auto_calls, core_id) then just(nested_auto_calls[core_id]) else nil;
      output_dep_nodes = lookup(output_trigger_down_nodes_map, node_id, [:]);
      assert not (? ns @ o <- output_dep_nodes : not disjoint(ns, [std_block_node_id(id) : id <- state_vars_ids]));
      return nested_auto_node(node_id, msg_disp, output_dep_nodes, level);
    ;

    dep_nodes = lookup(trigger_down_nodes_map, node_id, []);
    assert disjoint(dep_nodes, [std_block_node_id(id) : id <- state_vars_ids]);

    if has_key(automaton.rules, core_id):
      return derived(node_id, automaton.rules[core_id], dep_nodes, level);
    ;

    if has_key(automaton.time_rules, core_id):
      time_cond = automaton.time_rules[core_id];
      return match (time_cond)
        time_varying_boolean_cond()   = time_varying_node(node_id, time_cond.expr, time_cond.time_expr, :boolean, dep_nodes, level),
        time_varying_unchanged_cond() = time_varying_node(node_id, time_cond.expr, time_cond.time_expr, :unchanged, dep_nodes, level),
        time_varying_since_cond()     = discrete_time_varying_node(node_id, time_cond.signals, time_cond.time_expr, time_cond.starts_at_time_0, dep_nodes, level);
    ;

    if has_key(automaton.state, core_id):
      return state(
        node_id,
        lookup(state_vars_and_discrete_signals_update_values, core_id, ()),
        automaton.state[core_id].init_value,
        dep_nodes,
        level
      );
    ;

    if in(core_id, discrete_signals_ids):
      return derived_disc(node_id, state_vars_and_discrete_signals_update_values[core_id], dep_nodes, level);
    ;

    fail;
  }


  AutoNode create_auto_node(CondNodeId node_id, Nat level)
  {
    assert has_key(cond_nodes_by_id, node_id) or has_key(repeated_cond_nodes_by_id, node_id);

    is_rep = has_key(repeated_cond_nodes_by_id, node_id);
    cond_info = if is_rep then repeated_cond_nodes_by_id[node_id] else cond_nodes_by_id[node_id];

    then_actions = actions(cond_info, true);
    else_actions = actions(cond_info, false);

    then_nested_conds = [c.id : c <- cond_info.nested_conds, c.trigger == true];
    else_nested_conds = [c.id : c <- cond_info.nested_conds, c.trigger == false];

    //## UGLY UGLY UGLY: THE TWO CALLS ARE BASICALLY THE SAME
    if is_rep:
      info = rep_cond_node(node_id, cond_info.cond, cond_info.parent, then_actions, else_actions,
                            then_nested_conds, else_nested_conds, level);
    else
      info = cond_node(node_id, cond_info.cond, cond_info.parent, then_actions, else_actions,
                            then_nested_conds, else_nested_conds, level);
    ;

    return info;


    [AutoNodeAction] actions(CondInfo cond_info, Bool trigger_value) = [
      state_update_action(u.state_id, index_first(u.new_value, state_vars_and_discrete_signals_update_values[u.state_id]))
      : u <- cond_info.updates, u.trigger == trigger_value
    ] & [
      method_call_action(bare_id)
      : c <- cond_info.calls, c.trigger == trigger_value, bare_id = name(c.auto_var)
    ];
  }


  AutoNode create_auto_node(NestedAutoInputNodeId node_id, Nat level)
  {
    assert has_key(automaton.nested_autos, node_id.auto);

    expr = nested_auto_inputs[node_id];

    disc_vars = [v : v <- extern_vars(expr), in(unsafe_name(v), discrete_signals_ids)];
    disc_outputs = [
      (memb_auto_var(a), o)
      : ao <- possibly_discrete_nested_auto_output_deps_copy_2(expr),
        a = left(ao),
        o = right(ao),
        output_is_discrete(automaton.nested_autos[a].type, o)
    ];

    is_disc = input_is_discrete(automaton.nested_autos[node_id.auto].type, node_id.input);
    assert is_disc == {disc_vars != [] or disc_outputs != []};

    fail if not disc_vars :: [MembVar]; //## BAD BAD BAD

    return nested_auto_input_node(node_id, expr, disc_vars, disc_outputs, level);
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

([CondNodeId -> CondInfo], Nat) gen_action_nodes(<AutoCondAction, AutoRepAction> action, Nat root_id, Maybe[[id: CondNodeId, trigger: Bool]] parent)
{
  next_id = nat(root_id + 1);

  updates = [];
  calls = [];
  conditions = [:];
  nested_conds = [];

  for a, tv <- rand_sort([(a, true) : a <- action.body] & [(a, false) : a <- action.else]):
    if a :: <AutoUpdate, AutoSetDiscrete>:
      updates = updates & [[state_id: a.target, new_value: a.value, trigger: tv]];
    elif a :: AutoMethodCall:
      calls = calls & [[auto_var: a.target, method: a.method, message: a.message, trigger: tv]];
    else
      fail if not a :: <AutoCondAction, AutoRepAction>; //## BAD BAD: THE TYPECHECKER SHOULD AUTOMATICALLY INFER THE TYPE OF <a> IF WE TAKE THIS BRANCH
      nested_conds = nested_conds & [[id: cond_node_id(next_id), trigger: tv]];
      subconds, next_id = gen_action_nodes(a, next_id, just(id: cond_node_id(root_id), trigger: tv));
      conditions = conditions & subconds;
    ;
  ;

  return (conditions & [cond_node_id(root_id) -> [cond: action.cond, parent: parent, nested_conds: nested_conds, updates: updates, calls: calls]], next_id);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[AutoNodeDependency] time_rule_deps(TimeVaryingCond cond):
  time_varying_boolean_cond()   |
  time_varying_unchanged_cond() = expr_deps(cond.expr),
  time_varying_since_cond()     = union([expr_deps(s) : s <- cond.signals]);


[AutoNodeDependency] cond_deps(CondInfo cond)
{
  parent = cond.parent;
  return expr_deps(cond.cond) & [parent.id if parent != nil];
}


[AutoNodeDependency] expr_deps(Expr expr)
{
  assert extern_vars(expr) :: [<MembVar, MembCopyVar>]; //## BAD BAD BAD
  memb_vars_ids = [std_block_node_id(unsafe_name(v)) : v <- extern_vars(expr), memb_var() << v];
  auto_output_ids = nested_auto_output_deps(expr);
  auto_ids = nested_auto_deps(expr);
  return memb_vars_ids & auto_output_ids & auto_ids;
}

////////////////////////////////////////////////////////////////////////////////

//## THIS FUNCTION HAS TWO COPIES (ONE HERE AND ONE SYNTAX REMOVAL)
//## BECAUSE IT SEEMS WAY TOO SPECIAL PURPOSE TO PUT IN A SHARED FILE.
//## MAYBE THIS COPY COULD BE ELIMINATED IF WE MOVED SOME RESPONSABILITY
//## INTO THE SYNTAX REMOVAL LAYER
[(Atom, Atom)] possibly_discrete_nested_auto_output_deps_copy_2(Expr expr):
  get_output()        = [(name(expr.var), expr.output)],
  // This one is not relevant here because we only care about dependencies
  // that could potentially be discrete, and this signal is always continuous
  output_is_set()     = [],
  // This one should never appear outside the body of a procedure
  output_is_def()     = {fail;},
  // Not relevant either, because this is always a "continuous" signal
  method_call_expr()  = [],
  _                   = retrieve_from_nested_exprs(expr, possibly_discrete_nested_auto_output_deps_copy_2);

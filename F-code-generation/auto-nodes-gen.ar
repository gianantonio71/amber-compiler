type CondInfo     = ( cond:         Expr,
                      parent:       Maybe[(id: CondNodeId, trigger: Bool)],
                      nested_conds: (id: CondNodeId, trigger: Bool)*,
                      updates:      (state_id: Atom, new_value: Expr, trigger: Bool)*
                    );

////////////////////////////////////////////////////////////////////////////////

type NestedAutoOutputId = nested_auto_output_id(auto: Atom, output: Atom);
type AutoNodeDependency = BlockNodeId, NestedAutoOutputId;

NestedAutoOutputId nested_auto_output_id(Atom a, Atom o) = nested_auto_output_id(auto: a, output: o);

BlockNodeId dependency_to_node_id(BlockNodeId id)         = id;
BlockNodeId dependency_to_node_id(NestedAutoOutputId id)  = std_block_node_id(id.auto);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[AutoNode] gen_auto_nodes(Automaton automaton, (AutoSymbol => (Atom => Bool)) auto_input_is_disc, (AutoSymbol => (Atom => Bool)) auto_output_is_disc)
{
  // Generating condition nodes
  cond_nodes, next_id = gen_cond_nodes(automaton, 0);
  rep_cond_nodes = gen_rep_cond_nodes(automaton, next_id);

  // Generating nested automata inputs -> expression map
  nested_auto_inputs = (
    nested_auto_input_id(auto_id, in_id) => expr
    : auto @ auto_id <- automaton.nested_autos, expr @ in_id <- auto.args
  );

  // Creating node -> all nodes it depends on mapping
  conds_deps              = (id => cond_deps(c) : c @ id <- cond_nodes);
  rep_cond_deps           = (id => cond_deps(c) : c @ id <- rep_cond_nodes);
  nested_auto_input_deps  = (id => expr_deps(e) : e @ id <- nested_auto_inputs);
  state_trigger_deps      = map_state_trigger_deps(cond_nodes, rep_cond_nodes);
  state_value_deps        = map_state_value_deps(automaton, cond_nodes, rep_cond_nodes);
  rules_deps              = (std_block_node_id(a) => expr_deps(e) : e @ a <- automaton.rules);
  time_rules_deps         = (std_block_node_id(a) => expr_deps(c.cond) : c @ a <- automaton.time_rules);
  nested_autos_trigger_deps  = (
    std_block_node_id(auto_id) => {nested_auto_input_id(auto_id, in_id) : unused_var @ in_id <- auto.args}
    : auto @ auto_id <- automaton.nested_autos
  );

  // Putting all dependency maps together
  common_dep_map  = conds_deps & rep_cond_deps & rules_deps & time_rules_deps & nested_auto_input_deps & nested_autos_trigger_deps;
  trigger_dep_map = common_dep_map & state_trigger_deps;
  //## SHOULDN'T THE SET OF TRIGGER DEPENDENCIES BE A SUBSET OF THE VALUE DEPENDENCIES?
  //## SO COULDN'T THE FOLLOWING LINE BE JUST value_dep_map = common_dep_map & state_value_deps?
  value_dep_map   = common_dep_map & merge_value_sets({state_trigger_deps, state_value_deps});

  // Reversing the dependency mapping: node -> all nodes that depend on it
  fat_rev_trigger_dep_map = reverse_multi(trigger_dep_map);
  // Coalescing all the (automaton, output -> ...) into (automaton -> ...) entries
  pre_rev_output_trigger_dep_map = merge_values(
    {(std_block_node_id(s.auto) => (s.output => ts)) : ts @ s <- fat_rev_trigger_dep_map, nested_auto_output_id() << s}
  );
  rev_output_trigger_dep_map = (s => merge_value_sets(ms) : ms @ s <- pre_rev_output_trigger_dep_map);
  //## BAD BAD BAD: THIS IS SUPER SUPER UGLY
  rev_trigger_dep_map = (s => ts : ts @ s <- fat_rev_trigger_dep_map, s :: BlockNodeId);

  // Sorting nodes (node ids, actually) into layers
  level_0 = {std_block_node_id(a) : a <- keys(automaton.params) & keys(automaton.inputs)};
  coalesced_value_dep_map = (s => {dependency_to_node_id(t) : t <- ts} : ts @ s <- value_dep_map);
  nodes_by_level = topological_sort((s => new_ts : ts @ s <- coalesced_value_dep_map, new_ts = ts - level_0 - {s}));

  // Collecting all update values for state variables and discrete derived nodes
  update_values = group_and_sort_update_values(automaton, cond_nodes, rep_cond_nodes);

  // Collecting all method calls to nested automata
  nested_auto_calls = group_and_sort_nested_autos_calls(automaton);

  // Collecting the ids of state variables and discrete nodes
  state_vars_ids  = keys(automaton.state);
  disc_signal_ids = {id : input @ id <- automaton.inputs, input.discrete} &
                    union({updated_disc_vars_ids(a) : a <- automaton.actions & automaton.rep_actions});

  // Creating the final sorted list of nodes
  input_nodes = [input(std_block_node_id(i), automaton.inputs[i].discrete, lookup(rev_trigger_dep_map, std_block_node_id(i), {}), 0) : i <- rand_sort(keys(automaton.inputs))];
  let ( automaton                   = automaton,
        auto_input_is_disc          = auto_input_is_disc,
        auto_output_is_disc         = auto_output_is_disc,
        cond_nodes                  = cond_nodes,
        rep_cond_nodes              = rep_cond_nodes,
        update_values               = update_values,
        nested_auto_calls           = nested_auto_calls,
        state_vars_ids              = state_vars_ids,
        disc_signal_ids             = disc_signal_ids,
        nested_auto_inputs          = nested_auto_inputs,
        rev_trigger_dep_map         = rev_trigger_dep_map,
        rev_output_trigger_dep_map  = rev_output_trigger_dep_map
      )

    other_nodes = join([[create_node_info(n, nat(i+1)) : n <- rand_sort(l)] : l @ i <- nodes_by_level]);
  ;

  return input_nodes & other_nodes;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

((CondNodeId => CondInfo), Nat) gen_cond_nodes(Automaton automaton, Nat first_id)
{
  next_id = first_id;
  cond_nodes = ();
  for (a : rand_sort(automaton.actions))
    nodes, next_id = gen_action_nodes(a, next_id, nil);
    cond_nodes = cond_nodes & nodes;
  ;
  return (cond_nodes, next_id);
}


(CondNodeId => CondInfo) gen_rep_cond_nodes(Automaton automaton, Nat first_id)
{
  next_id = first_id;
  rep_cond_nodes = ();
  for (a @ i : rand_sort(automaton.rep_actions))
    nodes, next_id = gen_action_nodes(a, next_id, nil);
    rep_cond_nodes = rep_cond_nodes & nodes;
  ;
  return rep_cond_nodes;
}


((CondNodeId => CondInfo), Nat) gen_action_nodes(<AutoCondAction, AutoRepAction> action, Nat root_id, Maybe[(id: CondNodeId, trigger: Bool)] parent)
{
  next_id = nat(root_id + 1);

  updates = {};
  conditions = ();
  nested_conds = {};

  for (a, tv : rand_sort({(a, true) : a <- action.body} & {(a, false) : a <- action.else}))
    if (a :: AutoAtomicAction)
      updates = updates & {(state_id: a.target, new_value: a.value, trigger: tv)};
    else
      fail if not a :: <AutoCondAction, AutoRepAction>; //## BAD BAD: THE TYPECHECKER SHOULD AUTOMATICALLY INFER THE TYPE OF <a> IF WE TAKE THIS BRANCH
      nested_conds = nested_conds & {(id: cond_node_id(next_id), trigger: tv)};
      subconds, next_id = gen_action_nodes(a, next_id, just(id: cond_node_id(root_id), trigger: tv));
      conditions = conditions & subconds;
    ;
  ;

  return (conditions & (cond_node_id(root_id) => (cond: action.cond, parent: parent, nested_conds: nested_conds, updates: updates)), next_id);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

(StdBlockNodeId => BlockNodeId*) map_state_trigger_deps((CondNodeId => CondInfo) cond_nodes, (CondNodeId => CondInfo) rep_cond_nodes) =
  merge_values(
    {(std_block_node_id(u.state_id) => id) : c @ id <- cond_nodes, u <- c.updates} &
    {(std_block_node_id(u.state_id) => id : c @ id <- rep_cond_nodes, u <- c.updates)}
  );


(StdBlockNodeId => AutoNodeDependency*) map_state_value_deps(Automaton automaton, (CondNodeId => CondInfo) cond_nodes, (CondNodeId => CondInfo) rep_cond_nodes) =
  merge_value_sets(
    {(std_block_node_id(u.state_id) => expr_deps(u.new_value)) : c @ unused_var <- cond_nodes, u <- c.updates} &
    {(std_block_node_id(u.state_id) => expr_deps(u.new_value)) : c @ unused_var <- rep_cond_nodes, u <- c.updates} &
    {(std_block_node_id(id) => expr_deps(v.init_value)) : v @ id <- automaton.state}
  );


(Atom => [Expr]) group_and_sort_update_values(Automaton automaton, (CondNodeId => CondInfo) cond_nodes, (CondNodeId => CondInfo) rep_cond_nodes)
{
  update_values = merge_values(
    {(u.state_id => u.new_value) : c @ unused_var <- cond_nodes, u <- c.updates} &
    {(u.state_id => u.new_value) : c @ unused_var <- rep_cond_nodes, u <- c.updates} &
    {(id => v.init_value)        : v @ id <- automaton.state} &
    {(a => e)                    : m <- automaton.methods, e @ a <- m.asgnms}
  );
  return (s => rand_sort(vs) : vs @ s <- update_values);
}


(Atom => [(MethodSymbol, [Expr])]) group_and_sort_nested_autos_calls(Automaton automaton)
{
  calls = merge_values({(na => (c.method, c.args)) : m <- automaton.methods, c @ na <- m.calls});
  return (na => rand_sort(cs) : cs @ na <- calls);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

using
{
  Automaton                                   automaton,
  (AutoSymbol => (Atom => Bool))              auto_input_is_disc,
  (AutoSymbol => (Atom => Bool))              auto_output_is_disc,
  (CondNodeId => CondInfo)                    cond_nodes,
  (CondNodeId => CondInfo)                    rep_cond_nodes,
  (Atom => [Expr])                            update_values,
  (Atom => [(MethodSymbol, [Expr])])          nested_auto_calls,
  Atom*                                       state_vars_ids,
  Atom*                                       disc_signal_ids,
  (NestedAutoInputNodeId => Expr)             nested_auto_inputs,
  (BlockNodeId => BlockNodeId*)               rev_trigger_dep_map,
  (StdBlockNodeId => (Atom => BlockNodeId*))  rev_output_trigger_dep_map;


  AutoNode create_node_info(StdBlockNodeId node_id, Nat level)
  {
    core_id = get_inner_id(node_id);

    if (has_key(automaton.nested_autos, core_id))
      calls = lookup(nested_auto_calls, core_id, []);
      output_dep_nodes = lookup(rev_output_trigger_dep_map, node_id, ());
      assert not (? ns @ o <- output_dep_nodes : not disjoint(ns, {std_block_node_id(id) : id <- state_vars_ids}));
      return nested_auto_node(node_id, calls, output_dep_nodes, level);
    ;

    dep_nodes = lookup(rev_trigger_dep_map, node_id, {});
    assert disjoint(dep_nodes, {std_block_node_id(id) : id <- state_vars_ids});

    if (has_key(automaton.rules, core_id))
      return derived(node_id, automaton.rules[core_id], dep_nodes, level);
    ;

    if (has_key(automaton.time_rules, core_id))
      time_cond = automaton.time_rules[core_id];
      return time_varying_node(node_id, time_cond.cond, time_cond.time_expr, dep_nodes, level);
    ;

    if (has_key(automaton.state, core_id))
      return state(node_id, lookup(update_values, core_id, []), automaton.state[core_id].init_value, dep_nodes, level);
    ;

    if (in(core_id, disc_signal_ids))
      return derived_disc(node_id, update_values[core_id], dep_nodes, level);
    ;

    fail;
  }


  AutoNode create_node_info(CondNodeId node_id, Nat level)
  {
    assert has_key(cond_nodes, node_id) or has_key(rep_cond_nodes, node_id);

    is_rep = has_key(rep_cond_nodes, node_id);
    node = if is_rep then rep_cond_nodes[node_id] else cond_nodes[node_id];
    then_actions = {
      ( target: u.state_id,
        value_idx: index_first(u.new_value, update_values[u.state_id])
      ) : u <- node.updates, u.trigger == true
    };
    else_actions = {
      ( target: u.state_id,
        value_idx: index_first(u.new_value, update_values[u.state_id])
      ) : u <- node.updates, u.trigger == false
    };
    then_nested_conds = {c.id : c <- node.nested_conds, c.trigger == true};
    else_nested_conds = {c.id : c <- node.nested_conds, c.trigger == false};
    //## UGLY UGLY UGLY: THE TWO CALLS ARE BASICALLY THE SAME
    if (is_rep)
      info = rep_cond_node(node_id, node.cond, node.parent, then_actions, else_actions,
                            then_nested_conds, else_nested_conds, level);
    else
      info = cond_node(node_id, node.cond, node.parent, then_actions, else_actions,
                            then_nested_conds, else_nested_conds, level);
    ;

    return info;
  }


  AutoNode create_node_info(NestedAutoInputNodeId node_id, Nat level)
  {
    assert has_key(automaton.nested_autos, node_id.auto);

    expr = nested_auto_inputs[node_id];

    disc_vars = {v : v <- extern_vars(expr), in(unsafe_name(v), disc_signal_ids)};
    disc_outputs = {
      (memb_auto_var(a), o)
      : ao <- nested_auto_output_value_deps(expr),
        a = left(ao),
        o = right(ao),
        auto_output_is_disc[automaton.nested_autos[a].type][o]
    };

    is_disc = auto_input_is_disc[automaton.nested_autos[node_id.auto].type][node_id.input];
    assert is_disc == (disc_vars != {} or disc_outputs != {});

    fail if not disc_vars :: MembVar*; //## BAD BAD BAD

    return nested_auto_input_node(node_id, expr, disc_vars, disc_outputs, level);
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

AutoNodeDependency* cond_deps(CondInfo cond)
{
  parent = cond.parent;
  return expr_deps(cond.cond) & {parent.id if parent != nil};
}


AutoNodeDependency* expr_deps(Expr expr)
{
  memb_vars_ids = {std_block_node_id(unsafe_name(v)) : v <- extern_vars(expr)};
  auto_output_ids = {nested_auto_output_id(left(d), right(d)) : d <- nested_auto_output_deps(expr)};
  return memb_vars_ids & auto_output_ids;
}


Atom* updated_disc_vars_ids(AutoAtomicAction action):
  update()        = {},
  set_discrete()  = {action.target};


Atom* updated_disc_vars_ids(<AutoCondAction, AutoRepAction> action) =
  union({updated_disc_vars_ids(a) : a <- action.body}) &
  union({updated_disc_vars_ids(a) : a <- action.else});

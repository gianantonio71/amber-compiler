type CondInfo     = ( cond:         Expr,
                      parent:       Maybe[(id: CondNodeId, trigger: Bool)],
                      nested_conds: [(id: CondNodeId, trigger: Bool)],
                      updates:      [(state_id: Atom, new_value: Expr, trigger: Bool)],
                      msg_sends:    [(db_var: MembDBVar, message: Expr, trigger: Bool)]
                    );

////////////////////////////////////////////////////////////////////////////////

type AutoNodeDependency = BlockNodeId, QualMembVar, QualRelVar; // QualMembVar/QualRelVar ARE TOO LOOSE, AUTO/DB LOCAL VARIABLES SHOULD BE RULED OUT.


BlockNodeId dependency_to_node_id(BlockNodeId id)   = id;

StdBlockNodeId dependency_to_node_id(QualAutoMembVar var)  = auto_or_db_var_to_node_id(var.auto_var);
StdBlockNodeId dependency_to_node_id(QualDBMembVar var)    = auto_or_db_var_to_node_id(var.db_var);

StdBlockNodeId dependency_to_node_id(QualRelVar var)  = auto_or_db_var_to_node_id(var.db_var);


StdBlockNodeId auto_or_db_var_to_node_id(AnyAutoVar) =
  loc_auto_var()      = {fail;},
  memb_auto_var(a?)   = std_block_node_id(a);

StdBlockNodeId auto_or_db_var_to_node_id(AnyDBVar var) =
  loc_db_var()      = {fail;},
  memb_db_var(a?)   = std_block_node_id(a),
  nested_db_var()   = auto_or_db_var_to_node_id(var.outer);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit program : Program, automaton : Automaton
{
  AutoNode* gen_auto_nodes
  {
    input_nodes = (
      input(
        std_block_node_id(i),
        automaton.inputs[i].discrete,
        lookup(trigger_down_nodes_map, std_block_node_id(i), []),
        0
      )
      : i <- rand_sort(keys(automaton.inputs))
    );

    other_nodes = join(((create_auto_node(n, nat(i+1)) : n <- rand_sort(l)) : l @ i <- nodes_by_level));

    return input_nodes & other_nodes;
  }


  [BlockNodeId -> AutoNode] nodes_by_id = merge([[n.id -> n] : n <~ gen_auto_nodes]);


  [BlockNodeId]* nodes_ids_by_level
  {
    nodes = gen_auto_nodes;
    curr_level = 0;
    curr_level_ids = ();
    res = ();
    for n @ i <- nodes:
      if n.level != curr_level:
        assert n.level == curr_level + 1;
        res = (res | curr_level_ids);
        curr_level = curr_level + 1;
        curr_level_ids = ();
      ;
      curr_level_ids = (curr_level_ids | n.id);
    ;
    res = (res | curr_level_ids) if nodes != ();
    return (set(l) : l <- res);
  }


  [StdBlockNodeId -> Nat] multivalue_node_expr_count =
    [t.id -> length(t.exprs) : t <~ gen_auto_nodes, state() | derived_disc() ?= t];


  //## SHOULDN'T WE JUST INCLUDE THE PENDING STATE VAR IN THE LIST OF POSSIBLE
  //## VALUES INSIDE THE NODE OBJECT?
  // [Atom -> Nat] pending_state_var_asgnm_indexes = [get_inner_id(id) -> nat(n + 1) : n @ id <- multivalue_node_expr_count];


  [BlockNodeId -> Nat] nodes_indexes = merge(([n.id -> i] : n @ i <- gen_auto_nodes));


  Nat* levels_sizes = count_vector((n.level : n <- gen_auto_nodes));


  Nat* levels_offsets = (0) & partial_sums(levels_sizes);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit automaton : Automaton
{
  //////////////////////////////////////////////////////////////////////////////
  /////////////////// Continuous and discrete condition nodes //////////////////

  [CondNodeId -> CondInfo] cond_nodes_by_id
  {
    next_id = 0;
    cond_nodes = [:];
    for a <- rand_sort(automaton.actions):
      nodes, next_id = gen_action_nodes(a, next_id, nil);
      cond_nodes = cond_nodes & nodes;
    ;
    return cond_nodes;
  }


  [CondNodeId -> CondInfo] repeated_cond_nodes_by_id
  {
    already_used_ids = [get_inner_id(id) : id, unused_var <- cond_nodes_by_id];
    next_id = if already_used_ids != [] then nat(max(already_used_ids) + 1) else 0;
    rep_cond_nodes = [:];
    for a @ i <- rand_sort(automaton.rep_actions):
      nodes, next_id = gen_action_nodes(a, next_id, nil);
      rep_cond_nodes = rep_cond_nodes & nodes;
    ;
    return rep_cond_nodes;
  }

  //////////////////////////////////////////////////////////////////////////////
  ///////////////////// Partial upstream dependency maps ///////////////////////

  [BlockNodeId -> [AutoNodeDependency]] common_up_nodes_map
  {
    // Creating node -> all nodes it depends on mapping
    cond_up_nodes                 = [id -> cond_deps(c) : id, c <- cond_nodes_by_id];
    rep_cond_up_nodes             = [id -> cond_deps(c) : id, c <- repeated_cond_nodes_by_id];
    nested_auto_input_up_nodes    = [id -> expr_deps(e) : id, e <- nested_auto_inputs];
    rules_up_nodes                = [std_block_node_id(a) -> expr_deps(e) : a, e <- automaton.rules];
    time_rules_up_nodes           = [std_block_node_id(a) -> time_rule_deps(c) : a, c <- automaton.time_rules];
    nested_autos_up_nodes         = [std_block_node_id(auto_id) ->
                                      [nested_auto_input_id(auto_id, in_id) : in_id, unused_var <- auto.args]
                                      : auto_id, auto <- automaton.nested_autos
                                    ];

    // Putting all dependency maps together
    return cond_up_nodes & rep_cond_up_nodes & rules_up_nodes & time_rules_up_nodes &
           nested_auto_input_up_nodes & nested_autos_up_nodes;
  }


  [StdBlockNodeId -> [BlockNodeId]] state_trigger_up_nodes =
    merge_values(
      //## WHY ARE THE TWO DIFFERENT? A SET COMPREHENSION FOR THE FIRST, AND A MAP COMPREHENSION FOR THE SECOND?
      [[std_block_node_id(u.state_id) -> id] : id, c <- cond_nodes_by_id, u <- c.updates] &
      [[std_block_node_id(u.state_id) -> id : id, c <- repeated_cond_nodes_by_id, u <- c.updates]]
    );


  [StdBlockNodeId -> [AutoNodeDependency]] state_value_up_nodes =
    merge_value_sets(
      [[std_block_node_id(u.state_id) -> expr_deps(u.new_value)] : unused_var, c <- cond_nodes_by_id, u <- c.updates] &
      [[std_block_node_id(u.state_id) -> expr_deps(u.new_value)] : unused_var, c <- repeated_cond_nodes_by_id, u <- c.updates] &
      [[std_block_node_id(id) -> expr_deps(v.init_value)] : id, v <- automaton.state]
    );


  [StdBlockNodeId -> [AutoNodeDependency]] nested_dbs_trigger_up_nodes = merge_values([
      [std_block_node_id(bare_id(c.db_var)) -> id]
      : id, info <- cond_nodes_by_id & repeated_cond_nodes_by_id, c <- info.msg_sends
    ]);


  [StdBlockNodeId -> [AutoNodeDependency]] nested_dbs_value_up_nodes
  {
    all_args = merge_values([[bare_id(c.target) -> c.message] : a <- all_actions, c <- retrieve_msg_sends(a)]);
    return [std_block_node_id(a) -> union([expr_deps(e) : e <- es]) : a, es <- all_args];
  }

  //////////////////////////////////////////////////////////////////////////////
  /////// Complete upstream dependency maps, for both triggers and values //////

  [BlockNodeId -> [AutoNodeDependency]] trigger_up_nodes_map =
    common_up_nodes_map & state_trigger_up_nodes & nested_dbs_trigger_up_nodes;


  [BlockNodeId -> [AutoNodeDependency]] value_up_nodes_map
  {
    all_state_up_nodes = merge_value_sets([state_trigger_up_nodes, state_value_up_nodes]);
    all_nested_dbs_up_nodes = merge_value_sets([nested_dbs_trigger_up_nodes, nested_dbs_value_up_nodes]);
    return common_up_nodes_map & all_state_up_nodes & all_nested_dbs_up_nodes;
  }

  //////////////////////////////////////////////////////////////////////////////
  /////////////// Nodes (node ids, actually) sorted into layers ////////////////

  [+BlockNodeId]* nodes_by_level
  {
    level_0 = [std_block_node_id(a) : a <- keys(automaton.params) & keys(automaton.inputs)];
    coalesced_value_down_nodes_map = [s -> [dependency_to_node_id(t) : t <- ts] : s, ts <- value_up_nodes_map];
    return topological_sort([s -> new_ts : s, ts <- coalesced_value_down_nodes_map, new_ts = ts - level_0 - [s]]);
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////// Downstream dependency maps, just for triggers ///////////////

  //## TYPECHECKING BUG TYPECHECKING BUG TYPECHECKING BUG
  // [+BlockNodeId -> [+BlockNodeId]] trigger_down_nodes_map
  [BlockNodeId -> [BlockNodeId]] trigger_down_nodes_map
  {
    // Reversing the dependency mapping: node -> all nodes that depend on it
    fat_map = reverse_multi(trigger_up_nodes_map);
    //## BAD BAD BAD: THIS IS SUPER SUPER UGLY
    return [s -> ts : s, ts <- fat_map, s :: BlockNodeId];
  }


  //## TYPECHECKING BUG SAME AS ABOVE
  [StdBlockNodeId -> [MembVar -> [BlockNodeId]]] output_trigger_down_nodes_map
  {
    // Reversing the dependency mapping: node -> all nodes that depend on it: [AutoNodeDependency -> [+BlockNodeId]]
    fat_map = reverse_multi(trigger_up_nodes_map);
    // Coalescing all the (automaton, output -> ...) into (automaton -> ...) entries
    pre_map = merge_values(
      [[dependency_to_node_id(s) -> [one_level_down(s) -> ts]] : s, ts <- fat_map, qual_auto_memb_var() ?= s]
    );
    return [s -> merge_value_sets(ms) : s, ms <- pre_map];
  }


  //## TYPECHECKING BUG SAME AS ABOVE
  [StdBlockNodeId -> [<MembVar, QualDBMembVar, AnyRelVar> -> [BlockNodeId]]] nested_db_vars_trigger_down_nodes_map
  {
    // Reversing the dependency mapping: node -> all nodes that depend on it: [AutoNodeDependency -> [+BlockNodeId]]
    fat_map = reverse_multi(trigger_up_nodes_map);
    // Coalescing all the (automaton, output -> ...) into (automaton -> ...) entries
    pre_map = [
      [dependency_to_node_id(s) -> [one_level_down(s) -> ts]]
      : s, ts <- fat_map, qual_db_memb_var() | qual_rel_var() ?= s
    ];
    return [s -> merge_value_sets(ms) : s, ms <- merge_values(pre_map)];
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit program : Program, automaton : Automaton
{
  AutoNode create_auto_node(StdBlockNodeId node_id, Nat level)
  {
    core_id = get_inner_id(node_id);

    if has_key(automaton.nested_dbs, memb_db_var(core_id)):
      msg = nested_msg_sends[core_id];
      output_dep_nodes = lookup(nested_db_vars_trigger_down_nodes_map, node_id, [:]);
      //## WHAT DOES THIS ASSERTION DO?
      assert not (o, ns <- output_dep_nodes : not disjoint(ns, [std_block_node_id(id) : id <- state_vars_ids]));
      return nested_db_node(node_id, msg, output_dep_nodes, level);
    ;

    if has_key(automaton.nested_autos, core_id):
      output_dep_nodes = lookup(output_trigger_down_nodes_map, node_id, [:]);
      //## WHAT DOES THIS ASSERTION DO?
      assert not (o, ns <- output_dep_nodes : not disjoint(ns, [std_block_node_id(id) : id <- state_vars_ids]));
      return nested_auto_node(node_id, output_dep_nodes, level);
    ;

    dep_nodes = lookup(trigger_down_nodes_map, node_id, []);
    assert disjoint(dep_nodes, [std_block_node_id(id) : id <- state_vars_ids]);

    if has_key(automaton.rules, core_id):
      return derived(node_id, automaton.rules[core_id], dep_nodes, level);
    ;

    if has_key(automaton.time_rules, core_id):
      time_cond = automaton.time_rules[core_id];
      return match (time_cond)
        time_varying_boolean_cond()   = time_varying_node(node_id, time_cond.expr, time_cond.time_expr, :boolean, dep_nodes, level),
        time_varying_unchanged_cond() = time_varying_node(node_id, time_cond.expr, time_cond.time_expr, :unchanged, dep_nodes, level),
        time_varying_since_cond()     = discrete_time_varying_node(node_id, time_cond.signals, time_cond.time_expr, time_cond.starts_at_time_0, dep_nodes, level);
    ;

    if has_key(automaton.state, core_id):
      return state(
        node_id,
        lookup(state_vars_and_discrete_signals_update_values, core_id, ()),
        automaton.state[core_id].init_value,
        dep_nodes,
        level
      );
    ;

    if in(core_id, discrete_signals_ids):
      return derived_disc(node_id, state_vars_and_discrete_signals_update_values[core_id], dep_nodes, level);
    ;

    fail;
  }


  AutoNode create_auto_node(CondNodeId node_id, Nat level)
  {
    assert has_key(cond_nodes_by_id, node_id) or has_key(repeated_cond_nodes_by_id, node_id);

    is_rep = has_key(repeated_cond_nodes_by_id, node_id);
    cond_info = if is_rep then repeated_cond_nodes_by_id[node_id] else cond_nodes_by_id[node_id];

    then_actions = actions(cond_info, true);
    else_actions = actions(cond_info, false);

    then_nested_conds = [c.id : c <- cond_info.nested_conds, c.trigger == true];
    else_nested_conds = [c.id : c <- cond_info.nested_conds, c.trigger == false];

    //## UGLY UGLY UGLY: THE TWO CALLS ARE BASICALLY THE SAME
    if is_rep:
      info = rep_cond_node(node_id, cond_info.cond, cond_info.parent, then_actions, else_actions,
                            then_nested_conds, else_nested_conds, level);
    else
      info = cond_node(node_id, cond_info.cond, cond_info.parent, then_actions, else_actions,
                            then_nested_conds, else_nested_conds, level);
    ;

    return info;


    [AutoNodeAction] actions(CondInfo cond_info, Bool trigger_value) = [
      state_update_action(u.state_id, index_first(u.new_value, state_vars_and_discrete_signals_update_values[u.state_id]))
      : u <- cond_info.updates, u.trigger == trigger_value
    ] & [
      msg_send_action(bare_id)
      : c <- cond_info.msg_sends, c.trigger == trigger_value, bare_id = bare_id(c.db_var)
    ];
  }


  AutoNode create_auto_node(NestedAutoInputNodeId node_id, Nat level)
  {
    assert has_key(automaton.nested_autos, node_id.auto);

    expr = nested_auto_inputs[node_id];
    is_disc = input_is_discrete(automaton.nested_autos[node_id.auto].type, node_id.input);

    //## BY DOING THIS WE ARE ALSO INCLUDING THE VARIABLES IN THE is_set() EXPRESSIONS,
    //## WHICH SHOULD BE FINE AS THOSE VARIABLES SHOULD NEVER APPEAR IN THE INPUT OF A
    //## NESTED AUTOMATON.
    //## REMEMBER TO CHECK THIS IN THE WELL-FORMEDNESS CHECKING LAYER.
    //## WOULD BE NICE TO ADD AN ASSERT HERE, AS WELL.
    //## WE ARE ALSO IGNORING THE output_is_def() EXPRESSION, WHICH SHOULD BE ALLOWED
    //## ONLY INSIDE THE BODY OF A PROCEDURE
    disc_signals = [v : v <- auto_expr_extern_vars(expr), v :: <MembVar, QualAutoMembVar>, is_discrete(v)];

    assert is_disc == {disc_signals != []};

    return nested_auto_input_node(node_id, expr, disc_signals, level);
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

([CondNodeId -> CondInfo], Nat) gen_action_nodes(<AutoCondAction, AutoRepAction> action, Nat root_id, Maybe[(id: CondNodeId, trigger: Bool)] parent)
{
  next_id = nat(root_id + 1);

  updates = [];
  msg_sends = [];
  conditions = [:];
  nested_conds = [];

  for a, tv <- rand_sort([(a, true) : a <- action.body] & [(a, false) : a <- action.else]):
    if a :: <AutoUpdate, AutoSetDiscrete>:
      updates = updates & [(state_id: a.target, new_value: a.value, trigger: tv)];
    elif a :: AutoMsgSend:
      msg_sends = msg_sends & [(db_var: a.target, message: a.message, trigger: tv)];
    else
      fail if not a :: <AutoCondAction, AutoRepAction>; //## BAD BAD: THE TYPECHECKER SHOULD AUTOMATICALLY INFER THE TYPE OF <a> IF WE TAKE THIS BRANCH
      nested_conds = nested_conds & [(id: cond_node_id(next_id), trigger: tv)];
      subconds, next_id = gen_action_nodes(a, next_id, just(id: cond_node_id(root_id), trigger: tv));
      conditions = conditions & subconds;
    ;
  ;

  new_cond = [
    cond_node_id(root_id) -> (
      cond:         action.cond,
      parent:       parent,
      nested_conds: nested_conds,
      updates:      updates,
      msg_sends:    msg_sends
    )
  ];
  return (conditions & new_cond, next_id);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[AutoNodeDependency] time_rule_deps(TimeVaryingCond cond) =
  time_varying_boolean_cond()   |
  time_varying_unchanged_cond() = expr_deps(cond.expr),
  time_varying_since_cond()     = union([expr_deps(s) : s <- cond.signals]);


[AutoNodeDependency] cond_deps(CondInfo cond)
{
  parent = cond.parent;
  return expr_deps(cond.cond) & [parent.id if parent != nil];
}


[AutoNodeDependency] expr_deps(Expr expr)
{
  vars = extern_vars(expr);
  var_deps = [
    match (v)
      memb_var(a?)          = std_block_node_id(a),
      qual_auto_memb_var()  = v,
      qual_db_memb_var()    = v
    : v <- vars, not v :: MembCopyVar
  ];
  return var_deps & nested_deps(expr);


  [AutoNodeDependency] nested_deps(Expr expr) =
    auto_method_call()  |
    db_method_call()    = [std_block_node_id(bare_id(expr.var)) if expr.var?],
    ex_qual()           = nested_deps(expr.source) & nested_deps(expr.cond),
    set_comp()          = nested_deps(expr.source) & nested_deps(expr.expr),
    map_comp()          = nested_deps(expr.source) & nested_deps(expr.key_expr) & nested_deps(expr.value_expr),
    bin_rel_comp()      |
    tern_rel_comp()     = nested_deps(expr.source) & seq_union((nested_deps(e) : e <- expr.exprs)),
    _                   = retrieve_from_nested_exprs(expr, nested_deps($)); //## BAD: WORKAROUND FOR TYPECHECKING BUG


  [AutoNodeDependency] nested_deps(Clause cls)
  {
    rel_var_deps = match (cls)
      relvar_clause() = { match (cls.rel_var)
                            rel_var()       = [],
                            qual_rel_var()  = [cls.rel_var]
                        },
      _               = [];

    return rel_var_deps & retrieve_from_nested_exprs(cls, nested_deps($)); //## BAD: WORKAROUND FOR TYPECHECKING BUG
  }
}

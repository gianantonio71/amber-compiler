[Int+] retrieve_nested_int_seqs(Expr expr):
  tuple_expr(es?)   = if es :: IntObj+
                        then [(match (e) object(n?) = n : e <- es)]
                        else seq_union((retrieve_nested_int_seqs(e) : e <- es)),
  _                 = retrieve_from_nested_exprs(expr, retrieve_nested_int_seqs($)); //## BAD BAD: THE ($) PART IS A WORKAROUND FOR A BUG IN THE TYPECHECKER


[Int+] retrieve_nested_int_seqs(Statement* stmts) =
  seq_union((retrieve_from_nested_exprs(s, retrieve_nested_int_seqs($)) : s <- stmts)); //## BAD BAD: THE ($) PART IS A WORKAROUND FOR A BUG IN THE TYPECHECKER

////////////////////////////////////////////////////////////////////////////////

[Int+] retrieve_nested_int_seqs(FnDef fd) = retrieve_nested_int_seqs(fd.expr);

[Int+] retrieve_nested_int_seqs(ProcDef2 pd) = retrieve_nested_int_seqs(pd.body);

////////////////////////////////////////////////////////////////////////////////

[Int+] retrieve_nested_int_seqs(TimeVaryingCond cond):
  time_varying_boolean_cond()   |
  time_varying_unchanged_cond() = retrieve_nested_int_seqs(cond.expr),
  time_varying_since_cond()     = [];


[Int+] retrieve_nested_int_seqs(AutoAtomicAction action):
  update()        = retrieve_nested_int_seqs(action.value),
  set_discrete()  = retrieve_nested_int_seqs(action.value),
  method_call()   = retrieve_nested_int_seqs(action.message);


[Int+] retrieve_nested_int_seqs(AutoCondAction action) =
  retrieve_nested_int_seqs(action.cond) &
  union([retrieve_nested_int_seqs(a) : a <- action.body & action.else]);


[Int+] retrieve_nested_int_seqs(AutoRepAction action) =
  retrieve_nested_int_seqs(action.cond) &
  union([retrieve_nested_int_seqs(a) : a <- action.body & action.else]);


[Int+] retrieve_nested_int_seqs(ReadOnlyMethod method) = retrieve_nested_int_seqs(method.expr);


[Int+] retrieve_nested_int_seqs(UpdateMethod method) = retrieve_nested_int_seqs(method.body);


[Int+] retrieve_nested_int_seqs(Automaton auto) =
  union([retrieve_nested_int_seqs(sv.init_value) : sv @ unused_var <- auto.state]) &
  union([retrieve_nested_int_seqs(e) : e @ unused_var <- auto.params]) &
  union([retrieve_nested_int_seqs(e) : e @ unused_var <- auto.rules]) &
  union([retrieve_nested_int_seqs(c) : c @ unused_var <- auto.time_rules]) &
  union([retrieve_nested_int_seqs(a) : a <- auto.actions]) &
  union([retrieve_nested_int_seqs(a) : a <- auto.rep_actions]) &
  union([retrieve_nested_int_seqs(e) : na @ unused_var_1 <- auto.nested_autos, e @ unused_var_2 <- na.args]) &
  union([retrieve_nested_int_seqs(m) : m <- auto.read_only_methods]) &
  union([retrieve_nested_int_seqs(m) : m <- auto.update_methods]);


[Int+] retrieve_nested_int_seqs(Program prg) =
  union([retrieve_nested_int_seqs(fd) : fd <- prg.fndefs]) &
  union([retrieve_nested_int_seqs(pd) : pd <- prg.proc_defs]) &
  union([retrieve_nested_int_seqs(a)  : a  <- prg.auto_defs]);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

using Program program
{
  Int+* int_seqs = rand_sort(retrieve_nested_int_seqs(program));

  [Int+ -> Nat] int_seqs_ids = merge(([s -> i] : s @ i <- int_seqs));

  Bool input_is_discrete(AutoSymbol auto, Atom input) = auto_input_is_discrete_map[auto][input];

  Bool output_is_discrete(AutoSymbol auto, Atom output) = auto_output_is_discrete_map[auto][output];

  Bool is_time_sensitive(AutoSymbol auto) = in(auto, time_sensitive_autos);

  //////////////////////////////////////////////////////////////////////////////

  [AutoSymbol -> [Atom -> Bool]] auto_input_is_discrete_map =
    [a.name -> [id -> input.discrete  : input  @ id <- a.inputs]  : a <- program.auto_defs];


  [AutoSymbol -> [Atom -> Bool]] auto_output_is_discrete_map =
    [a.name -> [id -> output.discrete : output @ id <- a.outputs] : a <- program.auto_defs];


  [AutoSymbol] time_sensitive_autos
  {
    automata = program.auto_defs;
    autos_with_time_rules = [a.name : a <- automata, a.time_rules != [:]];
    auto_shallow_deps = [a.name -> [na.type : na @ unused_var <- a.nested_autos] : a <- automata];
    auto_deep_deps = transitive_closure(auto_shallow_deps);
    autos_with_time_sensitive_nested_autos =  [a.name : a <- automata, not disjoint(auto_deep_deps[a.name], autos_with_time_rules)];
    return autos_with_time_rules & autos_with_time_sensitive_nested_autos;
  }
}
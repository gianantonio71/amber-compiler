Nat+ choose_disp_args(AnyType++ types, [TypeName -> Type] typedefs)
{
  //## IF THERE'S MORE THAN ONE CHOICE OF DISPATCH ARGUMENTS,
  //## WE SHOULD CHOOSE THE ONE THAT IS THE MOST EFFICIENT
  some_types = types(0);
  obj_args = nonempty((i : t @ i <- some_types; t :: NeType));
  ptypes = ((pseudotype(cast_type(ts[i]), typedefs) : i <- obj_args) : ts <- types);
  count = length(obj_args);
  for n = 1...count:
    for idxs <- ordered_combinations(n, count):
      if are_sufficient(idxs, ptypes, typedefs):
        return (obj_args[i] : i <- idxs);
      ;
    ;
  ;
  fail;


  Bool are_sufficient(Nat+ arg_idxs, PseudoType++ ptypes, [TypeName -> Type] typedefs)
  {
    count = length(ptypes);
    for i1 < count-1; i2 = i1+1..count:
      pts1 = ptypes[i1];
      pts2 = ptypes[i2];
      disjoint = (j <~ arg_idxs : are_disjoint(pts1(j), pts2(j)));
      return false if not disjoint;
    ;
    return true;
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[Int+] retrieve_nested_int_seqs(Expr expr):
  tuple_expr(es?)   = if es :: IntObj+
                        then [(match (e) object(n?) = n : e <- es)]
                        else seq_union((retrieve_nested_int_seqs(e) : e <- es)),
  _                 = retrieve_from_nested_exprs(expr, retrieve_nested_int_seqs($)); //## BAD BAD: THE ($) PART IS A WORKAROUND FOR A BUG IN THE TYPECHECKER


[Int+] retrieve_nested_int_seqs(Statement* stmts) =
  seq_union((retrieve_from_nested_exprs(s, retrieve_nested_int_seqs($)) : s <- stmts)); //## BAD BAD: THE ($) PART IS A WORKAROUND FOR A BUG IN THE TYPECHECKER

////////////////////////////////////////////////////////////////////////////////

[Int+] retrieve_nested_int_seqs(Function fn) = retrieve_nested_int_seqs(fn.expr);

[Int+] retrieve_nested_int_seqs(Procedure pc) = retrieve_nested_int_seqs(pc.body);

////////////////////////////////////////////////////////////////////////////////

[Int+] retrieve_nested_int_seqs(TimeVaryingCond cond):
  time_varying_boolean_cond()   |
  time_varying_unchanged_cond() = retrieve_nested_int_seqs(cond.expr),
  time_varying_since_cond()     = [];


[Int+] retrieve_nested_int_seqs(AutoAtomicAction action):
  state_update()        = retrieve_nested_int_seqs(action.value),
  discrete_signal_def() = retrieve_nested_int_seqs(action.value),
  msg_send()            = retrieve_nested_int_seqs(action.message);


[Int+] retrieve_nested_int_seqs(AutoCondAction action) =
  retrieve_nested_int_seqs(action.cond) &
  union([retrieve_nested_int_seqs(a) : a <- action.body & action.else]);


[Int+] retrieve_nested_int_seqs(AutoRepAction action) =
  retrieve_nested_int_seqs(action.cond) &
  union([retrieve_nested_int_seqs(a) : a <- action.body & action.else]);


[Int+] retrieve_nested_int_seqs(Method method) = retrieve_nested_int_seqs(method.expr);


[Int+] retrieve_nested_int_seqs(Update update) = retrieve_nested_int_seqs(update.body);


[Int+] retrieve_nested_int_seqs(Handler handler) = retrieve_nested_int_seqs(handler.body);


[Int+] retrieve_nested_int_seqs(Automaton auto) =
  union([retrieve_nested_int_seqs(sv.init_value) : unused_var, sv <- auto.state]) &
  union([retrieve_nested_int_seqs(p.value) : unused_var, p <- auto.params]) &
  union([retrieve_nested_int_seqs(e) : unused_var, e <- auto.rules]) &
  union([retrieve_nested_int_seqs(c) : unused_var, c <- auto.time_rules]) &
  union([retrieve_nested_int_seqs(a) : a <- auto.actions]) &
  union([retrieve_nested_int_seqs(a) : a <- auto.rep_actions]) &
  union([retrieve_nested_int_seqs(e) : unused_var_1, na <- auto.nested_autos; unused_var_2, e <- na.args]) &
  union([retrieve_nested_int_seqs(m) : m <- auto.methods]);


[Int+] retrieve_nested_int_seqs(DataBase db) =
  union([retrieve_nested_int_seqs(m) : m <- db.methods]) &
  union([retrieve_nested_int_seqs(u) : u <- db.updates]) &
  union([retrieve_nested_int_seqs(h) : h <- db.handlers]);


[Int+] retrieve_nested_int_seqs(Program prg) =
  union([retrieve_nested_int_seqs(fd) : fd <- prg.fndefs]) &
  union([retrieve_nested_int_seqs(pd) : pd <- prg.proc_defs]) &
  union([retrieve_nested_int_seqs(a)  : a  <- prg.auto_defs]) &
  union([retrieve_nested_int_seqs(db) : db <- prg.data_bases]);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

type CounterSet[T] = counter_set(nz_ctrs: [T -> NzNat]);


Nat next_value(CounterSet[T] ctr_set, T ctr) = lookup(ctr_set.nz_ctrs, ctr, 0);


CounterSet[T] increment(CounterSet[T] ctr_set, T ctr)
{
  nz_ctrs = ctr_set.nz_ctrs;
  new_nz_ctrs = if nz_ctrs(ctr, ?)
    then [c -> nz_nat(n + bit(c == ctr)) : c, n <- nz_ctrs]
    else nz_ctrs & [ctr -> 1];
  return counter_set(nz_ctrs: new_nz_ctrs);
}

////////////////////////////////////////////////////////////////////////////////

type GenVarType = obj, int, bool, set_it, seq_it, bin_rel_it, tern_rel_it, table_it, stream, vector;

type VarGen = CounterSet[GenVarType];


VarGen blank_var_gen = counter_set(nz_ctrs: [:]);


(T, VarGen) next_var(VarGen gen, GenVarType var_type, (Nat -> T) mk_var) =
  (mk_var(next_value(gen, var_type)), increment(gen, var_type));
  //## BUG BUG BUG: THE COMPILER FAILED TO DETECT THE WRONG NUMBER
  //## OF ARGUMENTS IN THE next_value() CALL, AND THE DESUGARING CRASHED
  //## WHAT'S GOING ON HERE? WAS IT BECAUSE IT WAS AN ARGUMENT TO A CLOSURE?
  // (mk_var(next_value(gen)), increment(gen, var_type));


//## WHY DID I USE lvar($), ivar($), ... INSTEAD OF lvar, ivar, ...????
(LocVar, VarGen)  next_obj_var(VarGen gen)  = next_var(gen, :obj, lvar($));
(IntVar, VarGen)  next_int_var(VarGen gen)  = next_var(gen, :int, ivar($));
(BoolVar, VarGen) next_bool_var(VarGen gen) = next_var(gen, :bool, bvar($));

(SeqItVar, VarGen) next_seq_it_var(VarGen gen) = next_var(gen, :seq_it, seq_it_var($));

(SetItVar, VarGen) next_set_it_var(VarGen gen) = next_var(gen, :set_it, set_it_var($));
(BinRelItVar,  VarGen) next_bin_rel_it_var(VarGen gen)  = next_var(gen, :bin_rel_it, bin_rel_it_var($));
(TernRelItVar, VarGen) next_tern_rel_it_var(VarGen gen) = next_var(gen, :tern_rel_it, tern_rel_it_var($));

(TableItVar, VarGen) next_table_it_var(VarGen gen, NzNat arity) = next_var(gen, :table_it, table_it_var($, arity));

(StreamVar, VarGen) next_stream_var(VarGen gen) = next_var(gen, :stream, svar($));

(VecVar, VarGen) next_vector_var(VarGen gen, NzNat size) = next_var(gen, :vector, vvar($, size));


(IntVar*, VarGen) next_int_vars(VarGen gen, Nat count)
{
  g = gen;
  vs = ();
  for i < count:
    v, g = next_int_var(g);
    vs = (vs | v);
  ;
  return (vs, g);
}


(BoolVar*, VarGen) next_bool_vars(VarGen gen, Nat count)
{
  g = gen;
  vs = ();
  for i < count:
    v, g = next_bool_var(g);
    vs = (vs | v);
  ;
  return (vs, g);
}

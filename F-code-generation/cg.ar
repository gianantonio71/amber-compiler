
ProcDef* gen_prg_code(Program prg)
{
  simpl_prg  = generate_dispatch_functions(prg);
  memb_tests = gen_needed_memb_test_fns(simpl_prg);
  fndefs     = {gen_fn_code(fd) : fd <- simpl_prg.fndefs};
  proc_defs  = {gen_proc_code(pd) : pd <- simpl_prg.proc_defs};
  return memb_tests & fndefs & proc_defs;
}


BoolProcDef* gen_needed_memb_test_fns(Program prg)
{
  init_types = union({retrieve_types(fd.expr) : fd <- prg.fndefs}) &
               union({retrieve_from_nested_exprs(pd.body, retrieve_types) : pd <- prg.proc_defs});

  type_symbs = union({retrieve_type_symbs(t) : t <- init_types});
  new_type_symbs = type_symbs;
  while (new_type_symbs != {})
    new_types = {expand_type_ref(ts, prg.typedefs) : ts <- new_type_symbs};
    new_type_symbs = union({retrieve_type_symbs(t) : t <- new_types}) - type_symbs;
    type_symbs = type_symbs & new_type_symbs;
  ;

  return {mk_named_type_memb_test_fn(ts, prg.typedefs) : ts <- type_symbs};


  TypeSymbol* retrieve_type_symbs(Type type):
    type_ref(ts?) = {ts} & retrieve_from_nested_types(ts, retrieve_type_symbs),
    _             = retrieve_from_nested_types(type, retrieve_type_symbs);

  Type* retrieve_types(Expr expr):
    membership()  = {expr.type} & retrieve_from_nested_exprs(expr, retrieve_types),
    _             = retrieve_from_nested_exprs(expr, retrieve_types);
}


ObjProcDef gen_proc_code(ProcDef2 proc_def)
{
  fn_res_var = lvar(0);
  tmp_bvar   = bvar(0);

  body = [];

  let ( next_set_it_var_id = 0,
        next_seq_it_var_id = 0,
        next_map_it_var_id = 0,
        next_obj_var_id    = 1,
        next_int_var_id    = 0,
        next_bool_var_id   = 1,
        next_vector_var_id = 0,
        next_stream_var_id = 0)

    //// Checking parameter types
    //for (p @ i : fndef.params)
    //  body = body & gen_type_checking_code(p.type, fn_par(i), tmp_bvar) & [check(tmp_bvar)] if p.type?;
    //;

    // Setting named variables for parameters
    body = body & [set_var(p.var, fn_par(i)) : p @ i <- proc_def.params];

    // Evaluating the expression
    proc_body = proc_def.body;
    body = body & [execute_block(gen_code(proc_body, fn_res_var)) if proc_body != []];

    //// Checking the type of the result
    //if (fndef.res_type?)
    //  body = body & gen_type_checking_code(fndef.res_type, fn_res_var, tmp_bvar) & [check(tmp_bvar)];
    //;
  ;

  debug_code = [push_call_info(proc_def.name, [just(fn_par(i)) : p @ i <- proc_def.params])];
  ret_val = if proc_def.res_type != nil then fn_res_var else object(nil); //## BAD: HERE I'M CHEATING...
  body = debug_code & body & [pop_call_info, ret_val(ret_val)];

  return obj_proc_def(proc_def.name, arity(proc_def) * [:obj], (), nonempty(body), false);
}


ObjProcDef gen_fn_code(FnDef fndef)
{
  fn_res_var = lvar(0);
  tmp_bvar   = bvar(0);

  body = [];

  let ( next_set_it_var_id = 0,
        next_seq_it_var_id = 0,
        next_map_it_var_id = 0,
        next_obj_var_id    = 1,
        next_int_var_id    = 0,
        next_bool_var_id   = 1,
        next_vector_var_id = 0,
        next_stream_var_id = 0)

    //// Checking parameter types
    //for (p @ i : fndef.params)
    //  body = body & gen_type_checking_code(p.type, fn_par(i), tmp_bvar) & [check(tmp_bvar)] if p.type?;
    //;

    // Setting named variables for parameters
    body = body & [set_var_if_need_be(p, i) : p @ i <- fndef.params];

    // Evaluating the expression
    body = body & gen_eval_code(fndef.expr, fn_res_var);

    //// Checking the type of the result
    //if (fndef.res_type?)
    //  body = body & gen_type_checking_code(fndef.res_type, fn_res_var, tmp_bvar) & [check(tmp_bvar)];
    //;
  ;

  body = [push_call_info(fndef.name, [maybe(fn_par(i), is_scalar_par(p)) : p @ i <- fndef.params])] & body & [pop_call_info, ret_val(fn_res_var)];

  ObjProcPar low_level_param(FnFrmPar p):
    scalar_par()      = :obj,
    non_scalar_par()  = if p.var? then cls(p.var, p.arity) else cls(p.arity);

  params = [low_level_param(p) : p <- fndef.params];
  named_params = (v => arity(t) : t @ v <- fndef.named_params);

  cached = fndef.params == [] and fndef.named_params == () and not is_too_simple_to_be_worth_caching(fndef.expr);

  return obj_proc_def(fndef.name, params, named_params, nonempty(body), cached);


  //## UGLY: ISNT THERE ANY BETTER WAY? HAVING TO WRITE A FUNCTIONS FOR SOMETHING SO SIMPLE FEELS OVERKILL
  Instr set_var_if_need_be(FnFrmPar p, Nat i):
    scalar_par()      = if p.var? then set_var(p.var, fn_par(i)) else no_op,
    non_scalar_par()  = no_op;


  Bool is_too_simple_to_be_worth_caching(Expr expr) = is_within_complexity_level(expr, 1);

  Bool is_within_complexity_level(Expr expr, <0..1> max_compl):
    LeafObj         = true,
    FloatLit        = true,
    set_expr(es?)   = es == {},
    seq_expr(es?)   = es == [],
    map_expr(es?)   = es == {},
    tag_obj_expr()  = max_compl > 0 and is_within_complexity_level(expr.tag, 0) and is_within_complexity_level(expr.obj, 0),
    _               = false;
}


Program generate_dispatch_functions(Program prg)
{
  mult_map = bag([[fd.name, arity(fd)] : fd <- rand_sort(prg.fndefs)]); //## BAD: USING A SEQUENCE INSTEAD OF A BAG AND AGAIN A SEQUENCE INSTEAD OF A TUPLE

  overloaded_fns = for (m @ na <- mult_map)
                     if (m > 1) {{
                       fd : fd <- prg.fndefs, [fd.name, arity(fd)] == na
                     }};

  dispatched_fns = union({generate_dispatch_function(fns, prg.typedefs) : fns <- overloaded_fns});

  new_fns = dispatched_fns & (prg.fndefs - union(overloaded_fns));

  return program(
    typedefs:       prg.typedefs,
    proc_defs:      prg.proc_defs,
    subtype_decls:  prg.subtype_decls,
    fndefs:         new_fns
  );
}


FnDef+ generate_dispatch_function(FnDef+ fds, (TypeName => Type) typedefs)
{
  assert size(fds) > 1;
  assert size({length(fd.params) : fd <- fds}) == 1; // All functions have the same arity

  //## I DON'T PARTICULARLY LIKE THIS...
  rand_fd      = an_elem(fds);
  name         = rand_fd.name;
  rand_params  = nonempty(rand_fd.params);
  scalar_pars  = [i : p @ i <- rand_params, is_scalar_par(p)];
  arity        = nz_nat(arity(rand_fd));
  named_params = rand_fd.named_params;

  //## BAD: THIS IS REALLY UGLY. NEED A NON-DESTRUCTIVE OPERATION TO UPDATE THE FIELDS OF A TUPLE
  FnDef make_unique(FnDef fd, Nat i) =
    fn_def(
      name:         unique_fn_symbol(fd.name, i),
      params:       fd.params,
      named_params: fd.named_params,
      res_type:     fd.res_type if fd.res_type?,
      expr:         fd.expr
      // expr:         Expr
    );

  unique_fds = [make_unique(fd, i) : fd @ i <- rand_sort(fds)];

  candidates = [];
  for (i : scalar_pars)
    params = [fd.params[i] : fd <- rand_sort(fds)];
    ptypes = [if p.type? then pseudotype(get_scalar_param_type(p), typedefs) else pseudotype_any : p <- params];
    good = all([all([are_disjoint(p1, p2) : p2 <- right_subseq(ptypes, j+1)]) : p1 @ j <- ptypes]); //## BAD: INEFFICIENT. ALSO A BIT UGLY...
    candidates = candidates & [i] if good;
  ;

  dispatch_call_params = [if is_scalar_par(p) then fn_par(i) else cls_var(i) : p @ i <- rand_params];

  if (candidates != [])
    //## IF THERE'S MORE THAN ONE CANDIDATE PARAMETER, WE SHOULD CHOOSE THE ONE
    //## THAT CAN MAKE THE DISPATCH MORE EFFICIENT, NOT JUST THE FIRST ONE
    dispatch_param = head(candidates);
    cases = [];
    //## HERE WE SHOULD LEAVE THE FUNCTION WITH THE MOST EXPENSIVE CHECKING LAST
    //## (OR RATHER, FIRST, SINCE WE ARE REVERSING THE ORDER) SO THAT IT CAN BE
    //## MATCHED BY THE "ANY" PATTERN.
    for (fd @ i : unique_fds)
      ptrn = if i == 0 then ptrn_any else mk_ptrn(fd.params[dispatch_param], typedefs, true); //## THAT "true" IS UGLY...
      case  = (ptrns: [ptrn], expr: fn_call(fd.name, dispatch_call_params));
      cases = [case] & cases;
    ;
    new_expr = match_expr([fn_par(dispatch_param)], nonempty(cases));

  else
    //## THIS IS ALL WRONG, THERE'S USUALLY NO NEED TO CHECK ALL THE PARAMETERS
    is_checked = bit_map(scalar_pars, arity);
    dispatch_call_params = [if is_scalar_par(p) then fn_par(i) else cls_var(i) : p @ i <- rand_params];
    cases = [];
    for (fd @ i : unique_fds)
      ptrns = [if i == 0 then ptrn_any else mk_ptrn(p, typedefs, is_checked[j]) : p @ j <- nonempty(fd.params)];
      case  = (ptrns: ptrns, expr: fn_call(fd.name, dispatch_call_params));
      cases = [case] & cases;
    ;
    new_expr = match_expr(nonempty([fn_par(i) : i < arity]), nonempty(cases));
  ;

  params = [strip_fn_param(p) : p <- rand_params];

  dispatch_fn = fn_def(
    name:          name,
    params:        params,
    named_params:  named_params,
    //res_type: ????
    expr:          new_expr
  );

  return nonempty(set(unique_fds) & {dispatch_fn});


  Pattern mk_ptrn(FnFrmPar param, (TypeName => Type) typedefs, Bool is_checked) =
    if param.type? and is_checked
      then type_to_pseudotype_pattern(get_scalar_param_type(param), typedefs)
      else ptrn_any;

  Type get_scalar_param_type(FnFrmPar p):
    scalar_par()      = if p.type? then p.type else {fail;},
    non_scalar_par()  = {fail;};

  FnFrmPar strip_fn_param(FnFrmPar p):
    scalar_par()      = :scalar_par(()),
    non_scalar_par()  = non_scalar_par(p.arity);
}

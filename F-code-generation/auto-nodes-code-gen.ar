using
{
  AutoSymbol                  auto_name,
  (MembAutoVar => AutoSymbol) auto_vars_types,
  AutoSymbol*                 time_sensitive_autos,
  (BlockNodeId => Nat)        nodes_idxs,
  (BlockNodeId => Nat)        nodes_levels,
  (StdBlockNodeId => Nat)     multivalue_node_expr_count,
  (StdBlockNodeId => Nat)     time_varying_node_idxs,
  Atom*                       memb_copy_var_ids,
  Nat*                        nested_cond_ids,
  Nat                         next_int_var_id,
  CompilationOptions          options;



  [Instr] gen_any_node_code(AutoNode node) = gen_node_code(node) & [set_bvar(marked_for_update_var(node.id), false)];


  [Instr^] gen_node_code(AutoInputNode node)
  {
    id = get_inner_id(node.id);

    l0 = lvar(0);
    l1 = lvar(1);
    memb_var = memb_var(id);
    body = [set_var(memb_var, l0), set_bvar(memb_has_changed(id), true) if in(id, memb_copy_var_ids)] &
           [mark_for_update(n, false) : n <- rand_sort(node.dep_nodes)];

    return nonempty([get_new_input(l0, id), init_memb_var(new_input(id), :blank)] & body) if node.discrete;

    return [
      get_new_input(l0, id),
      init_memb_var(new_input(id), :blank),
      set_var(l1, memb_var),
      do_if_not(is_eq(l0, l1), body)
    ];
  }


  [Instr^] gen_node_code(AutoDerivedNode node)
  {
    id = get_inner_id(node.id);

    var = memb_var(id);
    nv_var = lvar(0);
    eval_code = gen_safe_eval_code(node.expr, nv_var, next_obj_var_id = 1, next_bool_var_id = 0);
    cond = neg(is_eq(var, nv_var));
    body = [set_var(var, nv_var), set_bvar(memb_has_changed(id), true) if in(id, memb_copy_var_ids)] &
           [mark_for_update(n, false) : n <- rand_sort(node.dep_nodes)];
    return [eval_code | do_if(cond, body)];
  }


  [Instr^] gen_node_code(AutoStateNode node)
  {
    id = get_inner_id(node.id);

    var = memb_var(id);
    nv_var = lvar(0);
    let (next_obj_var_id = 1, next_bool_var_id = 0)
      cases = nonempty([gen_safe_eval_code(e, nv_var) : e <- node.exprs] & [[clear_loc_var(nv_var)]]);
      eval_instr = switch_on_nat(update_source_var(id), cases);
    ;
    cond = neg(is_eq(var, nv_var));
    body = [set_var(var, nv_var), set_bvar(memb_has_changed(id), true) if in(id, memb_copy_var_ids)] &
           [mark_for_update(n, false) : n <- rand_sort(node.dep_nodes)];
    return [eval_instr, do_if(cond, body)];
  }


  [Instr^] gen_node_code(AutoDiscDerivedNode node)
  {
    id = get_inner_id(node.id);

    var = memb_var(id);
    nv_var = lvar(0);
    let (next_obj_var_id = 1, next_bool_var_id = 0)
      cases = nonempty([gen_safe_eval_code(e, nv_var) : e <- node.exprs] & [[clear_loc_var(nv_var)]]);
      eval_instr = switch_on_nat(update_source_var(id), cases);
    ;
    return nonempty([eval_instr, set_var(var, nv_var)] & [mark_for_update(n, false) : n <- rand_sort(node.dep_nodes)]);
  }


  [Instr] gen_node_code(AutoCondNode node)
  {
    id = get_inner_id(node.id);

    then_actions, else_actions = node.actions;
    all_actions = then_actions & else_actions;
    all_subcond_ids = seq_union(node.subconds);

    l0 = lvar(0);
    b0 = bvar(0);
    b1 = bvar(1);
    id_var = cond_value_var(id);
    cond_is_def_var = cond_is_def_var(id);

    // Evaluating the condition and storing the result in l0
    cond_eval_code = gen_cond_eval_code(id, node.cond, node.parent);

    // Propagating the update to dependent conditions
    dep_conds_update_prop_code = [mark_for_update(n, true) : n <- rand_sort(all_subcond_ids)];

    // Base case, the condition stays defined. b1 holds the value of the condition, b0 whether it has changed
    // If the condition has changed, we queue the updates for the appropriate branch
    cond_stays_def_branch = [
      set_bvar(b1, inline_is_eq(l0, obj_true)),
      set_bvar(b0, neg(is_eq(id_var, b1))),
      set_bvar(id_var, b1),
      do_if(
        and([b0, neg(is_new)]),
        [ branch_or_no_op(
            b1,
            join(rand_sort({gen_update_code(a.target, a.value_idx) : a <- then_actions})),
            join(rand_sort({gen_update_code(a.target, a.value_idx) : a <- else_actions}))
          )
        ]
      )
    ];

    // If the condition is now defined. If it was already defined before, we run the
    // standard code. Otherwise, there's nothing to do, except storing its new value.
    // In either case, we propagate the update to all dependent nodes
    cond_is_def_branch = [
      branch(
        cond_is_def_var,
        cond_stays_def_branch,
        [ set_bvar(id_var, inline_is_eq(l0, obj_true)),
          set_bvar(cond_is_def_var, true)
        ]
      )
    ] & dep_conds_update_prop_code;

    // The condition is undefined. If it already was, there's nothing we need to do.
    // If, on the other hand, it has just become undefined, we need execute all the
    // assignments with a null value. We also propagate the update to all dependent conditions.
    cond_is_undef_branch = [
      do_if(
        cond_is_def_var,
        [ set_bvar(cond_is_def_var, false),
          do_if_not(is_new, join([gen_clear_code(a.target) : a <- rand_sort(all_actions)]))
        ] & dep_conds_update_prop_code
      )
    ];

    return cond_eval_code & [branch(var_is_def(l0), cond_is_def_branch, cond_is_undef_branch)];
  }


  [Instr] gen_node_code(AutoRepCondNode node)
  {
    id = node.id;
    then_actions, else_actions = node.actions;
    all_actions = then_actions & else_actions;
    then_subcond_ids, else_subcond_ids = node.subconds;
    all_subcond_ids = then_subcond_ids & else_subcond_ids;

    l0 = lvar(0);

    // Evaluating the condition and storing the result in l0
    cond_eval_code = gen_rep_cond_eval_code(id, node.cond, node.parent, all_subcond_ids != {});

    // Executing all the actions associated with the condition
    action_exec_code = [
      branch(
        var_is_def(l0),
        // The condition is defined, we run the normal actions
        [ branch_or_no_op(
            inline_is_eq(l0, obj_true),
            // The condition is true, running the 'then' branch
            join(rand_sort({gen_update_code(a.target, a.value_idx) : a <- then_actions})) &
            [mark_for_update(n, true) : n <- rand_sort(then_subcond_ids)],
            // The condition is false, running the 'else' branch
            join(rand_sort({gen_update_code(a.target, a.value_idx) : a <- else_actions})) &
            [mark_for_update(n, true) : n <- rand_sort(else_subcond_ids)]
          )
        ],
        // The condition is not defined, we execute all assignments with a null value
        join(rand_sort({gen_clear_code(a.target) : a <- all_actions})) &
        [mark_for_update(n, true) : n <- rand_sort(all_subcond_ids)]
      )
    ];

    return [do_if_not(is_new, cond_eval_code & action_exec_code)];
  }


  [Instr] gen_node_code(AutoTimeVaryingNode node)
  {
    node_id = node.id;
    id = get_inner_id(node_id);
    time_expr = node.time_expr;

    time_varying_node_idx = time_varying_node_idxs[node_id];

    init_val = initial_value(time_expr);
    init_slot_len = initial_slot_length(time_expr);

    i0 = ivar(next_int_var_id);
    i1 = ivar(nat(next_int_var_id + 1));
    i2 = ivar(nat(next_int_var_id + 2));
    i3 = ivar(nat(next_int_var_id + 3));

    l0 = lvar(0);
    cond_var = memb_var(id);

    inner_cond_value_var = cond_expr_value_var(id);
    inner_cond_is_def_var = cond_expr_is_def_var(id);
    inner_cond_up_to_date_var = cond_expr_up_to_date_var(id);

    next_trigger_time_var = next_trigger_time_var(id);
    curr_time_slot_var = curr_time_slot_var(id);

    // Updating the inner condition, if it's not up-to-date already
    inner_cond_updating_code = [
      do_if(
        neg(inner_cond_up_to_date_var),
        gen_safe_eval_code(node.cond, l0, next_obj_var_id = 1, next_bool_var_id = 0) &
        [ branch(
            var_is_def(l0),
            [ branch(
                inner_cond_is_def_var,
                [ branch(
                    inner_cond_value_var,
                    [ do_if(
                        is_eq(l0, obj_false),
                        [ set_bvar(inner_cond_value_var, false),
                          clear_timer(auto_name, time_varying_node_idx)
                        ]
                      )
                    ],
                    [ do_if(
                        is_eq(l0, obj_true),
                        [ set_bvar(inner_cond_value_var, true),
                          set_ivar(curr_time_slot_var, 0),
                          set_ivar(i0, add(curr_time, init_slot_len)),
                          set_ivar(next_trigger_time_var, i0),
                          insert_timer(auto_name, time_varying_node_idx, i0)
                        ]
                      )
                    ]
                  )
                ],
                [ do_if(
                    is_eq(l0, obj_false),
                    [ set_bvar(inner_cond_value_var, false), set_bvar(inner_cond_is_def_var, true)]
                  )
                ]
              )
            ],
            [ do_if(
                inner_cond_is_def_var,
                [ do_if(inner_cond_value_var, clear_timer(auto_name, time_varying_node_idx)),
                  set_bvar(inner_cond_is_def_var, false)
                ]
              )
            ]
          ),
          set_bvar(inner_cond_up_to_date_var, true)
        ]
      )
    ];

    // Now calculating the overall condition, based on the time expression
    outer_cond_update_code = [
      branch(
        inner_cond_is_def_var,
        [ branch(
            inner_cond_value_var,
            [ set_ivar(i0, next_trigger_time_var),
              do_if(
                is_eq(i0, curr_time),
                [ set_ivar(i1, add(curr_time_slot_var, 1)),
                  set_ivar(curr_time_slot_var, i1),
                  set_ivar(i2, time_slot_length(time_expr, auto_name, id, i1)),
                  do_if(
                    neg(is_eq(i2, 0)),
                    [ set_ivar(i3, add(curr_time, i2)),
                      set_ivar(next_trigger_time_var, i3),
                      insert_timer(auto_name, time_varying_node_idx, i3)
                    ]
                  )
                ]
              ),
              set_var(l0, to_obj(if init_val == true then is_even(curr_time_slot_var) else is_odd(curr_time_slot_var)))
            ],
            [set_var(l0, obj_false)]
          )
        ],
        [clear_loc_var(l0)]
      ),

      do_if(
        neg(is_eq(cond_var, l0)),
        [set_var(cond_var, l0)] & [mark_for_update(n, false) : n <- rand_sort(node.dep_nodes)]
      )
    ];

    // Putting it all together
    return inner_cond_updating_code & outer_cond_update_code;
  }


  [Instr] gen_node_code(AutoNestedAutoInputNode node)
  {
    nv_var = lvar(0);
    node_id = node.id;
    auto_var = memb_auto_var(node_id.auto);

    eval_code = gen_safe_eval_code(node.value, nv_var, next_obj_var_id = 1, next_bool_var_id = 0);

    set_var_code = [
      //## SHOULD I CHECK THAT THE INPUT IS NOT NULL BEFORE SETTING IT, OR IS THIS ALREADY DONE
      //## INSIDE THE NESTED AUTOMATON?
      set_input(auto_var, auto_vars_types[auto_var], node_id.input, just(nv_var)),
      mark_for_update(std_block_node_id(node_id.auto), false)
    ];

    code = eval_code & set_var_code;

    for (av, o : rand_sort(node.disc_nested_auto_outputs))
      tmp_var = lvar(1);
      code = [
        read_output(tmp_var, av, auto_vars_types[av], o),
        do_if(var_is_set(tmp_var), code)
      ];
    ;

    disc_vars = rand_sort(node.disc_vars);
    if (disc_vars != [])
      cond = and([var_is_set(v) : v <- disc_vars]);
      code = [do_if(cond, code)];
    ;

    return code;
  }


  [Instr] gen_node_code(AutoNestedAutoNode node)
  {
    inner_id = get_inner_id(node.id);

    auto_var = memb_auto_var(inner_id);
    auto_type = auto_vars_types[auto_var];
    update_source_var = update_source_var(inner_id);

    elapsed_time_expr = if in(auto_type, time_sensitive_autos)
      then sub(curr_time, nested_auto_int_var(auto_var, last_update_time))
      else 0;

    call_code = [update_inputs(auto_var, auto_type, elapsed_time_expr)];
    if (node.calls != [])
      cases = [call_code];
      for (m, as : node.calls)
        args_eval_info = gen_safe_eval_info(as, next_obj_var_id = 0, next_bool_var_id = 0);
        update_inputs_instr = update_inputs(
          var:          auto_var,
          type:         auto_type,
          call:         (name: m, args: args_eval_info.exprs),
          elapsed_time: elapsed_time_expr
        );
        case_code = [args_eval_info.eval_code | update_inputs_instr];
        cases = [cases | case_code];
      ;
      call_code = [switch_on_nat(update_source_var, cases), set_ivar(update_source_var, 0)];
    ;

    //## CURRENTLY WE PROPAGATE THE UPDATE WITHOUT CHECKING WHAT INPUTS (IF ANY) HAVE CHANGED. FIX
    prop_code = [mark_for_update(id, false) : id <- rand_sort(union(values(node.dep_nodes)))];

    triggers_count_var = nested_auto_int_var(auto_var, time_triggers_count_var);
    first_trigger_var  = nested_auto_int_var(auto_var, trigger_times_heap_var(0));
    timer_code = [
      do_if(
        is_gt(triggers_count_var, 0),
        insert_timer(auto_name, time_varying_node_idxs[node.id], first_trigger_var)
      ) if in(auto_type, time_sensitive_autos)
    ];

    return call_code & prop_code & timer_code;
  }


  [Instr] gen_cond_eval_code(Nat id, Expr cond, Maybe[(id: CondNodeId, trigger: Bool)] parent)
  {
    l0 = lvar(0);

    // Evaluating the local condition. If there's no parent, that's all we need to do
    loc_cond_eval_code = gen_safe_eval_code(cond, l0, next_obj_var_id = 1, next_bool_var_id = 0);
    return loc_cond_eval_code if parent == nil;

    // Local condition variables
    cv_var = cond_expr_value_var(id);
    cd_var = cond_expr_is_def_var(id);
    utd_var = cond_expr_up_to_date_var(id);

    // Overall condition variables
    id_var = cond_value_var(id);

    // Parent condition variables
    pd_var = cond_is_def_var(get_inner_id(parent.id));
    pid_var = cond_value_var(get_inner_id(parent.id));

    return [
      // Getting the value of the local condition in l0.
      // The value is not necessarly the correct one,
      // when the and condition is determined by the parent anyway
      branch(
        // No need to refresh the local condition if it's not up-to-date
        // Also, if the parent is defined and not equal to the trigger value,
        // the overall condition is false anyway, so no need to refresh
        and([pd_var, is_eq(pid_var, parent.trigger), neg(utd_var)]),

        // Evaluating the local condition and permanently storing its value
        loc_cond_eval_code & [
          set_bvar(cv_var, inline_is_eq(l0, obj_true)),
          set_bvar(cd_var, var_is_def(l0)),
          set_bvar(utd_var, true)
        ],

        // Pulling the stored, and not necessarly up-to-date, value into l0
        [ branch(
            cd_var,
            [set_var(l0, to_obj(id_var))],
            [clear_loc_var(l0)]
          )
        ]
      ),

      // Evaluating the overall condition by anding the local condition and its parent
      branch(
        pd_var,
        [do_if_not(is_eq(pid_var, parent.trigger), [set_var(l0, obj_false)])],
        [do_if_not(inline_is_eq(l0, obj_false), [clear_loc_var(l0)])]
      )
    ];
  }


  [Instr] gen_rep_cond_eval_code(CondNodeId node_id, Expr cond, Maybe[(id: CondNodeId, trigger: Bool)] parent, Bool has_deps)
  {
    l0 = lvar(0);

    // Evaluating the local condition.
    cond_eval_code = gen_safe_eval_code(cond, l0, next_obj_var_id = 1, next_bool_var_id = 0);

    // Anding the local condition with the 'parent == trigger' one, if a parent exists
    if (parent != nil)
      pcv_var = rep_cond_value_var(get_inner_id(parent.id));
      pcd_var = rep_cond_is_def_var(get_inner_id(parent.id));

      cond_eval_code = [
        branch(
          // If the parent variable is defined and different from
          // the trigger value then the overall condition is false
          and([pcd_var, neg(is_eq(pcv_var, parent.trigger))]),
          [set_var(l0, obj_false)],
          // Otherwise, we first calculate the local condition,
          // which is the same as the overall condition unless the
          // parent is undefined and the local condition is true
          [ cond_eval_code |
            do_if(
              and([neg(pcd_var), is_eq(l0, obj_true)]),
              clear_loc_var(l0)
            )
          ]
        )
      ];
    ;

    // Saving the value of the condition for dependent condition, if there are any
    if (has_deps)
      id = get_inner_id(node_id);
      cv_var = rep_cond_value_var(id);
      cd_var = rep_cond_is_def_var(id);

      cond_eval_code = [
        cond_eval_code |
        set_bvar(cv_var, is_eq(l0, obj_true)),
        set_bvar(cd_var, var_is_def(l0))
      ];
    ;

    return cond_eval_code;
  }


  [Instr^] gen_update_code(Atom state, Nat src_idx) = [
      do_if(neg(marked_for_update_var(std_block_node_id(state))), set_ivar(update_source_var(state), src_idx)),
      mark_for_update(std_block_node_id(state), false)
    ];


  [Instr^] gen_clear_code(Atom state) = gen_update_code(state, multivalue_node_expr_count[std_block_node_id(state)]);


  Instr mark_for_update(BlockNodeId node_id, Bool from_cond):
    std_block_node_id(a?)   = if has_key(time_varying_node_idxs, node_id) and not has_key(auto_vars_types, memb_auto_var(a))
                                then queue_cond_update(auto_name, node_id, true)
                                else queue_update(auto_name, node_id),
    cond_node_id(n?)        = queue_cond_update(auto_name, node_id, not from_cond and in(n, nested_cond_ids)),
    nested_auto_input_id()  = queue_update(auto_name, node_id);
}


using
{
  (BlockNodeId => Nat)  nodes_idxs,
  (BlockNodeId => Nat)  nodes_levels,
  [Nat]                 levels_sizes,
  Nat*                  nested_cond_ids,
  Atom*                 time_rules_ids,
  Nat                   next_int_var_id;


  [Instr] queue_update_method_body(<StdBlockNodeId, CondNodeId, NestedAutoInputNodeId> node_id)
  {
    index = nodes_idxs[node_id];
    level = nodes_levels[node_id];
    level_size = levels_sizes[level];

    idx_var = ivar(next_int_var_id);
    mark_var = marked_for_update_var(node_id);
    count_var = update_count_var(level);
    nodes_var = nodes_to_update_var(level, idx_var);

    extra_code = if level_size > 2
      then [
        set_ivar(idx_var, count_var),
        set_ivar(nodes_var, index),
        set_ivar(count_var, add(idx_var, 1))
      ]
      else [];

    code = [do_if(neg(mark_var), [set_bvar(mark_var, true)] & extra_code)];

    return match (node_id)
      std_block_node_id(a?)   = if in(a, time_rules_ids)  then add_clear_cache_code(code, a) else code,
      cond_node_id(n?)        = if in(n, nested_cond_ids) then add_clear_cache_code(code, n) else code,
      nested_auto_input_id()  = code;


    [Instr] add_clear_cache_code([Instr] code, <Atom, Nat> id)
    {
      inv_cache_instr = do_if(invalidate_cond_expr_cache, set_bvar(cond_expr_up_to_date_var(id), false));
      return [code | inv_cache_instr];
    }
  }
}

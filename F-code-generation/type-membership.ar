BoolProcDef mk_named_type_memb_test_fn(TypeSymbol type_symb, [TypeName -> Type] typedefs)
{
  res_var, var_gen = next_bool_var(blank_var_gen);
  type = expand_type_ref(type_symb, typedefs);
  let typedefs = typedefs, next_var_gen = var_gen:
    code = gen_type_checking_code(type, fn_par(0), res_var);
  ;
  return bool_proc_def(memb_test(type_symb), 1, nonempty(code & (ret_val(res_var))));
}


implicit typedefs : [TypeName -> Type], next_var_gen : VarGen
{
  Instr+ gen_type_checking_code(Type type, AtomicExpr obj, BoolVar res_var)
  {
    return (set_bvar(res_var, true)) if is_type_any(type);

    return match (type)
      ne_set_type()       = gen_ne_set_type_checking_code(type.elem_type, obj, res_var),
      ne_seq_type()       = gen_ne_seq_type_checking_code(type.elem_type, obj, res_var),
      ne_map_type()       = gen_ne_map_type_checking_code(type.key_type, type.value_type, obj, res_var),
      ne_record_type(fs?) = gen_ne_record_type_checking_code(fs, obj, res_var),
      tuple_type(ts?)     = gen_tuple_type_checking_code(ts, obj, res_var),
      tag_obj_type()      = gen_tag_obj_type_checking_code(type.tag_type, type.obj_type, obj, res_var),
      union_type(ts?)     = gen_union_type_checking_code(ts, obj, res_var),
      _                   = (set_bvar(res_var, gen_type_checking_expr(type, obj)));
  }


  Instr+ gen_ne_set_type_checking_code(Type elem_type, AtomicExpr obj, BoolVar res_var)
  {
    return (set_bvar(res_var, is_ne_set(obj))) if is_type_any(elem_type);

    elem_var, var_gen = next_obj_var(next_var_gen);
    it_var, var_gen = next_set_it_var(var_gen);

    elem_code = gen_type_checking_code(elem_type, elem_var, res_var, next_var_gen = var_gen);

    code = (
      block_failure_if_not(is_ne_set(obj), res_var),
      get_iter(it_var, obj),
      repeat(
        nonempty(
          ( break_if(is_out_of_range(it_var)),
            get_curr_obj(elem_var, it_var)
          ) &
          elem_code &
          ( exit_block_if_not(res_var),
            move_forward(it_var)
          )
        )
      ),
      set_bvar(res_var, true)
    );

    return (execute_block(code));
  }


  Instr+ gen_ne_seq_type_checking_code(Type elem_type, AtomicExpr obj, BoolVar res_var)
  {
    return (set_bvar(res_var, is_ne_seq(obj))) if is_type_any(elem_type);

    elem_var, var_gen = next_obj_var(next_var_gen);
    it_var, var_gen = next_seq_it_var(var_gen);

    elem_code = gen_type_checking_code(elem_type, elem_var, res_var, next_var_gen = var_gen);

    code = (
      block_failure_if_not(is_ne_seq(obj), res_var),
      get_iter(it_var, obj),
      repeat(
        nonempty(
          ( break_if(is_out_of_range(it_var)),
            get_curr_obj(elem_var, it_var)
          ) &
          elem_code &
          ( exit_block_if_not(res_var),
            move_forward(it_var)
          )
        )
      ),
      set_bvar(res_var, true)
    );

    return (execute_block(code));
  }


  Instr+ gen_ne_map_type_checking_code(Type key_type, Type value_type, AtomicExpr obj, BoolVar res_var)
  {
    return (set_bvar(res_var, is_ne_map(obj))) if is_type_any(key_type) and is_type_any(value_type);

    obj_var, var_gen = next_obj_var(next_var_gen);
    it_var, var_gen = next_map_it_var(var_gen);

    let next_var_gen = var_gen:
      code = (
        //block_success_if(is_empty_map(obj), res_var),
        block_failure_if_not(is_ne_map(obj), res_var),
        get_iter(it_var, obj),
        repeat(
          nonempty(
            ( break_if(is_out_of_range(it_var)),
              get_curr_key(obj_var, it_var)
            ) &
            gen_type_checking_code(key_type, obj_var, res_var) &
            ( exit_block_if_not(res_var),
              get_curr_value(obj_var, it_var)
            ) &
            gen_type_checking_code(value_type, obj_var, res_var) &
            ( exit_block_if_not(res_var),
              move_forward(it_var)
            )
          )
        ),
        set_bvar(res_var, true)
      );
    ;

    return (execute_block(code));
  }


  Instr+ gen_ne_record_type_checking_code([+SymbObj -> (type: Type, optional: Bool)] fs, AtomicExpr obj, BoolVar res_var)
  {
    count_var, var_gen = next_int_var(next_var_gen);
    it_var,    var_gen = next_map_it_var(var_gen);
    key_var,   var_gen = next_obj_var(var_gen);
    value_var, var_gen = next_obj_var(var_gen);
    tmp_bvar,  var_gen = next_bool_var(var_gen);

    mandatory_fields_count = size([l | l : f <- fs, not f.optional]); //## BAD BAD BAD: REALLY UGLY WAY TO DO A COUNT

    let next_var_gen = var_gen:
      code_cases = [
        ( [bare_obj(l)],
          ( gen_type_checking_code(f.type, value_var, tmp_bvar) ||
            branch(tmp_bvar, (increment(count_var) if not f.optional), (exit_block))
          )
        ) | l : f <- fs
      ];
    ;

    return (
      execute_block((
        set_ivar(count_var, 0),
        set_bvar(res_var, false),
        get_iter(it_var, obj),
        repeat((
          break_if(is_out_of_range(it_var)),
          get_curr_key(key_var, it_var),
          get_curr_value(value_var, it_var),
          symb_switch(key_var, code_cases, (exit_block)),
          move_forward(it_var)
        )),
        set_bvar(res_var, is_eq(count_var, mandatory_fields_count))
      ))
    );
  }


  Instr+ gen_tuple_type_checking_code(Type+ ts, AtomicExpr obj, BoolVar res_var)
  {
    len_var, var_gen = next_int_var(next_var_gen);
    elem_var, var_gen = next_obj_var(var_gen);
    it_var, var_gen = next_seq_it_var(var_gen);

    len  = length(ts);

    code = (
      set_bvar(res_var, false),
      exit_block_if_not(is_ne_seq(obj)),
      set_ivar(len_var, get_seq_len(obj)),
      exit_block_if_not(is_eq(len_var, len)),
      get_iter(it_var, obj)
    );

    let next_var_gen = var_gen:
      for t @ i <- ts:
        code = code &
                (get_curr_obj(elem_var, it_var)) &
                gen_type_checking_code(t, elem_var, res_var) &
                ( exit_block_if_not(res_var),
                  maybe_op(move_forward(it_var), i != len - 1)
                );
      ;
    ;

    return (execute_block((code || set_bvar(res_var, true))));
  }


  Instr+ gen_tag_obj_type_checking_code(TagType tag_type, Type obj_type, AtomicExpr obj, BoolVar res_var)
  {
    obj_var, var_gen = next_obj_var(next_var_gen);

    let next_var_gen = var_gen:
      code = ( block_failure_if_not(is_tagged_obj(obj), res_var),
                set_var(obj_var, get_tag(obj))
              ) &
              gen_type_checking_code(tag_type, obj_var, res_var) &
              ( exit_block_if_not(res_var),
                set_var(obj_var, get_inner_obj(obj))
              ) &
              gen_type_checking_code(obj_type, obj_var, res_var);
    ;

    return (execute_block(nonempty(code)));
  }


  Instr+ gen_union_type_checking_code([+Type] ts, AtomicExpr obj, BoolVar res_var)
  {
    //## PERFORMANCE COULD BE IMPROVED HERE USING A SWITCH/CASE
    code = ();
    for t <- rand_sort(ts):
      code = code & gen_type_checking_code(t, obj, res_var) & (exit_block_if(res_var));
    ;
    return (execute_block(nonempty(code)));
  }
}


BoolExpr gen_type_checking_expr(Type type, AtomicExpr obj):
  atom_type       = is_symb(obj),
  symb_type(s?)   = is_eq(s, obj),
  integer         = is_int(obj),
  low_ints()      = and_then(is_int(obj), is_le(get_int_val(obj), type.max)),
  high_ints()     = and_then(is_int(obj), is_ge(get_int_val(obj), type.min)),
  int_range()     = and_then(is_int(obj), is_ge(get_int_val(obj), type.min), is_le(get_int_val(obj), max(type))),
  float_type      = is_float(obj),
  type_ref(ts?)   = eval_bool_fn(memb_test(ts), (obj)),
  type_var()      = true, //## BUG BUG BUG THIS IS TEMPORARY...
  empty_seq_type  = is_eq(obj, empty_seq),
  empty_set_type  = is_eq(obj, empty_set),
  empty_map_type  = is_eq(obj, empty_map);


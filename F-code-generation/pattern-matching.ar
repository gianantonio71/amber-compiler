using Nat next_obj_var_id, StdVar* loc_bound_vars, [Instr^] on_match_code, (AtomicExpr => LocVar) tag_vars
{
  [Instr] gen_ptrn_matching_code(Pattern ptrn, AtomicExpr obj, PseudoType ptype):
    ptrn_var()        = gen_ptrn_var_matching_code(ptrn.var, ptrn.ptrn, obj, ptype),
    ptrn_tag_obj()    = gen_ptrn_tag_obj_matching_code(ptrn.tag, ptrn.obj, obj, ptype),
    ptrn_union(ps?)   = gen_ptrn_union_matching_code(ps, obj, ptype),
    _                 = opt_do_if(gen_ptrn_matching_expr(ptrn, obj, ptype), on_match_code);


  [Instr] gen_ptrn_var_matching_code(StdVar var, Pattern ptrn, AtomicExpr obj, PseudoType ptype) =
    if in(var, loc_bound_vars)
      then [do_if(is_eq(obj, var), on_match_code)]
      else gen_ptrn_matching_code(ptrn, obj, ptype, on_match_code = nonempty([set_var(var, obj)] & on_match_code));


  [Instr] gen_ptrn_tag_obj_matching_code(TagPtrn tag_ptrn, Pattern obj_ptrn, AtomicExpr obj, PseudoType ptype)
  {
    return gen_opt_ptrn_tag_obj_matching_code(tag_ptrn, obj_ptrn, obj, ptype) if is_subset(ptype, pseudotype_tag_objs);

    //## DO WE ACTUALLY NEED THIS?
    if (tag_ptrn == ptrn_symbol and obj_ptrn == ptrn_any)
      // Optimizing for the special case of a catch-all pattern
      return [do_if(is_tagged_obj(obj), on_match_code)];
    ;

    var  = lvar(next_obj_var_id);

    let (next_obj_var_id = nat(next_obj_var_id + 1))
      obj_match_code = gen_ptrn_matching_code(obj_ptrn, var, pseudotype_any);
      on_tag_match_code = nonempty([set_var(var, get_inner_obj(obj))] & obj_match_code);
      tag_match_code = gen_ptrn_matching_code(tag_ptrn, var, pseudotype_any, on_match_code=on_tag_match_code);
      final_code = [do_if(is_tagged_obj(obj), [set_var(var, get_tag(obj))] & tag_match_code)];
    ;

    return final_code;
  }


  [Instr] gen_opt_ptrn_tag_obj_matching_code(TagPtrn tag_ptrn, Pattern obj_ptrn, AtomicExpr obj, PseudoType ptype):
    ptrn_symbol       = gen_opt_obj_ptrn_matching_code(obj_ptrn, obj),
    ptrn_symbol(s?)   = { code = gen_opt_obj_ptrn_matching_code(obj_ptrn, obj);
                          code = [do_if(is_eq(lookup(tag_vars, obj, get_tag(obj)), s), code)] if not is_subset(ptype, pseudotype_symbol(_obj_(s)));
                          return code;
                        },
    ptrn_var()        = [set_var(tag_ptrn.var, lookup(tag_vars, obj, get_tag(obj)))] & gen_opt_obj_ptrn_matching_code(obj_ptrn, obj);


  [Instr] gen_opt_obj_ptrn_matching_code(Pattern obj_ptrn, AtomicExpr obj):
    ptrn_any    = on_match_code,
    //## BUG BUG BUG: WHAT IF THE VARIABLE HERE IS LOCALLY BOUNG?
    ptrn_var()  = [set_var(obj_ptrn.var, get_inner_obj(obj))] &
                  gen_ptrn_matching_code(obj_ptrn.ptrn, obj_ptrn.var, pseudotype_any),
    _           = { var = lvar(next_obj_var_id);
                    let (next_obj_var_id = nat(next_obj_var_id + 1))
                      obj_ptrn_matching_code = gen_ptrn_matching_code(obj_ptrn, var, pseudotype_any);
                    ;
                    return [set_var(var, get_inner_obj(obj))] & obj_ptrn_matching_code;
                  };


  [Instr] gen_ptrn_union_matching_code(Pattern+ ptrns, AtomicExpr obj, PseudoType ptype)
  {
    ptrns_left = normalize_patterns(ptrns);

    easy_check_ptrns = intersection(ptrns_left, easy_check_ptrns);
    ptrns_left = ptrns_left - easy_check_ptrns;
    check_exprs = [gen_ptrn_matching_expr(p, obj, ptype) : p <- rand_sort(easy_check_ptrns)];

    //## HERE I COULD PROBABLY OPTIMIZE THE CASE WHERE WE HAVE MULTIPLE INTEGER PATTERNS. WOULD IT BE WORTH IT?
    int_ptrns = {p : p <- ptrns_left, ptrn_integer() << p};
    ptrns_left = ptrns_left - int_ptrns;
    check_exprs = check_exprs & [gen_ptrn_matching_expr(p, obj, ptype) : p <- rand_sort(int_ptrns)];

    if (in(ptrn_symbol, ptrns_left))
      ptrns_left = ptrns_left - {ptrn_symbol};
      check_exprs = [check_exprs | gen_ptrn_matching_expr(ptrn_symbol, obj, ptype)];
    ;

    symb_ptrns = {p : p <- ptrns_left, ptrn_symbol() << p};
    ptrns_left = ptrns_left - symb_ptrns;
    check_exprs = check_exprs & [gen_ptrn_matching_expr(p, obj, ptype) : p <- rand_sort(symb_ptrns)];

    if (in(ptrn_tag_objs, ptrns_left))
      ptrns_left = ptrns_left - {ptrn_tag_objs};
      check_expr = if is_subset(ptype, pseudotype_tag_objs) then true else is_tagged_obj(obj);
      check_exprs = [check_expr] & check_exprs;
    ;

    easy_tag_ptrns = {p : p <- ptrns_left, ptrn_tag_obj() << p, p.obj == ptrn_any, p.tag :: <ptrn_symbol(SymbObj)>};
    ptrns_left = ptrns_left - easy_tag_ptrns;
    easy_tags = {_obj_(tag) : p <- easy_tag_ptrns, tag = p.tag, tag :: <ptrn_symbol(SymbObj)>};

    if (size(easy_tags) == 1)
      tag = only_element(easy_tags);
      check_expr = if is_subset(ptype, pseudotype_tag_obj(_obj_(tag)))
        then true
        else and_then(is_tagged_obj(obj), inline_is_eq(get_tag(obj), tag));
      check_exprs = [check_expr] & check_exprs;
    ;

    code = if check_exprs != [] then opt_do_if(or_else(check_exprs), on_match_code) else [];

    if (size(easy_tags) > 1)
      tag_var = lvar(next_obj_var_id);
      tag_check_expr = or_else(nonempty([inline_is_eq(tag_var, tag) : tag <- rand_sort(easy_tags)]));
      inner_code = [set_var(tag_var, get_tag(obj))] & opt_do_if(tag_check_expr, on_match_code);
      if (is_subset(ptype, pseudotype_tag_objs))
        easy_tag_ptrns_code = inner_code;
      else
        easy_tag_ptrns_code = [do_if(is_tagged_obj(obj), inner_code)];
      ;
      code = easy_tag_ptrns_code & code;
    ;

    other_ptrns_code = join([gen_ptrn_matching_code(p, obj, ptype) : p <- rand_sort(ptrns_left)]);

    return other_ptrns_code & code;
  }
}

////////////////////////////////////////////////////////////////////////////////

using Nat next_obj_var_id
{
  [Instr^] gen_switch_code([ExprEvalRes^] exprs, LocVar tag_var, [(ptrns: [Pattern^], code: [Instr^])^] cases)
  {
    if (length(head(cases).ptrns) == 1)
      all_cases = [(only_item(c.ptrns), c.code) : c <- cases];

      catch_all_code = nil;
      for (p, c @ i : all_cases)
        if (is_pattern_any(p))
          // catch_all_code = just(c);
          // all_cases = subseq(all_cases, 0, i);
          // break;
          //## BUG BUG BUG: THIS IS A HACK TO WORK AROUND A BUG IN THE TYPECHECKER.
          //## REENABLE THE ABOVE IMPLEMENTATION AFTER THE BUG IS FIXED.
          if (catch_all_code == nil)
            catch_all_code = just(c);
            all_cases = subseq(all_cases, 0, i);
          ;
        ;
      ;

      //## BAD BAD BAD: THERE MUST BE A BETTER WAY TO WRITE THIS KIND OF THINGS...
      symb_cases    = [(restrict(p, pseudotype_symbols),  c) : p, c <- all_cases, matches(p, pseudotype_symbols)];
      int_cases     = [(restrict(p, pseudotype_integers), c) : p, c <- all_cases, matches(p, pseudotype_integers)];
      float_cases   = [(restrict(p, pseudotype_floats),   c) : p, c <- all_cases, matches(p, pseudotype_floats)];
      seq_cases     = [(restrict(p, pseudotype_seqs),     c) : p, c <- all_cases, matches(p, pseudotype_seqs)];
      set_cases     = [(restrict(p, pseudotype_sets),     c) : p, c <- all_cases, matches(p, pseudotype_sets)];
      map_cases     = [(restrict(p, pseudotype_maps),     c) : p, c <- all_cases, matches(p, pseudotype_maps)];
      tag_obj_cases = [(restrict(p, pseudotype_tag_objs), c) : p, c <- all_cases, matches(p, pseudotype_tag_objs)];

      mtc_expr = only_item(exprs);

      code = [];

      tag_objs_code = [set_var(tag_var, get_tag(mtc_expr))];
      for (p, c : tag_obj_cases)
        let (loc_bound_vars = {}, on_match_code = c, tag_vars = (mtc_expr => tag_var))
          matched_case_code = gen_ptrn_matching_code(try_value(p), mtc_expr, pseudotype_tag_objs);
        ;
        tag_objs_code = tag_objs_code & matched_case_code;
      ;
      code = code & opt_do_if(is_tagged_obj(mtc_expr), tag_objs_code) if tag_objs_code != [];

      ptypes_info = [
        // (symb_cases,    pseudotype_symbols,   is_symb(mtc_expr)),
        (symb_cases,    pseudotype_any,       true),
        // (tag_obj_cases, pseudotype_tag_objs,  is_tagged_obj(mtc_expr)),
        (int_cases,     pseudotype_integers,  is_int(mtc_expr)),
        (float_cases,   pseudotype_floats,    is_float(mtc_expr)),
        // (seq_cases,     pseudotype_seqs,      or([inline_is_eq(mtc_expr, :empty_seq), is_ne_seq(mtc_expr)])),
        (seq_cases,     pseudotype_any,       true),
        // (set_cases,     pseudotype_sets,      or([inline_is_eq(mtc_expr, :empty_set), is_ne_set(mtc_expr)])),
        (set_cases,     pseudotype_any,       true),
        // (map_cases,     pseudotype_maps,      or([inline_is_eq(mtc_expr, :empty_map), is_ne_map(mtc_expr)]))
        (map_cases,     pseudotype_any,       true)
      ];

      for (ptype_cases, pseudotype, memb_expr : ptypes_info)
        ptype_code = [];
        for (p, c : ptype_cases)
          let (loc_bound_vars={}, on_match_code=c, tag_vars=())
            ptype_code = ptype_code & gen_ptrn_matching_code(try_value(p), mtc_expr, pseudotype);
          ;
        ;
        code = code & opt_do_if(memb_expr, ptype_code) if ptype_code != [];
      ;

      if (catch_all_code != nil)
        code = [execute_block(nonempty(code & value(catch_all_code)))];
      else
        code = [execute_block([code | terminate])];
      ;

    else
      code = [];
      for (c : cases)
        case_code = gen_guarded_case_eval_code(exprs, c.ptrns, c.code);
        code = code & case_code;
      ;
      code = [execute_block([code | terminate])];
    ;

    return code;


    [Instr^] gen_guarded_case_eval_code([AtomicExpr] exprs, [Pattern] ptrns, [Instr^] code)
    {
      assert length(exprs) == length(ptrns);

      return code if exprs == [] or ptrns == []; // Shutting up the typechecker...

      next_step_code = gen_guarded_case_eval_code(tail(exprs), tail(ptrns), code);
      let (loc_bound_vars={}, on_match_code=next_step_code, tag_vars=())
        res = gen_ptrn_matching_code(head(ptrns), head(exprs), pseudotype_any);
      ;
      return nonempty(res);
    }
  }
}

////////////////////////////////////////////////////////////////////////////////

Pattern+ easy_check_ptrns = {ptrn_float, ptrn_empty_set, ptrn_ne_set, ptrn_empty_seq, ptrn_ne_seq, ptrn_empty_map, ptrn_ne_map};

Pattern+ normalize_patterns(Pattern+ ptrns) = ptrns; //## IMPLEMENT FOR REAL


BoolExpr gen_ptrn_matching_expr(Pattern ptrn, AtomicExpr obj, PseudoType ptype):
  ptrn_any                      = true,
  ptrn_symbol                   = if_subset(ptype, pseudotype_symbols,   is_symb(obj)),
  ptrn_float                    = if_subset(ptype, pseudotype_floats,    is_float(obj)),
  ptrn_empty_set                = if_subset(ptype, pseudotype_empty_set, is_eq(obj, empty_set)),
  ptrn_ne_set                   = if_subset(ptype, pseudotype_ne_sets,   is_ne_set(obj)),
  ptrn_empty_seq                = if_subset(ptype, pseudotype_empty_seq, is_eq(obj, empty_seq)),
  ptrn_ne_seq                   = if_subset(ptype, pseudotype_ne_seqs,   is_ne_seq(obj)),
  ptrn_empty_map                = if_subset(ptype, pseudotype_empty_map, is_eq(obj, empty_map)),
  ptrn_ne_map                   = if_subset(ptype, pseudotype_ne_maps,   is_ne_map(obj)),
  ptrn_symbol(object(s?) so?)   = if_subset(ptype, pseudotype_symbol(s), is_eq(obj, so)),
  ptrn_integer(integer)         = if_subset(ptype, pseudotype_integers,  is_int(obj)),
  ptrn_integer(low_ints() t?)   = if_subset(ptype, pseudotype_integers,  is_int(obj), is_le(get_int_val(obj), t.max)),
  ptrn_integer(high_ints() t?)  = if_subset(ptype, pseudotype_integers,  is_int(obj), is_ge(get_int_val(obj), t.min)),
  ptrn_integer(int_range() t?)  = if_subset(ptype, pseudotype_integers,  is_int(obj), and(is_ge(get_int_val(obj), t.min), is_le(get_int_val(obj), max(t)))),
  _                             = {fail;};


BoolExpr if_subset(PseudoType ptype, PseudoType ptype_bounds, BoolExpr expr) =
  if is_subset(ptype, ptype_bounds) then true else expr;

BoolExpr if_subset(PseudoType ptype1, PseudoType ptype2, BoolExpr expr1, BoolExpr expr2) =
  if is_subset(ptype1, ptype2) then expr2 else and_then(expr1, expr2);

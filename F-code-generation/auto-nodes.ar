type AutoNode = AutoInputNode, AutoDerivedNode, AutoStateNode, AutoDiscDerivedNode, AutoCondNode, AutoRepCondNode;

type AutoInputNode        = input(id: Atom, discrete: Bool, dep_nodes: <Atom, Nat>*, level: Nat);

type AutoDerivedNode      = derived(id: Atom, expr: Expr, dep_nodes: <Atom, Nat>*, level: Nat);

type AutoStateNode        = state(id: Atom, exprs: [Expr], dep_nodes: <Atom, Nat>*, level: Nat);

type AutoDiscDerivedNode  = derived_disc(id: Atom, exprs: [Expr], dep_nodes: <Atom, Nat>*, level: Nat);

type AutoCondNode         = cond_node(
                              id:         Nat,
                              cond:       Expr,
                              parent:     Maybe[(id: Nat, trigger: Bool)],
                              actions:    (AutoNodeAction*, AutoNodeAction*),
                              subconds:   (Nat*, Nat*),
                              level:      Nat
                            );

type AutoRepCondNode      = rep_cond_node(
                              id:         Nat,
                              cond:       Expr,
                              parent:     Maybe[(id: Nat, trigger: Bool)],
                              actions:    (AutoNodeAction*, AutoNodeAction*),
                              subconds:   (Nat*, Nat*),
                              level:      Nat
                            );


type AutoNodeAction = (target: Atom, value_idx: Nat);

////////////////////////////////////////////////////////////////////////////////

AutoNode input(Atom id, Bool d, <Atom, Nat>* ns, Nat l) =
  input(id: id, discrete: d, dep_nodes: ns, level: l);

AutoNode derived(Atom id, Expr e, <Atom, Nat>* ns, Nat l) =
  derived(id: id, expr: e, dep_nodes: ns, level: l);

AutoNode state(Atom id, [Expr] es, <Atom, Nat>* ns, Nat l) =
  state(id: id, exprs: es, dep_nodes: ns, level: l);

AutoNode derived_disc(Atom id, [Expr] es, <Atom, Nat>* ns, Nat l) =
  derived_disc(id: id, exprs: es, dep_nodes: ns, level: l);

AutoNode cond_node(Nat id, Expr c, Maybe[(id: Nat, trigger: Bool)] p,
                    AutoNodeAction* tas, AutoNodeAction* eas, Nat* tcs, Nat* ecs, Nat l) =
  cond_node(id: id, cond: c, parent: p, actions: (tas, eas), subconds: (tcs, ecs), level: l);

AutoNode rep_cond_node(Nat id, Expr c, Maybe[(id: Nat, trigger: Bool)] p,
                        AutoNodeAction* tas, AutoNodeAction* eas, Nat* tcs, Nat* ecs, Nat l) =
  rep_cond_node(id: id, cond: c, parent: p, actions: (tas, eas), subconds: (tcs, ecs), level: l);

////////////////////////////////////////////////////////////////////////////////

<Atom, Nat>* dep_nodes_ids(AutoNode node):
  input()         = node.dep_nodes,
  derived()       = node.dep_nodes,
  state()         = node.dep_nodes,
  derived_disc()  = node.dep_nodes,
  cond_node()     = {tscs, escs = node.subconds; return tscs & escs;},
  rep_cond_node() = {tscs, escs = node.subconds; return tscs & escs;};

////////////////////////////////////////////////////////////////////////////////

type CondInfo     = ( cond:         Expr,
                      parent:       Maybe[(id: Nat, trigger: Bool)],
                      nested_conds: (id: Nat, trigger: Bool)*,
                      updates:      (state_id: Atom, new_value: Expr, trigger: Bool)*
                    );


[AutoNode] gen_auto_nodes(Automaton automaton)
{
  next_id = 0;

  cond_nodes = ();
  for (a : rand_sort(automaton.actions))
    nodes, next_id = gen_action_nodes(a, next_id, nil);
    cond_nodes = cond_nodes & nodes;
  ;

  rep_cond_nodes = ();
  for (a @ i : rand_sort(automaton.rep_actions))
    nodes, next_id = gen_action_nodes(a, next_id, nil);
    rep_cond_nodes = rep_cond_nodes & nodes;
  ;

  conds_deps = (id => cond_deps(c) : c @ id <- cond_nodes);
  rep_cond_deps = (id => cond_deps(c) : c @ id <- rep_cond_nodes);
  state_trigger_deps = merge_values(
    {(u.state_id => id) : c @ id <- cond_nodes, u <- c.updates} &
    {(u.state_id => id : c @ id <- rep_cond_nodes, u <- c.updates)}
  );
  state_value_deps = merge_value_sets(
    {(u.state_id => expr_deps(u.new_value)) : c @ unused_var <- cond_nodes, u <- c.updates} &
    {(u.state_id => expr_deps(u.new_value)) : c @ unused_var <- rep_cond_nodes, u <- c.updates}
  );
  rules_deps = (a => {unsafe_name(v) : v <- extern_vars(e)} : e @ a <- automaton.rules);

  trigger_dep_map = conds_deps & rep_cond_deps & state_trigger_deps & rules_deps;
  value_dep_map = conds_deps & rep_cond_deps & rules_deps & merge_value_sets({state_trigger_deps, state_value_deps});

  rev_trigger_dep_map = reverse_multi(trigger_dep_map);

  params = keys(automaton.params);
  inputs = keys(automaton.inputs);
  level_0 = params & inputs;

  nodes_by_level = topological_sort((s => new_ts : ts @ s <- value_dep_map, new_ts = ts - level_0 - {s}));

  sorted_nodes = [input(i, automaton.inputs[i].discrete, lookup(rev_trigger_dep_map, i, {}), 0) : i <- rand_sort(inputs)];

  update_values = merge_values(
    {(u.state_id => u.new_value) : c @ unused_var <- cond_nodes, u <- c.updates} &
    {(u.state_id => u.new_value) : c @ unused_var <- rep_cond_nodes, u <- c.updates}
  );
  update_values = (s => rand_sort(vs) : vs @ s <- update_values);

  state_vars_ids = keys(automaton.state);

  disc_var_ids = union({updated_disc_vars_ids(a) : a <- automaton.actions & automaton.rep_actions});

  for (l @ i : nodes_by_level)
    nodes = rand_sort(l);
    for (n : nodes)
      level = nat(i + 1);
      dep_nodes = lookup(rev_trigger_dep_map, n, {}) - state_vars_ids;
      if (has_key(automaton.rules, n))
        fail if not n :: Atom;
        info = derived(n, automaton.rules[n], dep_nodes, level);
      elif (has_key(automaton.state, n))
        fail if not n :: Atom;
        info = state(n, update_values[n], dep_nodes, level);
      elif (in(n, disc_var_ids))
        fail if not n :: Atom;
        info = derived_disc(n, update_values[n], dep_nodes, level);
      else
        assert has_key(cond_nodes, n) or has_key(rep_cond_nodes, n);
        fail if not n :: Nat;
        is_rep = has_key(rep_cond_nodes, n);
        node = if is_rep then rep_cond_nodes[n] else cond_nodes[n];
        then_actions = {
          ( target: u.state_id,
            value_idx: index_first(u.new_value, update_values[u.state_id])
          ) : u <- node.updates, u.trigger == true
        };
        else_actions = {
          ( target: u.state_id,
            value_idx: index_first(u.new_value, update_values[u.state_id])
          ) : u <- node.updates, u.trigger == false
        };
        then_nested_conds = {c.id : c <- node.nested_conds, c.trigger == true};
        else_nested_conds = {c.id : c <- node.nested_conds, c.trigger == false};
        //## UGLY UGLY UGLY: THE TWO CALLS ARE BASICALLY THE SAME
        if (is_rep)
          info = rep_cond_node(n, node.cond, node.parent, then_actions, else_actions,
                                then_nested_conds, else_nested_conds, level);
        else
          info = cond_node(n, node.cond, node.parent, then_actions, else_actions,
                                then_nested_conds, else_nested_conds, level);
        ;
      ;
      sorted_nodes = [sorted_nodes | info];
    ;
  ;

  return sorted_nodes;


  <Atom, Nat>* cond_deps(CondInfo cond)
  {
    parent = cond.parent;
    return expr_deps(cond.cond) & {parent.id if parent != nil};
  }

  Atom* expr_deps(Expr e) = {unsafe_name(v) : v <- extern_vars(e)};
}


((Nat => CondInfo), Nat) gen_action_nodes(<AutoCondAction, AutoRepAction> action, Nat root_id, Maybe[(id: Nat, trigger: Bool)] parent)
{
  next_id = nat(root_id + 1);

  updates = {};
  conditions = ();
  nested_conds = {};

  for (a, tv : rand_sort({(a, true) : a <- action.body} & {(a, false) : a <- action.else}))
    if (a :: AutoAtomicAction)
      updates = updates & {(state_id: a.target, new_value: a.value, trigger: tv)};
    else
      fail if not a :: <AutoCondAction, AutoRepAction>; //## BAD BAD: THE TYPECHECKER SHOULD AUTOMATICALLY INFER THE TYPE OF <a> IF WE TAKE THIS BRANCH
      nested_conds = nested_conds & {(id: next_id, trigger: tv)};
      subconds, next_id = gen_action_nodes(a, next_id, just(id: root_id, trigger: tv));
      conditions = conditions & subconds;
    ;
  ;

  return (conditions & (root_id => (cond: action.cond, parent: parent, nested_conds: nested_conds, updates: updates)), next_id);
}



Atom* updated_disc_vars_ids(AutoAtomicAction action):
  update()        = {},
  set_discrete()  = {action.target};


Atom* updated_disc_vars_ids(<AutoCondAction, AutoRepAction> action) =
  union({updated_disc_vars_ids(a) : a <- action.body}) &
  union({updated_disc_vars_ids(a) : a <- action.else});

//  gen_eval_code(expr, var)
//    Generates code that evaluates <expr> and stores the result in <var>, reference counted

//  gen_eval_info(expr, var)
//    Generates code needed to evaluate expr
//    If need be, the code stores the result in variable var, but it doesn't have to
//    It also generates an expression that is used to access the result
//    The expression may not be valid anymore if a variable used in the expression
//    is updated or goes out of scope

//  gen_eval_info(expr)
//    Like above, but automatically choses the name of the variable, if one is needed.
//    Also returns the id of the first free object variable.

type EvalVar        = StdVar, LocVar;
type EvalDestVar    = StdVar, LocVar, ElemVar, MembVar;

type ExprEvalRes    = StdObjVar, LeafObj;

type EvalInfo       = (eval_code: [Instr], expr: ExprEvalRes, var_used: Bool);
type ExEvalInfo     = (eval_code: [Instr], expr: ExprEvalRes, var_used: Bool, next_var_id: Nat);
type MultEvalInfo   = (eval_code: [Instr], exprs: [ExprEvalRes], next_var_id: Nat);
type VectorEvalInfo = (code: [Instr], vect_var: VecVar, count_expr: IntExpr);


using
{
  Nat next_obj_var_id,
  Nat next_int_var_id,
  Nat next_bool_var_id,
  Nat next_set_it_var_id,
  Nat next_seq_it_var_id,
  Nat next_map_it_var_id,
  Nat next_vector_var_id,
  Nat next_stream_var_id,

  (Atom => Nat)               pending_state_var_asgnms_idxs,
  (AnyAutoVar => AutoSymbol)  auto_vars_types,
  Maybe[AutoSymbol]           self_auto,

  Bool ignore_assertions;


  (EvalVar, Nat) pick_temp_var(EvalDestVar res_var) =
    if (res_var :: EvalVar) then (res_var, next_obj_var_id) else (lvar(next_obj_var_id), nat(next_obj_var_id+1));


  [Instr^] gen_fn_body(Expr expr)
  {
    fn_res_var = lvar(next_obj_var_id);
    code = gen_eval_code(expr, fn_res_var, next_obj_var_id = nat(next_obj_var_id + 1));
    return nonempty(code & [ret_val(fn_res_var)]);
  }


  EvalInfo gen_eval_info(Expr expr, EvalVar var):
    LeafObj         = (eval_code: [],                       expr: expr,                             var_used: false),
    Var             = (eval_code: [],                       expr: expr,                             var_used: false),
    _               = (eval_code: gen_eval_code(expr, var), expr: var,                              var_used: true);


  ExEvalInfo gen_eval_info(Expr expr)
  {
    var           = lvar(next_obj_var_id);
    info          = gen_eval_info(expr, var, next_obj_var_id = nat(next_obj_var_id + 1)); //## BUG? BUG? BUG?
    next_var_id   = nat(next_obj_var_id + if info.var_used then 1 else 0);
    //## BAD BAD BAD: SHOULD BE SOMETHING LIKE:
    //## return (info | next_var_id: next_obj_var_id + if info.var_used then 1 else 0)
    return (eval_code: info.eval_code, expr: info.expr, var_used: info.var_used, next_var_id: next_var_id);
  }


  MultEvalInfo gen_eval_info([Expr] exprs)
  {
    eval_code         = [];
    res_exprs         = [];
    next_var_id       = next_obj_var_id;

    for (e : exprs)
      info = gen_eval_info(e, next_obj_var_id = next_var_id);
      eval_code         = eval_code & info.eval_code;
      res_exprs         = res_exprs & [info.expr];
      next_var_id       = info.next_var_id;
    ;

    return (eval_code: eval_code, exprs: res_exprs, next_var_id: next_var_id);
  }


  //## THIS IS ALL WRONG (WHY?)
  VectorEvalInfo gen_vector_eval_info([SubExpr^] exprs)
  {
    elems_var = vvar(next_vector_var_id, nz_nat(length(exprs)));
    count_var = ivar(next_int_var_id);

    code, count_expr = gen_vector_eval_code(
      exprs,
      elems_var,
      count_var,
      next_vector_var_id = nat(next_vector_var_id + 1),
      next_int_var_id    = nat(next_int_var_id + 1)
    );

    return (code: code, vect_var: elems_var, count_expr: count_expr);


    ([Instr], IntExpr) gen_vector_eval_code([SubExpr] exprs, VecVar elems_var, IntVar count_var)
    {
      var_id   = elems_var.id;
      cond_var = lvar(next_obj_var_id);

      has_cond_exprs = at_least_one([e :: CondExpr : e <- exprs]);

      code = [set_ivar(count_var, 0) if has_cond_exprs];

      no_cond_expr_yet = true;
      know_offset = 0;

      for (e @ i : exprs)
        target_var = if no_cond_expr_yet then evar(var_id, i) else evar(var_id, count_var, know_offset);

        if (e :: Expr)
          new_code = gen_eval_code(e, target_var);
          know_offset = nat(know_offset + 1);

        elif (e :: CondExpr)
          cond_eval_info = gen_eval_info(e.cond, cond_var, next_obj_var_id = nat(next_obj_var_id + 1));
          // No need to change next_obj_var_id, as cond_var is not used anymore when running this code
          expr_eval_code = gen_eval_code(e.expr, target_var);
          cond_instr = do_if(is_true(cond_eval_info.expr), expr_eval_code & [increment(count_var)]);
          new_code = [cond_eval_info.eval_code | cond_instr];
          no_cond_expr_yet = false;
        else
          fail;
        ;
        code = code & new_code;
      ;

      if (has_cond_exprs)
        count_expr = if know_offset == 0 then count_var else add(count_var, know_offset);
      else
        count_expr = know_offset;
      ;

      return (code, count_expr);
    }
  }


  [Instr^] gen_eval_code(Expr expr, EvalDestVar res_var):
    object()        = [set_var(res_var, expr)],
    float_lit()     = [mk_float(res_var, expr.mantissa, expr.dec_exp)],
    Var             = [set_var(res_var, expr)],

    set_expr(es?)   = gen_eval_code_for_set_expr(es, res_var),
    seq_expr(es?)   = gen_eval_code_for_seq_expr(es, res_var),
    seq_tail_expr() = gen_eval_code_for_seq_tail_expr(expr.seq, expr.tail, res_var),
    tuple_expr(es?) = gen_eval_code_for_tuple_expr(es, res_var),
    map_expr(es?)   = gen_eval_code_for_map_expr(es, res_var),
    tag_obj_expr()  = gen_eval_code_for_tag_obj_expr(expr.tag, expr.obj, res_var),

    fn_call()       = gen_eval_code_for_fn_call_expr(expr.name, expr.params, expr.named_args, res_var),
    cls_call()      = gen_eval_code_for_cls_call(expr.name, expr.params, res_var),
    builtin_call()  = gen_eval_code_for_builtin_call(expr.name, expr.params, res_var),

    and_expr()      = gen_eval_code_for_and_expr(expr.left, expr.right, res_var),
    or_expr()       = gen_eval_code_for_or_expr(expr.left, expr.right, res_var),
    not_expr(e?)    = gen_eval_code_for_not_expr(e, res_var),

    eq()            = gen_eval_code_for_eq_expr(expr.left, expr.right, res_var),

    membership()    = gen_eval_code_for_membership_expr(expr.obj, expr.type, res_var),

    accessor()      = gen_eval_code_for_accessor_expr(expr.expr, expr.field, res_var),
    accessor_test() = gen_eval_code_for_accessor_test_expr(expr.expr, expr.field, res_var),

    get_output()    = [read_output(res_var, expr.var, auto_vars_types[expr.var], expr.output)],
    output_is_set() = gen_eval_code_for_output_is_set_expr(expr.var, expr.output, res_var),
    output_is_def() = gen_eval_code_for_output_is_def_expr(expr.var, expr.output, res_var),

    if_expr()       = gen_eval_code_for_if_expr(expr.cond, expr.then, expr.else, res_var),
    match_expr()    = gen_eval_code_for_match_expr(expr.exprs, expr.cases, res_var),
    do_expr(ss?)    = [execute_block(gen_code(ss, res_var))],

    ex_qual()       = gen_eval_code_for_ex_qual_expr(expr.source, expr.cond, res_var),
    set_comp()      = gen_eval_code_for_set_comp_expr(expr.expr, expr.source, res_var),
    map_comp()      = gen_eval_code_for_map_comp_expr(expr.key_expr, expr.value_expr, expr.source, res_var),

    seq_comp(ei?)   = gen_eval_code_for_seq_comp_expr(ei, res_var),
    range_comp(ei?) = gen_eval_code_for_range_comp_expr(ei, res_var),

    is_set(v?)      = [set_var(res_var, to_obj(var_is_set(v)))];



  [Instr^] gen_eval_code_for_set_expr(SubExpr* subexprs, EvalDestVar res_var)
  {
    return [set_var(res_var, empty_set)] if subexprs == {};
    non_cond_exprs = {e : e <- subexprs, e :: Expr};
    cond_exprs = subexprs - non_cond_exprs;
    sorted_subexprs = rand_sort(non_cond_exprs) & rand_sort(cond_exprs);
    info = gen_vector_eval_info(nonempty(sorted_subexprs));
    return nonempty(info.code & [mk_set(res_var, info.vect_var, info.count_expr)]);
  }


  [Instr^] gen_eval_code_for_seq_expr([SubExpr] subexprs, EvalDestVar res_var)
  {
    return [set_var(res_var, empty_seq)] if subexprs == [];
    info = gen_vector_eval_info(subexprs);
    return nonempty(info.code & [mk_seq(res_var, info.vect_var, info.count_expr)]);
  }


  [Instr^] gen_eval_code_for_seq_tail_expr(Expr seq, [Expr^] tail, EvalDestVar res_var)
  {
    tmp_var, next_var_id = pick_temp_var(res_var);
    let (next_obj_var_id = next_var_id)
      seq_info = gen_eval_info(seq, tmp_var);
      code = seq_info.eval_code;
      for (e @ i : tail)
        info = gen_eval_info(e);
        target_var = if i < length(tail) - 1 then tmp_var else res_var;
        seq_var = if i == 0 then seq_info.expr else tmp_var;
        code = code & info.eval_code & [append_to_seq(target_var, seq_var, info.expr)];
      ;
    ;
    return nonempty(code);
  }


  [Instr^] gen_eval_code_for_tuple_expr([Expr^] exprs, EvalDestVar res_var)
  {
    info = gen_vector_eval_info(exprs);
    return nonempty(info.code & [mk_seq(res_var, info.vect_var, info.count_expr)]);
  }


  [Instr^] gen_eval_code_for_map_expr((key: Expr, value: Expr, cond: Expr?)* entries, EvalDestVar res_var)
  {
    return [set_var(res_var, empty_map)] if entries == {};

    cond_var   = lvar(next_obj_var_id);
    keys_var   = vvar(next_vector_var_id, nz_nat(size(entries)));
    values_var = vvar(nat(next_vector_var_id + 1), nz_nat(size(entries)));
    count_var  = ivar(next_int_var_id);

    curr_key_slot_var   = evar(keys_var.id, count_var);
    curr_value_slot_var = evar(values_var.id, count_var);

    code = [set_ivar(count_var, 0)];

    let (next_int_var_id = nat(next_int_var_id + 1), next_vector_var_id = nat(next_vector_var_id + 2))
      for (e : rand_sort(entries))
        key_code   = gen_eval_code(e.key, curr_key_slot_var);
        value_code = gen_eval_code(e.value, curr_value_slot_var);
        entry_code = key_code & value_code & [increment(count_var)];

        if (e.cond?)
          cond_info = gen_eval_info(e.cond, cond_var, next_obj_var_id = nat(next_obj_var_id + 1));
          entry_code = cond_info.eval_code & [do_if(is_true(cond_info.expr), entry_code)];
        ;

        code = code & entry_code;
      ;
    ;

    return nonempty(code & [mk_map(res_var, keys_var, values_var, count_var)]);
  }


  [Instr^] gen_eval_code_for_tag_obj_expr(Expr tag_expr, Expr obj_expr, EvalDestVar res_var)
  {
    info = gen_eval_info([tag_expr, obj_expr]);
    return nonempty(info.eval_code & [mk_tagged_obj(res_var, info.exprs[0], info.exprs[1])]);
  }


  [Instr^] gen_eval_code_for_fn_call_expr(FnSymbol name, [AnyExpr] params, (NamedArg => AnyExpr) named_args, EvalDestVar res_var)
  {
    if (named_args != ())
      //## BUG BUG BUG. THE ASSIGNMENTS ARE DONE IN RANDOM ORDER. FIX THIS
      var = an_elem(nonempty(keys(named_args)));
      expr = named_args[var];
      rem_named_args = (v => e : e @ v <- named_args, v != var);

      if (expr :: Expr)
        backup_var = lvar(next_obj_var_id);
        let (next_obj_var_id = nat(next_obj_var_id + 1))
          info = gen_eval_info(expr);
          body = gen_eval_code_for_fn_call_expr(name, params, rem_named_args, res_var, next_obj_var_id=info.next_var_id);
        ;
        set_up_code = [set_var(backup_var, var), set_var(var, info.expr)];
        tear_down_code = [set_var(var, backup_var)];
        return nonempty(info.eval_code & set_up_code & body & tear_down_code);

      else
        bound_cls = gen_non_scalar_par_code(cast_as_cls_expr(expr));
        body = gen_eval_code_for_fn_call_expr(name, params, rem_named_args, res_var);
        return [cls_scope(var, bound_cls, body)];
      ;

    else
      pars_are_first_order = [is_expr(p) : p <- params];
      par_packed_idxs = packed_indexes(pars_are_first_order);
      pars_info = gen_eval_info([cast_as_expr(p) : p @ i <- params, pars_are_first_order[i]]);
      all_params = [
        if pars_are_first_order[i]
          then pars_info.exprs[value(par_packed_idxs[i])]
          else gen_non_scalar_par_code(cast_as_cls_expr(p))
      : p @ i <- params];
      core_call_code = [call_proc(res_var, name, all_params)];
      return nonempty(pars_info.eval_code & core_call_code);
    ;
  }


  [Instr^] gen_eval_code_for_cls_call(<ClsVar, NamedArg> name, [Expr] params, EvalDestVar res_var)
  {
    pars_info = gen_eval_info(params);
    call_code = [call_cls(res_var, name, pars_info.exprs)];
    return nonempty(pars_info.eval_code & call_code);
  }


  [Instr^] gen_eval_code_for_builtin_call(BuiltIn name, [Expr] params, EvalDestVar res_var)
  {
    pars_info = gen_eval_info(params);
    call_code = gen_call_code(name, pars_info.exprs, res_var);
    return nonempty(pars_info.eval_code & call_code);


    [Instr^] gen_call_code(BuiltIn name, [AtomicExpr] params, EvalDestVar res_var):
      obj         = [set_var(res_var, get_inner_obj(params[0]))],
      has_key     = { bvar = bvar(next_bool_var_id);
                      map_par = params[0];
                      if (map_par :: StdObjVar)
                        return [lookup(bvar, res_var, map_par, params[1]), set_var(res_var, to_obj(bvar))];
                      else
                        assert map_par == empty_map;
                        return [set_var(res_var, obj_false)];
                      ;
                    },
      lookup      = { map_par = params[0];
                      fail if not map_par :: StdObjVar; //## REMEMBER TO CHECK THIS AS PART OF THE WELL-FORMEDNESS CHECK
                      return [lookup(res_var, map_par, params[1])];
                    },
      at          = [set_var(res_var, at(params[0], get_int_val(params[1])))],
      rand_elem   = [set_var(res_var, rand_elem(params[0]))],
      _           = [gen_eval_instr(name, params, res_var)];


    Instr gen_eval_instr(BuiltIn name, [AtomicExpr] ps, EvalDestVar res_var):
      slice         = get_seq_slice(res_var, ps[0], get_int_val(ps[1]), get_int_val(ps[2])),
      cat           = join_seqs(res_var, ps[0], ps[1]),
      mcat          = join_mult_seqs(res_var, ps[0]),
      rev           = rev_seq(res_var, ps[0]),
      set           = seq_to_set(res_var, ps[0]),
      // at            = get_at(res_var, ps[0], get_int_val(ps[1])),
      mset          = seq_to_mset(res_var, ps[0]),
      isort         = internal_sort(res_var, ps[0]),
      union         = merge_sets(res_var, ps[0]),
      merge         = merge_maps(res_var, ps[0]),
      list_to_seq   = list_to_seq(res_var, ps[0]),
      fneg          = neg_float(res_var, ps[0]),
      fadd          = add_floats(res_var, ps[0], ps[1]),
      fsub          = sub_floats(res_var, ps[0], ps[1]),
      fmult         = mult_floats(res_var, ps[0], ps[1]),
      fdiv          = div_floats(res_var, ps[0], ps[1]),
      fsqrt         = square_root(res_var, ps[0]),
      floor         = floor_op(res_var, ps[0]),
      ceiling       = ceiling_op(res_var, ps[0]),
      float         = int_to_float(res_var, ps[0]),
      str           = symb_to_str(res_var, ps[0]),
      attach        = add_attachment(res_var, ps[0], ps[1]),
      fetch         = fetch_attachments(res_var, ps[0]),
      _             = set_var(res_var, gen_eval_expr(name, ps));


    ObjExpr gen_eval_expr(BuiltIn name, [AtomicExpr] ps):
      symb        = to_symb(ps[0]),
      neg         = to_obj(minus(get_int_val(ps[0]))),
      add         = to_obj(add(get_int_val(ps[0]), get_int_val(ps[1]))),
      sub         = to_obj(sub(get_int_val(ps[0]), get_int_val(ps[1]))),
      mult        = to_obj(mult(get_int_val(ps[0]), get_int_val(ps[1]))),
      div         = to_obj(div(get_int_val(ps[0]), get_int_val(ps[1]))),
      mod         = to_obj(mod_op(get_int_val(ps[0]), get_int_val(ps[1]))),
      lt          = to_obj(is_lt(get_int_val(ps[0]), get_int_val(ps[1]))),
      le          = to_obj(is_le(get_int_val(ps[0]), get_int_val(ps[1]))),
      gt          = to_obj(is_gt(get_int_val(ps[0]), get_int_val(ps[1]))),
      ge          = to_obj(is_ge(get_int_val(ps[0]), get_int_val(ps[1]))),
      len         = to_obj(get_seq_len(ps[0])),
      tag         = get_tag(ps[0]),
      in          = to_obj(has_elem(ps[1], ps[0])),
      mantissa    = to_obj(mantissa(ps[0])),
      dec_exp     = to_obj(dec_exp(ps[0])),
      rand_nat    = to_obj(rand_nat(ps[0])),
      counter     = to_obj(unique_nat),
      ticks       = to_obj(ticks);
  }


  [Instr^] gen_eval_code_for_and_expr(Expr left_expr, Expr right_expr, EvalDestVar res_var)
  {
    tmp_var, next_var_id = pick_temp_var(res_var);
    let (next_obj_var_id = next_var_id)
      left_info = gen_eval_info(left_expr, tmp_var);
      if_code = gen_eval_code(right_expr, res_var);
      else_code = [set_var(res_var, obj_false) if left_info.expr != res_var];
    ;
    return [left_info.eval_code | branch(is_true(left_info.expr), if_code, else_code)];
  }


  [Instr^] gen_eval_code_for_or_expr(Expr left_expr, Expr right_expr, EvalDestVar res_var)
  {
    tmp_var, next_var_id = pick_temp_var(res_var);
    let (next_obj_var_id = next_var_id)
      left_info = gen_eval_info(left_expr, tmp_var);
      if_code = [set_var(res_var, obj_true) if left_info.expr != res_var];
      else_code = gen_eval_code(right_expr, res_var);
    ;
    return [left_info.eval_code | branch(is_true(left_info.expr), if_code, else_code)];
  }


  [Instr^] gen_eval_code_for_not_expr(Expr expr, EvalDestVar res_var)
  {
    tmp_var = lvar(next_obj_var_id);
    let (next_obj_var_id = nat(next_obj_var_id+1))
      info = gen_eval_info(expr, tmp_var);
      code = info.eval_code & [set_var(res_var, obj_neg(info.expr))];
    ;
    return nonempty(code);
  }


  [Instr^] gen_eval_code_for_eq_expr(Expr left_expr, Expr right_expr, EvalDestVar res_var)
  {
    info = gen_eval_info([left_expr, right_expr]);
    return nonempty(info.eval_code & [set_var(res_var, to_obj(is_eq(info.exprs[0], info.exprs[1])))]);
  }


  [Instr^] gen_eval_code_for_membership_expr(Expr expr, Type type, EvalDestVar res_var)
  {
    //bool_var_id = next_bool_var_id;
    bool_var = bvar(next_bool_var_id);
    info = gen_eval_info(expr);
    code = gen_type_checking_code(
      type,
      info.expr,
      bool_var,
      next_obj_var_id  = info.next_var_id
    );
    return nonempty(info.eval_code & code & [set_var(res_var, to_obj(bool_var))]);
  }


  [Instr^] gen_eval_code_for_accessor_expr(Expr expr, SymbObj field, EvalDestVar res_var)
  {
    info = gen_eval_info(expr);
    info_expr = info.expr;
    fail if not info_expr :: StdObjVar;
    code = [ext_lookup(res_var, info_expr, field)];
    return nonempty(info.eval_code & code);
  }


  [Instr^] gen_eval_code_for_accessor_test_expr(Expr expr, SymbObj field, EvalDestVar res_var)
  {
    info = gen_eval_info(expr);
    bvar = bvar(next_bool_var_id);
    unused_var = lvar(info.next_var_id);
    info_expr = info.expr;
    fail if not info_expr :: StdObjVar;
    // ## SHOULD I RESTORE THIS FOR VARIABLES OTHER THAN evar()?
    // // Here I use res_var to store a temporary value
    // // that has nothing to do with the actual result
    code = [ext_lookup(bvar, unused_var, info_expr, field), set_var(res_var, to_obj(bvar))];
    return nonempty(info.eval_code & code);
  }


  [Instr^] gen_eval_code_for_output_is_set_expr(AnyAutoVar var, Atom output, EvalDestVar res_var)
  {
    tmp_var = lvar(next_obj_var_id);
    return [
      read_output(tmp_var, var, auto_vars_types[var], output),
      set_var(res_var, to_obj(var_is_set(tmp_var)))
    ];
  }


  [Instr^] gen_eval_code_for_output_is_def_expr(LocAutoVar var, Atom output, EvalDestVar res_var)
  {
    tmp_var = lvar(next_obj_var_id);
    return [
      read_output(tmp_var, var, auto_vars_types[var], output),
      set_var(res_var, to_obj(var_is_def(tmp_var)))
    ];
  }


  [Instr^] gen_eval_code_for_if_expr(Expr cond, Expr then_expr, Expr else_expr, EvalDestVar res_var)
  {
    info = gen_eval_info(cond);
    branch_instr = branch(is_true(info.expr), gen_eval_code(then_expr, res_var), gen_eval_code(else_expr, res_var));
    return nonempty([info.eval_code | branch_instr]);
  }


  [Instr^] gen_eval_code_for_match_expr([Expr^] exprs, [(ptrns: [Pattern^], expr: Expr)^] cases, EvalDestVar res_var)
  {
    info = gen_eval_info(exprs);
    next_var_id = info.next_var_id;
    tag_var = lvar(next_var_id);
    let (next_obj_var_id = nat(next_var_id + 1))
      semicomp_cases = [(ptrns: c.ptrns, code: [gen_eval_code(c.expr, res_var) | exit_block]) : c <- cases];
      switch_code = gen_switch_code(nonempty(info.exprs), tag_var, semicomp_cases);
    ;
    return nonempty(info.eval_code & switch_code);
  }


  [Instr^] gen_eval_code_for_ex_qual_expr(Clause source, Expr cond, EvalDestVar res_var)
  {
    action = action(filter_clause(cond), set_found_var_and_leave(res_var));
    code = gen_clause_code(source, {}, action);
    return [set_var(res_var, obj_false), execute_block(code)];
  }


  [Instr^] gen_eval_code_for_set_comp_expr(Expr expr, Clause source, EvalDestVar res_var)
  {
    strm_var = svar(next_stream_var_id);
    action = eval_expr_and_add_to_set(expr, strm_var);
    code = gen_clause_code(source, {}, action, next_stream_var_id = nat(next_stream_var_id + 1));
    return nonempty([init_stream(strm_var)] & code & [mk_set_from_stream(res_var, strm_var)]);
  }


  [Instr^] gen_eval_code_for_map_comp_expr(Expr key_expr, Expr value_expr, Clause source, EvalDestVar res_var)
  {
    key_strm_var   = svar(next_stream_var_id);
    value_strm_var = svar(nat(next_stream_var_id + 1));

    action = eval_exprs_and_add_to_map(key_expr, value_expr, key_strm_var, value_strm_var);
    code = gen_clause_code(source, {}, action, next_stream_var_id = nat(next_stream_var_id + 2));

    return nonempty(
      [init_stream(key_strm_var), init_stream(value_strm_var)] & code &
      [mk_map_from_streams(res_var, key_strm_var, value_strm_var)]
    );
  }


  [Instr^] gen_eval_code_for_seq_comp_expr((expr: Expr, vars: [StdVar^], idx_var: StdVar?, src_expr: Expr, sel_expr: Expr?) expr, EvalDestVar res_var)
  {
    src_var   = lvar(next_obj_var_id);
    item_var  = lvar(nat(next_obj_var_id + 1));
    sel_var   = lvar(nat(next_obj_var_id + 2));
    tmp_var   = lvar(nat(next_obj_var_id + 3)); // This is only needed during a destructuring assignment, it can be safely reused elsewhere
    it_var    = seq_it_var(next_seq_it_var_id);
    strm_var  = svar(next_stream_var_id);
    idx_var   = ivar(next_int_var_id);      //## BAD USED EVEN WHEN NOT REQUIRED

    let ( next_obj_var_id    = nat(next_obj_var_id    + 3),
          next_seq_it_var_id = nat(next_seq_it_var_id + 1),
          next_stream_var_id = nat(next_stream_var_id + 1),
          next_int_var_id    = nat(next_int_var_id    + 1))

      src_info  = gen_eval_info(expr.src_expr, src_var);
      item_info = gen_eval_info(expr.expr, item_var);
      maybe_sel_info  = if expr.sel_expr? then just(gen_eval_info(expr.sel_expr, sel_var)) else nil; //## BUG BUG BUG
    ;

    knows_size = not expr.sel_expr?;

    eval_and_assign_code = item_info.eval_code &
                            if knows_size
                              then [set_at(res_var, idx_var, item_info.expr)]
                              else [append(strm_var, item_info.expr)];

    core_loop_code = eval_and_assign_code;
    if (maybe_sel_info != nil)
      sel_info = value(maybe_sel_info);
      core_loop_code = sel_info.eval_code & [do_if(is_true(sel_info.expr), core_loop_code)];
    ;

    needs_idx_var = not expr.sel_expr? or expr.idx_var?;

    if (length(expr.vars) == 1)
      var_set_code = [set_var(expr.vars[0], get_curr_obj(it_var))];
    else
      var_set_code = [set_var(tmp_var, get_curr_obj(it_var))];
      var_set_code = var_set_code & [set_var(v, at(tmp_var, i)) : v @ i <- expr.vars];
    ;
    var_set_code = var_set_code & [set_var(expr.idx_var, to_obj(idx_var))] if expr.idx_var?;

    loop_code = [
      if knows_size
        then mk_array(res_var, get_seq_len(src_info.expr), obj_nil)
        else init_stream(strm_var),
      get_iter(it_var, src_info.expr),
      maybe_op(set_ivar(idx_var, 0), needs_idx_var),
      repeat(
        nonempty(
          [break_if(is_out_of_range(it_var))] &
          var_set_code &
          core_loop_code &
          [move_forward(it_var), maybe_op(increment(idx_var), needs_idx_var)]
        )
      ),
      maybe_op(mk_seq_from_stream(res_var, strm_var), not knows_size)
    ];

    return nonempty(src_info.eval_code & loop_code);
  }


  [Instr^] gen_eval_code_for_range_comp_expr((expr: Expr, var: StdVar, bound_expr: Expr, inclusive: Bool, sel_expr: Expr?) expr, EvalDestVar res_var)
  {
    src_var   = lvar(next_obj_var_id);
    item_var  = lvar(nat(next_obj_var_id + 1));
    sel_var   = lvar(nat(next_obj_var_id + 2));
    strm_var  = svar(next_stream_var_id);
    idx_var   = ivar(next_int_var_id);      //## BAD USED EVEN WHEN NOT REQUIRED
    bound_var = ivar(nat(next_int_var_id + 1));

    let ( next_obj_var_id    = nat(next_obj_var_id    + 3),
          next_stream_var_id = nat(next_stream_var_id + 1),
          next_int_var_id    = nat(next_int_var_id    + 2))

      bound_info  = gen_eval_info(expr.bound_expr, src_var);
      item_info = gen_eval_info(expr.expr, item_var);
      maybe_sel_info  = if expr.sel_expr? then just(gen_eval_info(expr.sel_expr, sel_var)) else nil; //## BUG BUG BUG
    ;

    knows_size = not expr.sel_expr?;

    eval_and_assign_code = item_info.eval_code &
                            if knows_size
                              then [set_at(res_var, idx_var, item_info.expr)]
                              else [append(strm_var, item_info.expr)];

    core_loop_code = eval_and_assign_code;
    if (maybe_sel_info != nil)
      sel_info = value(maybe_sel_info);
      core_loop_code = sel_info.eval_code & [do_if(is_true(sel_info.expr), core_loop_code)];
    ;

    bound_included = expr.inclusive;
    iter_count = get_int_val(bound_info.expr);
    iter_count = add(iter_count, 1) if bound_included;
    loop_code = [
      if knows_size then mk_array(res_var, iter_count, obj_nil) else init_stream(strm_var),
      set_ivar(bound_var, get_int_val(bound_info.expr)),
      set_ivar(idx_var, 0),
      repeat(
        nonempty(
          [ break_if(if bound_included then is_gt(idx_var, bound_var) else is_ge(idx_var, bound_var)),
            set_var(expr.var, to_obj(idx_var))
          ] &
          core_loop_code &
          [increment(idx_var)]
        )
      ),
      maybe_op(mk_seq_from_stream(res_var, strm_var), not knows_size)
    ];

    return nonempty(bound_info.eval_code & loop_code);
  }




  BoundCls gen_non_scalar_par_code(ClsExpr expr):
    ClsVar      = expr,
    fn_ptr()    = {
      var = lvar(0);
      ps = [fn_par(i) : i < expr.arity];
      body = [call_proc(var, expr.name, ps), ret_val(var)];
      cls = cls_def(expr.arity, body);
      return bound_cls(cls, []);
    },
    cls_expr()  = {
      //###################################################################################
      //## BUG BUG BUG: WHAT HAPPENS HERE IF THE CLOSURE ITSELF USES A CLOSURE VARIABLE? ##
      //###################################################################################
      loc_vs = seq_union([{v if v != nil, fn_par(i)} : v @ i <- expr.params]);
      ext_vs = rand_sort(extern_vars(expr.expr) - loc_vs);

      subst_map = merge([(v => cls_ext_par(i)) : v @ i <- ext_vs]);
      new_expr = replace_external_vars(expr.expr, subst_map);

      cls_body = [set_var(v, fn_par(i)) : v @ i <- expr.params, v != nil] & gen_fn_body(new_expr);

      return bound_cls(cls_def(nz_nat(length(expr.params)), nonempty(cls_body)), ext_vs);
    };


  <[]> gen_code(<[]>, EvalDestVar) = [];  //## BAD BAD: SHOULD BE A SUBSIGNATURE

  [Instr^] gen_code([Statement^] stmts, EvalDestVar res_var)
  {
    code = [];
    for (s : stmts)
      code = code & gen_code(s, res_var);
    ;
    return nonempty(code);
  }


  [Instr^] gen_code(Statement stmt, EvalDestVar res_var):
    break_stmt                = [break_loop],
    fail_stmt                 = [terminate],
    loop_stmt(ss?)            = [repeat(gen_code(ss, res_var))],
    print_stmt(e?)            = {info = gen_eval_info(e); return nonempty(info.eval_code & [print_obj(info.expr)]);},
    return_stmt               = [exit_block],
    return_stmt(e?)           = nonempty(gen_eval_code(e, res_var) & [exit_block]),
    assert_stmt()             = gen_code_for_assert_stmt(stmt.cond, stmt.file, stmt.line, stmt.text),
    let_stmt()                = gen_code_for_let_stmt(stmt.asgnms, stmt.body, res_var),
    assignment_stmt()         = gen_code_for_assignment_stmt(stmt.vars, stmt.value, res_var),
    imp_update_stmt()         = gen_code_for_imp_update_stmt(stmt.obj, stmt.idx, stmt.value, res_var),
    if_stmt()                 = gen_code_for_if_stmt(stmt.cond, stmt.body, stmt.else, res_var),
    for_stmt()                = gen_code_for_for_stmt(if stmt.var? then just(stmt.var) else nil, stmt.start_val, stmt.end_val, stmt.end_val_incl, stmt.body, res_var),
    foreach_stmt()            = gen_code_for_foreach_stmt(stmt.vars, if stmt.idx_var? then just(stmt.idx_var) else nil, stmt.values, stmt.body, res_var),
    set_memb_var_stmt()       = gen_code_for_set_memb_var_stmt(stmt.var, stmt.value),
    method_call_stmt()        = gen_code_for_method_call_stmt(stmt),
    proc_call()               = gen_code_for_proc_call_stmt(if stmt.res_var? then just(stmt.res_var) else nil, stmt.proc_name, stmt.params),
    auto_set_input_stmt()     = gen_code_for_auto_set_input_stmt(stmt.var, stmt.input, stmt.value),
    auto_update_stmt()        = gen_code_for_auto_update_stmt(stmt);


  [Instr^] gen_code_for_set_memb_var_stmt(PendingStateVar var, Expr value)
  {
    tmp_var = lvar(next_obj_var_id);
    eval_code = gen_eval_code(value, tmp_var, next_obj_var_id = nat(next_obj_var_id + 1));

    bare_state_var_id = name(var);
    asgnm_code = [
      set_var(var, tmp_var),
      set_ivar(update_source_var(bare_state_var_id), pending_state_var_asgnms_idxs[bare_state_var_id]),
      queue_update(try_value(self_auto), std_block_node_id(bare_state_var_id))
    ];

    return nonempty(eval_code & asgnm_code);
  }


  [Instr^] gen_code_for_method_call_stmt(MethodCallStmt stmt)
  {
    eval_info = gen_eval_info(stmt.args);
    call_method_instr = call_method(
      var:      stmt.var if stmt.var?,
      type:     if stmt.var? then auto_vars_types[stmt.var] else try_value(self_auto),
      channel:  method_symbol(stmt.channel),
      args:     eval_info.exprs
    );
    code = [eval_info.eval_code | call_method_instr];
    //## THIS IS PRETTY UGLY. I'M USING self_auto and/or stmt.var? TO CHECK IF THIS STATEMENT IS
    //## EXECUTING FROM WITHIN A PROCEDURE OR A METHOD
    assert (self_auto != nil) == (not stmt.var? or match (stmt.var) memb_auto_var() = true, loc_auto_var() = false);
    code = [code | queue_update(value(self_auto), std_block_node_id(name(stmt.var)))] if self_auto != nil and stmt.var?;
    return code;
  }


  [Instr^] gen_code_for_auto_update_stmt(AutoUpdateStmt stmt)
  {
    var = stmt.var;
    type = auto_vars_types[var];

    if (stmt.elapsed_time?)
      time_eval_info = gen_eval_info(stmt.elapsed_time);
      code = time_eval_info.eval_code;
      time = get_int_val(time_eval_info.expr);
    else
      code = [];
      time = 0;
    ;

    return [code | prop_input_updates(var: var, type: type, elapsed_time: time)];
  }


  [Instr^] gen_code_for_assert_stmt(Expr cond, String file, NzNat line, Maybe[String] text)
  {
    return [no_op] if ignore_assertions; //## WHY RETURNING [no_op] INSTEAD OF JUST []?
    info = gen_eval_info(cond);
    vs = {v : v <- extern_vars(cond), v :: <StdVar, NamedArg>};
    return nonempty(info.eval_code & [runtime_check(info.expr, file, line, text, vs)]);
  }


  [Instr^] gen_code_for_let_stmt((NamedArg => Expr) asgnms, [Statement^] body, EvalDestVar res_var)
  {
    //## THIS SHOULD BE CHECKED IN THE PROPER PLACE, BOTH IN LAYER 1 AND 2
    //## IT'S A TEMPORARY LIMITATION THAT SHOULD BE REMOVED
    assert subset(outcomes(body), {:fails, :falls_through});

    if (asgnms != ())
      //## BUG BUG BUG. THE ASSIGNMENTS ARE DONE IN RANDOM ORDER. FIX THIS
      var = an_elem(nonempty(keys(asgnms)));
      expr = asgnms[var];
      rem_asgnms = (v => e : e @ v <- asgnms, v != var);

      backup_var = lvar(next_obj_var_id);

      let (next_obj_var_id = nat(next_obj_var_id + 1))
        info = gen_eval_info(expr);
        inner_body = gen_code_for_let_stmt(rem_asgnms, body, res_var, next_obj_var_id = info.next_var_id);
      ;

      set_up_code = [set_var(backup_var, var), set_var(var, info.expr)];
      tear_down_code = [set_var(var, backup_var)];

      return nonempty(info.eval_code & set_up_code & inner_body & tear_down_code);
    ;

    return gen_code(body, res_var);
  }


  [Instr^] gen_code_for_assignment_stmt([StdVar^] vars, Expr value, EvalDestVar res_var)
  {
    if (length(vars) == 1)
      var = vars[0];
      if (in(var, extern_vars(value)))
        tmp_var = lvar(next_obj_var_id);
        code    = gen_eval_code(value, tmp_var, next_obj_var_id = nat(next_obj_var_id + 1)) & [set_var(var, tmp_var)];
      else
        code = gen_eval_code(value, var);
      ;
    else
      tmp_var = lvar(next_obj_var_id);
      code = gen_eval_code(value, tmp_var, next_obj_var_id = nat(next_obj_var_id + 1));
      code = code & join([[set_var(v, at(tmp_var, i))] : v @ i <- vars]);
    ;
    return nonempty(code);
  }


  [Instr^] gen_code_for_imp_update_stmt(StdVar obj, Expr idx, Expr value, EvalDestVar res_var)
  {
    idx_var = lvar(next_obj_var_id);
    value_var = lvar(nat(next_obj_var_id + 1));

    idx_info = gen_eval_info(idx, idx_var, next_obj_var_id = nat(next_obj_var_id + 1));
    val_info = gen_eval_info(value, value_var, next_obj_var_id = nat(next_obj_var_id + 2));

    //## SINCE THE INDEX VARIABLE IS AN INTEGER, THERE'S NO NEED TO WORRY ABOUT
    //## ABOUT MEMORY ALLOCATION AND DEALLOCATION. BUT IF WE EXTEND THE CONSTRUCT
    //## TO MAPS AS WELL, THE CODE WILL HAVE TO BE CHANGED...
    return nonempty(
      idx_info.eval_code & val_info.eval_code &
      [set_at(obj, get_int_val(idx_info.expr), val_info.expr)]
    );
  }


  [Instr^] gen_code_for_if_stmt(Expr cond, [Statement^] body, [Statement] else, EvalDestVar res_var)
  {
    cond_info = gen_eval_info(cond);
    // The variable used to store the value of the condition is not
    // needed anymore here, so there's no need to update next_obj_var_id
    if_code   = gen_code(body, res_var);
    else_code = gen_code(else, res_var);
    branch_code = [branch(is_true(cond_info.expr), if_code, else_code)];
    return nonempty(cond_info.eval_code & branch_code);
  }


  [Instr^] gen_code_for_for_stmt(Maybe[StdVar] maybe_var, Expr start_val, Expr end_val, Bool end_val_incl, [Statement^] body, EvalDestVar res_var)
  {
    tmp_var   = lvar(next_obj_var_id);
    start_var = ivar(next_int_var_id);
    end_var   = ivar(nat(next_int_var_id + 1));
    idx_var   = ivar(nat(next_int_var_id + 2));

    let (next_obj_var_id = nat(next_obj_var_id + 1))
      start_eval_code = gen_eval_code(start_val, tmp_var);
      end_eval_code   = gen_eval_code(end_val, tmp_var);
      body_code       = gen_code(body, res_var, next_int_var_id = nat(next_int_var_id + 3));
    ;

    loop_code = [
      repeat(
        nonempty(
          [ break_if(if end_val_incl then is_gt(idx_var, end_var) else is_ge(idx_var, end_var)),
            set_var(value(maybe_var), to_obj(idx_var)) if maybe_var != nil
          ] & body_code &
          [increment(idx_var)]
        )
      )
    ];

    return nonempty(
      start_eval_code & [set_ivar(idx_var, get_int_val(tmp_var))] &
      end_eval_code   & [set_ivar(end_var, get_int_val(tmp_var))] &
      loop_code
    );
  }


  [Instr^] gen_code_for_foreach_stmt([StdVar^] vars, Maybe[StdVar] maybe_idx_var, Expr values, [Statement^] body, EvalDestVar res_var)
  {
    src_var = lvar(next_obj_var_id);
    tmp_var = lvar(nat(next_obj_var_id + 1)); // Only used for destructuring assignments, remains free for the body to use
    idx_var = ivar(next_int_var_id);
    it_var  = seq_it_var(next_seq_it_var_id);

    has_idx_var = maybe_idx_var != nil;

    src_eval_code = gen_eval_code(values, src_var, next_obj_var_id = nat(next_obj_var_id + 1));

    body_code = gen_code(
      body,
      res_var,
      next_obj_var_id    = nat(next_obj_var_id + 1),
      next_int_var_id    = nat(next_int_var_id + if has_idx_var then 1 else 0),
      next_seq_it_var_id = nat(next_seq_it_var_id + 1)
    );

    if (length(vars) == 1)
      var_set_code = [set_var(vars[0], get_curr_obj(it_var))];
    else
      var_set_code = [set_var(tmp_var, get_curr_obj(it_var))];
      var_set_code = var_set_code & [set_var(v, at(tmp_var, i)) : v @ i <- vars];
    ;
    var_set_code = var_set_code & [set_var(value(maybe_idx_var), to_obj(idx_var))] if has_idx_var;

    loop_code = [
      get_iter(it_var, src_var),
      if has_idx_var then set_ivar(idx_var, 0) else no_op,
      repeat(
        nonempty(
          [break_if(is_out_of_range(it_var))] &
          var_set_code &
          body_code &
          [ move_forward(it_var),
            if has_idx_var then increment(idx_var) else no_op
          ]
        )
      )
    ];

    return nonempty(src_eval_code & loop_code);
  }


  [Instr^] gen_code_for_proc_call_stmt(Maybe[StdVar] maybe_res_var, ProcSymbol proc_name, [Expr] params)
  {
    pars_info = gen_eval_info(params);
    call_code = [call_proc(var: value(maybe_res_var) if maybe_res_var != nil, name: proc_name, params: pars_info.exprs)];
    return nonempty(pars_info.eval_code & call_code);
  }


  [Instr^] gen_code_for_auto_set_input_stmt(LocAutoVar var, Atom input, Maybe[Expr] value)
  {
    auto_type = auto_vars_types[var];
    if (value != nil)
      val_info = gen_eval_info(value(value));
      return nonempty(val_info.eval_code & [set_input(var, auto_type, input, just(val_info.expr))]);
    else
      return [set_input(var, auto_type, input, nil)];
    ;
  }
}

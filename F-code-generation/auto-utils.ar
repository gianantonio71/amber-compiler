MembCopyVar* memb_copy_vars(Automaton auto)
{
  assert not (? s <- values(auto.state)  : memb_copy_vars_in_expr(s.init_value) != {});
  assert not (? p <- values(auto.params) : memb_copy_vars_in_expr(p) != {});

  return union(
    {memb_copy_vars_in_expr(r) : r <- values(auto.rules)} &
    {memb_copy_vars(a) : a <- auto.actions} &
    {memb_copy_vars(a) : a <- auto.rep_actions}
  );
}


MembCopyVar* memb_copy_vars(AutoAtomicAction action):
  update()        = memb_copy_vars_in_expr(action.value),
  set_discrete()  = memb_copy_vars_in_expr(action.value),
  method_call()   = seq_union([memb_copy_vars_in_expr(e) : e <- action.args]);


MembCopyVar* memb_copy_vars(<AutoCondAction, AutoRepAction> action)
{
  cond_vars = memb_copy_vars_in_expr(action.cond);
  body_vars = union({memb_copy_vars(a) : a <- action.body});
  else_vars = union({memb_copy_vars(a) : a <- action.else});
  return cond_vars & body_vars & else_vars;
}


MembCopyVar* memb_copy_vars_in_expr(Expr expr):
  memb_copy_var()   = {expr},
  _                 = retrieve_from_nested_exprs(expr, memb_copy_vars_in_expr);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

using
{
  (AnyAutoVar => AutoSymbol)  auto_vars_types,
  Nat                         next_obj_var_id,
  Nat                         next_int_var_id,
  Nat                         next_bool_var_id,
  CompilationOptions          options;


  //## BAD BAD BAD: THIS IS BASICALLY A COPY OF gen_eval_info(), THE ONLY DIFFERENCE
  //## BEING THAT IT CALLS gen_safe_eval_info() INSTEAD OF gen_eval_info()
  EvalInfo gen_safe_eval_info(Expr expr, LocVar var):
    LeafObj         = (eval_code: [], expr: expr, var_used: false),
    Var             = (eval_code: [], expr: expr, var_used: false),
    // is_def(v?)      = {fail;},
    _               = (eval_code: gen_safe_eval_code(expr, var), expr: var, var_used: true);


  //## BAD BAD BAD: THIS IS BASICALLY A COPY OF gen_eval_info(), THE ONLY DIFFERENCE
  //## BEING THAT IT CALLS gen_safe_eval_info() INSTEAD OF gen_eval_info()
  ExEvalInfo gen_safe_eval_info(Expr expr)
  {
    var           = lvar(next_obj_var_id);
    info          = gen_safe_eval_info(expr, var, next_obj_var_id = nat(next_obj_var_id + 1)); //## BUG? BUG? BUG?
    next_var_id   = nat(next_obj_var_id + if info.var_used then 1 else 0);
    //## BAD BAD BAD: SHOULD BE SOMETHING LIKE:
    //## return (info | next_var_id: next_obj_var_id + if info.var_used then 1 else 0)
    return (eval_code: info.eval_code, expr: info.expr, var_used: info.var_used, next_var_id: next_var_id);
  }

  //## BAD BAD BAD: THIS IS BASICALLY A COPY OF gen_eval_info(), THE ONLY DIFFERENCE
  //## BEING THAT IT CALLS gen_safe_eval_info() INSTEAD OF gen_eval_info()
  MultEvalInfo gen_safe_eval_info([Expr] exprs)
  {
    eval_code         = [];
    res_exprs         = [];
    next_var_id       = next_obj_var_id;

    for (e : exprs)
      info = gen_safe_eval_info(e, next_obj_var_id = next_var_id);
      eval_code         = eval_code & info.eval_code;
      res_exprs         = res_exprs & [info.expr];
      next_var_id       = info.next_var_id;
    ;

    return (eval_code: eval_code, exprs: res_exprs, next_var_id: next_var_id);
  }

  //////////////////////////////////////////////////////////////////////////////

  [Instr^] gen_safe_eval_code(Expr expr, <MembVar, LocVar> res_var):
    and_expr()    = gen_safe_eval_code_for_and_expr(expr.left, expr.right, res_var),
    or_expr()     = gen_safe_eval_code_for_or_expr(expr.left, expr.right, res_var),
    _             = gen_default_safe_eval_code(expr, res_var);


  [Instr^] gen_safe_eval_code_for_and_expr(Expr left_expr, Expr right_expr, <MembVar, LocVar> res_var)
  {
    left_tmp_var = lvar(next_obj_var_id);
    right_tmp_var = lvar(nat(next_obj_var_id + 1));
    let (next_obj_var_id = nat(next_obj_var_id + 2))
      left_eval_code = gen_safe_eval_code(left_expr, left_tmp_var);
      right_eval_code = gen_safe_eval_code(right_expr, right_tmp_var);
    ;
    // If the left term is false, there's no need to compute the right value
    if_false_code = [set_var(res_var, obj_false)];
    // If the left term is true, the right one decides the final value
    if_true_code = [set_var(res_var, right_tmp_var)];
    // If the left term is undefined, then we need to check the value of the right term
    if_undef_code = [branch(is_false(right_tmp_var), [set_var(res_var, obj_false)], [make_var_undef(res_var)])];
    // true + undefined cases, they both require the evaluation of the right term
    if_not_false_code = [right_eval_code | branch(is_true(left_tmp_var), if_true_code, if_undef_code)];
    // Putting it all together
    return [left_eval_code | branch(is_false(left_tmp_var), if_false_code, if_not_false_code)];
  }


  [Instr^] gen_safe_eval_code_for_or_expr(Expr left_expr, Expr right_expr, <MembVar, LocVar> res_var)
  {
    left_tmp_var = lvar(next_obj_var_id);
    right_tmp_var = lvar(nat(next_obj_var_id + 1));
    let (next_obj_var_id = nat(next_obj_var_id + 2))
      left_eval_code = gen_safe_eval_code(left_expr, left_tmp_var);
      right_eval_code = gen_safe_eval_code(right_expr, right_tmp_var);
    ;
    // If the left term is true, there's no need to compute the right value
    if_true_code = [set_var(res_var, obj_true)];
    // If the left term is false, the right one decides the final value
    if_false_code = [set_var(res_var, right_tmp_var)];
    // If the left term is undefined, then we need to check the value of the right term
    if_undef_code = [branch(is_true(right_tmp_var), [set_var(res_var, obj_true)], [make_var_undef(res_var)])];
    // false + undefined cases, they both require the evaluation of the right term
    if_not_true_code = [right_eval_code | branch(is_false(left_tmp_var), if_false_code, if_undef_code)];
    // Putting it all together
    return [left_eval_code | branch(is_true(left_tmp_var), if_true_code, if_not_true_code)];
  }


  [Instr^] gen_default_safe_eval_code(Expr expr, <MembVar, LocVar> res_var)
  {
    eval_code = gen_eval_code(
      expr,
      res_var,
      next_set_it_var_id  = 0,
      next_seq_it_var_id  = 0,
      next_map_it_var_id  = 0,
      next_vector_var_id  = 0,
      next_stream_var_id  = 0,
      // auto_vars_types     = auto_vars_types,
      ignore_assertions   = options.ignore_assertions
    );

    vars_to_safeguard = non_nullable_vars(expr);
    if (vars_to_safeguard != {})
      cond = and([var_is_def(v) : v <- rand_sort(vars_to_safeguard)]);
      eval_code = [branch(cond, eval_code, [make_var_undef(res_var)])];
    ;

    return eval_code;
  }
}

////////////////////////////////////////////////////////////////////////////////

//## THIS FUNCTION HAS A REALLY STRANGE NAME. SHOULDN'T IT BE THE OPPOSITE?
<MembVar, MembCopyVar>* non_nullable_vars(Expr expr)
{
  //## BUG BUG BUG: THIS IS WRONG. VARIABLES IN is-def EXPRESSIONS SHOULD NOT BE COUNTED HERE
  vs = extern_vars(expr);
  return {v : v <- vs, v :: <MembVar, MembCopyVar>};
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Atom* discrete_signals(Automaton auto)
{
  return {id : info @ id <- auto.inputs, info.discrete} &
         union({discrete_signals(a) : a <- auto.actions & auto.rep_actions});


  Atom* discrete_signals(<AutoCondAction, AutoRepAction> action) =
    union({discrete_signals(a) : a <- action.body & action.else});

  Atom* discrete_signals(AutoUpdate) = {};

  Atom* discrete_signals(AutoSetDiscrete action) = {action.target};

  Atom* discrete_signals(AutoMethodCall) = {};
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

AutoMethodCall* retrieve_method_calls(AutoCondAction action) =
  union({retrieve_method_calls(a) : a <- action.body & action.else});

AutoMethodCall* retrieve_method_calls(AutoRepAction action) =
  union({retrieve_method_calls(a) : a <- action.body & action.else});

AutoMethodCall* retrieve_method_calls(AutoUpdate)           = {};
AutoMethodCall* retrieve_method_calls(AutoSetDiscrete)      = {};
AutoMethodCall* retrieve_method_calls(AutoMethodCall call)  = {call};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[Nat] trigger_times_table(BasicTimeExpr time_expr)
{
  trigger_times = trigger_times(time_expr);
  assert trigger_times != [];
  interval_lengths = [nz_nat(t - if i == 0 then 0 else trigger_times[i-1]) : t @ i <- trigger_times];
  return [interval_lengths | 0]; //## DO I REALLY NEED TO ADD THAT 0 AT THE END?
}


IntConst time_slot_length(BasicTimeExpr time_expr, AutoSymbol auto_name, Atom expr_id, IntExpr time_slot_expr) =
  time_slot_length(auto_name, expr_id, time_slot_expr);


[Nat] trigger_times_table(CyclicTimeExpr time_expr)
{
  trigger_times = trigger_times(time_expr);
  return [] if trigger_times == [];
  interval_lengths = [nz_nat(t - if i == 0 then 0 else trigger_times[i-1]) : t @ i <- trigger_times];
  count = length(trigger_times);
  if (mod(count, 2) != 0)
    head_seq = interval_lengths;
    tail_elem = nat(time_expr.nanosecs - last(trigger_times));
  else
    head_seq = tail(interval_lengths);
    tail_elem = nat(time_expr.nanosecs - last(trigger_times) + head(interval_lengths));
  ;

  return [head_seq | tail_elem];
}


IntConst time_slot_length(CyclicTimeExpr time_expr, AutoSymbol auto_name, Atom expr_id, IntExpr time_slot_expr)
{
  trigger_times = trigger_times(time_expr);
  assert trigger_times != [];
  fail if trigger_times == [];
  count = length(trigger_times);
  if (mod(count, 2) != 0)
    final_time_slot_expr = mod_op(time_slot_expr, count + 1);
  else
    final_time_slot_expr = mod_op(sub(time_slot_expr, 1), count);
  ;
  return time_slot_length(auto_name, expr_id, final_time_slot_expr);
}

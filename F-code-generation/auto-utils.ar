MembCopyVar* memb_copy_vars(Automaton auto)
{
  assert not (? s <- values(auto.state)  : memb_copy_vars_in_expr(s.init_value) != {});
  assert not (? p <- values(auto.params) : memb_copy_vars_in_expr(p) != {});

  return union(
    {memb_copy_vars_in_expr(r) : r <- values(auto.rules)} &
    {memb_copy_vars(a) : a <- auto.actions} &
    {memb_copy_vars(a) : a <- auto.rep_actions}
  );
}


MembCopyVar* memb_copy_vars(AutoAtomicAction action) = memb_copy_vars_in_expr(action.value);


MembCopyVar* memb_copy_vars(<AutoCondAction, AutoRepAction> action)
{
  cond_vars = memb_copy_vars_in_expr(action.cond);
  body_vars = union({memb_copy_vars(a) : a <- action.body});
  else_vars = union({memb_copy_vars(a) : a <- action.else});
  return cond_vars & body_vars & else_vars;
}


MembCopyVar* memb_copy_vars_in_expr(Expr expr):
  memb_copy_var()   = {expr},
  _                 = retrieve_from_nested_exprs(expr, memb_copy_vars_in_expr);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

using Nat next_obj_var_id, Nat next_int_var_id, Nat next_bool_var_id, CompilationOptions options
{
  [Instr^] gen_safe_eval_code(Expr expr, <MembVar, LocVar> res_var):
    and_expr()    = gen_safe_eval_code_for_and_expr(expr.left, expr.right, res_var),
    or_expr()     = gen_safe_eval_code_for_or_expr(expr.left, expr.right, res_var),
    _             = gen_default_safe_eval_code(expr, res_var);


  [Instr^] gen_safe_eval_code_for_and_expr(Expr left_expr, Expr right_expr, <MembVar, LocVar> res_var)
  {
    left_tmp_var = lvar(next_obj_var_id);
    right_tmp_var = lvar(nat(next_obj_var_id + 1));
    let (next_obj_var_id = nat(next_obj_var_id + 2))
      left_eval_code = gen_safe_eval_code(left_expr, left_tmp_var);
      right_eval_code = gen_safe_eval_code(right_expr, right_tmp_var);
    ;
    // If the left term is false, there's no need to compute the right value
    if_false_code = [set_var(res_var, obj_false)];
    // If the left term is true, the right one decides the final value
    if_true_code = [set_var(res_var, right_tmp_var)];
    // If the left term is undefined, then we need to check the value of the right term
    if_undef_code = [branch(is_false(right_tmp_var), [set_var(res_var, obj_false)], [make_var_undef(res_var)])];
    // true + undefined cases, they both require the evaluation of the right term
    if_not_false_code = [right_eval_code | branch(is_true(left_tmp_var), if_true_code, if_undef_code)];
    // Putting it all together
    return [left_eval_code | branch(is_false(left_tmp_var), if_false_code, if_not_false_code)];
  }


  [Instr^] gen_safe_eval_code_for_or_expr(Expr left_expr, Expr right_expr, <MembVar, LocVar> res_var)
  {
    left_tmp_var = lvar(next_obj_var_id);
    right_tmp_var = lvar(nat(next_obj_var_id + 1));
    let (next_obj_var_id = nat(next_obj_var_id + 2))
      left_eval_code = gen_safe_eval_code(left_expr, left_tmp_var);
      right_eval_code = gen_safe_eval_code(right_expr, right_tmp_var);
    ;
    // If the left term is true, there's no need to compute the right value
    if_true_code = [set_var(res_var, obj_true)];
    // If the left term is false, the right one decides the final value
    if_false_code = [set_var(res_var, right_tmp_var)];
    // If the left term is undefined, then we need to check the value of the right term
    if_undef_code = [branch(is_true(right_tmp_var), [set_var(res_var, obj_true)], [make_var_undef(res_var)])];
    // false + undefined cases, they both require the evaluation of the right term
    if_not_true_code = [right_eval_code | branch(is_false(left_tmp_var), if_false_code, if_undef_code)];
    // Putting it all together
    return [left_eval_code | branch(is_true(left_tmp_var), if_true_code, if_not_true_code)];
  }


  [Instr^] gen_default_safe_eval_code(Expr expr, <MembVar, LocVar> res_var)
  {
    eval_code = gen_eval_code(
      expr,
      res_var,
      next_set_it_var_id  = 0,
      next_seq_it_var_id  = 0,
      next_map_it_var_id  = 0,
      next_vector_var_id  = 0,
      next_stream_var_id  = 0,
      auto_vars_types     = (),
      ignore_assertions   = options.ignore_assertions
    );

    vars_to_safeguard = non_nullable_vars(expr);
    if (vars_to_safeguard != {})
      cond = and([var_is_def(v) : v <- rand_sort(vars_to_safeguard)]);
      eval_code = [branch(cond, eval_code, [make_var_undef(res_var)])];
    ;

    return eval_code;
  }
}

////////////////////////////////////////////////////////////////////////////////

//## THIS FUNCTION HAS A REALLY STRANGE NAME. SHOULDN'T IT BE THE OPPOSITE?
<MembVar, MembCopyVar>* non_nullable_vars(Expr expr)
{
  //## BUG BUG BUG: THIS IS WRONG. VARIABLES IN is-def EXPRESSIONS SHOULD NOT BE COUNTED HERE
  vs = extern_vars(expr);
  return {v : v <- vs, v :: <MembVar, MembCopyVar>};
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Atom* discrete_signals(Automaton auto)
{
  return {id : info @ id <- auto.inputs, info.discrete} &
         union({discrete_signals(a) : a <- auto.actions & auto.rep_actions});


  Atom* discrete_signals(<AutoCondAction, AutoRepAction> action) =
    union({discrete_signals(a) : a <- action.body & action.else});

  Atom* discrete_signals(AutoUpdate) = {};

  Atom* discrete_signals(AutoSetDiscrete action) = {action.target};
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[Nat] trigger_times_table(BasicTimeExpr time_expr)
{
  trigger_times = trigger_times(time_expr);
  assert trigger_times != [];
  interval_lengths = [nz_nat(t - if i == 0 then 0 else trigger_times[i-1]) : t @ i <- trigger_times];
  return [interval_lengths | 0]; //## DO I REALLY NEED TO ADD THAT 0 AT THE END?
}


IntConst time_slot_length(BasicTimeExpr time_expr, AutoSymbol auto_name, Atom expr_id, IntExpr time_slot_expr) =
  time_slot_length(auto_name, expr_id, time_slot_expr);


[Nat] trigger_times_table(CyclicTimeExpr time_expr)
{
  trigger_times = trigger_times(time_expr);
  return [] if trigger_times == [];
  interval_lengths = [nz_nat(t - if i == 0 then 0 else trigger_times[i-1]) : t @ i <- trigger_times];
  count = length(trigger_times);
  if (mod(count, 2) != 0)
    head_seq = interval_lengths;
    tail_elem = nat(time_expr.nanosecs - last(trigger_times));
  else
    head_seq = tail(interval_lengths);
    tail_elem = nat(time_expr.nanosecs - last(trigger_times) + head(interval_lengths));
  ;

  return [head_seq | tail_elem];
}


IntConst time_slot_length(CyclicTimeExpr time_expr, AutoSymbol auto_name, Atom expr_id, IntExpr time_slot_expr)
{
  trigger_times = trigger_times(time_expr);
  assert trigger_times != [];
  fail if trigger_times == [];
  count = length(trigger_times);
  if (mod(count, 2) != 0)
    final_time_slot_expr = mod_op(time_slot_expr, count + 1);
  else
    final_time_slot_expr = mod_op(sub(time_slot_expr, 1), count);
  ;
  return time_slot_length(auto_name, expr_id, final_time_slot_expr);
}

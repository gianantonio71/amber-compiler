Var* syn_new_vars(SynPtrn ptrn):
    ptrn_var()      = {ptrn.var} & syn_new_vars(ptrn.ptrn),
    ptrn_tag_obj()  = syn_new_vars(ptrn.tag) & syn_new_vars(ptrn.obj),
    _               = {};


Var* syn_new_vars(SynStmt stmt):
  assignment_stmt() = set(stmt.vars),
  if_stmt()         = {
    bodies = {b.body : b <- set(stmt.branches)} & {stmt.else};
    return intersection({syn_new_vars(ss) : ss <- bodies, not never_falls_through(ss)});
  },
  let_stmt()        = syn_new_vars(stmt.body),
  proc_call()       = {stmt.res_var if stmt.res_var?},
  _                 = {};


Var* syn_new_vars([<SynStmt, SynClause>] objs) = seq_union([syn_new_vars(obj) : obj <- objs]);


Var* syn_new_vars(SynClause clause):
  in_clause()           = syn_new_vars(clause.ptrn),
  map_in_clause()       = syn_new_vars(clause.key_ptrn) & syn_new_vars(clause.value_ptrn),
  eq_clause()           = {clause.var},
  and_clause(cs?)       = seq_union([syn_new_vars(c) : c <- cs]),
  or_clause()           = intersection(syn_new_vars(clause.left), syn_new_vars(clause.right));


Var* syn_new_vars(SynIter iter):
  seq_iter()    = set(iter.vars) & {iter.idx_var if iter.idx_var?},
  range_iter()  = {iter.var if iter.var?};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

TypeSymbol syn_type_symbol_to_type_symbol(SynTypeSymbol ts, Maybe[[TypeVar]] type_vars):
  BasicTypeSymbol   = ts,
  par_type_symbol() = par_type_symbol(ts.symbol, [syn_type_to_type(p, type_vars) : p <- ts.params]);


Type syn_type_to_type(SynType type, Maybe[[TypeVar]] type_vars):
  LeafType            = type,
  type_var(+)         = if type_vars /= nil then type_var(index_first(type, value(type_vars))) else type,
  type_var(*)         = type,
  type_ref(ts?)       = type_ref(syn_type_symbol_to_type_symbol(ts, type_vars)),
  syn_int_range()     = int_range(type.min, type.max),
  ne_seq_type()       = ne_seq_type(syn_type_to_type(type.elem_type, type_vars)),
  ne_set_type()       = ne_set_type(syn_type_to_type(type.elem_type, type_vars)),
  ne_map_type()       = ne_map_type(syn_type_to_type(type.key_type, type_vars), syn_type_to_type(type.value_type, type_vars)),
  record_type(fs?)    = record_type((f.label => (type: syn_type_to_type(f.type, type_vars), optional: f.optional) : f <- set(fs))),
  tuple_type(ts?)     = tuple_type([syn_type_to_type(t, type_vars) : t <- ts]),
  tag_obj_type()      = { tag_type = type.tag_type;
                          fail if not tag_type :: TagType; //## BAD: HANDLE THE ERROR
                          return tag_obj_type(tag_type, syn_type_to_type(type.obj_type, type_vars));
                        },
  union_type(ts?)     = union_type({syn_type_to_type(t, type_vars) : t <- set(ts)});


ClsType syn_type_to_type(SynClsType type, Maybe[[TypeVar]] type_vars) =
  cls_type(
    [syn_type_to_type(t, type_vars) : t <- type.in_types],
    syn_type_to_type(type.out_type, type_vars)
  );

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Bool syn_is_last_for_sure(SynStmt stmt):
  return_stmt()       = true,
  fail_stmt           = true,
  if_stmt()           = all([at_least_one([syn_is_last_for_sure(s) : s <- b.body]) : b <- stmt.branches])
                        and at_least_one([syn_is_last_for_sure(s) : s <- stmt.else]),
  inf_loop_stmt(ss?)  = none([syn_can_break_loop(s) : s <- ss]),
  //:break_stmt         = //## NOT SURE HERE
  let_stmt()          = at_least_one([syn_is_last_for_sure(s) : s <- stmt.body]),
  _                   = false;


Bool syn_can_break_loop(SynStmt stmt):
  break_stmt  = true,
  if_stmt()   = at_least_one([at_least_one([syn_can_break_loop(s) : s <- b.body]) : b <- stmt.branches])
                or at_least_one([syn_can_break_loop(s) : s <- stmt.else]),
  _           = false;


Bool has_top_level_break([SynStmt] stmts)
{
  for (s : stmts)
    return true if s == :break_stmt;

    if (s :: SynIfStmt) //## BAD BAD BAD
      //## BAD BAD BAD A LOOP SHOULD NOT BE NECESSARY HERE
      for (b : s.branches)
        return true if has_top_level_break(b.body);
      ;
      return true if has_top_level_break(s.else);
    ;
  ;

  return false;
}

//## BUG BUG BUG IF THE RETURN STATEMENT IS INSIDE A NESTED,
//## DO EXPRESSION IT EXITS THAT AND NOT THE MAIN ONE
Bool has_return([SynStmt] stmts) = select(stmts, $ :: <return_stmt(Any)>) /= {}; //## BAD: HERE I NEED A SEARCH FUNCTION, NOT A SELECT ONE

Bool never_falls_through(SynStmt stmt):
  return_stmt()       = true,
  fail_stmt           = true,

  inf_loop_stmt(ss?)  = not has_top_level_break(ss),

  if_stmt()           = { for (b : stmt.branches) //## BAD BAD BAD A LOOP SHOULDN'T BE NEEDED
                            return false if not never_falls_through(b.body);
                          ;
                          return never_falls_through(stmt.else);
                        },

  let_stmt()          = never_falls_through(stmt.body),

  //## WHY DID I DO THIS? IT MAKES NO SENSE...
  //loop_stmt()       = never_falls_through(stmt.body),
  //for_stmt()        = never_falls_through(stmt.body), //## BAD

  _                   = false;


//## BAD BAD BAD A LOOP SHOULDN'T BE NEEDED
Bool never_falls_through([SynStmt] stmts)
{
  for (s : stmts)
    return true if never_falls_through(s);
  ;
  return false;
}

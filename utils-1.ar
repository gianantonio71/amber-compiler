[StdVar] syn_new_vars(SynPtrn ptrn):
    ptrn_var()      = [ptrn.var] & syn_new_vars(ptrn.ptrn),
    ptrn_tuple(ps?) = seq_union((syn_new_vars(p) | p <- ps)),
    ptrn_tag_obj()  = syn_new_vars(ptrn.tag) & syn_new_vars(ptrn.obj),
    ptrn_union(ps?) = intersection(set((syn_new_vars(p) | p <- ps))),
    _               = [];


[StdVar] syn_new_vars(SynStmt stmt):
  assignment_stmt() = set(stmt.vars),
  if_stmt()         = {
    bodies = [b.body | b <- set(stmt.branches)] & [stmt.else];
    return intersection([syn_new_vars(ss) | ss <- bodies, syn_may_fall_through(ss)]);
  },
  let_stmt()        = syn_new_vars(stmt.body),
  proc_call_stmt()  = [stmt.res_var if stmt.res_var?],
  _                 = [];


[StdVar] syn_new_vars(<SynStmt, SynClause>* objs) = seq_union((syn_new_vars(obj) | obj <- objs));


[StdVar] syn_new_vars(SynClause clause):
  iter_clause()         = set(clause.vars),
  and_clause(cs?)       = seq_union((syn_new_vars(c) | c <- cs)),
  or_clause()           = intersection(syn_new_vars(clause.left), syn_new_vars(clause.right)),
  match_clause()        = syn_new_vars(clause.ptrn),
  asgnm_clause()        = [clause.var],
  filter_clause()       = [];


[StdVar] syn_new_vars(SynIter iter):
  seq_iter()    = set(iter.vars) & [iter.idx_var if iter.idx_var?],
  range_iter()  = [iter.var if iter.var?];

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[TypeVar] syn_type_vars(SynClsType type) = seq_union((syn_type_vars(t) | t <- type.in_types)) & syn_type_vars(type.out_type);

[TypeVar] syn_type_vars(SynType type):
  SynLeafType         = [],
  type_ref(ts?)       = syn_type_vars(ts),
  type_var()          = [type],
  ne_seq_type()       = syn_type_vars(type.elem_type),
  ne_set_type()       = syn_type_vars(type.elem_type),
  ne_map_type()       = syn_type_vars(type.key_type) & syn_type_vars(type.value_type),
  ne_rel_type()       = seq_union((syn_type_vars(t) | t <- type.args_types)),
  record_type(fs?)    = seq_union((syn_type_vars(f.type) | f <- fs)),
  tuple_type(ts?)     = seq_union((syn_type_vars(t) | t <- ts)),
  tag_obj_type()      = syn_type_vars(type.tag_type) & syn_type_vars(type.obj_type),
  union_type(ts?)     = seq_union((syn_type_vars(t) | t <- ts));

[TypeVar] syn_type_vars(SynTypeSymbol type_symb):
  BasicTypeSymbol   = [],
  par_type_symbol() = seq_union((syn_type_vars(t) | t <- type_symb.params));

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

TypeSymbol syn_type_symbol_to_type_symbol(SynTypeSymbol ts, Maybe[TypeVar*] type_vars):
  BasicTypeSymbol   = ts,
  par_type_symbol() = par_type_symbol(ts.symbol, (syn_type_to_type(p, type_vars) | p <- ts.params));


NeType syn_type_to_type(SynType type, Maybe[TypeVar*] type_vars):
  LeafType            = type,
  type_var(+)         = if type_vars != nil then type_var(index_first(type, value(type_vars))) else type,
  type_var(*)         = type,
  type_ref(ts?)       = type_ref(syn_type_symbol_to_type_symbol(ts, type_vars)),
  syn_int_range()     = int_range(type.min, type.max),
  ne_seq_type()       = ne_seq_type(syn_type_to_type(type.elem_type, type_vars)),
  ne_set_type()       = ne_set_type(syn_type_to_type(type.elem_type, type_vars)),
  ne_map_type()       = ne_map_type(syn_type_to_type(type.key_type, type_vars), syn_type_to_type(type.value_type, type_vars)),
  ne_rel_type()       = { match ((syn_type_to_type(t, type_vars) | t <- type.args_types))
                            (_, _)    ts? = ne_bin_rel_type(args_types: ts),
                            (_, _, _) ts? = ne_tern_rel_type(args_types: ts)
                        },
  record_type(fs?)    = record_type_nonempty([f.label -> (type: syn_type_to_type(f.type, type_vars), optional: f.optional) | f <- set(fs)]),
  tuple_type(ts?)     = tuple_type_nonempty((syn_type_to_type(t, type_vars) | t <- ts)),
  tag_obj_type()      = { tag_type = type.tag_type;
                          fail if not tag_type :: TagType; //## BAD: HANDLE THE ERROR
                          return tag_obj_type(tag_type, syn_type_to_type(type.obj_type, type_vars));
                        },
  union_type(ts?)     = union_type_nonempty([syn_type_to_type(t, type_vars) | t <- set(ts)]);


ClsType syn_type_to_type(SynClsType type, Maybe[TypeVar*] type_vars) =
  cls_type(
    (syn_type_to_type(t, type_vars) | t <- type.in_types),
    syn_type_to_type(type.out_type, type_vars)
  );


[TypeName -> Type] create_type_map([SynTypedef] tdefs, [SynParTypedef] par_tdefs)
{
  type_map = [type_name(td.name, 0) -> syn_type_to_type(td.type, just(())) | td <- tdefs];
  par_type_map = [type_name(td.name, length(td.params)) -> syn_type_to_type(td.type, just(td.params)) | td <- par_tdefs];
  return type_map & par_type_map;
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

PseudoType syn_pseudotype(SynType type, [TypeName -> Type] typedefs) = pseudotype(syn_type_to_type(type, nil), typedefs);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//## THIS IS JUST A COPY OF THE CORRENSPONDING FUNCTIONS FOR CORE/LEVEL 2 STATEMENTS
//## IS THERE A WAY TO WRITE THEM JUST ONCE?
[+StmtOutcome] syn_outcomes(SynStmt* stmts)
{
  os = [:falls_through];
  for s <- stmts:
    os = {os - [:falls_through]} & syn_outcomes(s);
    break if not in(:falls_through, os);
  ;
  return nonempty(os);
}


[+StmtOutcome] syn_outcomes(SynStmt stmt):
  return_stmt             = [:returns],
  return_stmt()           = [:fails, :returns],
  if_stmt()               = nonempty(
                              [:fails] & syn_outcomes(stmt.else) & seq_union((syn_outcomes(b.body) | b <- stmt.branches))
                            ),
  loop_stmt(body?)        = loop_stmt_syn_outcomes(stmt.skip_first, stmt.body),
  inf_loop_stmt(ss?)      = inf_loop_stmt_syn_outcomes(ss),
  for_stmt()              = [:fails, :falls_through, :returns if in(:returns, syn_outcomes(stmt.body))],
  let_stmt()              = nonempty([:fails] & syn_outcomes(stmt.body)),
  break_stmt              = [:breaks],
  fail_stmt               = [:fails],
  assignment_stmt()       |
  assert_stmt()           |
  print_stmt()            |
  imp_update_stmt()       |
  proc_call_stmt()        |
  send_msg_stmt()         |
  try_update_stmt()       |
  set_memb_var_stmt()     |
  delete_stmt()           |
  insert_stmt()           |
  set_input_ctrl_stmt()   |
  clear_input_ctrl_stmt() |
  apply_ctrl_stmt()       |
  send_msg_ctrl_stmt()    = [:falls_through, :fails];


[+StmtOutcome] loop_stmt_syn_outcomes(Bool skip_first, SynStmt+ body)
{
  os = syn_outcomes(body);
  return [
    :falls_through  if in(:falls_through, os) or in(:breaks, os) or not skip_first,
    :returns        if in(:returns, os),
    :fails
  ];
}


[+StmtOutcome] inf_loop_stmt_syn_outcomes(SynStmt+ body)
{
  os = syn_outcomes(body);
  return nonempty([
    :falls_through  if in(:breaks, os),
    :returns        if in(:returns, os),
    :fails          if in(:fails, os) or in(:falls_through, os)
  ]);
}

////////////////////////////////////////////////////////////////////////////////

Bool syn_may_fall_through(SynStmt stmt) = in(:falls_through, syn_outcomes(stmt));

Bool syn_may_fall_through(SynStmt* stmts) = in(:falls_through, syn_outcomes(stmts));

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[Var] already_def_vars([Var] new_vars, [Var] curr_vars) = [v | v <- new_vars, already_def(v, curr_vars)];

Bool already_def(Var var, [Var] vars):
  var(n?)         = already_def(n, vars),
  named_arg(n?)   = already_def(n, vars),
  memb_var(n?)    = already_def(n, vars),
  _               = in(var, vars);

Bool already_def(Atom var_name, [Var] vars) =
  in(var(var_name), vars)         or
  in(named_arg(var_name), vars)   or
  in(memb_var(var_name), vars);

FnSymbol named_arg_to_fn_symb(NamedArg p):
  named_arg(n?)   = fn_symbol(n);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Atom rule_id(ConstDecl decl)  = decl.name;

Atom rule_id(RuleDecl decl):
  syn_plain_rule()                  |
  syn_cond_rule()                   |
  syn_foreach_rule()                |
  syn_time_varying_boolean_rule()   |
  syn_time_varying_unchanged_rule() |
  syn_time_varying_inactive_rule()  |
  syn_nested_auto()                 = decl.name,
  syn_msg_send()                    = decl.target;


//## THIS IS CALLED TWICE IN THE SYNTAX REMOVAL STAGE. CONSIDER USING AN IMPLICIT PARAMETER
[SynAutoDef] resolve_inheritance([SynAutoDef] automata)
{
  autos_by_id = [a.name -> a | a <- automata];

  parent_child_rels = [a.name -> [auto_symbol(a.parent) if a.parent?] | a <- automata];
  sorted_auto_ids = topological_sort(parent_child_rels);

  resolved_autos_by_id = [:];
  for ids <- sorted_auto_ids:
    layer_autos_by_id = [id -> resolve_inheritance(autos_by_id[id], resolved_autos_by_id) | id <- ids];
    resolved_autos_by_id = resolved_autos_by_id & layer_autos_by_id;
  ;

  return values(resolved_autos_by_id);


  SynAutoDef resolve_inheritance(SynAutoDef child, [AutoSymbol -> SynAutoDef] resolved_autos_by_id)
  {
    return child if not child.parent?;
    parent = resolved_autos_by_id[auto_symbol(child.parent)];

    overriding_ids = [rule_id(d) | d <- set(child.rules & child.consts)];

    inherited_inputs = (i | i <- parent.inputs, not in(i.name, overriding_ids));
    inherited_consts = (c | c <- parent.consts, not in(c.name, overriding_ids));
    inherited_rules  = (r | r <- parent.rules,  not in(rule_id(r), overriding_ids));

    return syn_auto_def(
      name:       child.name,
      pos_inputs: child.pos_inputs,
      res_type:   child.res_type if child.res_type?,
      inputs:     inherited_inputs & child.inputs,
      outputs:    parent.outputs & child.outputs,
      state_vars: parent.state_vars & child.state_vars,
      nested_dbs: parent.nested_dbs & child.nested_dbs,
      consts:     inherited_consts & child.consts,
      rules:      inherited_rules & child.rules
    );
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//## NOT SURE THIS IS THE RIGHT PLACE FOR THIS STUFF

type AccessorChain = accessor(expr: <ConstOrVar, AccessorChain>, field: Atom);

type IdChain = ConstOrVar, AccessorChain;

(Atom) destructure_id_chain(ConstOrVar expr):
  const_or_var(a?)  = (a);

Atom+ destructure_id_chain(AccessorChain expr) =
  match (expr.expr)
    const_or_var(a?)  = (a, expr.field),
    accessor()        = (destructure_id_chain(expr.expr) || expr.field);

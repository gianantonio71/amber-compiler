[StdVar] syn_new_vars(SynPtrn ptrn):
    ptrn_var()      = [ptrn.var] & syn_new_vars(ptrn.ptrn),
    ptrn_tuple(ps?) = seq_union((syn_new_vars(p) : p <- ps)),
    ptrn_tag_obj()  = syn_new_vars(ptrn.tag) & syn_new_vars(ptrn.obj),
    ptrn_union(ps?) = intersection([syn_new_vars(p) : p <~ ps]),
    _               = [];


[StdVar] syn_new_vars(SynStmt stmt):
  assignment_stmt()       = set(stmt.vars),
  if_stmt()               = { bodies = [b.body : b <~ stmt.branches] & [stmt.else];
                              return intersection([syn_new_vars(ss) : ss <- bodies; syn_may_fall_through(ss)]);
                            },
  let_stmt()              = syn_new_vars(stmt.body),
  proc_call_stmt()        = [stmt.res_var if stmt.res_var?],
  send_msg_ctrl_stmt()    = [var(stmt.res_var)],
  read_state_ctrl_stmt()  = [var(stmt.res_var)],
  _                       = [];


[StdVar] syn_new_vars(<SynStmt, SynClause>* objs) = seq_union((syn_new_vars(obj) : obj <- objs));


[StdVar] syn_new_vars(SynClause clause):
  iter_clause()         = set(clause.vars),
  seq_clause()          = [var(value(v)) : v <~ (clause.vars | clause.idx_var); v != nil],
  and_clause(cs?)       = seq_union((syn_new_vars(c) : c <- cs)),
  or_clause(cs?)        = intersection([syn_new_vars(c) : c <~ cs]),
  match_clause()        = syn_new_vars(clause.ptrn),
  asgnm_clause()        = [clause.var],
  filter_clause()       = [];


[StdVar] syn_new_vars(SynIter iter):
  seq_iter()    = set(iter.vars) & [iter.idx_var if iter.idx_var?],
  range_iter()  = [iter.var if iter.var?];

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[TypeVar] syn_type_vars(SynClsType type) = seq_union((syn_type_vars(t) : t <- type.in_types)) & syn_type_vars(type.out_type);

[TypeVar] syn_type_vars(SynType type):
  SynLeafType         = [],
  type_ref(ts?)       = syn_type_vars(ts),
  type_var()          = [type],
  ne_seq_type()       = syn_type_vars(type.elem_type),
  ne_set_type()       = syn_type_vars(type.elem_type),
  ne_map_type()       = syn_type_vars(type.key_type) & syn_type_vars(type.value_type),
  ne_rel_type()       = seq_union((syn_type_vars(t) : t <- type.args_types)),
  record_type(fs?)    = seq_union((syn_type_vars(f.type) : f <- fs)),
  tuple_type(ts?)     = seq_union((syn_type_vars(t) : t <- ts)),
  tag_obj_type()      = syn_type_vars(type.tag_type) & syn_type_vars(type.obj_type),
  union_type(ts?)     = seq_union((syn_type_vars(t) : t <- ts));

[TypeVar] syn_type_vars(SynTypeSymbol type_symb):
  BasicTypeSymbol   = [],
  par_type_symbol() = seq_union((syn_type_vars(t) : t <- type_symb.params));

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

NeType desugar_type(SynType type) =
  desugar_type(
    type,
    match ($)
      type_var() = $,
      type_ref() = desugar_type_ref($, desugar_type)
  );


NeType desugar_par_type_def(SynType type, TypeVar+ sorted_type_vars) =
  desugar_type(
    type,
    match ($)
      type_var() = type_var(index_first($, sorted_type_vars)),
      type_ref() = desugar_type_ref($, desugar_par_type_def($, sorted_type_vars))
  );


NeType desugar_prot_aware_type(SynType type, [Atom -> TypeVar] subst_map) =
  desugar_type(
    type,
    match ($)
      type_var()                = $,
      type_ref(type_symbol(a?)) = if subst_map(a, ?) then subst_map(a) else $,
      type_ref()                = desugar_type_ref($, desugar_prot_aware_type($, subst_map))
  );

////////////////////////////////////////////////////////////////////////////////

ClsType desugar_cls_type(SynClsType type, (SynType -> NeType) desugar) =
  cls_type((desugar(t) : t <- type.in_types), desugar(type.out_type));

////////////////////////////////////////////////////////////////////////////////

NeType desugar_type_ref(SynTypeRef, (<SynTypeRef, SynTypeVar> -> NeType) desugar):
  type_ref(ts?) = type_ref(desugar_type_symb(ts, desugar));


TypeSymbol desugar_type_symb(SynTypeSymbol type_symb, (<SynTypeRef, SynTypeVar> -> NeType) desugar):
  BasicTypeSymbol   = type_symb,
  par_type_symbol() = { type_pars = (desugar_type(p, desugar) : p <- type_symb.params);
                        return par_type_symbol(type_symb.symbol, type_pars);
                      };

////////////////////////////////////////////////////////////////////////////////

NeType desugar_type(SynType type, (<SynTypeRef, SynTypeVar> -> NeType) desugar):
  LeafType          = type,
  type_var()        = desugar(type),
  type_ref()        = desugar(type),
  syn_int_range()   = int_range(type.min, type.max),
  ne_seq_type()     = ne_seq_type(desugar_type(type.elem_type, desugar)),
  ne_set_type()     = ne_set_type(desugar_type(type.elem_type, desugar)),
  ne_map_type()     = ne_map_type(desugar_type(type.key_type, desugar), desugar_type(type.value_type, desugar)),
  ne_rel_type()     = { match ((desugar_type(t, desugar) : t <- type.args_types))
                          (_, _)    ts? = ne_bin_rel_type(args_types: ts),
                          (_, _, _) ts? = ne_tern_rel_type(args_types: ts)
                      },
  record_type(fs?)  = ne_record_type([f.label -> (type: desugar_type(f.type, desugar), optional: f.optional) : f <~ fs]),
  tuple_type(ts?)   = ne_tuple_type((desugar_type(t, desugar) : t <- ts)),
  tag_obj_type()    = { tag_type = type.tag_type;
                        fail if not tag_type :: TagType; //## BAD: HANDLE THE ERROR
                        return tag_obj_type(tag_type, desugar_type(type.obj_type, desugar));
                      },
  union_type(ts?)   = ne_union_type([desugar_type(t, desugar) : t <~ ts]);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[Atom] refd_prot_types(SynType type, [Atom] prot_types):
  type_ref(ts?)     = {match (ts) type_symbol(a?) = [a if prot_types(a)], _ = []},
  LeafType          = [],
  type_var()        = [],
  syn_int_range()   = [],
  ne_seq_type()     = refd_prot_types(type.elem_type, prot_types),
  ne_set_type()     = refd_prot_types(type.elem_type, prot_types),
  ne_map_type()     = refd_prot_types(type.key_type, prot_types) & refd_prot_types(type.value_type, prot_types),
  ne_rel_type()     = seq_union((refd_prot_types(t, prot_types) : t <- type.args_types)),
  record_type(fs?)  = seq_union((refd_prot_types(f.type, prot_types) : f <- fs)),
  tuple_type(ts?)   = seq_union((refd_prot_types(t, prot_types) : t <- ts)),
  tag_obj_type()    = refd_prot_types(type.obj_type, prot_types),
  union_type(ts?)   = seq_union((refd_prot_types(t, prot_types) : t <- ts));


[Atom] refd_prot_types(SynClsType type, [Atom] prot_types) =
  seq_union((refd_prot_types(t, prot_types) : t <- type.in_types)) &
  refd_prot_types(type.out_type, prot_types);


[Atom] refd_prot_types(SynType+ args_types, SynType ret_type, [Atom] prot_types)
{
  args_prot_types = seq_union((refd_prot_types(t, prot_types) : t <- args_types));
  ret_prot_types  = refd_prot_types(ret_type, prot_types);
  return args_prot_types & ret_prot_types;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[TypeName -> NeType] create_type_map([SynTypedef] tdefs, [SynParTypedef] par_tdefs)
{
  type_map = [type_name(td.name, 0) -> desugar_type(td.type) : td <- tdefs];
  par_type_map = [
    type_name(td.name, length(td.params)) ->
    desugar_par_type_def(td.type, td.params)
    : td <- par_tdefs
  ];
  return type_map & par_type_map;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

PseudoType syn_pseudotype(SynType type, [TypeName -> Type] typedefs) = pseudotype(desugar_type(type), typedefs);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//## THIS IS JUST A COPY OF THE CORRENSPONDING FUNCTIONS FOR CORE/LEVEL 2 STATEMENTS
//## IS THERE A WAY TO WRITE THEM JUST ONCE?
[+StmtOutcome] syn_outcomes(SynStmt* stmts)
{
  os = [:falls_through];
  for s <- stmts:
    os = {os - [:falls_through]} & syn_outcomes(s);
    break if not in(:falls_through, os);
  ;
  return nonempty(os);
}


[+StmtOutcome] syn_outcomes(SynStmt stmt):
  return_stmt               = [:returns],
  return_stmt()             = [:fails; :returns],
  if_stmt()                 = nonempty(
                                [:fails] & syn_outcomes(stmt.else) & seq_union((syn_outcomes(b.body) : b <- stmt.branches))
                              ),
  loop_stmt(body?)          = loop_stmt_syn_outcomes(stmt.skip_first, stmt.body),
  inf_loop_stmt(ss?)        = inf_loop_stmt_syn_outcomes(ss),
  for_stmt()                = [:fails; :falls_through; :returns if in(:returns, syn_outcomes(stmt.body))],
  let_stmt()                = nonempty([:fails] & syn_outcomes(stmt.body)),
  break_stmt                = [:breaks],
  fail_stmt                 = [:fails],
  assignment_stmt()         |
  assert_stmt()             |
  print_stmt()              |
  imp_update_stmt()         |
  proc_call_stmt()          |
  send_msg_stmt()           |
  try_update_stmt()         |
  set_memb_var_stmt()       |
  delete_stmt()             |
  insert_stmt()             |
  set_input_ctrl_stmt()     |
  clear_input_ctrl_stmt()   |
  apply_ctrl_stmt()         |
  send_msg_ctrl_stmt()      |
  read_state_ctrl_stmt()    |
  restore_state_ctrl_stmt() = [:falls_through; :fails];


[+StmtOutcome] loop_stmt_syn_outcomes(Bool skip_first, SynStmt+ body)
{
  os = syn_outcomes(body);
  return [
    :falls_through  if in(:falls_through, os) or in(:breaks, os) or not skip_first;
    :returns        if in(:returns, os);
    :fails
  ];
}


[+StmtOutcome] inf_loop_stmt_syn_outcomes(SynStmt+ body)
{
  os = syn_outcomes(body);
  return nonempty([
    :falls_through  if in(:breaks, os);
    :returns        if in(:returns, os);
    :fails          if in(:fails, os) or in(:falls_through, os)
  ]);
}

////////////////////////////////////////////////////////////////////////////////

Bool syn_may_fall_through(SynStmt stmt) = in(:falls_through, syn_outcomes(stmt));

Bool syn_may_fall_through(SynStmt* stmts) = in(:falls_through, syn_outcomes(stmts));

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[Var] already_def_vars([Var] new_vars, [Var] curr_vars) = [v : v <- new_vars; already_def(v, curr_vars)];

Bool already_def(Var var, [Var] vars):
  var(n?)       = already_def(n, vars),
  impl_arg(n?)  = already_def(n, vars),
  memb_var(n?)  = already_def(n, vars),
  _             = in(var, vars);

Bool already_def(Atom var_name, [Var] vars) =
  in(var(var_name), vars)       or
  in(impl_arg(var_name), vars)  or
  in(memb_var(var_name), vars);

FnSymbol impl_arg_to_fn_symb(ImplArg p):
  impl_arg(n?)   = fn_symbol(n);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Atom rule_id(ConstDecl decl)  = decl.name;

Atom rule_id(RuleDecl decl):
  syn_plain_rule()                  |
  syn_cond_rule()                   |
  syn_foreach_rule()                |
  syn_time_varying_boolean_rule()   |
  syn_time_varying_unchanged_rule() |
  syn_time_varying_inactive_rule()  |
  syn_nested_auto()                 = decl.name,
  syn_msg_send()                    = decl.target;


//## THIS IS CALLED TWICE IN THE SYNTAX REMOVAL STAGE. CONSIDER USING AN IMPLICIT PARAMETER
[SynAutoDef] resolve_inheritance([SynAutoDef] automata)
{
  autos_by_id = [a.name -> a : a <- automata];

  parent_child_rels = [a.name -> [auto_symbol(a.parent) if a.parent?] : a <- automata];
  sorted_auto_ids = topological_sort(parent_child_rels);

  resolved_autos_by_id = [:];
  for ids <- sorted_auto_ids:
    layer_autos_by_id = [id -> resolve_inheritance(autos_by_id[id], resolved_autos_by_id) : id <- ids];
    resolved_autos_by_id = resolved_autos_by_id & layer_autos_by_id;
  ;

  return values(resolved_autos_by_id);


  SynAutoDef resolve_inheritance(SynAutoDef child, [AutoSymbol -> SynAutoDef] resolved_autos_by_id)
  {
    return child if not child.parent?;
    parent = resolved_autos_by_id[auto_symbol(child.parent)];

    overriding_ids = [rule_id(d) : d <~ child.rules & child.consts];

    inherited_inputs = (i : i <- parent.inputs; not in(i.name, overriding_ids));
    inherited_consts = (c : c <- parent.consts; not in(c.name, overriding_ids));
    inherited_rules  = (r : r <- parent.rules;  not in(rule_id(r), overriding_ids));

    return syn_auto_def(
      name:       child.name,
      pos_inputs: child.pos_inputs,
      res_type:   child.res_type if child.res_type?,
      inputs:     inherited_inputs & child.inputs,
      outputs:    parent.outputs & child.outputs,
      state_vars: parent.state_vars & child.state_vars,
      nested_dbs: parent.nested_dbs & child.nested_dbs,
      consts:     inherited_consts & child.consts,
      rules:      inherited_rules & child.rules
    );
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//## NOT SURE THIS IS THE RIGHT PLACE FOR THIS STUFF

type AccessorChain = accessor(expr: <ConstOrVar, AccessorChain>, field: Atom);

type IdChain = ConstOrVar, AccessorChain;

(Atom) destructure_id_chain(ConstOrVar expr):
  const_or_var(a?)  = (a);

Atom+ destructure_id_chain(AccessorChain expr) =
  match (expr.expr)
    const_or_var(a?)  = (a, expr.field),
    accessor()        = (destructure_id_chain(expr.expr) | expr.field);

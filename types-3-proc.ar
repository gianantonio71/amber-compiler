type LocVar         = lvar(Nat);  //## FIND BETTER NAME.
type ElemVar        = evar(id: Nat, idx: <Nat, IntVar, add(val1: IntVar, val2: Nat)>);
type MembObjVar     = new_input(Atom);

type ObjVar         = Var, LocVar, ElemVar;

type ReadOnlyObjVar = FnPar, CaptVar;
type WriteObjVar    = RWObjVar, ElemVar;
type RWObjVar       = StdVar, LocVar, MembVar, MembCopyVar;

type StdObjVar      = RWObjVar, NamedArg, ReadOnlyObjVar;

type VecVar         = vvar(id: Nat, size: NzNat);

type MembBoolVar    = cond_value_var(Nat),
                      cond_is_def_var(Nat),
                      cond_expr_value_var(Nat),
                      cond_expr_is_def_var(Nat),
                      cond_expr_up_to_date_var(Nat),
                      marked_for_update_var(<Atom, Nat>),
                      is_new;

type MembIntVar     = update_source_var(Atom),
                      update_count_var(IntExpr),
                      nodes_to_update_var(level: IntExpr, index: IntExpr);

type MembIntVectVar = nodes_to_update_vect_var(level: Nat, size: NzNat); //## BAD: <size> SHOULD BE OF TYPE <3..*>

type SpecialLocVar  = invalidate_cond_expr_cache; //## FIND BETTER NAME

type BoolVar        = bvar(Nat),
                      memb_has_changed(Atom),
                      rep_cond_value_var(Nat),
                      rep_cond_is_def_var(Nat),
                      SpecialLocVar,
                      MembBoolVar;

type IntVar         = ivar(Nat), MembIntVar;

type StreamVar      = svar(Nat); //## DOES THIS NEED CLEANUP?

type SetItVar       = set_it_var(Nat); //## MUST WORK WITHOUT THE NEED FOR EXPLICIT CLEANUP
type SeqItVar       = seq_it_var(Nat); //## MUST WORK WITHOUT THE NEED FOR EXPLICIT CLEANUP
type MapItVar       = map_it_var(Nat); //## MUST WORK WITHOUT THE NEED FOR EXPLICIT CLEANUP

type ItVar          = SetItVar, SeqItVar, MapItVar;

type AnyVar         = ObjVar, VecVar, BoolVar, IntVar, ItVar, StreamVar;

type ObjFnName      = FnSymbol, ProcSymbol;

type BoolFnName     = memb_test(TypeSymbol);

type InlineObj      = LeafObj, empty_set, empty_seq, empty_map;

type AtomicExpr     = InlineObj, StdObjVar;

type AtomicBoolExpr = Bool, BoolVar;

type NatBoolOp      = is_symb(ObjExpr),
                      is_int(ObjExpr),
                      is_float(ObjExpr),
                      is_ne_set(ObjExpr),
                      is_ne_seq(ObjExpr),
                      is_ne_map(ObjExpr),
                      is_tagged_obj(ObjExpr),
                      has_elem(set: ObjExpr, elem: ObjExpr),
                      //has_key(map: ObjExpr, key: ObjExpr),
                      //comes_before(expr1: ObjExpr, expr2: ObjExpr),
                      is_eq_bool(expr1: BoolExpr, expr2: BoolExpr),
                      is_eq_int(expr1: IntExpr, expr2: IntExpr),
                      is_eq(expr1: ObjExpr, expr2: ObjExpr),
                      is_gt(expr1: IntExpr, expr2: IntExpr),
                      is_ge(expr1: IntExpr, expr2: IntExpr),
                      is_lt(expr1: IntExpr, expr2: IntExpr),
                      is_le(expr1: IntExpr, expr2: IntExpr),
                      inline_is_eq(expr: ObjExpr, value: InlineObj),
                      is_out_of_range(ItVar),
                      var_is_def(<MembVar, MembObjVar, MembCopyVar, LocVar>),
                      output_is_def(var: AutoVar, output: Atom);

type NatIntOp       = get_int_val(ObjExpr),
                      get_set_size(ObjExpr),
                      get_seq_len(ObjExpr),
                      get_map_size(ObjExpr),
                      minus(IntExpr),
                      add(val1: IntExpr, val2: IntExpr),
                      sub(val1: IntExpr, val2: IntExpr),
                      mult(val1: IntExpr, val2: IntExpr),
                      div(val1: IntExpr, val2: IntExpr),
                      mod(val1: IntExpr, val2: IntExpr),
                      mantissa(ObjExpr),
                      dec_exp(ObjExpr),
                      rand_nat(IntExpr),  // Non-deterministic
                      unique_nat,         // Non-deterministic
                      ticks;              // Impure

type NatObjOp       = at(seq: ObjExpr, idx: IntExpr),
                      //lookup(map: ObjExpr, key: ObjExpr),
                      get_tag(ObjExpr),
                      get_inner_obj(ObjExpr), //## RENAME?

                      to_obj(<BoolExpr, IntExpr>),
                      obj_neg(ObjExpr),

                      to_symb(ObjExpr),

                      get_curr_obj(<SetItVar, SeqItVar>),
                      get_curr_key(MapItVar),
                      get_curr_value(MapItVar),

                      rand_elem(ObjExpr); // Non-deterministic

type BoolExpr       = AtomicBoolExpr,
                      NatBoolOp,
                      neg(BoolExpr),
                      and([BoolExpr^]), //## SEQUENCES OR SETS?
                      or([BoolExpr^]),  //## DITTO
                      and_then([BoolExpr^]),
                      or_else([BoolExpr^]),
                      eval_bool_fn(name: BoolFnName, params: [AnyTypeExpr^]);

type IntExpr        = Int, IntVar, NatIntOp;

type ObjExpr        = AtomicExpr, NatObjOp;

type AnyTypeExpr    = BoolExpr, IntExpr, ObjExpr;

type FloatExpr      = mk_float(mantissa: Int, dec_exp: Int),
                      neg_float(value: AtomicExpr),
                      add_floats(values: (AtomicExpr, AtomicExpr)),
                      sub_floats(values: (AtomicExpr, AtomicExpr)),
                      mult_floats(values: (AtomicExpr, AtomicExpr)),
                      div_floats(values: (AtomicExpr, AtomicExpr)),
                      square_root(value: AtomicExpr),
                      floor_op(value: AtomicExpr),
                      ceiling_op(value: AtomicExpr),
                      int_to_float(value: AtomicExpr);

type RefObjExpr     = mk_set_from_stream(stream: StreamVar),
                      mk_set(elems: VecVar, size: IntExpr),
                      mk_seq_from_stream(stream: StreamVar),
                      mk_seq(elems: VecVar, size: IntExpr),
                      mk_map_from_streams(key_stream: StreamVar, value_stream: StreamVar),
                      mk_map(keys: VecVar, values: VecVar, size: IntExpr),
                      mk_tagged_obj(tag: AtomicExpr, obj: AtomicExpr),      // Ownership transfer: <obj>
                      mk_array(size: IntExpr, value: AtomicExpr), //## CURRENTLY ONLY USED WITH <value> = object(nil)
                      get_seq_slice(seq: AtomicExpr, idx_first: IntExpr, len: IntExpr),
                      append_to_seq(seq: AtomicExpr, new_elem: AtomicExpr), // Ownership transfer: <seq>, <new_elem>
                      join_seqs(left: AtomicExpr, right: AtomicExpr),
                      join_mult_seqs(seqs: AtomicExpr),
                      rev_seq(seq: AtomicExpr),
                      merge_sets(sets: AtomicExpr),
                      merge_maps(maps: AtomicExpr),
                      seq_to_set(seq: AtomicExpr),
                      seq_to_mset(seq: AtomicExpr),
                      list_to_seq(list: AtomicExpr),
                      internal_sort(set: AtomicExpr),
                      symb_to_str(AtomicExpr),
                      // Can be used only once per input, and does not automatically clear the new input,
                      // which has to be manually cleared with clear_memb_var(new_input(...))
                      get_new_input(Atom),
                      read_output(var: AutoVar, type: AutoSymbol, output: Atom),
                      add_attachment(target: AtomicExpr, data: AtomicExpr), // Impure
                      fetch_attachments(AtomicExpr);                        // Impure

type BasicInstr     = init_stream(StreamVar),
                      append(stream: StreamVar, obj: AtomicExpr),  // Ownership transfer: <obj>

                      // get_at(var: ObjVar, seq: ObjExpr, idx: IntExpr),
                      //## BUG BUG BUG: IF ObjExpr CONTAINS A NON-COUNTED REFERENCE TO THE ARRAY,
                      //## I COULD END UP WITH A CYCLE IN THE OBJECT GRAPH AND MAYBE OTHER PROBLEMS
                      set_at(var: WriteObjVar, idx: IntExpr, value: AtomicExpr),  // Ownership transfer: <value>

                      //## IT DOESN'T REALLY MAKES SENSE TO HAVE THE <map> FIELD OF TYPE AtomicExpr
                      //## AS OPPOSED TO JUST ObjVar? BUT IN THAT CASE, WHAT ABOUT "()[k]"?
                      lookup(success_var: BoolVar?, var: WriteObjVar, map: StdObjVar, key: AtomicExpr),
                      //## DITTO, EVEN THOUGH THIS CASE IS A BIT MORE COMPLICATED (E.G. "().f?")
                      ext_lookup(success_var: BoolVar?, var: WriteObjVar, map: StdObjVar, key: SymbObj),

                      get_set_iter(var: SetItVar, src: AtomicExpr),
                      get_seq_iter(var: SeqItVar, src: AtomicExpr),
                      get_map_iter(var: MapItVar, src: AtomicExpr),

                      move_forward(ItVar),

                      set_var(var: <WriteObjVar, NamedArg>, value: ObjExpr),
                      set_bvar(var: BoolVar, value: BoolExpr),
                      set_ivar(var: IntVar, value: IntExpr),

                      set_rc_var(var: WriteObjVar, value: <FloatExpr, RefObjExpr>),

                      clear_memb_var(<MembVar, MembObjVar>),
                      init_memb_var(MembVar),
                      clear_loc_var(LocVar), //## BAD: I DON'T LIKE THE ABILITY TO CLEAR A NON-MEMBER VARIABLE

                      add_ref(ObjVar),
                      release(<ObjVar, MembObjVar>),

                      print_obj(obj: AtomicExpr),

                      no_op,

                      call_proc(var: WriteObjVar?, name: ObjFnName, params: [<AtomicExpr, BoundCls>]),
                      call_cls(var: WriteObjVar, cls_var: <ClsVar, NamedArg>, params: [AtomicExpr]),

                      queue_update(type: AutoSymbol, id: Atom),
                      queue_cond_update(type: AutoSymbol, id: Nat, inval_cache: Bool),

                      set_input(var: AutoVar, type: AutoSymbol, input: Atom, value: AtomicExpr),
                      update_inputs(var: AutoVar, type: AutoSymbol),

                      push_call_info(fn_name: ObjFnName, params: [Maybe[FnPar]]),
                      pop_call_info,

                      runtime_check(cond: AtomicExpr, file: String, line: NzNat, text: Maybe[String], vars: <StdVar, NamedArg>*);

type JumpInstr      = break_loop,
                      exit_block,
                      //## MAYBE IT WOULD BE A GOOD IDEA TO SEPARATE THE BOOLEAN FROM THE OBJECT VERSION
                      //## ALSO, THE BOOLEAN VERSION DOESN'T NEED TO USE AND ATOMIC EXPRESSION, IT CAN USE THE FULL ONE, CAN'T IT?
                      ret_val(<AtomicExpr, AtomicBoolExpr>),
                      terminate;

type CompInstr      = branch(cond: BoolExpr, when_true: [Instr^], when_false: [Instr]),
                      switch_on_nat(value: IntExpr, cases: [[Instr]^]),
                      repeat([Instr^]),
                      execute_block([Instr^]),
                      cls_scope(var: NamedArg, bound_cls: BoundCls, body: [Instr^]); //## BAD: BoundCls IS TOO LOOSE A TYPE HERE, BECAUSE A ClsVar CANNOT APPEAR HERE

type Instr          = BasicInstr, JumpInstr, CompInstr;

type ClsDef         = cls_def(arity: NzNat, body: [Instr^]);

type BoundCls       = ClsVar, bound_cls(cls: ClsDef, env: [Var]); //## WHY IS THE .env FIELD OF TYPE [Var] INSTEAD OF [ObjVar]?

type ObjProcPar     = obj, cls(name: ClsVar?, arity: NzNat);

type ObjProcDef     = obj_proc_def(
                        name:         ObjFnName,
                        params:       [ObjProcPar],
                        named_args:   (NamedArg => Nat), //## SHOULD IT BE <named_var(name: Atom, arity: Nat)>* INSTEAD?
                        body:         [Instr^],
                        cached:       Bool
                      );

type BoolProcDef    = bool_proc_def(
                        name:  BoolFnName,
                        arity: NzNat,
                        body:  [Instr^]
                      );

type ProcDef        = ObjProcDef, BoolProcDef;

type Block          = block(
                        name:               AutoSymbol,
                        inputs:             [Atom],
                        outputs:            Atom*,
                        memb_vars:          <MembVar, MembObjVar, MembIntVar, MembIntVectVar, MembBoolVar>*,
                        init_code:          [Instr],
                        update_code:        [Instr],
                        cleanup_code:       [Instr],
                        queue_update_code:  (<Atom, Nat> => [Instr])
                      );

type CompiledPrg    = compiled_prg(bool_procs: BoolProcDef*, procs: ObjProcDef*, blocks: Block*);
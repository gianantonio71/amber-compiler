type LocVar         = lvar(Nat), never_used_lvar;  //## FIND BETTER NAME.
type ElemVar        = evar(id: Nat, idx: <Nat, IntVar, add(val1: IntVar, val2: Nat)>);
type MembObjVar     = new_input(Atom);

type ObjVar         = Var, LocVar, ElemVar;

type ReadOnlyObjVar = FnPar, CaptVar;
type WriteObjVar    = RWObjVar, ElemVar;
type RWObjVar       = StdVar, LocVar, MembVar, MembCopyVar, PendingStateVar;

type StdObjVar      = RWObjVar, NamedArg, ReadOnlyObjVar;

type VecVar         = vvar(id: Nat, size: NzNat);

type MembBoolVar    = cond_value_var(Nat),
                      cond_is_def_var(Nat),
                      cond_expr_value_var(<Nat, Atom>),
                      cond_expr_is_def_var(<Nat, Atom>),
                      cond_expr_up_to_date_var(<Nat, Atom>),
                      has_pending_message_var(Atom),
                      marked_for_update_var(BlockNodeId),
                      is_new;

type MembIntVar     = update_source_var(Atom),
                      update_count_var(Nat),
                      nodes_to_update_var(level: IntExpr, index: IntExpr),
                      next_trigger_time_var(Atom),
                      curr_time_slot_var(Atom),
                      time_triggers_count_var,
                      trigger_times_heap_var(IntExpr),
                      time_varying_cond_ids_heap_var(IntExpr),
                      last_update_time,
                      nested_auto_int_var(auto_var: MembAutoVar, memb_var: MembIntVar);

type IntConst       = time_slot_length(automaton: AutoSymbol, expr_id: Atom, time_slot: IntExpr);

type MembIntVectVar = nodes_to_update_vect_var(level: Nat, size: NzNat); //## BAD: <size> SHOULD BE OF TYPE <3..*>

type BoolArgVar     = invalidate_cond_expr_cache; //## FIND BETTER NAME

type BoolVar        = bvar(Nat),
                      memb_has_changed(Atom),
                      rep_cond_value_var(Nat),
                      rep_cond_is_def_var(Nat),
                      MembBoolVar,
                      BoolArgVar;

type IntArgVar      = elapsed_time;

type IntVar         = ivar(Nat), curr_time, update_time, MembIntVar, IntArgVar;

type StreamVar      = svar(Nat); //## DOES THIS NEED CLEANUP?

type SetItVar       = set_it_var(Nat); //## MUST WORK WITHOUT THE NEED FOR EXPLICIT CLEANUP
type SeqItVar       = seq_it_var(Nat); //## MUST WORK WITHOUT THE NEED FOR EXPLICIT CLEANUP
type MapItVar       = map_it_var(Nat); //## MUST WORK WITHOUT THE NEED FOR EXPLICIT CLEANUP

type ItVar          = SetItVar, SeqItVar, MapItVar;

type AnyVar         = ObjVar, VecVar, BoolVar, IntVar, ItVar, StreamVar;

type ObjFnName      = FnSymbol, ProcSymbol;

type BoolFnName     = memb_test(TypeSymbol);

type InlineObj      = LeafObj, empty_set, empty_seq, empty_map;

type AtomicExpr     = InlineObj, StdObjVar;

type AtomicBoolExpr = Bool, BoolVar;

type NatBoolOp      = is_symb(ObjExpr),
                      is_int(ObjExpr),
                      is_float(ObjExpr),
                      is_ne_set(ObjExpr),
                      is_ne_seq(ObjExpr),
                      is_ne_map(ObjExpr),
                      is_tagged_obj(ObjExpr),
                      has_elem(set: ObjExpr, elem: ObjExpr),
                      //has_key(map: ObjExpr, key: ObjExpr),
                      //comes_before(expr1: ObjExpr, expr2: ObjExpr),
                      is_eq_bool(expr1: BoolExpr, expr2: BoolExpr),
                      is_eq_int(expr1: IntExpr, expr2: IntExpr),
                      is_eq(expr1: ObjExpr, expr2: ObjExpr),
                      is_gt(expr1: IntExpr, expr2: IntExpr),
                      is_ge(expr1: IntExpr, expr2: IntExpr),
                      is_lt(expr1: IntExpr, expr2: IntExpr),
                      is_le(expr1: IntExpr, expr2: IntExpr),
                      inline_is_eq(expr: ObjExpr, value: InlineObj),
                      is_out_of_range(ItVar),
                      //## EITHER var_is_set(v) SHOULD NOT BE CALLED IF var_is_def(v) IS NOT TRUE OR VICE VERSA.
                      //## FIGURE THIS OUT AND ADD ALL THE NECESSARY CHECKS
                      var_is_set(<MembVar, LocVar>),
                      var_is_def(<MembVar, MembObjVar, MembCopyVar, LocVar>); // We should never feed it a blank variable
                      // It should not be possible to call field_is_set(v, s) if field_is_def(v, s) is not true.
                      // This is because field_is_set(...) is not defined is field_is_def(...) is false,
                      // and outside automata the language cannot deal with undefined values.
                      //## TODO: ADD ALL THE NECESSARY CHECKS
                      //## NEW: WHAT HAPPENS WHEN field_is_set() IS CALLED ON A NULL FIELD INSIDE AN AUTOMATON?
                      //## THERE IT CANNOT BE PREVENTED FROM BEING CALLED ON A NULL FIELD. OR CAN IT? LEVEL 3 CODE
                      //## IS GENERATED BY THE COMPILER AFTER ALL, NOW CODED DIRECTLY BY THE PROGRAMMER
                      //## ITS RETURN VALUE IS NOT BOOLEAN ANYMORE, UNLESS WE DECIDE TO FAIL
                      //## THE WHOLE var_is_set/var_is_def/field_is_set/field_is_def THING HAS TO BE RETHOUGHT
                      //## MAYBE THESE TWO OPERATIONS ARE REDUNDANT AFTER ALL. I CAN ALWAYS REPLACE THEM
                      //## WITH read_output() + var_is_set() / var_is_def()
                      // field_is_set(var: AnyAutoVar, field: Atom),
                      // field_is_def(var: LocAutoVar, field: Atom);

type NatIntOp       = get_int_val(ObjExpr),
                      get_set_size(ObjExpr),
                      get_seq_len(ObjExpr),
                      get_map_size(ObjExpr),
                      minus(IntExpr),
                      add(val1: IntExpr, val2: IntExpr),
                      sub(val1: IntExpr, val2: IntExpr),
                      mult(val1: IntExpr, val2: IntExpr),
                      div(val1: IntExpr, val2: IntExpr),
                      mod(val1: IntExpr, val2: IntExpr),
                      mantissa(ObjExpr),
                      dec_exp(ObjExpr),
                      rand_nat(IntExpr),  // Non-deterministic
                      unique_nat,         // Non-deterministic
                      ticks;              // Impure

type NatObjOp       = at(seq: ObjExpr, idx: IntExpr),
                      //lookup(map: ObjExpr, key: ObjExpr),
                      get_tag(ObjExpr),
                      get_inner_obj(ObjExpr), //## RENAME?

                      to_obj(<BoolExpr, IntExpr>),
                      obj_neg(ObjExpr),

                      to_symb(ObjExpr),

                      get_curr_obj(<SetItVar, SeqItVar>),
                      get_curr_key(MapItVar),
                      get_curr_value(MapItVar),

                      rand_elem(ObjExpr); // Non-deterministic

type BoolExpr       = AtomicBoolExpr,
                      NatBoolOp,
                      neg(BoolExpr),
                      and([BoolExpr^]), //## SEQUENCES OR SETS?
                      or([BoolExpr^]),  //## DITTO
                      and_then([BoolExpr^]),
                      or_else([BoolExpr^]),
                      eval_bool_fn(name: BoolFnName, params: [AnyTypeExpr^]);

type IntExpr        = Int, IntConst, IntVar, NatIntOp;

type ObjExpr        = AtomicExpr, NatObjOp;

type AnyTypeExpr    = BoolExpr, IntExpr, ObjExpr;

type FloatExpr      = mk_float(mantissa: Int, dec_exp: Int),
                      neg_float(value: AtomicExpr),
                      add_floats(values: (AtomicExpr, AtomicExpr)),
                      sub_floats(values: (AtomicExpr, AtomicExpr)),
                      mult_floats(values: (AtomicExpr, AtomicExpr)),
                      div_floats(values: (AtomicExpr, AtomicExpr)),
                      square_root(value: AtomicExpr),
                      floor_op(value: AtomicExpr),
                      ceiling_op(value: AtomicExpr),
                      int_to_float(value: AtomicExpr);

type RefObjExpr     = mk_set_from_stream(stream: StreamVar),
                      mk_set(elems: VecVar, size: IntExpr),
                      mk_seq_from_stream(stream: StreamVar),
                      mk_seq(elems: VecVar, size: IntExpr),
                      mk_map_from_streams(key_stream: StreamVar, value_stream: StreamVar),
                      mk_map(keys: VecVar, values: VecVar, size: IntExpr),
                      mk_tagged_obj(tag: AtomicExpr, obj: AtomicExpr),      // Ownership transfer: <obj>
                      mk_array(size: IntExpr, value: AtomicExpr), //## CURRENTLY ONLY USED WITH <value> = object(nil)
                      get_seq_slice(seq: AtomicExpr, idx_first: IntExpr, len: IntExpr),
                      append_to_seq(seq: AtomicExpr, new_elem: AtomicExpr), // Ownership transfer: <seq>, <new_elem>
                      join_seqs(left: AtomicExpr, right: AtomicExpr),
                      join_mult_seqs(seqs: AtomicExpr),
                      rev_seq(seq: AtomicExpr),
                      merge_sets(sets: AtomicExpr),
                      merge_maps(maps: AtomicExpr),
                      seq_to_set(seq: AtomicExpr),
                      seq_to_mset(seq: AtomicExpr),
                      list_to_seq(list: AtomicExpr),
                      internal_sort(set: AtomicExpr),
                      symb_to_str(AtomicExpr),
                      // Can be used only once per pending variable, and does not automatically clear it,
                      // it has to be manually cleared with init_memb_var(...)
                      read_pending_var(<PendingStateVar, MembObjVar>),
                      read_output(var: AnyAutoVar, type: AutoSymbol, output: Atom),
                      add_attachment(target: AtomicExpr, data: AtomicExpr), // Impure
                      fetch_attachments(AtomicExpr);                        // Impure

type BasicInstr     = init_stream(StreamVar),
                      append(stream: StreamVar, obj: AtomicExpr),  // Ownership transfer: <obj>

                      // get_at(var: ObjVar, seq: ObjExpr, idx: IntExpr),
                      //## BUG BUG BUG: IF ObjExpr CONTAINS A NON-COUNTED REFERENCE TO THE ARRAY,
                      //## I COULD END UP WITH A CYCLE IN THE OBJECT GRAPH AND MAYBE OTHER PROBLEMS
                      set_at(var: WriteObjVar, idx: IntExpr, value: AtomicExpr),  // Ownership transfer: <value>

                      //## IT DOESN'T REALLY MAKES SENSE TO HAVE THE <map> FIELD OF TYPE AtomicExpr
                      //## AS OPPOSED TO JUST ObjVar? BUT IN THAT CASE, WHAT ABOUT "()[k]"?
                      lookup(success_var: BoolVar?, var: WriteObjVar, map: StdObjVar, key: AtomicExpr),
                      //## DITTO, EVEN THOUGH THIS CASE IS A BIT MORE COMPLICATED (E.G. "().f?")
                      ext_lookup(success_var: BoolVar?, var: WriteObjVar, map: StdObjVar, key: SymbObj),

                      get_set_iter(var: SetItVar, src: AtomicExpr),
                      get_seq_iter(var: SeqItVar, src: AtomicExpr),
                      get_map_iter(var: MapItVar, src: AtomicExpr),

                      move_forward(ItVar),

                      set_var(var: <WriteObjVar, NamedArg>, value: ObjExpr),
                      set_bvar(var: BoolVar, value: BoolExpr),
                      set_ivar(var: IntVar, value: IntExpr),

                      set_rc_var(var: WriteObjVar, value: <FloatExpr, RefObjExpr>),

                      init_memb_var(var: <MembVar, MembObjVar, PendingStateVar>, new_state: <blank, undefined>),
                      reset_memb_var(var: <MembVar>, new_state: <blank, undefined>),
                      clear_loc_var(LocVar), //## BAD: I DON'T LIKE THE ABILITY TO CLEAR A NON-MEMBER VARIABLE

                      add_ref(ObjVar),
                      release(<ObjVar, MembObjVar>),

                      print_obj(obj: AtomicExpr),

                      no_op,

                      call_proc(var: WriteObjVar?, name: ObjFnName, params: [<AtomicExpr, BoundCls>]),
                      call_cls(var: WriteObjVar, cls_var: <ClsVar, NamedArg>, params: [AtomicExpr]),

                      //## THESE TYPES SHOULD BE REFINED, BlockNodeId IS TOO GENERAL
                      queue_update(type: AutoSymbol, id: BlockNodeId),
                      queue_cond_update(type: AutoSymbol, id: BlockNodeId, inval_cache: Bool),

                      insert_timer(type: AutoSymbol, idx: IntExpr, time: IntExpr),
                      clear_timer(type: AutoSymbol, idx: IntExpr),

                      auto_init(var: AnyAutoVar, type: AutoSymbol),
                      auto_cleanup(var: AnyAutoVar, type: AutoSymbol),

                      set_input(var: AnyAutoVar, type: AutoSymbol, input: Atom, value: Maybe[AtomicExpr]),
                      prop_input_updates(var: AnyAutoVar?, type: AutoSymbol, elapsed_time: IntExpr),
                      call_method(var: AnyAutoVar?, type: AutoSymbol, channel: ExMethodSymbol, args: [AtomicExpr]),

                      push_call_info(fn_name: ObjFnName, params: [Maybe[FnPar]]),
                      pop_call_info,

                      runtime_check(cond: AtomicExpr, file: String, line: NzNat, text: Maybe[String], vars: <StdVar, NamedArg>*);

type JumpInstr      = break_loop,
                      exit_block,
                      //## MAYBE IT WOULD BE A GOOD IDEA TO SEPARATE THE BOOLEAN FROM THE OBJECT VERSION
                      //## ALSO, THE BOOLEAN VERSION DOESN'T NEED TO USE AND ATOMIC EXPRESSION, IT CAN USE THE FULL ONE, CAN'T IT?
                      ret_val(<AtomicExpr, AtomicBoolExpr>),
                      terminate;

type CompInstr      = branch(cond: BoolExpr, when_true: [Instr^], when_false: [Instr]),
                      switch_on_nat(value: IntExpr, cases: [[Instr]^]),
                      repeat([Instr^]),
                      execute_block([Instr^]),
                      cls_scope(var: NamedArg, bound_cls: BoundCls, body: [Instr^]); //## BAD: BoundCls IS TOO LOOSE A TYPE HERE, BECAUSE A ClsVar CANNOT APPEAR HERE

type Instr          = BasicInstr, JumpInstr, CompInstr;

type ClsDef         = cls_def(arity: NzNat, body: [Instr^]);

type BoundCls       = ClsVar, bound_cls(cls: ClsDef, env: [Var]); //## WHY IS THE .env FIELD OF TYPE [Var] INSTEAD OF [ObjVar]?

type ObjProcPar     = obj, cls(name: ClsVar?, arity: NzNat);

type ObjProcDef     = obj_proc_def(
                        name:         ObjFnName,
                        params:       [ObjProcPar],
                        named_args:   (NamedArg => Nat), //## SHOULD IT BE <named_var(name: Atom, arity: Nat)>* INSTEAD?
                        body:         [Instr^],
                        cached:       Bool
                      );

type BoolProcDef    = bool_proc_def(
                        name:  BoolFnName,
                        arity: NzNat,
                        body:  [Instr^]
                      );

type ProcDef        = ObjProcDef, BoolProcDef;

type ConstBlockData = time_slots_len(expr_id: Atom, lengths: [Nat^]);

type StdBlockNodeId         = std_block_node_id(Atom);
type CondNodeId             = cond_node_id(Nat);
type NestedAutoInputNodeId  = nested_auto_input_id(auto: Atom, input: Atom);

type BlockNodeId    = StdBlockNodeId, CondNodeId, NestedAutoInputNodeId;

//## PUT IT SOMEWHERE ELSE MAYBE?
type ExMethodSymbol = MethodSymbol, ex_method_symbol(symbol: MethodSymbol, id: Nat);

type Block          = block(
                        name:               AutoSymbol,
                        inputs:             [Atom],
                        outputs:            Atom*,
                        memb_vars:          <MembVar, PendingStateVar, MembObjVar, MembIntVar, MembIntVectVar, MembBoolVar>*,
                        nested_auto_vars:   (MembAutoVar => AutoSymbol),
                        init_code:          [Instr],
                        update_code:        [Instr],
                        cleanup_code:       [Instr],
                        queue_update_code:  (BlockNodeId => (body: [Instr], two_level_update: Bool)),
                        methods_code:       ((ExMethodSymbol, Nat) => [Instr]),
                        const_data:         ConstBlockData*,
                        time_rules_count:   Nat
                      );

type CompiledPrg    = compiled_prg(bool_procs: BoolProcDef*, procs: ObjProcDef*, blocks: Block*);
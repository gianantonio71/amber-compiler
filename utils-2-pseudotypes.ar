
type AtomicPseudoType = symbol(Atom), integers, floats, empty_set, ne_sets, empty_seq, ne_seqs, empty_map, ne_maps, tag_obj(Atom);

type BasicPseudoType  = symbols, tag_objs, AtomicPseudoType;

type PseudoType       = pseudotype(BasicPseudoType*); //## BAD: THIS ALLOWS FOR INVALID COMBINATIONS, LIKE {symbol(a), symbols}


///////////////////////////////////////////////////////////////////////////////

PseudoType pseudotype(BasicPseudoType* pts)
{
  red_symb_pts    = if in(:symbols, pts)  then {pt : symbol() pt <- pts} else {};
  red_tag_obj_pts = if in(:tag_objs, pts) then {pt : tag_obj() pt <- pts} else {};
  return :pseudotype(pts - (red_symb_pts & red_tag_obj_pts));
}

BasicPseudoType* basic_pseudotypes(PseudoType pt) = _obj_(pt);


PseudoType pseudotype_union(PseudoType* pseudotypes) = pseudotype(union({pts : pseudotype(pts) <- pseudotypes}));


PseudoType pseudotype_any = pseudotype({:symbols, :integers, :empty_set, :ne_sets, :empty_seq, :ne_seqs, :empty_map, :ne_maps, :tag_objs});

PseudoType pseudotype_symbol(Atom a)  = pseudotype({:symbol(a)});
PseudoType pseudotype_symbols         = pseudotype({:symbols});
PseudoType pseudotype_integers        = pseudotype({:integers});
PseudoType pseudotype_floats          = pseudotype({:floats});
PseudoType pseudotype_empty_seq       = pseudotype({:empty_seq});
PseudoType pseudotype_empty_set       = pseudotype({:empty_set});
PseudoType pseudotype_empty_map       = pseudotype({:empty_map});
PseudoType pseudotype_ne_seqs         = pseudotype({:ne_seqs});
PseudoType pseudotype_ne_sets         = pseudotype({:ne_sets});
PseudoType pseudotype_ne_maps         = pseudotype({:ne_maps});
PseudoType pseudotype_seqs            = pseudotype({:empty_seq, :ne_seqs});
PseudoType pseudotype_sets            = pseudotype({:empty_set, :ne_sets});
PseudoType pseudotype_maps            = pseudotype({:empty_map, :ne_maps});
PseudoType pseudotype_tag_obj(Atom a) = pseudotype({:tag_obj(a)});
PseudoType pseudotype_tag_objs        = pseudotype({:tag_objs});

///////////////////////////////////////////////////////////////////////////////

Bool is_subset(BasicPseudoType basic_ptype, PseudoType pseudotype):
  symbol(),   pseudotype(pts?)  = in(basic_ptype, pts) or in(:symbols, pts),
  tag_obj(),  pseudotype(pts?)  = in(basic_ptype, pts) or in(:tag_objs, pts),
  _,          pseudotype(pts?)  = in(basic_ptype, pts);

Bool is_subset(PseudoType subset, PseudoType superset) = not (? bpt <- basic_pseudotypes(subset) : not is_subset(bpt, superset));


Bool are_disjoint(PseudoType pseudotype, BasicPseudoType basic_pseudotype):
  pseudotype(pts?),   symbols           = not (in(:symbols, pts) or (? symbol() <- pts)),
  pseudotype(pts?),   tag_objs          = not (in(:tag_objs, pts) or (? tag_obj() <- pts)),
  _,                  AtomicPseudoType  = not is_subset(basic_pseudotype, pseudotype); // Shutting up the type checker

Bool are_disjoint(PseudoType pt1, PseudoType pt2) = not (? bpt1 <- basic_pseudotypes(pt1) : not are_disjoint(pt2, bpt1));

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

PseudoType pseudotype(Obj obj) = pseudotype({atomic_pseudotype(obj)});

AtomicPseudoType atomic_pseudotype(Obj):
  object(+ a?)        = :symbol(a),
  object(*)           = :integers,
  object(^)           = :floats,
  object({...} s?)    = if s == {} then :empty_set else :ne_sets,
  object([...] s?)    = if s == [] then :empty_seq else :ne_seqs,
  object((...) m?)    = if m == () then :empty_map else :ne_maps,
  object(tag @ obj)   = :tag_obj(tag); //## REPLACE THE obj VARIABLE WITH _ AS SOON AS THE PARSER ALLOWS IT

///////////////////////////////////////////////////////////////////////////////

PseudoType pseudotype(Pattern ptrn):
  ptrn_symbol             = pseudotype_symbols,
  ptrn_float              = pseudotype_floats,
  ptrn_empty_set          = pseudotype_empty_set,
  ptrn_ne_set             = pseudotype_ne_sets,
  ptrn_empty_seq          = pseudotype_empty_seq,
  ptrn_ne_seq             = pseudotype_ne_seqs,
  ptrn_empty_map          = pseudotype_empty_map,
  ptrn_ne_map             = pseudotype_ne_maps,
  ptrn_any                = pseudotype_any,
  ptrn_symbol(object(a?)) = pseudotype_symbol(a),
  ptrn_integer()          = pseudotype_integers,
  ptrn_var()              = pseudotype(ptrn.ptrn),
  ptrn_union(ps?)         = pseudotype_union({pseudotype(p) : p <- ps}),
  ptrn_tag_obj()          = match (ptrn.tag)
                              ptrn_symbol             = pseudotype_tag_objs,
                              ptrn_symbol(object(a?)) = pseudotype_tag_obj(a),
                              ptrn_var()              = pseudotype_tag_objs;

///////////////////////////////////////////////////////////////////////////////

Pattern pseudotype_pattern(PseudoType pseudotype) = ptrn_union({pseudotype_pattern(pt) : pt <- basic_pseudotypes(pseudotype)});

Pattern pseudotype_pattern(BasicPseudoType pseudotype):
  symbol(a?)  = ptrn_symbol(a),
  symbols     = ptrn_symbol,
  integers    = ptrn_integer,
  floats      = ptrn_float,
  empty_set   = ptrn_empty_set,
  ne_sets     = ptrn_ne_set,
  empty_seq   = ptrn_empty_seq,
  ne_seqs     = ptrn_ne_seq,
  empty_map   = ptrn_empty_map,
  ne_maps     = ptrn_ne_map,
  tag_obj(a?) = ptrn_tag_obj(ptrn_symbol(a), ptrn_any),
  tag_objs    = ptrn_tag_obj(ptrn_symbol, ptrn_any);

///////////////////////////////////////////////////////////////////////////////

Bool matches(Pattern ptrn, PseudoType ptype) = not are_disjoint(pseudotype(ptrn), ptype);

///////////////////////////////////////////////////////////////////////////////

Maybe[Pattern] restrict(Pattern ptrn, PseudoType ptype):
  ptrn_symbol       = restrict_ptrn_symbol(ptype),
  ptrn_any          = just(pseudotype_pattern(ptype)),
  ptrn_tag_obj()    = ( match (ptrn.tag)
                          ptrn_symbol             = restrict_ptrn_any_tag_obj(ptrn.obj, ptype),
                          ptrn_symbol(object(s?)) = if is_subset(pseudotype_tag_obj(s), ptype) then just(ptrn) else nil,
                          ptrn_var()              = if not are_disjoint(ptype, pseudotype_tag_objs) then just(ptrn) else nil
                      ),
  ptrn_var()        = restrict_ptrn_var(ptrn.var, ptrn.ptrn, ptype),
  ptrn_union(ps?)   = restrict_ptrn_union(ps, ptype),
  _                 = if matches(ptrn, ptype) then just(ptrn) else nil;


Maybe[Pattern] restrict_ptrn_symbol(PseudoType ptype)
{
  return just(ptrn_symbol) if is_subset(pseudotype_symbols, ptype);
  ptrns = {ptrn_symbol(a) : symbol(a) <- basic_pseudotypes(ptype)};
  return if ptrns != {} then just(ptrn_union(ptrns)) else nil;
}


Maybe[Pattern] restrict_ptrn_any_tag_obj(Pattern obj_ptrn, PseudoType ptype)
{
  return just(ptrn_tag_obj(ptrn_symbol, obj_ptrn)) if is_subset(pseudotype_tag_objs, ptype);
  ptrns = {ptrn_tag_obj(ptrn_symbol(s), obj_ptrn) : tag_obj(s) <- basic_pseudotypes(ptype)};
  return if ptrns != {} then just(ptrn_union(ptrns)) else nil;
}


Maybe[Pattern] restrict_ptrn_var(StdVar var, Pattern ptrn, PseudoType ptype)
{
  restr_ptrn = restrict(ptrn, ptype);
  return if restr_ptrn != nil then just(ptrn_var(var, value(restr_ptrn))) else nil;
}


Maybe[Pattern] restrict_ptrn_union(Pattern+ ptrns, PseudoType ptype)
{
  restr_ptrns = {value(rp) : p <- ptrns, rp = restrict(p, ptype), rp != nil};
  return if restr_ptrns != {} then just(ptrn_union(restr_ptrns)) else nil;
}
// Things left to do:
//   Implement getters for sequences of monomorphically tagged basic types
//   Add way to track input changes no matter via which channel the input is set
//   Add support for method calls
//
// Things done but not fully tested:
//   For both tuple and record, create a "generic" getter if the type of the field is not a basic one
//
// Testing to do:
//   Discrete inputs and outputs (including refusal to set discrete inputs before the automaton is fully initialized)

type InterType = bool, integer, float, symbol, string, bool_seq, int_seq, int32_seq, float_seq, generic;


InterType+ std_interface_types = (:bool, :integer, :float, :symbol, :string, :bool_seq, :int_seq, :float_seq);


NeType internal_type(InterType) =
  bool        = type_bool,
  integer     = integer,
  float       = float_type,
  symbol      = atom_type,
  string      = type_string,
  bool_seq    = type_seq(type_bool),
  int_seq     = type_seq(integer),
  float_seq   = type_seq(float_type),
  generic     = type_any;


String return_value_type(InterType) =
  bool        = "bool ",
  integer     = "long long ",
  float       = "double ",
  symbol      = "const char *",
  string      = "void ",
  bool_seq    = "unsigned int ",
  int_seq     = "unsigned int ",
  float_seq   = "unsigned int ",
  generic     = "void ";


String constructor_function(InterType) =
  bool        = "make_bool",
  integer     = "make_int",
  float       = "make_float",
  symbol      = "extern_str_to_symb",
  string      = "str_to_obj",
  bool_seq    = "convert_bool_seq",
  int_seq     = "convert_int_seq",
  int32_seq   = "convert_int32_seq",
  float_seq   = "convert_float_seq",
  generic     = "convert_text";


String accessor_function(InterType) =
  bool        = "get_bool",
  integer     = "get_int",
  float       = "get_float",
  symbol      = "symb_to_raw_str",
  string      = "export_as_c_string",
  bool_seq    = "export_as_bool_array",
  int_seq     = "export_as_long_long_array",
  float_seq   = "export_as_float_array",
  generic     = "export_as_text";


String* input_args_types(InterType) =
  bool        = ("bool "),
  integer     = ("long long "),
  float       = ("double "),
  symbol      = ("const char *"),
  string      = ("const char *"),
  bool_seq    = ("const bool *",      "unsigned int "),
  int_seq     = ("const long long *", "unsigned int "),
  int32_seq   = ("const int *",       "unsigned int "),
  float_seq   = ("const double *",    "unsigned int "),
  generic     = ("const char *",      "unsigned int ");


String* output_args_types(InterType) =
  bool        = (),
  integer     = (),
  float       = (),
  symbol      = (),
  string      = ("char *",      "unsigned int "),
  bool_seq    = ("bool *",      "unsigned int "),
  int_seq     = ("long long *", "unsigned int "),
  float_seq   = ("double *",    "unsigned int "),
  generic     = ("char *",      "unsigned int ");


// String* no_ret_val_output_args_types(InterType inter_type) =
//   bool        = ("bool &"),
//   integer     = ("long long &"),
//   float       = ("double &"),
//   symbol      = ("const char *&"),
//   string      = ("char *",      "unsigned int "),
//   bool_seq    = ("bool *",      "unsigned int &"),
//   int_seq     = ("long long *", "unsigned int &"),
//   float_seq   = ("double *",    "unsigned int &"),
//   generic     = ("char *",      "unsigned int &");


Bool returns_value(InterType) =
  bool | integer | float | symbol                               = true,
  string | bool_seq | int_seq | int32_seq | float_seq | generic = false;


String arg_name(InterType, Nat idx) =
  bool | integer | float | symbol                               = {match (idx) 0 = "value"},
  string | bool_seq | int_seq | int32_seq | float_seq | generic = {match (idx) 0 = "buffer", 1 = "size"};

////////////////////////////////////////////////////////////////////////////////

String* input_args_names(InterType it)  = (arg_name(it, i) : unused_var @ i <- input_args_types(it));
String* input_args_decls(InterType it)  = (t & arg_name(it, i) : t @ i <- input_args_types(it));

String* input_args_names(InterType it, Nat idx)  = (a & printed(idx+1) : a <- input_args_names(it));
String* input_args_decls(InterType it, Nat idx)  = (a & printed(idx+1) : a <- input_args_decls(it));

String* output_args_names(InterType it) = (arg_name(it, i) : unused_var @ i <- output_args_types(it));
String* output_args_decls(InterType it) = (t & arg_name(it, i) : t @ i <- output_args_types(it));

// String* output_args_decls(InterType it, Nat idx) = (a & printed(idx+1) : a <- output_args_decls(it));
String* output_args_names(InterType it, Nat idx) = (a & printed(idx+1) : a <- output_args_names(it));

// String* no_ret_val_output_args_decls(InterType it, Nat idx) =
//   (t & arg_name(it, i) & printed(idx+1) : t @ i <- no_ret_val_output_args_types(it));

// String* no_ret_val_output_args_names(InterType it, Nat idx) =
//   (arg_name(it, i) & printed(idx+1) : t @ i <- no_ret_val_output_args_types(it));

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

type GetterType = plain, seq_elm, rec_field(Atom), tuple_field(Nat);


implicit typedefs : [TypeName -> NeType]
{
  //## CASE STUDY: REWRITE THIS FUNCTION WITHOUT USING LOOPS
  Maybe[InterType+] maybe_interface_types(NeType+ field_types) {
    inter_types = ();
    for field_type <- field_types:
      maybe_inter_type = nil;
      for it <- std_interface_types:
        if is_subset(field_type, internal_type(it)):
          maybe_inter_type = just(it);
          break;
        ;
      ;
      return nil if maybe_inter_type == nil;
      inter_types = (inter_types | value(maybe_inter_type));
    ;
    return just(nonempty(inter_types));
  }


  (NeType, Maybe[SymbObj]) maybe_inner_obj_and_tag_types(NeType type) {
    if is_subset(type, type_tagged_obj):
      tag_type = tag_supertype(type);
      if is_symb_singl_type(tag_type):
        just_tag = just(only_symb(tag_type));
        obj_type = untagged_objs_supertype(type);
        return (nonempty_type(obj_type), just_tag);
      ;
    ;
    return (type, nil);
  }
}


implicit block : Block
{
  String auto_class_name = upper_camel_case(bare_id(block.name));
  String auto_struct_ptr = "((" & to_c_name(block.name) & " *) ptr)";
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit block : Block, typedefs : [TypeName -> NeType]
{
  (String*, String*) input_setter(Atom id, InterType inter_type, Maybe[SymbObj] maybe_tag) {
    name = sentence_case(id);
    uc_name = uppercase(id);

    decl = "  void set_" & name & "(" & append(input_args_types(inter_type), ", ") & ");";

    ctor_args = append(input_args_names(inter_type), ", ");
    ctor_expr = constructor_function(inter_type) & "(" & ctor_args & ")";
    ctor_expr = "build_tagged_obj(" & to_c_expr(value(maybe_tag)) & ", " & ctor_expr & ")" if maybe_tag != nil;

    impl = (
      "",
      "void " & auto_class_name & "::set_" & name & "(" & append(input_args_decls(inter_type), ", ") & ") {",
      "  internal_set_input(" & uc_name & ", " & ctor_expr & ");",
      "}"
    );

    return ((decl), impl);
  }


  (String*, String*) record_input_setter(Atom id, RecordTypeFields fields, Maybe[SymbObj] maybe_tag) {
    return ((), ()) if (l, f <- fields : f.optional);

    ord_fields = nonempty(rand_sort([bare_obj(l) : l, unused_var <- fields]));
    field_types = (fields(object(l)).type : l <- ord_fields);
    inter_types = maybe_interface_types(field_types);
    return ((), ()) if inter_types == nil;
    inter_types = value(inter_types);

    uc_name = uppercase(id);
    meth_name = "set_" & sentence_case(id) & "_" & append((sentence_case(l) : l <- ord_fields), "_");
    args_types = join((input_args_types(it) : it <- inter_types));
    args_decls = join((input_args_decls(it, i) : it @ i <- inter_types));

    decl = "  void " & meth_name & "(" & append(args_types, ", ") & ");";

    size_str = printed(length(ord_fields));
    impl = (
      "",
      "void " & auto_class_name & "::" & meth_name & "(" & append(args_decls, ", ") & ") {",
      "  OBJ keys[" & size_str & "], values[" & size_str & "];"
    );
    impl = impl & ("  keys[" & printed(i) & "] = " & to_c_expr(object(f)) & ";" : f @ i <- ord_fields);
    for it @ i <- inter_types:
      args_names = input_args_names(it, i);
      impl = (impl | "  values[" & printed(i) & "] = " & constructor_function(it) & "(" & append(args_names, ", ") & ");");
    ;
    ctor_expr = "build_map(keys, values, " & size_str & ")";
    ctor_expr = "build_tagged_obj(" & to_c_expr(value(maybe_tag)) & ", " & ctor_expr & ")" if maybe_tag != nil;
    impl = impl & (
      "  internal_set_input(" & uc_name & ", " & ctor_expr & ");",
      "}"
    );

    return ((decl), impl);
  }


  (String*, String*) tuple_input_setter(Atom id, NeType+ field_types, Maybe[SymbObj] maybe_tag) {
    inter_types = maybe_interface_types(field_types);
    return ((), ()) if inter_types == nil;
    inter_types = value(inter_types);

    name = sentence_case(id);
    uc_name = uppercase(id);
    args_types = join((input_args_types(it) : it <- inter_types));
    args_list = join((input_args_decls(it, i) : it @ i <- inter_types));

    decl = "  void set_" & name & "(" & append(args_types, ", ") & ");";

    impl = (
      "",
      "void " & auto_class_name & "::set_" & name & "(" & append(args_list, ", ") & ") {",
      "  OBJ fields[" & printed(length(field_types)) & "];"
    );
    for it @ i <- inter_types:
      args_names = input_args_names(it, i);
      impl = (impl | "  fields[" & printed(i) & "] = " & constructor_function(it) & "(" & append(args_names, ", ") & ");");
    ;
    ctor_expr = "build_seq(fields, " & printed(length(field_types)) & ")";
    ctor_expr = "build_tagged_obj(" & to_c_expr(value(maybe_tag)) & ", " & ctor_expr & ")" if maybe_tag != nil;
    impl = impl & (
      "  internal_set_input(" & uc_name & ", " & ctor_expr & ");",
      "}"
    );

    return ((decl), impl);
  }


  (String*, String*) input_setter(Atom id) {
    input_type = block.inputs(id).type;
    return input_setter(id, :string, nil) if is_subset(input_type, type_string);

    adj_input_type, maybe_tag = maybe_inner_obj_and_tag_types(input_type);

    fields = maybe_record_type_fields(adj_input_type);
    return record_input_setter(id, value(fields), maybe_tag) if fields != nil;

    fields = maybe_tuple_type_fields(adj_input_type);
    return tuple_input_setter(id, value(fields), maybe_tag) if fields != nil;

    if is_subset(adj_input_type, type_seq(integer)):
      extra_decl, extra_impl = input_setter(id, :int32_seq, maybe_tag);
    else
      extra_decl, extra_impl = ((), ());
    ;

    for it <- std_interface_types:
      if is_subset(adj_input_type, internal_type(it)):
        decl, impl = input_setter(id, it, maybe_tag);
        return (extra_decl & decl, extra_impl & impl);
      ;
    ;

    return ((), ());
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  (String*, String*) output_getter(Atom id, InterType inter_type, GetterType getter_type, Bool untag) {
    base_name = sentence_case(id);
    meth_name = match (getter_type)
      plain           = "get_" & base_name,
      seq_elm         = "at_" & base_name,
      rec_field(l?)   = "get_" & base_name & "_" & sentence_case(l),
      tuple_field(n?) = "get" & printed(n) & "_" & base_name;

    var_name = to_c_var_decl_name(memb_var(id));
    ret_type = return_value_type(inter_type);

    args_types = ("unsigned int" if getter_type == :seq_elm) & output_args_types(inter_type);
    args_decls = ("unsigned int index" if getter_type == :seq_elm) & output_args_decls(inter_type);

    decl = "  " & ret_type & meth_name & "(" & append(args_types, ", ") & ");";

    is_set_cond = if block.outputs(id).discrete then " | is_blank_obj(" & auto_struct_ptr & "->" & var_name & ")" else "";
    opt_return = if returns_value(inter_type) then "return " else "";

    acc_target = auto_struct_ptr & "->" & var_name;
    acc_target = "get_inner_obj(" & acc_target & ")" if untag;
    acc_target = match (getter_type)
      plain           = acc_target,
      seq_elm         = "at(" & acc_target & ", index)",
      rec_field(l?)   = "ext_lookup(" & acc_target & ", " & to_c_expr(object(l)) & ")",
      tuple_field(n?) = "at(" & acc_target & ", " & printed(n) & ")";

    impl = (
      "",
      ret_type & auto_class_name & "::" & meth_name & "(" & append(args_decls, ", ") & ") {",
      "  if (is_null_obj(" & auto_struct_ptr & "->" & var_name & ")" & is_set_cond & ")",
      "    throw 0;",
      "  " & opt_return & accessor_function(inter_type) & "(" & append((acc_target) & output_args_names(inter_type), ", ") & ");",
      "}"
    );

    return ((decl), impl);
  }


  (String*, String*) struct_field_output_getter(Atom output_id, NeType field_type, GetterType getter_type, Bool untag) {
    for it <- std_interface_types:
      return output_getter(output_id, it, getter_type, untag) if is_subset(field_type, internal_type(it));
    ;
    return output_getter(output_id, :generic, getter_type, untag);
  }


  (String*, String*) record_output_getters(Atom id, RecordTypeFields fields, Bool untag) {
    decls, impls = unzip(({
        field = fields(object(field_id));
        return ((), ()) if field.optional;
        return struct_field_output_getter(id, field.type, :rec_field(field_id), untag);
      } : field_id <- rand_sort([bare_obj(l) : l, unused_var <- fields])
    ));
    return (join(decls), join(impls));
  }


  (String*, String*) tuple_output_getters(Atom id, NeType+ field_types, Bool untag) {
    decls, impls = unzip((struct_field_output_getter(id, t, :tuple_field(i), untag) : t @ i <- field_types));
    return (join(decls), join(impls));
  }


  // (String*, String*) tuple_output_getter(Atom id, NeType+ field_types) {
  //   inter_types = maybe_interface_types(field_types);
  //   return ((), ()) if inter_types == nil;
  //   inter_types = value(inter_types);

  //   name = sentence_case(id);
  //   var_name = to_c_var_decl_name(memb_var(id));
  //   args_types = join((no_ret_val_output_args_types(it) : it <- inter_types));
  //   args_list = join((no_ret_val_output_args_decls(it, i) : it @ i <- inter_types));

  //   decl = "  void get_" & name & "(" & append(args_types, ", ") & ");";

  //   is_set_cond = if block.outputs(id).discrete then " | is_blank_obj(" & auto_struct_ptr & "->" & var_name & ")" else "";
  //   impl = (
  //     "",
  //     "void " & auto_class_name & "::get_" & name & "(" & append(args_list, ", ") & ") {",
  //     "  if (is_null_obj(" & auto_struct_ptr & "->" & var_name & ")" & is_set_cond & ")",
  //     "    throw 0;",
  //     "  OBJ *fields = get_seq_buffer_ptr(" & auto_struct_ptr & "->" & var_name & ");"
  //   );
  //   for it @ i <- inter_types:
  //     out_args_list = append((", " & n : n <- output_args_names(it, i)));
  //     instr = accessor_function(it) & "(fields[" & printed(i) & "]" & out_args_list & ");";
  //     if it != :string:
  //       asgn_var_idx = match (it)
  //         bool | integer | float | symbol = 0,
  //         bool_seq | int_seq | float_seq  = 1;
  //       instr = arg_name(it, asgn_var_idx) & printed(i+1) & " = " & instr;
  //     ;
  //     impl = (impl | "  " & instr);
  //   ;
  //   impl = (impl | "}");

  //   return ((decl), impl);
  // }

  (String*, String*) output_len_getter(Atom id, Bool untag) {
    name = sentence_case(id);
    var_name = to_c_var_decl_name(memb_var(id));
    decl = "  unsigned int len_" & name & "();";
    target = auto_struct_ptr & "->" & var_name;
    target = "get_inner_obj(" & target & ")" if untag;
    impl = (
      "",
      "unsigned int " & auto_class_name & "::" & "len_" & name & "() {",
      "  if (is_null_obj(" & auto_struct_ptr & "->" & var_name & "))",
      "    throw 0;",
      "  return get_seq_len(" & target & ");",
      "}"
    );
    return ((decl), impl);
  }


  (String*, String*) output_getter(Atom id) {
    output_type = block.outputs(id).type;
    return output_getter(id, :string, :plain, false) if is_subset(output_type, type_string);

    untag = is_subset(output_type, type_tagged_obj);
    output_type = nonempty_type(untagged_objs_supertype(output_type)) if untag;

    fields = maybe_record_type_fields(output_type);
    return record_output_getters(id, value(fields), untag) if fields != nil;

    fields = maybe_tuple_type_fields(output_type);
    return tuple_output_getters(id, value(fields), untag) if fields != nil;

    is_seq = is_subset(output_type, type_seq);
    len_decl, len_impl = if is_seq then output_len_getter(id, untag) else ((), ());

    for it <- std_interface_types:
      if is_subset(output_type, internal_type(it)):
        get_decl, get_impl = output_getter(id, it, :plain, untag);
        return (len_decl & get_decl, len_impl & get_impl);
      ;
    ;

    if is_seq:
      elm_type = seq_elem_supertype(output_type);
      get_decl, get_impl = struct_field_output_getter(id, nonempty_type(elm_type), :seq_elm, untag);
      return (len_decl & get_decl, len_impl & get_impl);
    ;

    assert len_decl == () and len_impl == ();
    return ((), ());
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  (String*, String*) reactive_automaton_wrapper {
    ord_inputs = block.ord_inputs;
    ord_outputs = (o : o <- block.ord_outputs, not block.inputs(o, ?));

    inputs = (uppercase(i) : i <- ord_inputs);
    outputs = (uppercase(o) : o <- ord_outputs, not block.inputs(o, ?));

    is_time_sensitive = block.memb_vars(elapsed_time); //## BAD BAD: NOT A RELIABLE WAY TO DO IT...
    apply_ret_type = if is_time_sensitive then "bool" else "void";

    auto_name = to_c_name(block.name);

    pre_init_method_name = pre_init_method_name(block.name);
    cleanup_method_name = cleanup_method_name(block.name);
    apply_method_name = apply_method_name(block.name);

    input_set_methods_names = (input_set_method_name(block.name, i) : i <- ord_inputs);
    output_vars_names = (to_c_var_decl_name(memb_var(o)) : o <- ord_outputs);

    input_memb_test_pred_name = (to_c_fn_name(block.input_memb_preds(i)) : i <- ord_inputs);

    elapsed_time_var_name = to_c_var_decl_name(elapsed_time);
    changed_outputs_count_var_name = to_c_var_decl_name(changed_outputs_count);

    input_setters_decl, input_setters_impl = unzip((input_setter(i) : i <- ord_inputs));
    input_setters_decl = join(input_setters_decl);
    input_setters_impl = join(input_setters_impl);

    output_getters_decl, output_getters_impl = unzip((output_getter(o) : o <- ord_outputs));
    output_getters_decl = join(output_getters_decl);
    output_getters_impl = join(output_getters_impl);

    input_enum_decl = if inputs == ()
        then ()
      elif sum((length(i) : i <- inputs)) <= 80
        then ("  enum Input {" & append(inputs, ", ") & "};")
      else
        ("  enum Input {") & ("    " & i & "," : i <- inputs) & ("  };");

    output_enum_decl = if outputs == ()
        then ()
      elif sum((length(o) : o <- inputs)) <= 80
        then ("  enum Output {" & append(outputs, ", ") & "};")
      else
        ("  enum Output {") & ("    " & o & "," : o <- outputs) & ("  };");

    enums_decl = input_enum_decl & ("" if input_enum_decl != () and output_enum_decl != ()) & output_enum_decl;

    class_decl = (
      "class " & auto_class_name & " {",
      "public:"
    ) & enums_decl & (
      "",
      "  " & auto_class_name & "();",
      "  ~" & auto_class_name & "();",
      "",
      "  void set_input(Input input, const char *value);" if inputs != (),
      "  void read_output(Output output, char *buffer, unsigned int size);" if outputs != (),
      "" if is_time_sensitive,
      "  void set_elapsed_nanosecs(unsigned long long time);" if is_time_sensitive,
      "  void set_elapsed_microsecs(unsigned long long time);" if is_time_sensitive,
      "  void set_elapsed_millisecs(unsigned long long time);" if is_time_sensitive,
      "  void set_elapsed_secs(unsigned long long time);" if is_time_sensitive,
      "",
      "  " & apply_ret_type & " apply();",
      "",
      "  unsigned int changed_outputs_count();" if outputs != (),
      "  Output changed_output_id(unsigned int idx);" if outputs != ()
    );

    class_decl = class_decl & ("") & input_setters_decl if input_setters_decl != ();
    class_decl = class_decl & ("") & output_getters_decl if output_getters_decl != ();

    class_decl = class_decl & (
      "",
      "private:",
      "  void internal_set_input(Input input, OBJ obj);" if inputs != (),
      "" if inputs != (),
      "  void *ptr;",
      "};"
    );

    class_impl = (
      auto_class_name & "::" & auto_class_name & "() {",
      "  ENV env;",
      "  memset(&env, 0, sizeof(ENV));",
      "  ptr = malloc(sizeof(" & auto_name & "));",
      "  " & pre_init_method_name & "(" & auto_struct_ptr & ", env);",
      "}",
      "",
      auto_class_name & "::~" & auto_class_name & "() {",
      "  " & cleanup_method_name & "(" & auto_struct_ptr & ");",
      "  free(ptr);",
      "}",
      "",
      apply_ret_type & " " & auto_class_name & "::apply() {",
      "  ENV env;",
      "  memset(&env, 0, sizeof(ENV));",
      "  " & apply_method_name & "((" & auto_name & " *) ptr, env);",
      "  return " & auto_struct_ptr & "->" & elapsed_time_var_name & " == 0;" if is_time_sensitive,
      "}"
    );

    if is_time_sensitive:
      class_impl = class_impl & (
        "",
        "void " & auto_class_name & "::set_elapsed_nanosecs(unsigned long long time) {",
        "  if (" & auto_struct_ptr & "->is_new | " & auto_struct_ptr & "->" & elapsed_time_var_name & " > 0)",
        "    throw 0;",
        "  " & auto_struct_ptr & "->" & elapsed_time_var_name & " = time;",
        "}",
        "",
        "void " & auto_class_name & "::set_elapsed_microsecs(unsigned long long time) {",
        "  set_elapsed_nanosecs(1000 * time);",
        "}",
        "",
        "void " & auto_class_name & "::set_elapsed_millisecs(unsigned long long time) {",
        "  set_elapsed_nanosecs(1000000 * time);",
        "}",
        "",
        "void " & auto_class_name & "::set_elapsed_secs(unsigned long long time) {",
        "  set_elapsed_nanosecs(1000000000 * time);",
        "}"
      );
    ;

    if inputs != ():
      class_impl = class_impl & (
        "",
        "void " & auto_class_name & "::set_input(Input input, const char *value) {",
        "  internal_set_input(input, " & constructor_function(:generic) & "(value));",
        "}",
        "",
        "void " & auto_class_name & "::internal_set_input(Input input, OBJ obj) {",
        "  switch (input) {"
      );
      for input @ j <- inputs:
        class_impl = class_impl & (
          "" if j > 0,
          "    case " & input & ":",
          "      if (" & input_memb_test_pred_name(j) & "(obj)) {",
          "        " & input_set_methods_names(j) & "((" & auto_name & " *) ptr, obj);",
          "        return;",
          "      }",
          "      break;"
        );
      ;
      class_impl = (class_impl |
        "  }",
        "  release(obj);",
        "  throw -1LL;",
        "}"
      );
    ;

    if outputs != ():
      class_impl = class_impl & (
        "",
        "unsigned int " & auto_class_name & "::changed_outputs_count() {",
        "  return " & auto_struct_ptr & "->" & changed_outputs_count_var_name & ";",
        "}",
        "",
        auto_class_name & "::Output " & auto_class_name & "::changed_output_id(unsigned int idx) {",
        "  if (idx < " & auto_struct_ptr & "->" & changed_outputs_count_var_name & ")",
        "    return (Output) " & auto_struct_ptr & "->changed_outputs[idx];",
        "  else",
        "    throw 0;",
        "}",
        "",
        "void " & auto_class_name & "::read_output(Output output, char *buffer, unsigned int size) {",
        "  OBJ obj;",
        "  switch (output) {"
      );
      for output @ i <- outputs:
        class_impl = class_impl & (
          "" if i > 0,
          "    case " & output & ":",
          "      obj = " & auto_struct_ptr & "->" & output_vars_names(i) & ";",
          "      break;"
        );
      ;
      class_impl = class_impl & (
        "  }",
        "  " & accessor_function(:generic) & "(obj, buffer, size);",
        "}"
      );
    ;

    class_impl = class_impl & input_setters_impl & output_getters_impl;

    return (class_decl, class_impl);
  }
}

type CCodeOutput = [body: String*, header: String*];

CCodeOutput compile_to_c(CompiledPrg prg)
{
  ptss = par_type_symbols(prg);

  symbs = used_symbols(prg);
  assert length(symbs) <= 64 * 1024; //## IMPLEMENT PROPERLY

  symb_names = ("symb_idx_" & printed(match (s) object(a?) = a) : s <- symbs);

  //## WHY IS PASSING THE typesymb2name() FUNCTION AT ALL NECESSARY? THERE ARE NO TYPES INVOLVED HERE...
  symb_strs = (to_c_expr(s, typesymb2name(ts) = typesymb2str(ts, ptss)) : s <- symbs);
  //## REPLACING THE LINE ABOVE WITH THE FOLLOWING ONE CRASHES THE COMPILER. INVESTIGATE
  // symb_strs = (to_c_expr(s, typesymb2name(ts) = {fail;}) : s <- symbs);

  c_code = ("const uint16 " & symb_names[i] & " = " & printed(i) & ";" : i < length(symbs)) & 4 * ("") &
           ("const OBJ " & symb_strs[i] & " = make_symb(" & symb_names[i] & ");" : i < length(symbs)) & 4 * ("");

  symb_decls = ("const uint32 EMB_SYMB_COUNT = " & printed(length(symbs)) & ";") & 4 * ("");
  c_code = c_code & symb_decls;

  symb_strs  = ("  \"" & _str_(_obj_(s)) & "\"," : s <- symbs);
  c_code     = c_code & ("const char *map_symb_to_str[EMB_SYMB_COUNT] = {") & symb_strs & ("};") & 4 * ("");
  symb_decls = symb_decls & ("extern const char *map_symb_to_str[EMB_SYMB_COUNT];") & 4 * ("");

  cls_defs = cls_defs(prg);

  env_decl = gen_env_decl(prg);

  c_code = c_code & env_decl;

  all_cls_arities = [p.arity : pd <- prg.procs, p <- set(pd.params), p != :obj]; //## MAYBE HERE IT WOULD BE BETTER TO DO A NORMAL SORT

  cls_obj_typedefs = join(intermix((generate_cls_obj_typedef(a) : a <- rand_sort(all_cls_arities)), 2 * (""))) & 4 * ("");
  c_code = c_code & cls_obj_typedefs;

  all_fn_arities = set((in_arity(d) : d <- rand_sort(prg.procs)));
  c_code = c_code & join(intermix((generate_push_call_info_wrapper(a) : a <- rand_sort(all_fn_arities)), 2 * (""))) & 4 * ("");

  int_seqs_decls, int_seqs_defs = gen_int_seqs_decl_and_def(prg.int_seqs);

  c_code = c_code & int_seqs_decls & 4 * ("");

  sorted_cls_defs = rand_sort(cls_defs);

  int_seqs_types_and_lengths = ((int_type_c_name(min(s), max(s)), length(s)) : s <- prg.int_seqs);

  proc_code = compile_to_c(
    rand_sort(prg.procs),
    rand_sort(prg.bool_procs),
    sorted_cls_defs,
    rand_sort(prg.blocks),
    prg.int_seqs,
    typesymb2name(ts)           = typesymb2str(ts, ptss),
    cls2id(cls)                 = index_first(cls, sorted_cls_defs),
    int_seqs_types_and_lengths  = int_seqs_types_and_lengths
  );


  body = (
    "#include \"lib.h\"\n\n",
    "#include \"iolib.h\"\n\n",
    "",
    "namespace generated",
    "{"
  ) & indent_lines(c_code & proc_code.body & int_seqs_defs) & ("}");

  header = ("namespace generated", "{") & indent_lines(symb_decls & env_decl & cls_obj_typedefs & proc_code.header) & ("}");

  return [body: body, header: header];


  String* generate_cls_obj_typedef(NzNat arity) = (
    "struct CLS" & printed(arity) & " {",
    "  OBJ (*fn_ptr)(" & append(arity * ("OBJ"), ", ") & ", const OBJ *, ENV &env);",
    "  const OBJ *data;",
    "};"
  );

  String typesymb2str(TypeSymbol ts, ParTypeSymbol* par_types):
    type_symbol(a?)     = upper_camel_case(a),
    par_type_symbol()   = typesymb2str(ts.symbol, par_types) & "_" & printed(index_first(ts, par_types));
}


String* gen_env_decl(CompiledPrg prg)
{
  all_named_args = merge_values(set((p.named_args : p <- rand_sort(prg.procs))));
  all_param_arity_pairs = rand_sort([[var: v, arity: a] : ars @ v <- all_named_args, a <- ars]);

  env_decl = ("struct ENV {");

  for na @ i <- all_param_arity_pairs:
    var   = na.var;
    arity = na.arity;

    name = _str_(_obj_(var));

    if arity > 0:
      ls = (
        "  OBJ (*n" & printed(arity) & "_" & name & ")(" & append(("OBJ p" & printed(j) & ", " : j < na.arity)) & "const OBJ *C, ENV &env);",
        "  const OBJ *C" & printed(arity) & "_" & name & ";"
      );
    else
      ls = ("  OBJ n_" & name & ";");
    ;

    ls = ("") & ls if i > 0;
    env_decl = env_decl & ls;
  ;

  env_decl = env_decl & ("};") & 4 * ("");
  return env_decl;
}


String int_type_c_name(Int min_val, Int max_val)
{
  for lb, up, type_name <- type_bounds:
    return type_name if min_val >= lb and max_val < up;
  ;
  return "int64";
}


(Int, Int, String)+ type_bounds = (
  (0,             pow(2, 8),    "uint8"),
  (0,             pow(2, 16),   "uint16"),
  (0,             pow(2, 32),   "uint32"),
  (-pow(2, 7),    pow(2, 7),    "int8"),
  (-pow(2, 15),   pow(2, 15),   "int16"),
  (-pow(2, 31),   pow(2, 31),   "int32")
);


Int pow(Int b, Nat e)
{
  res = 1;
  for e:
    res = b * res;
  ;
  return res;
}


(String*, String*) gen_int_seqs_decl_and_def(Int+* int_seqs)
{
  decls, defs = unzip((gen_int_seq_decl_and_def(s, i) : s @ i <- int_seqs));
  return (decls, join(intermix(defs, 2 * (""))));
}


(String, String*) gen_int_seq_decl_and_def(Int+ int_seq, Nat seq_id)
{
  min_elem = min(int_seq);
  max_elem = max(int_seq);

  type_name = int_type_c_name(min_elem, max_elem);

  sgn = "const " & type_name & " " & const_int_seq_c_name(seq_id) & "[" & printed(length(int_seq)) & "]";

  decl = "extern " & sgn & ";";

  strs = (printed(n) : n <- int_seq);
  total_len = sum((length(s) : s <- strs)) + 2 * length(strs);
  if total_len < 60:
    def = (sgn & " = {" & append(strs, ", ") & "};");
  else
    max_len = nat(max((length(printed(n)) : n <- (min_elem, max_elem))));
    last_idx = length(int_seq) - 1;
    strs = (align_text(s, max_len, ascii_space) & if i != last_idx then ", " else "" : s @ i <- strs);
    cont_lines = ("  " & append(ss) : ss <- split_into_groups(strs, nz_nat(100 / {max_len + 2})));
    def = (sgn & " = {") & cont_lines & ("};");
  ;

  return (decl, def);


  T+* split_into_groups(T+ items, NzNat max_group_size)
  {
    len = length(items);
    num_of_comp_groups = len / max_group_size;
    comp_groups_total_size = num_of_comp_groups * max_group_size;
    last_group_size = len - comp_groups_total_size;
    groups = (nonempty(subseq(items, i * max_group_size, max_group_size)) : i < num_of_comp_groups);
    groups = (groups | nonempty(subseq(items, comp_groups_total_size, last_group_size))) if last_group_size > 0;
    return groups;
  }


  String align_text(String str, Nat len, Nat filler)
  {
    str_len = length(str);
    return {if len >= str_len then string(nat(len-str_len) * (filler)) else ""} & str;
  }
}


String+ generate_push_call_info_wrapper(Nat arity)
{
  signature = "void push_call_info_wrapper(const char *fn_name" & append((", OBJ p" & printed(i) : i < arity)) & ")";
  code = (signature, "{", "#ifndef NDEBUG");
  if arity == 0:
    code = code & ("  push_call_info(fn_name, 0, (OBJ *)0);");
  else
    code = code & ("  OBJ *params = new_obj_array(" & printed(arity) & ");");
    for i < arity:
      code = code & ("  params[" & printed(i) & "] = p" & printed(i) & ";");
    ;
    code = code & ("  push_call_info(fn_name, " & printed(arity) & ", params);");
  ;
  return nonempty(code & ("#endif", "}"));
}


//## THIS SHOULD NOT GO HERE
type FnCallParam = blank_obj, ObjExpr, ElemVar, PendingInputVar, VecVar, BoolExpr, IntExpr, ItVar, StreamVar, ClsVar;


using
{
  String                typesymb2name(TypeSymbol),
  Nat                   cls2id(ClsDef),
  (String, Nat)*        int_seqs_types_and_lengths;


  CCodeOutput compile_block_to_c(Block block)
  {
    has_time_rules = block.time_rules_count != 0;

    name_str = to_c_name(block.name);

    vars_decl = (var_c_type(v) & " " & to_c_var_decl_name(v) & ";" : v <- rand_sort(block.memb_vars)) &
                (to_c_name(t) & " " & to_c_var_decl_name(v) & ";" : v, t <- rand_sort_pairs(block.nested_auto_vars));

    if block.time_rules_count != 0:
      size_str = printed(block.time_rules_count);
      vars_decl = vars_decl & (
        "int64 trigger_times_heap[" & size_str & "];",
        "int time_varying_cond_ids_heap[" & size_str & "];"
      );
    ;

    decl = ("struct " & name_str, "{") & indent_lines(vars_decl) & ("};");

    pre_init_vars_decl = gen_vars_decls(block.pre_init_code);
    pre_init_vars_decl = pre_init_vars_decl & ("") if pre_init_vars_decl != ();
    pre_init_body = pre_init_vars_decl & compile_to_c(block.pre_init_code, nil);
    pre_init_sgn = "void " & pre_init_method_name(block.name) & "(" & name_str & " *self, ENV &env)";
    pre_init_decl = (pre_init_sgn & ";");
    pre_init_proc = (pre_init_sgn, "{") & indent_lines(pre_init_body) & ("}");

    cleanup_body = compile_to_c(block.cleanup_code, nil);
    cleanup_sgn = "void " & cleanup_method_name(block.name) & "(" & name_str & " *self)";
    cleanup_decl = (cleanup_sgn & ";");
    cleanup_proc = (cleanup_sgn, "{") & indent_lines(cleanup_body) & ("}");

    all_loc_vars = vars_to_declare(block.apply_code) & union([vars_to_declare(c) : c @ id <- block.nodes_update_code]);
    aux_vars = [v : v <- all_loc_vars, v :: AuxVar] & [curr_time if has_time_rules];
    aux_name_str = aux_struct_c_name(block.name);
    aux_decls = ("struct " & aux_name_str, "{") & indent_lines((var_decl(v) : v <- rand_sort(aux_vars))) & ("};");

    apply_method_vars_decls = (gen_vars_decls(block.apply_code) | aux_name_str & " self_aux;");
    apply_method_vars_decls = (apply_method_vars_decls | "") if apply_method_vars_decls != ();

    apply_body = apply_method_vars_decls & compile_to_c(block.apply_code, nil);
    // time_arg = if block.time_rules_count != 0 then ", int64 " & to_c_var_decl_name(elapsed_time) else "";
    time_arg = ", int64 " & to_c_var_decl_name(elapsed_time);
    apply_sgn = "void " & apply_method_name(block.name) & "(" & name_str & " *self" & time_arg & ", ENV &env)";
    apply_decl = (apply_sgn & ";");
    apply_proc = (apply_sgn, "{") & indent_lines(apply_body) & ("}");

    update_node_bodies = [
      id -> {
        lines = gen_vars_decls(c);
        lines = (lines | "") if lines != ();
        return lines & compile_to_c(c, nil);
      } : c @ id <- block.nodes_update_code
    ];
    time_arg = if has_time_rules then ", int64 " & to_c_var_decl_name(curr_time) else "";
    update_node_sngs = [
      id -> "void " & node_update_method_name(block.name, id) & "(" & name_str & " *self" & time_arg & ", " & aux_name_str & " &self_aux, ENV &env)"
      : unused_var @ id <- block.nodes_update_code
    ];
    update_node_decls = rand_sort([s & ";" : s @ unused_var <- update_node_sngs]);
    update_node_procs_unsorted = [
      (update_node_sngs[id], "{") & indent_lines(update_node_bodies[id]) & ("}")
      : unused_var @ id <- block.nodes_update_code
    ];
    update_node_procs = join(intermix(rand_sort(update_node_procs_unsorted), ("", "")));

    queue_methods_decls_and_impls = [gen_queue_update_method(block.name, id, method.body, method.two_level_update) : method @ id <- block.queue_update_code];
    queue_methods_decls, queue_methods_impls = unzip(rand_sort(queue_methods_decls_and_impls));
    queue_methods_impls = join(intermix(queue_methods_impls, ("", "")));

    insert_timer_method_decl, insert_timer_method_impl = gen_insert_timer_method(block.name);
    clear_timer_method_decl, clear_timer_method_impl = gen_clear_timer_method(block.name);

    queue_input_updates = length(block.inputs) > 2; //## BAD BAD BAD: THE NUMBER 2 IS REPEATED IN THE CODE GENERATION PHASE
    input_decls, input_impls = unzip((gen_input_setter(block.name, id, i, queue_input_updates) : id @ i <- block.inputs));
    input_impls = join(intermix(input_impls, ("", "")));

    output_decls, output_impls = unzip((gen_output_getter(block.name, o) : o <- rand_sort(block.outputs)));
    output_impls = join(intermix(output_impls, ("", "")));

    method_decls, method_impls = unzip(rand_sort([gen_method(block.name, id, b) : b @ id <- block.methods_code]));
    method_impls = join(intermix(method_impls, ("", "")));

    const_data = rand_sort([gen_const_data(block.name, c) : c <- block.const_data]);

    header = join(
               intermix(
                 ( decl, aux_decls, const_data, pre_init_decl, cleanup_decl, apply_decl, update_node_decls, input_decls,
                   output_decls, queue_methods_decls, method_decls,
                   (insert_timer_method_decl, clear_timer_method_decl) if has_time_rules
                 ),
                 ("", "")
               )
             );

    body = join(
             intermix(
               ( pre_init_proc, cleanup_proc, apply_proc, update_node_procs, input_impls, output_impls,
                 queue_methods_impls, method_impls,
                 insert_timer_method_impl if has_time_rules,
                 clear_timer_method_impl  if has_time_rules
               ),
               ("", "")
             )
           );

    return [body: body, header: header];


    String gen_const_data(AutoSymbol block_name, ConstBlockData const) =
      "const int64 " & to_c_time_slots_table_name(block_name, const.expr_id) & "[] = {" &
      append((printed(l) & "LL" : l <- const.lengths), ", ") & "};";


    (String, String*) gen_method(AutoSymbol block_name, ExMethodSymb name, Instr* body)
    {
      args_str = append((to_c_name(block_name) & " *self", "int64 elapsed_time") & ("OBJ p" & printed(i) : i < name.arity), ", ");
      ret_type_str = match (name.symbol)
        read_only_method_symb()   = "OBJ",
        update_method_symb()      = "void";
      sgn = ret_type_str & " " & user_def_method_name(block_name, name) & "(" & args_str & ", ENV &env)";
      vars_decls = gen_vars_decls(body);
      body_text = vars_decls & ("" if vars_decls != ()) & compile_to_c(body, nil);
      return (sgn & ";", (sgn, "{") & indent_lines(body_text) & ("}"));
    }


    (String, String*) gen_input_setter(AutoSymbol block_name, Atom input_name, Nat node_idx, Bool queue_node)
    {
      sgn = "void " & input_set_method_name(block_name, input_name) & "(" & to_c_name(block_name) & " *self, OBJ new_val)";
      pending_input_var_str = to_c_var_ref_name(pending_input_var(input_name));
      marked_for_update_var = to_c_var_ref_name(marked_for_update_var(std_block_node_id(input_name)));
      body = (
        sgn,
        "{",
        "  if (" & marked_for_update_var & ")",
        "  {",
        "    release(" & pending_input_var_str & ");",
        "    " & pending_input_var_str & " = new_val;",
        "  }",
        "  else",
        "  {",
        "    " & pending_input_var_str & " = new_val;",
        "    int64 idx = self->update_count_0;" if queue_node,
        "    self->nodes_to_update_0[idx] = " & printed(node_idx) & ";" if queue_node,
        "    self->update_count_0 = idx + 1;" if queue_node,
        "    " & marked_for_update_var & " = true;",
        "  }",
        "}"
      );
      return (sgn & ";", body);
    }


    (String, String*) gen_output_getter(AutoSymbol block_name, Atom output_name)
    {
      sgn = "OBJ " & output_get_method_name(block_name, output_name) & "(" & to_c_name(block_name) & " *self)";
      body = (
        sgn,
        "{",
        "  OBJ value = " & to_c_var_ref_name(memb_var(output_name)) & ";",
        "  add_ref(value);",
        "  return value;",
        "}"
      );
      return (sgn & ";", body);
    }


    (String, String*) gen_queue_update_method(AutoSymbol block_name, StdBlockNodeId memb_id, Instr* body, Bool two_level_update)
    {
      method_name = queue_update_method_name(memb_id, block_name);
      other_arg = if two_level_update then ", bool " & to_c_var_decl_name(invalidate_cond_expr_cache) else "";
      sgn = "void " & method_name & "(" & to_c_name(block_name) & " *self" & other_arg & ")";
      vars_decl_text = gen_vars_decls(body);
      vars_decl_text = (vars_decl_text | "") if vars_decl_text != ();
      body_text = vars_decl_text & compile_to_c(body, nil);
      return (sgn & ";", (sgn, "{") & indent_lines(body_text) & ("}"));
    }


    (String, String*) gen_queue_update_method(AutoSymbol block_name, CondNodeId cond_id, Instr* body, Bool two_level_update)
    {
      method_name = queue_update_method_name(cond_id, block_name);
      inval_cache_var_name = to_c_var_decl_name(invalidate_cond_expr_cache);
      sgn = "void " & method_name & "(" & to_c_name(block_name) & " *self, bool " & inval_cache_var_name & ")";
      vars_decl_text = gen_vars_decls(body);
      vars_decl_text = (vars_decl_text | "") if vars_decl_text != ();
      body_text = vars_decl_text & compile_to_c(body, nil);
      return (sgn & ";", (sgn, "{") & indent_lines(body_text) & ("}"));
    }


    (String, String*) gen_queue_update_method(AutoSymbol block_name, NestedAutoInputNodeId input_id, Instr* body, Bool two_level_update)
    {
      method_name = queue_update_method_name(input_id, block_name);
      sgn = "void " & method_name & "(" & to_c_name(block_name) & " *self)";
      vars_decl_text = gen_vars_decls(body);
      vars_decl_text = (vars_decl_text | "") if vars_decl_text != ();
      body_text = vars_decl_text & compile_to_c(body, nil);
      return (sgn & ";", (sgn, "{") & indent_lines(body_text) & ("}"));
    }


    (String, String*) gen_insert_timer_method(AutoSymbol block_name)
    {
      method_name = insert_timer_method_name(block_name);
      sgn = "void " & method_name & "(" & to_c_name(block_name) & " *self, int64 cond_idx, int64 time)";

      body_text = (
        "int n = self->time_triggers_count;",
        "int64 *tt = self->trigger_times_heap;",
        "int *ids = self->time_varying_cond_ids_heap;",

        "int i = 0;",
        "while (i < n && tt[i] < time)",
        "  i++;",

        "for (int j=n ; j > i ; j--)",
        "{",
        "  tt[j] = tt[j-1];",
        "  ids[j] = ids[j-1];",
        "}",

        "tt[i] = time;",
        "ids[i] = cond_idx;",

        "self->time_triggers_count = n + 1;"
      );

      return (sgn & ";", (sgn, "{") & indent_lines(body_text) & ("}"));
    }


    (String, String*) gen_clear_timer_method(AutoSymbol block_name)
    {
      method_name = clear_timer_method_name(block_name);
      sgn = "void " & method_name & "(" & to_c_name(block_name) & " *self, int64 cond_idx)";

      body_text = (
        "int n = self->time_triggers_count;",
        "int64 *tt = self->trigger_times_heap;",
        "int *ids = self->time_varying_cond_ids_heap;",

        "int i = 0;",
        "while (i < n && ids[i] != cond_idx)",
        "  i++;",

        "if (i < n)",
        "  self->time_triggers_count = n - 1;",

        "for ( ; i < n - 1 ; i++)",
        "{",
        "  tt[i] = tt[i+1];",
        "  ids[i] = ids[i+1];",
        "}"
      );

      return (sgn & ";", (sgn, "{") & indent_lines(body_text) & ("}"));
    }
  }


  CCodeOutput compile_to_c(ObjProcDef* obj_proc_defs, BoolProcDef* bool_proc_defs, ClsDef* cls_defs, Block* blocks, Int+* int_seqs)
  {
    type_checking_fn_decls = (gen_c_decl(pd) : pd <- bool_proc_defs) & 4 * ("");
    // print "Type checking function declarations generated";

    closure_decls = (gen_c_decl(d, i) : d @ i <- cls_defs) & 4 * ("");
    // print "Closure declarations generated";

    fn_decls = (gen_c_decl(pd) : pd <- obj_proc_defs) & 4 * ("");
    // print "Function declarations generated";

    type_checking_fns = join((compile_to_c(d) & ("", "") : d <- bool_proc_defs)) & 4 * ("");
    // print "Type checking functions generated";

    closures = join((compile_to_c(d, i) & ("", "") : d @ i <- cls_defs)) & 4 * ("");
    // print "Closures generated";

    functions = join((compile_to_c(d) & ("", "") : d <- obj_proc_defs));
    // print "Functions generated";

    blocks_code = (compile_block_to_c(b) : b <- blocks);
    blocks_decls = join((b.header & ("", "") : b <- blocks_code));
    blocks_bodies = join(intermix((b.body : b <- blocks_code), ("", "")));

    body = join((type_checking_fn_decls, closure_decls, fn_decls, blocks_decls, type_checking_fns, closures, functions, blocks_bodies));

    return [body: body, header: fn_decls & ("", "") & blocks_decls];
  }


  String gen_c_decl(ObjProcDef pd)
  {
    par_types = (if p == :obj then "OBJ" else "CLS" & printed(p.arity) & " &" : p <- pd.params);
    par_list = append(par_types & ("ENV &"), ", ");
    return "OBJ " & to_c_fn_name(pd.name, in_arity(pd)) & "(" & par_list & ");";
  }


  String gen_c_decl(BoolProcDef pd)
  {
    par_list = append(pd.arity * ("OBJ"), ", ");
    return "bool " & to_c_fn_name(pd.name) & "(" & par_list & ");";
  }


  String gen_c_decl(ClsDef cd, Nat id)
  {
    par_list = append(cd.arity * ("OBJ") & ("const OBJ *", "ENV &"), ", ");
    return "OBJ cls_" & printed(id) & "(" & par_list & ");";
  }


  String* compile_to_c(ProcDef pd)
  {
    cached = pd.cached? and pd.cached;

    fn_name = to_c_fn_name(pd.name, in_arity(pd));

    suffix = if cached then "__CALCULATE_CONSTANT" else "";

    par_list = gen_fn_pars(pd);
    par_list_str = append(par_list, ", ");

    signature = ret_type_str(pd) & fn_name & suffix & "(" & par_list_str & ")";

    body = pd.body;
    auto_vars_types = auto_vars_to_decl_and_init(body);

    var_decls = gen_vars_decls(body);

    auto_vars = rand_sort(keys(auto_vars_types));
    auto_var_decls = (to_c_name(auto_vars_types[v]) & " " & to_c_var_decl_name(v) & ";" : v <- auto_vars);

    comp_body = compile_to_c(body, nil);

    code = (signature, "{") & indent_lines(var_decls) & indent_lines(auto_var_decls) &
           ("" if var_decls != () or auto_var_decls != ()) & indent_lines(comp_body) & ("}");

    if cached:
      wrapper_code = (
        "",
        "",
        ret_type_str(pd) & fn_name & "(" & par_list_str & ")",
        "{",
        "  static OBJ cached_res = make_blank_obj();",
        "  if (is_blank_obj(cached_res))",
        "  {",
        "    cached_res = " & fn_name & suffix & "(env);",
        "    add_obj_to_cache(cached_res);",
        "  }",
        "  add_ref(cached_res);",
        "  return cached_res;",
        "}"
      );
      code = code & wrapper_code;
    ;

    return code;


    Nat arity(ProcDef pd):
      obj_proc_def()    = in_arity(pd),
      bool_proc_def()   = pd.arity;

    String ret_type_str(ProcDef):
      obj_proc_def()    = "OBJ ",
      bool_proc_def()   = "bool ";

    String gen_fn_par(ObjProcPar par, Nat pos):
      obj   = "OBJ p" & printed(pos),
      cls() = "CLS" & printed(par.arity) & " &" & to_c_var_decl_name(if par.name? then par.name else cls_var(pos));

    String* gen_fn_pars(ProcDef pd):
      ObjProcDef  = (gen_fn_par(p, i) : p @ i <- pd.params) & ("ENV &env"),
      BoolProcDef = ("OBJ p" & printed(n) : n < arity(pd));
  }


  String* gen_vars_decls(Instr* body)
  {
    vars_to_decl = [v : v <- vars_to_declare(body), not v :: AuxVar];

    vector_vars = [v : v <- vars_to_decl, v :: VecVar];
    scalar_vars = vars_to_decl - vector_vars;

    vec_vars_by_id = group_by(vector_vars, $.id);
    new_vec_vars = [vvar(id, nz_nat(max([v.size : v <- vs]))) : vs @ id <- vec_vars_by_id];

    assert {
      vec_var_ids  = [v.id : v <- vector_vars];
      ref_new_vec_vars = [vvar(id, nz_nat(max(nonempty([v.size : v <- vector_vars, v.id == id])))) : id <- vec_var_ids];
      return new_vec_vars == ref_new_vec_vars;
    };

    vars_to_decl = scalar_vars & new_vec_vars;
    return (var_decl(v) : v <- rand_sort(vars_to_decl));
  }


  //## DUPLICATED CODE
  String* compile_to_c(ClsDef cd, Nat id)
  {
    par_list  = ("OBJ p" & printed(n) : n < cd.arity) & ("const OBJ C[]", "ENV &env"); //## BAD
    signature = "OBJ cls_" & printed(id) & "(" & append(par_list, ", ") & ")";

    vars_decls = gen_vars_decls(cd.body);
    comp_body = compile_to_c(cd.body, nil);

    return (signature, "{") & indent_lines(vars_decls) & ("") & indent_lines(comp_body) & ("}");
  }


  String var_decl(AnyVar v):
    ObjVar    = "OBJ "       & to_c_var_decl_name(v) & ";",
    VecVar    = "OBJ "       & to_c_var_decl_name(v) & "[" & printed(v.size) & "];",
    BoolVar   = "bool "      & to_c_var_decl_name(v) & ";",
    IntVar    = "int64 "     & to_c_var_decl_name(v) & ";",
    SeqItVar  = "SEQ_ITER "  & to_c_var_decl_name(v) & ";",
    SetItVar  = "SET_ITER "  & to_c_var_decl_name(v) & ";",
    MapItVar  = "MAP_ITER "  & to_c_var_decl_name(v) & ";",
    StreamVar = "STREAM "    & to_c_var_decl_name(v) & ";";


  String* compile_to_c(Instr* instrs, <Nat, nil> block_id) = join((compile_to_c(instr, block_id) : instr <- instrs));

  String* compile_to_c(Instr instr, <Nat, nil> block_id):

    init_stream(v?)       = mk_call("init", (v)),
    append()              = mk_call("append", (instr.stream, instr.obj)),

    // get_at()              = mk_call(instr.var, "get_at", [instr.seq, instr.idx]),

    set_at()              = mk_call("set_at", (instr.var, instr.idx, instr.value)),

    lookup()              = mk_call(
                              instr.var,
                              "lookup",
                              (instr.map, instr.key, instr.success_var if instr.success_var?)
                            ),

    //## BAD BAD IT'S ALMOST THE SAME AS THE EXPRESSION ABOVE
    ext_lookup()          = mk_call(
                              instr.var,
                              "ext_lookup",
                              (instr.map, instr.key, instr.success_var if instr.success_var?)
                            ),

    get_set_iter()        = mk_call("get_set_iter", (instr.var, instr.src)),
    get_seq_iter()        = mk_call("get_seq_iter", (instr.var, instr.src)),
    get_map_iter()        = mk_call("get_map_iter", (instr.var, instr.src)),

    move_forward(v?)      = mk_call("move_forward", (v)),

    set_var()             = mk_assignment(instr.var, instr.value),
    set_bvar()            = mk_assignment(instr.var, instr.value), //## BAD
    set_ivar()            = mk_assignment(instr.var, instr.value), //## BAD

    set_rc_var()          = compile_to_c(instr.value, instr.var),

    init_memb_var()       = (to_c_var_ref_name(instr.var) & " = " & to_c_const(instr.new_state) & ";"),
    reset_memb_var()      = (to_c_var_ref_name(instr.var) & " = " & to_c_const(instr.new_state) & ";"),
    clear_loc_var(v?)     = (to_c_var_ref_name(v) & " = make_null_obj();"),

    terminate             = ("fail();"),

    add_ref(v?)           = mk_call("add_ref", (v)),
    release(v?)           = mk_call("release", (v)),

    print_obj()           = mk_call("print", (instr.obj)),

    ret_val(e?)           = ("return " & to_c_expr(e) & ";"),

    no_op                 = (),

    repeat(body?)         = ("for ( ; ; )", "{") & indent_lines(compile_to_c(body, block_id)) & ("}"),

    break_loop            = ("break;"),


    execute_block(body?)  = { new_block_id = _counter_(nil);
                              body_code = compile_to_c(body, new_block_id);
                              label = ("block_" & printed(new_block_id) & "_end:;");
                              return body_code & label;
                            },

    exit_block            = { fail if block_id == nil; //assert block_id != nil; //## BAD
                              return ("goto block_" & printed(block_id) & "_end;");
                            },

    switch_on_nat()       = compile_switch_on_nat_to_c(instr.value, instr.cases, block_id),

    symb_switch()         = compile_symb_switch_to_c(instr.value, instr.cases, instr.else, block_id),

    call_proc()           = compile_call_proc_to_c(if instr.var? then just(instr.var) else nil, instr.name, instr.params, block_id),

    call_cls()            = mk_cls_call(instr.cls_var, instr.var, instr.params), //## INLINE THE FUNCTION

    push_call_info()      = { fn_name = (printed(fn_name_to_str(instr.fn_name)));
                              params = (if p == nil then :blank_obj else value(p) : p <- instr.params);
                              return (mk_gen_call("push_call_info_wrapper", fn_name, params, ()));
                            },

    pop_call_info         = mk_call("pop_call_info", ()),

    runtime_check()       = compile_runtime_check_to_c(instr.cond, instr.file, instr.line, instr.text, instr.vars),

    branch()              = compile_branch_to_c(instr.cond, instr.when_true, instr.when_false, block_id),

    cls_scope()           = { bound_cls = instr.bound_cls;
                              return match (bound_cls)
                                ClsVar      = {fail;}, //## THIS SHOULD NOT BE POSSIBLE FOR NOW
                                bound_cls() = compile_cls_scope_to_c(instr.var, bound_cls.cls, bound_cls.env, instr.body, block_id);
                            },

    queue_update()        = (queue_update_method_name(instr.id, instr.type) & "(self);"),

    queue_cond_update()   = (queue_update_method_name(instr.id, instr.type) & "(self, " & to_c_expr(instr.inval_cache) & ");"),

    insert_timer()        = (insert_timer_method_name(instr.type) & "(self, " & to_c_expr(instr.idx) & ", " & to_c_expr(instr.time) & ");"),

    clear_timer()         = (clear_timer_method_name(instr.type) & "(self, " & to_c_expr(instr.idx) & ");"),

    auto_pre_init()       = (pre_init_method_name(instr.type) & "(&" & to_c_var_ref_name(instr.var) & ", env);"),

    auto_cleanup()        = (cleanup_method_name(instr.type) & "(&" & to_c_var_ref_name(instr.var) & ");"),

    set_input()           = { maybe_value = instr.value;
                              value_str = if maybe_value != nil then to_c_expr(value(maybe_value)) else "make_null_obj()";
                              method_name = input_set_method_name(instr.type, instr.input);
                              return (method_name & "(&" & to_c_var_ref_name(instr.var) & ", " & value_str & ");");
                            },


                      // auto_init(var: AnyAutoVar?, type: AutoSymbol),
                      // auto_update(var: AnyAutoVar?, type: AutoSymbol),
                      // auto_update_node(type: AutoSymbol, node: BlockNodeId),


    auto_update_node()    = compile_auto_update_node_to_c(instr.type, instr.node, if instr.time_var? then just(instr.time_var) else nil),

    auto_apply()          = compile_auto_apply_to_c(if instr.var? then just(instr.var) else nil, instr.type, instr.elapsed_time),
    call_method()         = compile_call_method_to_c(if instr.res_var? then just(instr.res_var) else nil, if instr.auto_var? then just(instr.auto_var) else nil, instr.type, instr.name, instr.args);



  String* compile_auto_update_node_to_c(AutoSymbol type, BlockNodeId node, Maybe[IntVar] maybe_time_var)
  {
    time_arg = if maybe_time_var != nil then ", " & to_c_var_ref_name(value(maybe_time_var)) else "";
    return (node_update_method_name(type, node) & "(self" & time_arg & ", self_aux, env);");
  }


  //## BUG BUG BUG: IF THERE IS INSIDE ONE OF THE CASES A BREAK STATEMENT MEANT TO
  //## TERMIMATE AN OUTER LOOP, THAT BREAK WILL TERMINATE THE SWITCH/CASE INSTEAD.
  String* compile_switch_on_nat_to_c(IntExpr value, Instr*+ cases, <Nat, nil> block_id)
  {
    cases_code = (
      ("case " & printed(i) & ":") & indent_lines((compile_to_c(c, block_id) | "break;", ""))
      : c @ i <- cases
    );
    return ("switch (" & to_c_expr(value) & ")", "{") & indent_lines(join(cases_code)) & ("}");
  }


  //## BUG BUG BUG: IF THERE IS INSIDE ONE OF THE CASES A BREAK STATEMENT MEANT TO
  //## TERMIMATE AN OUTER LOOP, THAT BREAK WILL TERMINATE THE SWITCH/CASE INSTEAD.
  String* compile_symb_switch_to_c(ObjExpr value, [+([+Atom], Instr+)] cases, Instr* else, <Nat, nil> block_id)
  {
    value_str = match (value)
      get_tag(tag_obj?)   = "get_tag_idx(" & to_c_expr(tag_obj) & ")",
      _                   = "get_symb_idx(" & to_c_expr(value) & ")";

    body_code = (
      ("" if i > 0) &
      ("case symb_idx_" & _str_(a) & ":" : a <- rand_sort(as)) &
      indent_lines((compile_to_c(is, block_id) | "break;"))
      : as, is @ i <- rand_sort(cases)
    );
    body_code = (body_code | ("", "default:") & indent_lines(compile_to_c(else, block_id))) if else != ();

    return ("switch (" & value_str & ")", "{") & indent_lines(join(body_code)) & ("}");
  }


  String* compile_auto_apply_to_c(Maybe[AnyAutoVar] var, AutoSymbol type, IntExpr elapsed_time)
  {
    var_str = if var != nil then "&" & to_c_var_ref_name(value(var)) else "self";
    name_str = apply_method_name(type);
    time_str = to_c_expr(elapsed_time);
    return (mk_gen_call(name_str, (var_str, time_str), (), ("env")));
  }


  String* compile_call_method_to_c(Maybe[WriteObjVar] res_var, Maybe[AnyAutoVar] auto_var, AutoSymbol type, ExMethodSymb name, AtomicExpr* args)
  {
    auto_var_str = if auto_var != nil then "&" & to_c_var_ref_name(value(auto_var)) else "self";
    name_str = user_def_method_name(type, name);
    // time_str = to_c_expr(elapsed_time);
    time_str = to_c_expr(0);
    return (
      if res_var == nil
        then mk_gen_call(name_str, (auto_var_str, time_str), args, ("env"))
        else mk_gen_call(value(res_var), name_str, (auto_var_str, time_str), args, ("env"))
    );
  }


  String* compile_to_c(FloatExpr expr, ObjVar var):
    mk_float()            = (mk_gen_call(var, "make_float", (printed(expr.mantissa) & "e" & printed(expr.dec_exp)), (), ())),
    neg_float()           = mk_call(var, "neg_float",     (expr.value)),
    add_floats()          = mk_call(var, "add_floats",    expr.values),
    sub_floats()          = mk_call(var, "sub_floats",    expr.values),
    mult_floats()         = mk_call(var, "mult_floats",   expr.values),
    div_floats()          = mk_call(var, "div_floats",    expr.values),
    square_root()         = mk_call(var, "square_root",   (expr.value)),
    floor_op()            = mk_call(var, "floor",         (expr.value)),
    ceiling_op()          = mk_call(var, "ceiling",       (expr.value)),
    int_to_float()        = mk_call(var, "int_to_float",  (expr.value));


  String* compile_to_c(RefObjExpr expr, ObjVar var):
    mk_set_from_stream()  = mk_call(var, "build_set",           (expr.stream)),
    mk_set()              = mk_call(var, "build_set",           (expr.elems, expr.size)),
    mk_seq_from_stream()  = mk_call(var, "build_seq",           (expr.stream)),
    mk_seq()              = mk_call(var, "build_seq",           (expr.elems, expr.size)),
    build_const_int_seq() = compile_build_const_int_seq_to_c(expr.seq_id, var),
    mk_map_from_streams() = mk_call(var, "build_map",           (expr.key_stream, expr.value_stream)),
    mk_map()              = mk_call(var, "build_map",           (expr.keys, expr.values, expr.size)),
    mk_tagged_obj()       = mk_call(var, "build_tagged_obj",    (expr.tag, expr.obj)),
    mk_array()            = mk_call(var, "blank_array",         (expr.size)),
    get_seq_slice()       = mk_call(var, "get_seq_slice",       (expr.seq, expr.idx_first, expr.len)),
    append_to_seq()       = mk_call(var, "append_to_seq",       (expr.seq, expr.new_elem)),
    join_seqs()           = mk_call(var, "join_seqs",           (expr.left, expr.right)),
    join_mult_seqs()      = mk_call(var, "join_mult_seqs",      (expr.seqs)),
    rev_seq()             = mk_call(var, "rev_seq",             (expr.seq)),
    merge_sets()          = mk_call(var, "merge_sets",          (expr.sets)),
    merge_maps()          = mk_call(var, "merge_maps",          (expr.maps)),
    seq_to_set()          = mk_call(var, "seq_to_set",          (expr.seq)),
    seq_to_mset()         = mk_call(var, "seq_to_mset",         (expr.seq)),
    internal_sort()       = mk_call(var, "internal_sort",       (expr.set)),
    symb_to_str(e?)       = mk_call(var, "to_str",              (e)),
    read_pending_var(v?)  = (to_c_var_ref_name(var) & " = " & to_c_var_ref_name(v) & ";"),
    read_output()         = (mk_gen_call(var, output_get_method_name(expr.type, expr.output), ("&" & to_c_var_ref_name(expr.var)))),
    add_attachment()      = mk_call(var, "add_attachment",      (expr.target, expr.data)),
    fetch_attachments(e?) = mk_call(var, "fetch_attachments",   (e));


  String* compile_build_const_int_seq_to_c(Nat seq_id, ObjVar var)
  {
    type, len = int_seqs_types_and_lengths[seq_id];
    seq_name = const_int_seq_c_name(seq_id);
    return (mk_gen_call(var, "build_const_" & type & "_seq", (seq_name, printed(len))));
  }

  ///////////////////////////////////////////////////////////////////////////////

  String* compile_call_proc_to_c(Maybe[ObjVar] var, ObjFnName name, <ObjExpr, BoundCls>* params, <Nat, nil> block_id)
  {
    pars_info = (gen_par_info(p) : p <- params);
    code_frags, args = unzip(pars_info);
    call_code = if var != nil
      then mk_fn_call(value(var), to_c_fn_name(name, length(params)), args)
      else mk_fn_call(to_c_fn_name(name, length(params)), args);
    return join(code_frags) & call_code;


    (String*, FnCallParam) gen_par_info(ObjExpr p) = ((), p);

    (String*, FnCallParam) gen_par_info(BoundCls p):
      ClsVar      = ((), p),
      // fn_ref()    = {
      //   par_id = _counter_(nil);
      //   par_var = cls_var(par_id);
      //   par_name = to_c_expr(par_var);
      //   code = [
      //     "CLS" & printed(p.arity) & " " & par_name & ";",
      //     par_name & ".fn_ptr = " & to_c_fn_name(p.name) & ";",
      //     par_name & ".data = 0;"
      //   ];
      //   return (code, par_var);
      // },
      bound_cls() = {
        //## BAD: THE FIRST LINES OF CODE ARE THE SAME AS ABOVE...
        par_id = _counter_(nil);
        par_var = cls_var(par_id);
        par_name = to_c_expr(par_var);
        code = (
          "CLS" & printed(p.cls.arity) & " " & par_name & ";",
          par_name & ".fn_ptr = " & "cls_" & printed(cls2id(p.cls)) & ";"
        );
        if p.env != ():
          var_name = "cd_" & printed(par_id);
          code = code & ("OBJ " & var_name & "[" & printed(length(p.env)) & "];");
          for v @ i <- p.env:
            code = code & (var_name & "[" & printed(i) & "] = " & to_c_expr(v) & ";");
          ;
          code = code & (par_name & ".data = " & var_name & ";");
        else
          code = code & (par_name & ".data = 0;");
        ;
        return (code, par_var);
      };
  }


  String* compile_branch_to_c(BoolExpr cond, Instr* when_true, Instr* when_false, <Nat, nil> block_id)
  {
    assert when_true != ();
    code = ("if (" & to_c_expr(cond) & ")", "{")     &
           indent_lines(compile_to_c(when_true, block_id)) &
           ("}");
    if when_false != ():
      code = code & ("else", "{") & indent_lines(compile_to_c(when_false, block_id)) & ("}");
    ;
    return code;
  }


  String* compile_cls_scope_to_c(NamedArg var, ClsDef cls, Var* env, Instr+ body, <Nat, nil> block_id)
  {
    scope_id = printed(_counter_(nil));

    arity = cls.arity;
    env_size = length(env);

    var_str = _str_(_obj_(var)); //## BAD, DUPLICATED LOGIC
    arity_str = printed(arity);
    env_size_str = printed(env_size);

    fn_var = "env.n" & arity_str & "_" & var_str;  //## BAD, DUPLICATED LOGIC
    data_var = "env.C" & arity_str & "_" & var_str; //## BAD, DUPLICATED LOGIC
    fn_bk_var = "BF" & scope_id;
    data_bk_var = "BD" & scope_id;
    new_data_var = "ND" & scope_id;

    tmp = append(arity * ("OBJ") & ("const OBJ *", "ENV &"), ", ");

    code = (
      "OBJ (*" & fn_bk_var & ")(" & tmp & ") = " & fn_var & ";",
      "const OBJ *BD" & scope_id & " = " & data_var & ";"
    );

    code = code & ("OBJ " & new_data_var & "[" & env_size_str & "];") if env_size > 0;

    //## HERE I'M ADDING THE add_ref/release PAIRS IN THE WRONG LAYERS
    for i < env_size:
      code = code & (
        new_data_var & "[" & printed(i) & "] = " & to_c_var_ref_name(env[i]) & ";",
        "add_ref(" & new_data_var & "[" & printed(i) & "]);"
      );
    ;

    code = code & (
      fn_var & " = cls_" & printed(cls2id(cls)) & ";",
      data_var & " = " & {if env_size > 0 then new_data_var else "0"} & ";"
    );

    code = code & compile_to_c(body, block_id);

    code = code & (
      fn_var & " = " & fn_bk_var & ";",
      data_var & " = " & data_bk_var & ";"
    );

    for i < env_size:
      code = code & ("release(" & new_data_var & "[" & printed(i) & "]);");
    ;

    code = ("{") & indent_lines(code) & ("}");

    return code;
  }


  String* compile_runtime_check_to_c(AtomicExpr cond, String file, NzNat line, Maybe[String] text, <StdVar, NamedArg>* vars)
  {
    text_arg = if text != nil then printed(value(text)) else "0";
    header = (
      "if (is_symb(" & to_c_expr(cond) & ", symb_idx_false))",
      "{",
      "  print_assertion_failed_msg(" & printed(file) & ", " & printed(line) & ", " & text_arg & ");"
    );
    vars_content = ("  dump_var(" & printed(_str_(name(v))) & ", " & to_c_var_ref_name(v) & ");" : v <- vars);
    footer = (
      "  hard_fail(0);",
      "}"
    );
    return header & vars_content & footer;
  }

  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  String mk_gen_call(String fn_name, String* leading_params, FnCallParam* params, String* trailing_params) =
    fn_name & "(" & append(leading_params & (to_c_expr(p) : p <- params) & trailing_params, ", ") & ");";

  String mk_gen_call(AnyVar var, String fn_name, String* leading_params, FnCallParam* params, String* trailing_params) =
    to_c_var_ref_name(var) & " = " & mk_gen_call(fn_name, leading_params, params, trailing_params);

  String mk_gen_call(AnyVar var, String fn_name, String* params) = mk_gen_call(var, fn_name, params, (), ());

  String* mk_call(String fn_name, FnCallParam* params)             = (mk_gen_call(fn_name, (), params, ()));
  String* mk_call(AnyVar var, String fn_name, FnCallParam* params) = (mk_gen_call(var, fn_name, (), params, ()));

  String* mk_fn_call(String fn_name, FnCallParam* params)             = (mk_gen_call(fn_name, (), params, ("env")));
  String* mk_fn_call(AnyVar var, String fn_name, FnCallParam* params) = (mk_gen_call(var, fn_name, (), params, ("env")));

  //## AnyVar IS WRONG HERE, SHOULD ONLY BE OBJ/BOOL/INT VARS
  String* mk_assignment(AnyVar var, AnyTypeExpr value) = (to_c_var_ref_name(var) & " = " & to_c_expr(value) & ";");


  String* mk_cls_call(<ClsVar, NamedArg> cls_var, ObjVar var, ObjExpr* params):
    cls_var(+ symb?) = { //## NO NEED FOR NOW TO HANDLE THE CASE cls_var(Nat), AS THOSE VARIABLES ARE NEVER "CALLED", ONLY PASSED ON
      name = to_c_var_ref_name(cls_var);
      return (mk_gen_call(var, name & ".fn_ptr", (), params, (name & ".data", "env")));
    },
    named_arg(symb?) = {
      name = printed(length(params)) & "_" & _str_(_obj_(cls_var));
      return (mk_gen_call(var, "env.n" & name, (), params, ("env.C" & name, "env")));
    };
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

using String typesymb2name(TypeSymbol)
{
  //## IT WOULD MUCH BETTER IF WE COULD USE mk_call HERE...
  String to_c_expr(ObjExpr expr):
    object(Atom a?)     = upper_camel_case(a) & "_S",
    object(Int n?)      = "make_int(" & printed(n) & ")",
    empty_set           = "make_empty_set()",
    empty_seq           = "make_empty_seq()",
    empty_map           = "make_empty_map()",
    ObjVar              = to_c_var_ref_name(expr),
    at()                = "at("                 & to_c_expr(expr.seq)    & ", " & to_c_expr(expr.idx) & ")",
    search_or_lookup()  = "search_or_lookup("   & to_c_expr(expr.collection) & ", " & to_c_expr(expr.value) & ")",
    get_tag(e?)         = "get_tag("            & to_c_expr(e)           & ")",
    get_inner_obj(e?)   = "get_inner_obj("      & to_c_expr(e)           & ")",
    bool_obj(e?)        = "make_bool("          & to_c_expr(e)           & ")",
    int_obj(e?)         = "make_int("           & to_c_expr(e)           & ")",
    obj_neg(e?)         = "obj_neg("            & to_c_expr(e)           & ")",
    to_symb(e?)         = "to_symb("            & to_c_expr(e)           & ")",
    get_curr_obj(v?)    = "get_curr_obj("       & to_c_var_ref_name(v) & ")",
    get_curr_key(v?)    = "get_curr_key("       & to_c_var_ref_name(v) & ")",
    get_curr_value(v?)  = "get_curr_value("     & to_c_var_ref_name(v) & ")",
    rand_elem(e?)       = "rand_set_elem("      & to_c_expr(e)           & ")";


  String to_c_expr(BoolExpr expr)           = to_c_expr(expr, false);
  String to_c_expr(ObjExpr expr, Bool)      = to_c_expr(expr);

  String to_c_expr(PendingInputVar v)       = to_c_var_ref_name(v);
  String to_c_expr(PendingInputVar v, Bool) = to_c_var_ref_name(v);


  String to_c_expr(BoolExpr expr, Bool parentesised):
    true                  = "true",
    false                 = "false",
    BoolVar               = to_c_var_ref_name(expr),
    is_symb(e?)           = "is_symb("    & to_c_expr(e) & ")",
    is_int(e?)            = "is_int("     & to_c_expr(e) & ")",
    is_float(e?)          = "is_float("   & to_c_expr(e) & ")",
    is_ne_set(e?)         = "is_ne_set("  & to_c_expr(e) & ")",
    is_ne_seq(e?)         = "is_ne_seq("  & to_c_expr(e) & ")",
    is_ne_map(e?)         = "is_ne_map("  & to_c_expr(e) & ")",
    is_tagged_obj(e?)     = "is_tag_obj(" & to_c_expr(e) & ")",

    has_elem()            = "has_elem(" & to_c_expr(expr.set) & ", " & to_c_expr(expr.elem) & ")",

    is_eq_bool()          = to_nary_op(" == ", (expr.expr1, expr.expr2), parentesised), //## BAD
    is_eq_int()           = to_nary_op(" == ", (expr.expr1, expr.expr2), parentesised), //## BAD

    is_eq()               = "are_eq(" & to_c_expr(expr.expr1) & ", " & to_c_expr(expr.expr2) & ")",

    //## BUG BUG BUG HUGE BUG HERE, NOT CHECKING THAT THE OPERANDS ARE INTEGERS
    is_gt()               = to_nary_op(" > ",  (expr.expr1, expr.expr2), parentesised), //## BAD
    is_ge()               = to_nary_op(" >= ", (expr.expr1, expr.expr2), parentesised), //## BAD
    is_lt()               = to_nary_op(" < ",  (expr.expr1, expr.expr2), parentesised), //## BAD
    is_le()               = to_nary_op(" <= ", (expr.expr1, expr.expr2), parentesised), //## BAD

    inline_is_eq()        = inline_is_eq_to_c_expr(expr.expr, expr.value, parentesised),

    is_out_of_range(v?)   = "is_out_of_range(" & to_c_var_ref_name(v) & ")",

    //## ONE OF THESE TWO TEST SHOULD NEVER BE CALLED IF THE OTHER IS NOT TRUE.
    //## FIGURE THIS OUT AND ADD A CHECK.
    var_is_set(v?)        = "!is_blank_obj(" & to_c_var_ref_name(v) & ")",
    var_is_def(v?)        = "!is_null_obj(" & to_c_var_ref_name(v) & ")",

    neg(e?)               = parentesize("!" & to_c_expr(e, true), parentesised),

    and(es?)              = to_nary_op(" & ",  es, parentesised),
    or(es?)               = to_nary_op(" | ",  es, parentesised),
    and_then(es?)         = to_nary_op(" && ", es, parentesised),
    or_else(es?)          = to_nary_op(" || ", es, parentesised),

    eval_bool_fn()        = to_c_fn_name(expr.name) & "(" & to_nary_op(", ", expr.params, false) & ")";


  String inline_is_eq_to_c_expr(ObjExpr expr, InlineObj value, Bool parentesised)
  {
    expr_str = to_c_expr(expr, false);
    return match (value)
      object(Atom a?)   = "is_symb(" & expr_str & ", symb_idx_" & printed(a) & ")",
      object(Int n?)    = "is_int("  & expr_str & ", " & printed(n) & ")",
      empty_seq         = "is_empty_seq(" & expr_str & ")",
      empty_set         = "is_empty_set(" & expr_str & ")",
      empty_map         = "is_empty_map(" & expr_str & ")";
  }


  String to_c_expr(IntExpr expr) = to_c_expr(expr, false);

  String to_c_expr(IntExpr expr, Bool parentesised):
    Int                 = printed(expr),
    time_slot_length()  = to_c_time_slots_table_name(expr.automaton, expr.expr_id) & "[" & to_c_expr(expr.time_slot) & "]",
    IntVar              = to_c_var_ref_name(expr),
    get_int_val(e?)     = "get_int_val("  & to_c_expr(e) & ")",
    get_set_size(e?)    = "get_set_size(" & to_c_expr(e) & ")",
    get_seq_len(e?)     = "get_seq_len("  & to_c_expr(e) & ")",
    get_map_size(e?)    = "get_map_size(" & to_c_expr(e) & ")",
    minus(e?)           = "-" & to_c_expr(e, true),
    add()               = to_nary_op(" + ", (expr.val1, expr.val2), parentesised),
    sub()               = to_nary_op(" - ", (expr.val1, expr.val2), parentesised),
    mult()              = to_nary_op(" * ", (expr.val1, expr.val2), parentesised),
    div()               = to_nary_op(" / ", (expr.val1, expr.val2), parentesised),
    mod()               = to_nary_op(" % ", (expr.val1, expr.val2), parentesised),
    mantissa(e?)        = "mantissa(" & to_c_expr(e) & ")",
    dec_exp(e?)         = "dec_exp(" & to_c_expr(e) & ")",
    rand_nat(e?)        = "rand_nat(" & to_c_expr(e) & ")",
    unique_nat          = "unique_nat()",
    ticks               = "get_tick_count()";


  String to_c_expr(<ElemVar, VecVar, ItVar, StreamVar> var) = to_c_var_ref_name(var);

  String to_c_expr(<blank_obj>) = "make_blank_obj()";
  String to_c_expr(<null_obj>) = "make_null_obj()";

  String to_c_expr(ClsVar v) = to_c_var_ref_name(v);

  String to_nary_op(String op, AnyTypeExpr+ exprs, Bool parentesised)
  {
    expr = append((to_c_expr(e, true) : e <- exprs), op);
    expr = "(" & expr & ")" if length(exprs) > 1 and parentesised;
    return expr;
  }
}

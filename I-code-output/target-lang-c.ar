type CCodeOutput = (body: [String], header: [String]);

CCodeOutput compile_to_c(ProcDef* prg)
{
  tss = {if mt :: <memb_test(TypeSymbol)> then _obj_(mt) else {fail;} : mt <- select(prg, $ :: <memb_test(TypeSymbol)>)};

  btss = {ts : type_symbol()     ts <- tss};
  ptss = {ts : par_type_symbol() ts <- tss};

  btss = rand_sort(btss);
  ptss = rand_sort(ptss);

  bool_proc_defs = rand_sort({p : bool_proc_def() p <- prg});
  obj_proc_defs  = rand_sort({p : obj_proc_def()  p <- prg});

  // symbs = (select SymbObj in prg end - {obj_true, obj_false}) & {:object(:string)};
  // symbs = [obj_true, obj_false] & sort_set(symbs, $a < $b);
  symbs = select(prg, $ :: SymbObj) & {obj_true, obj_false, :object(:string)};
  fail if not symbs :: SymbObj+;
  symbs = sort_set(symbs, $a < $b);

  symb_decls = ["const Obj " & to_c_expr(s, typesymb2name(ts) = typesymb2str(ts, ptss)) & " = symb(" & to_str(i) & ");" : s @ i <- symbs] & 4 * [""];
  symb_decls = symb_decls & ["const int EMB_SYMB_COUNT = " & to_text(length(symbs)) & ";"] & 4 * [""];

  c_code = symb_decls;

  if (symbs /= [])
    symb_strs  = ["  \"" & _str_(_obj_(s)) & "\"," : s <- symbs];
    c_code     = c_code & ["const char *map_symb_to_str[EMB_SYMB_COUNT] = {"] & symb_strs & ["};"] & 4 * [""];
    symb_decls = symb_decls & ["extern const char *map_symb_to_str[EMB_SYMB_COUNT];"] & 4 * [""];
  ;

  // print "Symbol declarations generated";

  // cls_defs = select ClsDef in prg end;
  // loop
  //   new_cls_defs = select ClsDef in {cd.body : cd <- cls_defs} end;
  //   break if subset(new_cls_defs, cls_defs); //## WHY BREAK WHEN IT'S A SUBSET AND NOT WHEN IT'S EMPTY?
  //   cls_defs = cls_defs & new_cls_defs;
  // ;
  cls_defs = select_rec(prg, $ :: ClsDef); //## TODO: THIS SHOULD BE TESTED
  fail if not cls_defs :: ClsDef*;

  all_named_pars = merge_values(set([p.named_params : p <- obj_proc_defs]));
  all_param_arity_pairs = rand_sort({(var: v, arity: a) : v => ars <- all_named_pars, a <- ars});

  env_decl = ["struct Env {"];

  for (na @ i : all_param_arity_pairs)
    var   = na.var;
    arity = na.arity;

    name = _str_(_obj_(var));

    if (arity > 0)
      ls = [ "  Obj (*n" & to_str(arity) & "_" & name & ")(" & append(["Obj p" & to_str(j) & ", " : j < na.arity]) & "const Obj *C, Env &env);",
              "  const Obj *C" & to_str(arity) & "_" & name & ";"
            ];
    else
      ls = ["  Obj n_" & name & ";"];
    ;

    ls = [""] & ls if i > 0;
    env_decl = env_decl & ls;
  ;

  env_decl = env_decl & ["};"] & 4 * [""];

  c_code = c_code & env_decl;

  NzNat* cls_arities(ProcDef pd):
    obj_proc_def()  = set([p.arity : p <- pd.params, p /= :obj]),
    bool_proc_def() = {};

  all_cls_arities = union({cls_arities(pd) : pd <- prg}); //## MAYBE HERE IT WOULD BE BETTER TO DO A NORMAL SORT

  [String] generate_cls_obj_typedef(NzNat arity) = [
    "struct CLS" & to_str(arity) & " {",
    "  Obj (*fn_ptr)(" & append(intermix(arity * ["Obj"], ", ")) & ", const Obj *, Env &env);",
    "  const Obj *data;",
    "};"
  ];

  cls_obj_typedefs = join(intermix([generate_cls_obj_typedef(a) : a <- rand_sort(all_cls_arities)], 2 * [""])) & 4 * [""];
  c_code = c_code & cls_obj_typedefs;

  all_fn_arities = set([in_arity(d) : d <- obj_proc_defs]);
  c_code = c_code & join(intermix([generate_push_call_info_wrapper(a) : a <- rand_sort(all_fn_arities)], 2 * [""])) & 4 * [""];

  sorted_cls_defs = rand_sort(cls_defs);

  proc_code = compile_to_c(
    obj_proc_defs,
    bool_proc_defs,
    sorted_cls_defs,
    typesymb2name(ts) = typesymb2str(ts, ptss),
    cls2id(cls)       = index_first(cls, sorted_cls_defs)
  );

  body = [
    "#include \"lib.h\"\n\n",
    "#include \"iolib.h\"\n\n",
    "",
    "namespace generated",
    "{"
  ] & indent(c_code & proc_code.body) & ["}"];

  header = ["namespace generated", "{"] & indent(symb_decls & env_decl & cls_obj_typedefs & proc_code.header) & ["}"];

  return (body: body, header: header);


  String typesymb2str(TypeSymbol ts, [ParTypeSymbol] par_types):
    type_symbol(a?)     = upper(_str_(a)),
    par_type_symbol()   = typesymb2str(ts.symbol, par_types) & "__" & to_str(index_first(ts, par_types));
}


[String^] generate_push_call_info_wrapper(Nat arity)
{
  signature = "void push_call_info_wrapper(const char *fn_name" & append([", Obj p" & to_str(i) : i < arity]) & ")";
  code = [signature, "{", "#ifndef NDEBUG"];
  if (arity == 0)
    code = code & ["  push_call_info(fn_name, 0, (Obj *)0);"];
  else
    code = code & ["  Obj *params = new_obj_array(" & to_str(arity) & ");"];
    for (i < arity)
      code = code & ["  params[" & to_str(i) & "] = p" & to_str(i) & ";"];
    ;
    code = code & ["  push_call_info(fn_name, " & to_str(arity) & ", params);"];
  ;
  return nonempty(code & ["#endif", "}"]);
}


//## THIS SHOULD NOT GO HERE
type FnCallParam = null_obj, ObjExpr, ElemVar, VecVar, BoolExpr, IntExpr, ItVar, StreamVar, ClsVar;


using String typesymb2name(TypeSymbol), Nat cls2id(ClsDef)
{
  CCodeOutput compile_to_c([ObjProcDef] obj_proc_defs, [BoolProcDef] bool_proc_defs, [ClsDef] cls_defs)
  {
    type_checking_fn_decls = [gen_c_decl(pd) : pd <- bool_proc_defs] & 4 * [""];
    // print "Type checking function declarations generated";

    closure_decls = [gen_c_decl(d, i) : d @ i <- cls_defs] & 4 * [""];
    // print "Closure declarations generated";

    fn_decls = [gen_c_decl(pd) : pd <- obj_proc_defs] & 4 * [""];
    // print "Function declarations generated";

    type_checking_fns = join([compile_to_c(d) & ["", ""] : d <- bool_proc_defs]) & 4 * [""];
    // print "Type checking functions generated";

    closures = join([compile_to_c(d, i) & ["", ""] : d @ i <- cls_defs]) & 4 * [""];
    // print "Closures generated";

    functions = join([compile_to_c(d) & ["", ""] : d <- obj_proc_defs]);
    // print "Functions generated";

    body = join([type_checking_fn_decls, closure_decls, fn_decls, type_checking_fns, closures, functions]);

    return (body: body, header: fn_decls);
  }


  String gen_c_decl(ObjProcDef pd)
  {
    par_types = [if p == :obj then "Obj" else "CLS" & to_str(p.arity) & " &" : p <- pd.params];
    par_list = append(intermix(par_types & ["Env &"], ", "));
    return "Obj " & to_c_fn_name(pd.name) & "(" & par_list & ");";
  }


  String gen_c_decl(BoolProcDef pd)
  {
    par_list = append(intermix(pd.arity * ["Obj"], ", "));
    return "bool " & to_c_fn_name(pd.name) & "(" & par_list & ");";
  }


  String gen_c_decl(ClsDef cd, Nat id)
  {
    par_list = append(intermix(cd.arity * ["Obj"] & ["const Obj *", "Env &"], ", "));
    return "Obj cls_" & to_str(id) & "(" & par_list & ");";
  }


  [String] compile_to_c(ProcDef pd)
  {
    cached = pd.cached? and pd.cached;

    suffix = if cached then "__CALCULATE_CONSTANT" else "";

    par_list = gen_fn_pars(pd);
    par_list_str = append(intermix(par_list, ", "));

    signature = ret_type_str(pd) & to_c_fn_name(pd.name) & suffix & "(" & par_list_str & ")";

    body = pd.body;

    vars_to_decl = vars_to_declare(body);

    vector_vars = {v : v <- vars_to_decl, v :: VecVar};
    scalar_vars = vars_to_decl - vector_vars;

    vec_var_ids  = {v.id : v <- vector_vars};
    new_vec_vars = for (id <- vec_var_ids) {
                      vvar(id, nz_nat(max({v.size : v <- vector_vars, v.id == id})))
                    };

    vars_to_decl = scalar_vars & new_vec_vars;
    var_decls = [var_decl(v) : v <- rand_sort(vars_to_decl)];

    comp_body = compile_to_c(body, nil);

    code = [signature, "{"] & indent(var_decls) & [""] & indent(comp_body) & ["}"];

    if (cached)
      wrapper_code = [
        "",
        "",
        ret_type_str(pd) & to_c_fn_name(pd.name) & "(" & par_list_str & ")",
        "{",
        "  static Obj cached_res = null_obj;",
        "  if (cached_res == null_obj)",
        "  {",
        "    cached_res = " & to_c_fn_name(pd.name) & "__CALCULATE_CONSTANT(env);",
        "    add_obj_to_cache(cached_res);",
        "  }",
        "  add_ref(cached_res);",
        "  return cached_res;",
        "}"
      ];
      code = code & wrapper_code;
    ;

    return code;


    Nat arity(ProcDef pd):
      obj_proc_def()    = in_arity(pd),
      bool_proc_def()   = pd.arity;

    String ret_type_str(ProcDef):
      obj_proc_def()    = "Obj ",
      bool_proc_def()   = "bool ";

    String gen_fn_par(ObjProcPar par, Nat pos):
      obj   = "Obj p" & to_str(pos),
      cls() = "CLS" & to_str(par.arity) & " &" & if par.name? then to_c_var_name(par.name) else "c_" & to_str(pos);

    [String] gen_fn_pars(ProcDef pd):
      ObjProcDef  = [gen_fn_par(p, i) : p @ i <- pd.params] & ["Env &env"],
      BoolProcDef = ["Obj p" & to_str(n) : n < arity(pd)];
  }


  //## DUPLICATED CODE
  [String] compile_to_c(ClsDef cd, Nat id)
  {
    par_list  = ["Obj p" & to_str(n) : n < cd.arity] & ["const Obj C[]", "Env &env"]; //## BAD
    signature = "Obj cls_" & to_str(id) & "(" & append(intermix(par_list, ", ")) & ")";

    body = cd.body;
    vars_to_decl = vars_to_declare(body);

    var_decls = [var_decl(v) : v <- rand_sort(vars_to_decl)];
    comp_body = compile_to_c(body, nil);

    return [signature, "{"] & indent(var_decls) & [""] & indent(comp_body) & ["}"];
  }


  //## BAD: THIS THING IS INCREDIBLY MESSY. I MUST IMPLEMENT A VERSION OF SELECT WITH A <STOP> GUARD
  // AnyVar* vars_to_declare([Instr] instrs) = {
  //   x : x <- select <AnyVar, ClsDef> in instrs end,
  //       not x :: <fn_par(Nat), named_par(Atom), cls_ext_par(Nat), evar(id: Nat, idx: <Nat, IntVar>), ClsDef>
  // };
  AnyVar* vars_to_declare([Instr] instrs)
  {
    vars = select(
      instrs,
      $ :: <AnyVar, ClsDef> and not $ :: <FnPar, NamedPar, CaptVar, ElemVar, ClsDef>
    );
    fail if not vars :: AnyVar*;
    return vars;
  }


  String var_decl(AnyVar v):
    ObjVar    = "Obj "      & to_c_var_name(v) & ";",
    VecVar    = "Obj "      & to_c_var_name(v) & "[" & to_str(v.size) & "];",
    BoolVar   = "bool "     & to_c_var_name(v) & ";",
    IntVar    = "int "      & to_c_var_name(v) & ";",
    SetItVar  = "SetIter "  & to_c_var_name(v) & ";",
    SeqItVar  = "SeqIter "  & to_c_var_name(v) & ";",
    MapItVar  = "MapIter "  & to_c_var_name(v) & ";",
    StreamVar = "Stream "   & to_c_var_name(v) & ";";


  [String] compile_to_c([Instr] instrs, <Nat, nil> block_id) = join([compile_to_c(instr, block_id) : instr <- instrs]);

  [String] compile_to_c(Instr instr, <Nat, nil> block_id):

    init_stream(v?)       = mk_call("init", [v]),
    append()              = mk_call("append", [instr.stream, instr.obj]),

    // get_at()              = mk_call(instr.var, "get_at", [instr.seq, instr.idx]),

    set_at()              = mk_call("set_at", [instr.var, instr.idx, instr.value]),

    lookup()              = mk_call(
                              instr.var,
                              "lookup",
                              [instr.map, instr.key, instr.success_var if instr.success_var?]
                            ),

    //## BAD BAD IT'S ALMOST THE SAME AS THE EXPRESSION ABOVE
    ext_lookup()          = mk_call(
                              instr.var,
                              "ext_lookup",
                              [instr.map, instr.key, instr.success_var if instr.success_var?]
                            ),

    get_set_iter()        = mk_call("get_set_iter", [instr.var, instr.src]),
    get_seq_iter()        = mk_call("get_seq_iter", [instr.var, instr.src]),
    get_map_iter()        = mk_call("get_map_iter", [instr.var, instr.src]),

    move_forward(v?)      = mk_call("move_forward", [v]),

    set_var()             = mk_assignment(instr.var, instr.value),
    set_bvar()            = mk_assignment(instr.var, instr.value), //## BAD
    set_ivar()            = mk_assignment(instr.var, instr.value), //## BAD

    set_rc_var()          = compile_to_c(instr.value, instr.var),

    terminate             = ["fail();"],

    add_ref(v?)           = mk_call("add_ref", [v]),
    release(v?)           = mk_call("release", [v]),

    print_obj()           = mk_call("print", [instr.obj]),

    ret_val(e?)           = ["return " & to_c_expr(e) & ";"],

    no_op                 = [],

    repeat(body?)         = ["for ( ; ; )", "{"] & indent(compile_to_c(body, block_id)) & ["}"],

    break_loop            = ["break;"],


    execute_block(body?)  = { new_block_id = _counter_(nil);
                              body_code = compile_to_c(body, new_block_id);
                              label = ["block_" & to_str(new_block_id) & "_end:;"];
                              return body_code & label;
                            },

    exit_block            = { fail if block_id == nil; //assert block_id /= nil; //## BAD
                              return ["goto block_" & to_str(block_id) & "_end;"];
                            },

    call_proc()           = compile_call_proc_to_c(if instr.var? then just(instr.var) else nil, instr.name, instr.params, block_id),

    call_cls()            = mk_cls_call(instr.cls_var, instr.var, instr.params), //## INLINE THE FUNCTION

    push_call_info()      = { fn_name = [quote(fn_name_to_str(instr.fn_name))];
                              params = [if p == nil then :null_obj else value(p) : p <- instr.params];
                              return [mk_gen_call("push_call_info_wrapper", fn_name, params, [])];
                            },

    pop_call_info         = mk_call("pop_call_info", []),

    runtime_check()       = mk_call("runtime_check", [instr.cond]),

    branch()              = compile_branch_to_c(instr.cond, instr.when_true, instr.when_false, block_id),

    // symbol_switch()       = compile_symbol_switch_to_c(instr.val, instr.cases, if instr.else? then instr.else else [], block_id),

    cls_scope()           = { bound_cls = instr.bound_cls;
                              return match (bound_cls)
                                ClsVar      = {fail;}, //## THIS SHOULD NOT BE POSSIBLE FOR NOW
                                bound_cls() = compile_cls_scope_to_c(instr.var, bound_cls.cls, bound_cls.env, instr.body, block_id);
                              ;
                            };


  [String] compile_to_c(FloatExpr expr, ObjVar var):
    mk_float()            = [mk_gen_call(var, "make_float", [float_to_str(expr.mantissa, expr.dec_exp)], [], [])],
    neg_float()           = mk_call(var, "neg_float",     [expr.value]),
    add_floats()          = mk_call(var, "add_floats",    expr.values),
    sub_floats()          = mk_call(var, "sub_floats",    expr.values),
    mult_floats()         = mk_call(var, "mult_floats",   expr.values),
    div_floats()          = mk_call(var, "div_floats",    expr.values),
    square_root()         = mk_call(var, "square_root",   [expr.value]),
    floor_op()            = mk_call(var, "floor",         [expr.value]),
    ceiling_op()          = mk_call(var, "ceiling",       [expr.value]),
    int_to_float()        = mk_call(var, "int_to_float",  [expr.value]);


  [String] compile_to_c(RefObjExpr expr, ObjVar var):
    mk_set_from_stream()  = mk_call(var, "make_set",        [expr.stream]),
    mk_set()              = mk_call(var, "make_set",        [expr.elems, expr.size]),
    mk_seq_from_stream()  = mk_call(var, "make_seq",        [expr.stream]),
    mk_seq()              = mk_call(var, "make_seq",        [expr.elems, expr.size]),
    mk_map_from_streams() = mk_call(var, "make_map",        [expr.key_stream, expr.value_stream]),
    mk_map()              = mk_call(var, "make_map",        [expr.keys, expr.values, expr.size]),
    mk_tagged_obj()       = mk_call(var, "make_tagged_obj", [expr.tag, expr.obj]),
    mk_array()            = mk_call(var, "make_array",      [expr.size, expr.value]),
    get_seq_slice()       = mk_call(var, "get_seq_slice",   [expr.seq, expr.idx_first, expr.len]),
    append_to_seq()       = mk_call(var, "append_to_seq",   [expr.seq, expr.new_elem]),
    join_seqs()           = mk_call(var, "join_seqs",       [expr.left, expr.right]),
    join_mult_seqs()      = mk_call(var, "join_mult_seqs",  [expr.seqs]),
    rev_seq()             = mk_call(var, "rev_seq",         [expr.seq]),
    merge_sets()          = mk_call(var, "merge_sets",      [expr.sets]),
    merge_maps()          = mk_call(var, "merge_maps",      [expr.maps]),
    seq_to_set()          = mk_call(var, "seq_to_set",      [expr.seq]),
    seq_to_mset()         = mk_call(var, "seq_to_mset",     [expr.seq]),
    list_to_seq()         = mk_call(var, "list_to_seq",     [expr.list]),
    internal_sort()       = mk_call(var, "internal_sort",   [expr.set]),
    symb_to_str(e?)       = mk_call(var, "to_str",          [e]);


  ///////////////////////////////////////////////////////////////////////////////

  [String] compile_call_proc_to_c(Maybe[ObjVar] var, ObjFnName name, [<ObjExpr, BoundCls>] params, <Nat, nil> block_id)
  {
    pars_info = [gen_par_info(p) : p <- params];
    code_frags, args = unzip(pars_info);
    call_code = if var /= nil
      then mk_fn_call(value(var), to_c_fn_name(name), args)
      else mk_fn_call(to_c_fn_name(name), args);
    return join(code_frags) & call_code;


    ([String], FnCallParam) gen_par_info(ObjExpr p) = ([], p);

    ([String], FnCallParam) gen_par_info(BoundCls p):
      ClsVar      = ([], p),
      // fn_ref()    = {
      //   par_id = _counter_(nil);
      //   par_var = cls_var(par_id);
      //   par_name = to_c_expr(par_var);
      //   code = [
      //     "CLS" & to_str(p.arity) & " " & par_name & ";",
      //     par_name & ".fn_ptr = " & to_c_fn_name(p.name) & ";",
      //     par_name & ".data = 0;"
      //   ];
      //   return (code, par_var);
      // },
      bound_cls() = {
        //## BAD: THE FIRST LINES OF CODE ARE THE SAME AS ABOVE...
        par_id = _counter_(nil);
        par_var = cls_var(par_id);
        par_name = to_c_expr(par_var);
        code = [
          "CLS" & to_str(p.cls.arity) & " " & par_name & ";",
          par_name & ".fn_ptr = " & "cls_" & to_str(cls2id(p.cls)) & ";"
        ];
        if (p.env /= [])
          var_name = "cd_" & to_str(par_id);
          code = code & ["Obj " & var_name & "[" & to_str(length(p.env)) & "];"];
          for (v @ i : p.env)
            code = code & [var_name & "[" & to_str(i) & "] = " & to_c_expr(v) & ";"];
          ;
          code = code & [par_name & ".data = " & var_name & ";"];
        else
          code = code & [par_name & ".data = 0;"];
        ;
        return (code, par_var);
      };
  }


  [String] compile_branch_to_c(BoolExpr cond, [Instr] when_true, [Instr] when_false, <Nat, nil> block_id)
  {
    assert when_true /= [];
    code = ["if (" & to_c_expr(cond) & ")", "{"]     &
           indent(compile_to_c(when_true, block_id)) &
           ["}"];
    if (when_false /= [])
      code = code & ["else", "{"] & indent(compile_to_c(when_false, block_id)) & ["}"];
    ;
    return code;
  }


  //## HUGE BUG HERE: IF THE CODE IN ONE OF THE CASE STATEMENTS CONTAINS A BREAK
  //## THAT AFFECTS A LOOP THAT CONTAINS THE SWITCH STATEMENT, THEN THE BREAK WILL
  //## MISTAKINGLY TERMINATE THE SWITCH, NOT THE LOOP
  // [String] compile_symbol_switch_to_c(ObjExpr val, (vals: SymbObj+, instrs: [Instr])* cases, [Instr] default, <Nat, nil> block_id)
  // {
  //   code = ["switch (" & to_c_expr(val) & ")", "{"];
  //   for (c : rand_sort(cases))
  //     case_code = ["case S_" & _str_(_obj_(s)) & ":" : s <- rand_sort(c.vals)] & //## BAD
  //                  indent(compile_to_c(c.instrs, block_id) & ["break;"]);
  //     code = code & indent(case_code);
  //   ;
  //   if (default /= [])
  //     code = code & ["default:"] & indent(compile_to_c(default, block_id));
  //   ;
  //   return code & ["}"];
  // }


  [String] compile_cls_scope_to_c(NamedPar var, ClsDef cls, [Var] env, [Instr^] body, <Nat, nil> block_id)
  {
    scope_id = to_str(_counter_(nil));

    arity = cls.arity;
    env_size = length(env);

    var_str = _str_(_obj_(var)); //## BAD, DUPLICATED LOGIC
    arity_str = to_str(arity);
    env_size_str = to_str(env_size);

    fn_var = "env.n" & arity_str & "_" & var_str;  //## BAD, DUPLICATED LOGIC
    data_var = "env.C" & arity_str & "_" & var_str; //## BAD, DUPLICATED LOGIC
    fn_bk_var = "BF" & scope_id;
    data_bk_var = "BD" & scope_id;
    new_data_var = "ND" & scope_id;

    tmp = arity * ["Obj"] & ["const Obj *", "Env &"];
    tmp = intermix(tmp, ", ");
    tmp = append(tmp);

    code = [
      "Obj (*" & fn_bk_var & ")(" & tmp & ") = " & fn_var & ";",
      "const Obj *BD" & scope_id & " = " & data_var & ";"
    ];

    code = code & ["Obj " & new_data_var & "[" & env_size_str & "];"] if env_size > 0;

    //## HERE I'M ADDING THE add_ref/release PAIRS IN THE WRONG LAYERS
    for (i < env_size)
      code = code & [
        new_data_var & "[" & to_str(i) & "] = " & to_c_var_name(env[i]) & ";",
        "add_ref(" & new_data_var & "[" & to_str(i) & "]);"
      ];
    ;

    code = code & [
      fn_var & " = cls_" & to_str(cls2id(cls)) & ";",
      data_var & " = " & (if env_size > 0 then new_data_var else "0") & ";"
    ];

    code = code & compile_to_c(body, block_id);

    code = code & [
      fn_var & " = " & fn_bk_var & ";",
      data_var & " = " & data_bk_var & ";"
    ];

    for (i < env_size)
      code = code & ["release(" & new_data_var & "[" & to_str(i) & "]);"];
    ;

    code = ["{"] & indent(code) & ["}"];

    return code;
  }

  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  String mk_gen_call(String fn_name, [String] leading_params, [FnCallParam] params, [String] trailing_params) =
    fn_name & "(" & append(intermix(leading_params & [to_c_expr(p) : p <- params] & trailing_params, ", ")) & ");";

  String mk_gen_call(AnyVar var, String fn_name, [String] leading_params, [FnCallParam] params, [String] trailing_params) =
    to_c_var_name(var) & " = " & mk_gen_call(fn_name, leading_params, params, trailing_params);

  [String] mk_call(String fn_name, [FnCallParam] params)             = [mk_gen_call(fn_name, [], params, [])];
  [String] mk_call(AnyVar var, String fn_name, [FnCallParam] params) = [mk_gen_call(var, fn_name, [], params, [])];

  [String] mk_fn_call(String fn_name, [FnCallParam] params)             = [mk_gen_call(fn_name, [], params, ["env"])];
  [String] mk_fn_call(AnyVar var, String fn_name, [FnCallParam] params) = [mk_gen_call(var, fn_name, [], params, ["env"])];

  //## AnyVar IS WRONG HERE, SHOULD ONLY BE OBJ/BOOL/INT VARS
  [String] mk_assignment(AnyVar var, AnyTypeExpr value) = [to_c_var_name(var) & " = " & to_c_expr(value) & ";"];


  [String] mk_cls_call(<ClsVar, NamedPar> cls_var, ObjVar var, [ObjExpr] params):
    cls_var(+ symb?) = { //## NO NEED FOR NOW TO HANDLE THE CASE cls_var(Nat), AS THOSE VARIABLES ARE NEVER "CALLED", ONLY PASSED ON
      name = "c_" & _str_(symb);
      return [mk_gen_call(var, name & ".fn_ptr", [], params, [name & ".data", "env"])];
    },
    named_par(symb?) = {
      name = to_str(length(params)) & "_" & _str_(_obj_(cls_var));
      return [mk_gen_call(var, "env.n" & name, [], params, ["env.C" & name, "env"])];
    };
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

using String typesymb2name(TypeSymbol)
{
  //## IT WOULD MUCH BETTER IF WE COULD USE mk_call HERE...
  String to_c_expr(ObjExpr expr):
    object(Atom a?)     = "S_" & _str_(a),
    object(Int n?)      = "to_obj(" & to_str(n) & ")",
    empty_set           = "empty_set",
    empty_seq           = "empty_seq",
    empty_map           = "empty_map",
    ObjVar              = to_c_var_name(expr),
    at()                = "at("         & to_c_expr(expr.seq) & ", " & to_c_expr(expr.idx) & ")",
    get_tag(e?)         = "get_tag("        & to_c_expr(e)     & ")",
    get_inner_obj(e?)   = "get_inner_obj("  & to_c_expr(e)     & ")",
    to_obj(e?)          = "to_obj("         & to_c_expr(e)     & ")",
    obj_neg(e?)         = "obj_neg("        & to_c_expr(e)     & ")",
    to_symb(e?)         = "to_symb("        & to_c_expr(e)     & ")",
    get_curr_obj(v?)    = "get_curr_obj("   & to_c_var_name(v) & ")",
    get_curr_key(v?)    = "get_curr_key("   & to_c_var_name(v) & ")",
    get_curr_value(v?)  = "get_curr_value(" & to_c_var_name(v) & ")",
    rand_elem(e?)       = "rand_set_elem("  & to_c_expr(e)     & ")";


  String to_c_expr(ObjExpr expr, Bool) = to_c_expr(expr);


  String to_c_expr(BoolExpr expr) = to_c_expr(expr, false);

  String to_c_expr(BoolExpr expr, Bool parentesised):
    true                  = "true",
    false                 = "false",
    BoolVar               = to_c_var_name(expr),
    is_symb(e?)           = "is_symb("    & to_c_expr(e) & ")",
    is_int(e?)            = "is_int("     & to_c_expr(e) & ")",
    is_float(e?)          = "is_float("   & to_c_expr(e) & ")",
    is_ne_set(e?)         = "is_ne_set("  & to_c_expr(e) & ")",
    is_ne_seq(e?)         = "is_ne_seq("  & to_c_expr(e) & ")",
    is_ne_map(e?)         = "is_ne_map("  & to_c_expr(e) & ")",
    is_tagged_obj(e?)     = "is_tag_obj(" & to_c_expr(e) & ")",

    has_elem()            = "has_elem(" & to_c_expr(expr.set) & ", " & to_c_expr(expr.elem) & ")",

    is_eq_bool()          = to_nary_op(" == ", [expr.expr1, expr.expr2], parentesised), //## BAD
    is_eq_int()           = to_nary_op(" == ", [expr.expr1, expr.expr2], parentesised), //## BAD

    is_eq()               = "are_eq(" & to_c_expr(expr.expr1) & ", " & to_c_expr(expr.expr2) & ")",

    //## BUG BUG BUG HUGE BUG HERE, NOT CHECKING THAT THE OPERANDS ARE INTEGERS
    is_gt()               = to_nary_op(" > ",  [expr.expr1, expr.expr2], parentesised), //## BAD
    is_ge()               = to_nary_op(" >= ", [expr.expr1, expr.expr2], parentesised), //## BAD
    is_lt()               = to_nary_op(" < ",  [expr.expr1, expr.expr2], parentesised), //## BAD
    is_le()               = to_nary_op(" <= ", [expr.expr1, expr.expr2], parentesised), //## BAD

    inline_is_eq()        = "inline_eq(" & to_c_expr(expr.expr) & ", " & to_c_expr(expr.value) & ")",

    is_out_of_range(v?)   = "is_out_of_range(" & to_c_var_name(v) & ")",

    neg(e?)               = { s = "!" & to_c_expr(e, true);
                              s = "(" & s & ")" if parentesised;
                              return s;
                            },

    and(es?)              = to_nary_op(" & ",  es, parentesised),
    or(es?)               = to_nary_op(" | ",  es, parentesised),
    and_then(es?)         = to_nary_op(" && ", es, parentesised),
    or_else(es?)          = to_nary_op(" || ", es, parentesised),

    eval_bool_fn()        = to_c_fn_name(expr.name) & "(" & to_nary_op(", ", expr.params, false) & ")";


  String to_c_expr(IntExpr expr) = to_c_expr(expr, false);

  String to_c_expr(IntExpr expr, Bool parentesised):
    Int               = to_str(expr),
    IntVar            = to_c_var_name(expr),
    get_int_val(e?)   = "get_int_val("  & to_c_expr(e) & ")",
    get_set_size(e?)  = "get_set_size(" & to_c_expr(e) & ")",
    get_seq_len(e?)   = "get_seq_len("  & to_c_expr(e) & ")",
    get_map_size(e?)  = "get_map_size(" & to_c_expr(e) & ")",
    minus(e?)         = "-" & to_c_expr(e, true),
    add()             = to_nary_op(" + ", [expr.val1, expr.val2], parentesised),
    sub()             = to_nary_op(" - ", [expr.val1, expr.val2], parentesised),
    mult()            = to_nary_op(" * ", [expr.val1, expr.val2], parentesised),
    div()             = to_nary_op(" / ", [expr.val1, expr.val2], parentesised),
    mod()             = to_nary_op(" % ", [expr.val1, expr.val2], parentesised),
    mantissa(e?)      = "mantissa(" & to_c_expr(e) & ")",
    dec_exp(e?)       = "dec_exp(" & to_c_expr(e) & ")",
    rand_nat(e?)      = "rand_nat(" & to_c_expr(e) & ")",
    unique_nat        = "unique_nat()",
    ticks             = "get_tick_count()";


  String to_c_expr(<ElemVar, VecVar, ItVar, StreamVar> var) = to_c_var_name(var);

  String to_c_expr(<null_obj>) = "null_obj";

  String to_c_expr(ClsVar v) = to_c_var_name(v);

  String to_nary_op(String op, [AnyTypeExpr^] exprs, Bool parentesised)
  {
    expr = append(intermix([to_c_expr(e, true) : e <- exprs], op));
    expr = "(" & expr & ")" if length(exprs) > 1 and parentesised;
    return expr;
  }

  String to_c_var_name(ObjVar v):
    var(Atom a?)          = "v_"  & _str_(a),
    fn_par(Nat n?)        = "p"   & to_str(n),
    named_par(Atom a?)    = "env.n_"  & _str_(a),
    unique_var(Nat n?)    = "u"   & to_str(n),
    cls_ext_par(Nat n?)   = "C["  & to_str(n) & "]",
    lvar(Nat n?)          = "l"   & to_str(n),
    evar()                = "V" & to_str(v.id) & "[" & to_c_expr(v.idx) & "]";

  String to_c_var_name(ClsVar v):
    cls_var(+ a?)  = "c_" & _str_(a),
    cls_var(* n?)  = "c_" & to_str(n);
    // cls_var(+)  = "c_" & _str_(_obj_(v)),
    // cls_var(*)  = "c_" & to_str(_obj_(v));

  // String to_c_var_name(ClsVar v) = "c_" & _str_(_obj_(v));

  //## USE AnyVar?
  String to_c_var_name(VecVar v)    = "V" & to_str(v.id);
  String to_c_var_name(BoolVar v)   = "b" & to_str(_obj_(v));
  String to_c_var_name(IntVar v)    = "i" & to_str(_obj_(v));
  String to_c_var_name(SetItVar v)  = "s" & to_str(_obj_(v));
  String to_c_var_name(SeqItVar v)  = "q" & to_str(_obj_(v));
  String to_c_var_name(MapItVar v)  = "m" & to_str(_obj_(v));
  String to_c_var_name(StreamVar v) = "t" & to_str(_obj_(v));

  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  //String to_c_imp_var_name(FnSymbol fn_symb, Nat arity) = "imp_" & to_c_fn_name(fn_symb, arity);
  //String to_c_env_var_name(FnSymbol fn_symb, Nat arity) = "env_" & to_c_fn_name(fn_symb, arity);
  //String to_c_imp_var_name(FnSymbol fn_symb, Nat arity) = "imp_" & to_c_fn_name(fn_symb, arity);
  //String to_c_env_var_name(FnSymbol fn_symb, Nat arity) = "env_" & to_c_fn_name(fn_symb, arity);

  //String to_c_imp_bkp_var_name(FnSymbol fn_symb, Nat arity, Nat id) = "bkp_imp_" & to_c_fn_name(fn_symb, arity, id);
  //String to_c_env_bkp_var_name(FnSymbol fn_symb, Nat arity, Nat id) = "bkp_env_" & to_c_fn_name(fn_symb, arity, id);

  //String to_c_cls_name(FnSymbol fn_symb, Nat arity, Nat id) = "cls_" & to_c_fn_name(fn_symb, arity, id);

  String to_c_fn_name(FnSymbol fn_symb, Nat arity, Nat id) = to_c_fn_name(fn_symb, arity) & "__" & to_str(id);
  String to_c_fn_name(FnSymbol fn_symb, Nat arity)         = to_c_fn_name(fn_symb) & "__" & to_str(arity);

  //String to_c_fn_name(ObjFnName name) = to_c_fn_name(_obj_(name));
  String to_c_fn_name(FnSymbol fn_symb):
    fn_symbol(symb?)    = capitalize(_str_(symb), true),
    op_symbol(op?)      = _str_(op),
    nested_fn_symbol()  = to_c_fn_name(fn_symb.outer) & "__" & to_c_fn_name(fn_symb.inner),
    unique_fn_symbol()  = to_c_fn_name(fn_symb.symbol) & "__" & to_str(fn_symb.id); //## IS THIS ENOUGHT TO AVOID CONFLICTS?

  String to_c_fn_name(BoolFnName): memb_test(ts?)   = "is_" & typesymb2name(ts); //## UGLY UGLY UGLY

  String to_c_fn_name(ProcSymbol): proc_symbol(s?)  = "io_" & capitalize(_str_(s), true); //## UGLY UGLY UGLY

  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  String fn_name_to_str(FnSymbol fn_symb):
    fn_symbol(symb?)    = _str_(symb),
    op_symbol(op?)      = _str_(op),
    //## BUG: THIS DOESN'T SPECIFY WHICH OF THE OUTER FUNCTIONS
    //## WITH THE SAME NAME THE NESTED FUNCTION BELONGS TO
    nested_fn_symbol()  = fn_name_to_str(fn_symb.outer) & ":" & fn_name_to_str(fn_symb.inner),
    unique_fn_symbol()  = fn_name_to_str(fn_symb.symbol); //## BAD: THE DISPATCH FUNCTION WILL APPEAR ON THE STACK, AND IT WILL BE INDISTINGUISHABLE FROM ONE OF THE REAL FUNCTIONS

  String fn_name_to_str(ProcSymbol proc_symbol): proc_symbol(s?) = capitalize(_str_(s), false); //## UGLY UGLY UGLY
}

///////////////////////////////////////////////////////////////////////////////

[String] indent([String] strs) = [indent_line(s) : s <- strs];

String indent_line(String str) = "  " & str;


String capitalize(String s, Bool keep_underscores)
{
  first = true;
  res = [];
  for (ch @ i : _obj_(s))
    if (ch == ascii_underscore)
      first = true;
    else
      ch  = nat(ch - ascii_lower_a + ascii_upper_a) if ch >= ascii_lower_a and ch <= ascii_lower_z and first; //## CREATE PRELUDE FUNCTION is_lower()/is_upper() AND to_lower()/to_upper()
      first = false;
    ;
    res = res & [ch if ch /= ascii_underscore or keep_underscores];
  ;
  return string(res);
}

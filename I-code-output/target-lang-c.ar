type CCodeOutput = (body: [String], header: [String]);

CCodeOutput compile_to_c(CompiledPrg prg)
{
  ptss = par_type_symbols(prg);

  symbs = used_symbols(prg);

  symb_decls = ["const Obj " & to_c_expr(s, typesymb2name(ts) = typesymb2str(ts, ptss)) & " = symb(" & to_str(i) & ");" : s @ i <- symbs] & 4 * [""];
  symb_decls = symb_decls & ["const int EMB_SYMB_COUNT = " & to_text(length(symbs)) & ";"] & 4 * [""];

  c_code = symb_decls;

  if (symbs != [])
    symb_strs  = ["  \"" & _str_(_obj_(s)) & "\"," : s <- symbs];
    c_code     = c_code & ["const char *map_symb_to_str[EMB_SYMB_COUNT] = {"] & symb_strs & ["};"] & 4 * [""];
    symb_decls = symb_decls & ["extern const char *map_symb_to_str[EMB_SYMB_COUNT];"] & 4 * [""];
  ;

  // print "Symbol declarations generated";

  cls_defs = cls_defs(prg);

  all_named_args = merge_values(set([p.named_args : p <- rand_sort(prg.procs)]));
  all_param_arity_pairs = rand_sort({(var: v, arity: a) : ars @ v <- all_named_args, a <- ars});

  env_decl = ["struct Env {"];

  for (na @ i : all_param_arity_pairs)
    var   = na.var;
    arity = na.arity;

    name = _str_(_obj_(var));

    if (arity > 0)
      ls = [ "  Obj (*n" & to_str(arity) & "_" & name & ")(" & append(["Obj p" & to_str(j) & ", " : j < na.arity]) & "const Obj *C, Env &env);",
              "  const Obj *C" & to_str(arity) & "_" & name & ";"
            ];
    else
      ls = ["  Obj n_" & name & ";"];
    ;

    ls = [""] & ls if i > 0;
    env_decl = env_decl & ls;
  ;

  env_decl = env_decl & ["};"] & 4 * [""];

  c_code = c_code & env_decl;

  all_cls_arities = {p.arity : pd <- prg.procs, p <- set(pd.params), p != :obj}; //## MAYBE HERE IT WOULD BE BETTER TO DO A NORMAL SORT

  cls_obj_typedefs = join(intermix([generate_cls_obj_typedef(a) : a <- rand_sort(all_cls_arities)], 2 * [""])) & 4 * [""];
  c_code = c_code & cls_obj_typedefs;

  all_fn_arities = set([in_arity(d) : d <- rand_sort(prg.procs)]);
  c_code = c_code & join(intermix([generate_push_call_info_wrapper(a) : a <- rand_sort(all_fn_arities)], 2 * [""])) & 4 * [""];

  sorted_cls_defs = rand_sort(cls_defs);

  proc_code = compile_to_c(
    rand_sort(prg.procs),
    rand_sort(prg.bool_procs),
    sorted_cls_defs,
    rand_sort(prg.blocks),
    typesymb2name(ts) = typesymb2str(ts, ptss),
    cls2id(cls)       = index_first(cls, sorted_cls_defs)
  );

  body = [
    "#include \"lib.h\"\n\n",
    "#include \"iolib.h\"\n\n",
    "",
    "namespace generated",
    "{"
  ] & indent_lines(c_code & proc_code.body) & ["}"];

  header = ["namespace generated", "{"] & indent_lines(symb_decls & env_decl & cls_obj_typedefs & proc_code.header) & ["}"];

  return (body: body, header: header);


  [String] generate_cls_obj_typedef(NzNat arity) = [
    "struct CLS" & to_str(arity) & " {",
    "  Obj (*fn_ptr)(" & append(arity * ["Obj"], ", ") & ", const Obj *, Env &env);",
    "  const Obj *data;",
    "};"
  ];

  String typesymb2str(TypeSymbol ts, [ParTypeSymbol] par_types):
    type_symbol(a?)     = upper_camel_case(a),
    par_type_symbol()   = typesymb2str(ts.symbol, par_types) & "_" & to_str(index_first(ts, par_types));
}


[String^] generate_push_call_info_wrapper(Nat arity)
{
  signature = "void push_call_info_wrapper(const char *fn_name" & append([", Obj p" & to_str(i) : i < arity]) & ")";
  code = [signature, "{", "#ifndef NDEBUG"];
  if (arity == 0)
    code = code & ["  push_call_info(fn_name, 0, (Obj *)0);"];
  else
    code = code & ["  Obj *params = new_obj_array(" & to_str(arity) & ");"];
    for (i < arity)
      code = code & ["  params[" & to_str(i) & "] = p" & to_str(i) & ";"];
    ;
    code = code & ["  push_call_info(fn_name, " & to_str(arity) & ", params);"];
  ;
  return nonempty(code & ["#endif", "}"]);
}


//## THIS SHOULD NOT GO HERE
type FnCallParam = null_obj, ObjExpr, ElemVar, MembObjVar, VecVar, BoolExpr, IntExpr, ItVar, StreamVar, ClsVar;


using String typesymb2name(TypeSymbol), Nat cls2id(ClsDef)
{
  CCodeOutput compile_block_to_c(Block block)
  {
    name_str = to_c_name(block.name);

    vars_decl = [var_c_type(v) & " " & to_c_var_name(v, true) & ";" : v <- rand_sort(block.memb_vars)];

    decl = ["struct " & name_str, "{"] & indent_lines(vars_decl) & ["};"];

    init_vars_decl = gen_vars_decls(block.init_code);
    init_vars_decl = init_vars_decl & [""] if init_vars_decl != [];
    init_body = init_vars_decl & compile_to_c(block.init_code, nil);
    init_sgn = "void " & init_method_name(block.name) & "(" & name_str & " *self, Env &env)";
    init_decl = [init_sgn & ";"];
    init_proc = [init_sgn, "{"] & indent_lines(init_body) & ["}"];

    cleanup_body = compile_to_c(block.cleanup_code, nil);
    cleanup_sgn = "void " & cleanup_method_name(block.name) & "(" & name_str & " *self)";
    cleanup_decl = [cleanup_sgn & ";"];
    cleanup_proc = [cleanup_sgn, "{"] & indent_lines(cleanup_body) & ["}"];

    update_body = gen_vars_decls(block.update_code) & [""] & compile_to_c(block.update_code, nil);
    update_sgn = "void " & update_method_name(block.name) & "(" & name_str & " *self, Env &env)";
    update_decl = [update_sgn & ";"];
    update_proc = [update_sgn, "{"] & indent_lines(update_body) & ["}"];

    queue_methods_decls_and_impls = {gen_queue_update_method(block.name, id, body) : body @ id <- block.queue_update_code};
    queue_methods_decls, queue_methods_impls = unzip(rand_sort(queue_methods_decls_and_impls));
    queue_methods_impls = join(intermix(queue_methods_impls, ["", ""]));

    input_decls, input_impls = unzip([gen_input_setter(block.name, id, i) : id @ i <- block.inputs]);
    input_impls = join(intermix(input_impls, ["", ""]));

    output_decls, output_impls = unzip([gen_output_getter(block.name, o) : o <- rand_sort(block.outputs)]);
    output_impls = join(intermix(output_impls, ["", ""]));

    header = join(intermix([decl, init_decl, update_decl, cleanup_decl, input_decls, output_decls, queue_methods_decls], ["", ""]));

    body = join(intermix([init_proc, update_proc, cleanup_proc, input_impls, output_impls, queue_methods_impls], ["", ""]));

    return (body: body, header: header);


    (String, [String]) gen_input_setter(AutoSymbol block_name, Atom input_name, Nat node_idx)
    {
      sgn = "void " & input_set_method_name(block_name, input_name) & "(" & to_c_name(block_name) & " *self, Obj new_val)";
      new_input_var_str = to_c_var_name(new_input(input_name));
      marked_for_update_var = to_c_var_name(marked_for_update_var(input_name));
      body = [
        sgn,
        "{",
        "  if (" & marked_for_update_var & ")",
        "  {",
        // "    internal_fail_if(" & new_input_var_str & " == null_obj);",
        "    release(" & new_input_var_str & ");",
        "    " & new_input_var_str & " = new_val;",
        "  }",
        "  else",
        "  {",
        // "    internal_fail_if(" & new_input_var_str & " != null_obj);",
        "    " & new_input_var_str & " = new_val;",
        "    int idx = self->update_count_0;",
        "    self->nodes_to_update_0[idx] = " & to_str(node_idx) & ";",
        "    self->update_count_0 = idx + 1;",
        "    " & marked_for_update_var & " = true;",
        "  }",
        "}"
      ];
      return (sgn & ";", body);
    }


    (String, [String]) gen_output_getter(AutoSymbol block_name, Atom output_name)
    {
      sgn = "Obj " & output_get_method_name(block_name, output_name) & "(" & to_c_name(block_name) & " *self)";
      body = [
        sgn,
        "{",
        "  Obj value = " & to_c_var_name(memb_var(output_name)) & ";",
        "  add_ref(value);",
        "  return value;",
        "}"
      ];
      return (sgn & ";", body);
    }


    (String, [String]) gen_queue_update_method(AutoSymbol block_name, Atom memb_id, [Instr] body)
    {
      method_name = queue_update_method_name(memb_id, block_name);
      sgn = "void " & method_name & "(" & to_c_name(block_name) & " *self)";
      body_text = gen_vars_decls(body) & [""] & compile_to_c(body, nil);
      return (sgn & ";", [sgn, "{"] & indent_lines(body_text) & ["}"]);
    }


    (String, [String]) gen_queue_update_method(AutoSymbol block_name, Nat cond_id, [Instr] body)
    {
      method_name = queue_update_method_name(cond_id, block_name);
      inval_cache_var_name = to_c_var_name(invalidate_cond_expr_cache);
      sgn = "void " & method_name & "(" & to_c_name(block_name) & " *self, bool " & inval_cache_var_name & ")";
      body_text = gen_vars_decls(body) & [""] & compile_to_c(body, nil);
      return (sgn & ";", [sgn, "{"] & indent_lines(body_text) & ["}"]);
    }
  }

  CCodeOutput compile_to_c([ObjProcDef] obj_proc_defs, [BoolProcDef] bool_proc_defs, [ClsDef] cls_defs, [Block] blocks)
  {
    type_checking_fn_decls = [gen_c_decl(pd) : pd <- bool_proc_defs] & 4 * [""];
    // print "Type checking function declarations generated";

    closure_decls = [gen_c_decl(d, i) : d @ i <- cls_defs] & 4 * [""];
    // print "Closure declarations generated";

    fn_decls = [gen_c_decl(pd) : pd <- obj_proc_defs] & 4 * [""];
    // print "Function declarations generated";

    type_checking_fns = join([compile_to_c(d) & ["", ""] : d <- bool_proc_defs]) & 4 * [""];
    // print "Type checking functions generated";

    closures = join([compile_to_c(d, i) & ["", ""] : d @ i <- cls_defs]) & 4 * [""];
    // print "Closures generated";

    functions = join([compile_to_c(d) & ["", ""] : d <- obj_proc_defs]);
    // print "Functions generated";

    blocks_code = [compile_block_to_c(b) : b <- blocks];
    blocks_decls = join([b.header & ["", ""] : b <- blocks_code]);
    blocks_bodies = join(intermix([b.body : b <- blocks_code], ["", ""]));

    body = join([type_checking_fn_decls, closure_decls, fn_decls, blocks_decls, type_checking_fns, closures, functions, blocks_bodies]);

    return (body: body, header: fn_decls & ["", ""] & blocks_decls);
  }


  String gen_c_decl(ObjProcDef pd)
  {
    par_types = [if p == :obj then "Obj" else "CLS" & to_str(p.arity) & " &" : p <- pd.params];
    par_list = append(par_types & ["Env &"], ", ");
    return "Obj " & to_c_fn_name(pd.name, in_arity(pd)) & "(" & par_list & ");";
  }


  String gen_c_decl(BoolProcDef pd)
  {
    par_list = append(pd.arity * ["Obj"], ", ");
    return "bool " & to_c_fn_name(pd.name) & "(" & par_list & ");";
  }


  String gen_c_decl(ClsDef cd, Nat id)
  {
    par_list = append(cd.arity * ["Obj"] & ["const Obj *", "Env &"], ", ");
    return "Obj cls_" & to_str(id) & "(" & par_list & ");";
  }


  [String] compile_to_c(ProcDef pd)
  {
    cached = pd.cached? and pd.cached;

    fn_name = to_c_fn_name(pd.name, in_arity(pd));

    suffix = if cached then "__CALCULATE_CONSTANT" else "";

    par_list = gen_fn_pars(pd);
    par_list_str = append(par_list, ", ");

    signature = ret_type_str(pd) & fn_name & suffix & "(" & par_list_str & ")";

    body = pd.body;
    auto_vars_types = auto_vars_to_decl_and_init(body);

    var_decls = gen_vars_decls(body);

    auto_vars = rand_sort(keys(auto_vars_types));
    auto_var_decls = [to_c_name(auto_vars_types[v]) & " " & to_c_var_name(v) & ";" : v <- auto_vars];
    auto_vars_init = [init_method_name(auto_vars_types[v]) & "(&" & to_c_var_name(v) & ", env);" : v <- auto_vars];
    auto_vars_cleanup = [cleanup_method_name(auto_vars_types[v]) & "(&" & to_c_var_name(v) & ");" : v <- auto_vars];

    comp_body = compile_to_c(body, nil);

    code = [signature, "{"] & indent_lines(var_decls) & indent_lines(auto_var_decls) & [""] &
           //## HERE I SPLIT THE RETURN STATEMENT AT THE END FROM THE REST OF THE BODY
           //## IT WORKS, BUT IT'S VERY HACKY. JUST REMOVE THE RETURN STATEMENT FROM
           //## THE LEVEL 3 AST, CREATE A SPECIAL VARIABLE TO HOLD THE RETURN VALUE,
           //## AND JUST GENERATE THE RETURN STATEMENT HERE.
           indent_lines(auto_vars_init) & [""] & indent_lines(subseq(comp_body, 0, nil, 1)) &
           [""] & indent_lines(auto_vars_cleanup) & [""] & indent_lines(subseq(comp_body, nil, 1, 0)) & ["}"];

    if (cached)
      wrapper_code = [
        "",
        "",
        ret_type_str(pd) & fn_name & "(" & par_list_str & ")",
        "{",
        "  static Obj cached_res = null_obj;",
        "  if (cached_res == null_obj)",
        "  {",
        "    cached_res = " & fn_name & suffix & "(env);",
        "    add_obj_to_cache(cached_res);",
        "  }",
        "  add_ref(cached_res);",
        "  return cached_res;",
        "}"
      ];
      code = code & wrapper_code;
    ;

    return code;


    Nat arity(ProcDef pd):
      obj_proc_def()    = in_arity(pd),
      bool_proc_def()   = pd.arity;

    String ret_type_str(ProcDef):
      obj_proc_def()    = "Obj ",
      bool_proc_def()   = "bool ";

    String gen_fn_par(ObjProcPar par, Nat pos):
      obj   = "Obj p" & to_str(pos),
      cls() = "CLS" & to_str(par.arity) & " &" & to_c_var_name(if par.name? then par.name else cls_var(pos));

    [String] gen_fn_pars(ProcDef pd):
      ObjProcDef  = [gen_fn_par(p, i) : p @ i <- pd.params] & ["Env &env"],
      BoolProcDef = ["Obj p" & to_str(n) : n < arity(pd)];
  }


  [String] gen_vars_decls([Instr] body)
  {
    vars_to_decl = vars_to_declare(body);

    vector_vars = {v : v <- vars_to_decl, v :: VecVar};
    scalar_vars = vars_to_decl - vector_vars;

    vec_var_ids  = {v.id : v <- vector_vars};
    new_vec_vars = {vvar(id, nz_nat(max({v.size : v <- vector_vars, v.id == id}))) : id <- vec_var_ids};

    vars_to_decl = scalar_vars & new_vec_vars;
    return [var_decl(v) : v <- rand_sort(vars_to_decl)];
  }


  //## DUPLICATED CODE
  [String] compile_to_c(ClsDef cd, Nat id)
  {
    par_list  = ["Obj p" & to_str(n) : n < cd.arity] & ["const Obj C[]", "Env &env"]; //## BAD
    signature = "Obj cls_" & to_str(id) & "(" & append(par_list, ", ") & ")";

    vars_decls = gen_vars_decls(cd.body);
    comp_body = compile_to_c(cd.body, nil);

    return [signature, "{"] & indent_lines(vars_decls) & [""] & indent_lines(comp_body) & ["}"];
  }


  String var_decl(AnyVar v):
    ObjVar    = "Obj "      & to_c_var_name(v) & ";",
    VecVar    = "Obj "      & to_c_var_name(v) & "[" & to_str(v.size) & "];",
    BoolVar   = "bool "     & to_c_var_name(v) & ";",
    IntVar    = "int "      & to_c_var_name(v) & ";",
    SetItVar  = "SetIter "  & to_c_var_name(v) & ";",
    SeqItVar  = "SeqIter "  & to_c_var_name(v) & ";",
    MapItVar  = "MapIter "  & to_c_var_name(v) & ";",
    StreamVar = "Stream "   & to_c_var_name(v) & ";";


  [String] compile_to_c([Instr] instrs, <Nat, nil> block_id) = join([compile_to_c(instr, block_id) : instr <- instrs]);

  [String] compile_to_c(Instr instr, <Nat, nil> block_id):

    init_stream(v?)       = mk_call("init", [v]),
    append()              = mk_call("append", [instr.stream, instr.obj]),

    // get_at()              = mk_call(instr.var, "get_at", [instr.seq, instr.idx]),

    set_at()              = mk_call("set_at", [instr.var, instr.idx, instr.value]),

    lookup()              = mk_call(
                              instr.var,
                              "lookup",
                              [instr.map, instr.key, instr.success_var if instr.success_var?]
                            ),

    //## BAD BAD IT'S ALMOST THE SAME AS THE EXPRESSION ABOVE
    ext_lookup()          = mk_call(
                              instr.var,
                              "ext_lookup",
                              [instr.map, instr.key, instr.success_var if instr.success_var?]
                            ),

    get_set_iter()        = mk_call("get_set_iter", [instr.var, instr.src]),
    get_seq_iter()        = mk_call("get_seq_iter", [instr.var, instr.src]),
    get_map_iter()        = mk_call("get_map_iter", [instr.var, instr.src]),

    move_forward(v?)      = mk_call("move_forward", [v]),

    set_var()             = mk_assignment(instr.var, instr.value),
    set_bvar()            = mk_assignment(instr.var, instr.value), //## BAD
    set_ivar()            = mk_assignment(instr.var, instr.value), //## BAD

    set_rc_var()          = compile_to_c(instr.value, instr.var),

    init_memb_var(v?)     = [to_c_var_name(v) & " = blank_obj;"],

    clear_memb_var(v?)    = [to_c_var_name(v) & " = null_obj;"],
    clear_loc_var(v?)     = [to_c_var_name(v) & " = null_obj;"],

    terminate             = ["fail();"],

    add_ref(v?)           = mk_call("add_ref", [v]),
    release(v?)           = mk_call("release", [v]),

    print_obj()           = mk_call("print", [instr.obj]),

    ret_val(e?)           = ["return " & to_c_expr(e) & ";"],

    no_op                 = [],

    repeat(body?)         = ["for ( ; ; )", "{"] & indent_lines(compile_to_c(body, block_id)) & ["}"],

    break_loop            = ["break;"],


    execute_block(body?)  = { new_block_id = _counter_(nil);
                              body_code = compile_to_c(body, new_block_id);
                              label = ["block_" & to_str(new_block_id) & "_end:;"];
                              return body_code & label;
                            },

    exit_block            = { fail if block_id == nil; //assert block_id != nil; //## BAD
                              return ["goto block_" & to_str(block_id) & "_end;"];
                            },

                            //## BUG BUG BUG: IF THERE IS INSIDE ONE OF THE CASES A BREAK STATEMENT MEANT TO TERMIMATE
                            //## AN OUTER LOOP, THAT BREAK WILL TERMINATE THE SWITCH/CASE INSTEAD.
    switch_on_nat()       = { cases_code = [
                                ["case " & to_str(i) & ":"] & indent_lines([compile_to_c(c, block_id) | "break;"] & [""])
                                : c @ i <- instr.cases
                              ];
                              return ["switch (" & to_c_expr(instr.value) & ")", "{"] & indent_lines(join(cases_code)) & ["}"];
                            },

    call_proc()           = compile_call_proc_to_c(if instr.var? then just(instr.var) else nil, instr.name, instr.params, block_id),

    call_cls()            = mk_cls_call(instr.cls_var, instr.var, instr.params), //## INLINE THE FUNCTION

    push_call_info()      = { fn_name = [quote(fn_name_to_str(instr.fn_name))];
                              params = [if p == nil then :null_obj else value(p) : p <- instr.params];
                              return [mk_gen_call("push_call_info_wrapper", fn_name, params, [])];
                            },

    pop_call_info         = mk_call("pop_call_info", []),

    runtime_check()       = compile_runtime_check_to_c(instr.cond, instr.file, instr.line, instr.text, instr.vars),

    branch()              = compile_branch_to_c(instr.cond, instr.when_true, instr.when_false, block_id),

    // symbol_switch()       = compile_symbol_switch_to_c(instr.val, instr.cases, if instr.else? then instr.else else [], block_id),

    cls_scope()           = { bound_cls = instr.bound_cls;
                              return match (bound_cls)
                                ClsVar      = {fail;}, //## THIS SHOULD NOT BE POSSIBLE FOR NOW
                                bound_cls() = compile_cls_scope_to_c(instr.var, bound_cls.cls, bound_cls.env, instr.body, block_id);
                            },

    queue_update()        = [queue_update_method_name(instr.id, instr.type) & "(self);"],

    queue_cond_update()   = [queue_update_method_name(instr.id, instr.type) & "(self, " & to_c_expr(instr.inval_cache) & ");"],

    set_input()           = [input_set_method_name(instr.type, instr.input) & "(&" & to_c_var_name(instr.var) & ", " & to_c_expr(instr.value) & ");"],

    update_inputs()       = [update_method_name(instr.type) & "(&" & to_c_var_name(instr.var) & ", env);"];




  [String] compile_to_c(FloatExpr expr, ObjVar var):
    mk_float()            = [mk_gen_call(var, "make_float", [float_to_str(expr.mantissa, expr.dec_exp)], [], [])],
    neg_float()           = mk_call(var, "neg_float",     [expr.value]),
    add_floats()          = mk_call(var, "add_floats",    expr.values),
    sub_floats()          = mk_call(var, "sub_floats",    expr.values),
    mult_floats()         = mk_call(var, "mult_floats",   expr.values),
    div_floats()          = mk_call(var, "div_floats",    expr.values),
    square_root()         = mk_call(var, "square_root",   [expr.value]),
    floor_op()            = mk_call(var, "floor",         [expr.value]),
    ceiling_op()          = mk_call(var, "ceiling",       [expr.value]),
    int_to_float()        = mk_call(var, "int_to_float",  [expr.value]);


  [String] compile_to_c(RefObjExpr expr, ObjVar var):
    mk_set_from_stream()  = mk_call(var, "make_set",            [expr.stream]),
    mk_set()              = mk_call(var, "make_set",            [expr.elems, expr.size]),
    mk_seq_from_stream()  = mk_call(var, "make_seq",            [expr.stream]),
    mk_seq()              = mk_call(var, "make_seq",            [expr.elems, expr.size]),
    mk_map_from_streams() = mk_call(var, "make_map",            [expr.key_stream, expr.value_stream]),
    mk_map()              = mk_call(var, "make_map",            [expr.keys, expr.values, expr.size]),
    mk_tagged_obj()       = mk_call(var, "make_tagged_obj",     [expr.tag, expr.obj]),
    mk_array()            = mk_call(var, "make_array",          [expr.size, expr.value]),
    get_seq_slice()       = mk_call(var, "get_seq_slice",       [expr.seq, expr.idx_first, expr.len]),
    append_to_seq()       = mk_call(var, "append_to_seq",       [expr.seq, expr.new_elem]),
    join_seqs()           = mk_call(var, "join_seqs",           [expr.left, expr.right]),
    join_mult_seqs()      = mk_call(var, "join_mult_seqs",      [expr.seqs]),
    rev_seq()             = mk_call(var, "rev_seq",             [expr.seq]),
    merge_sets()          = mk_call(var, "merge_sets",          [expr.sets]),
    merge_maps()          = mk_call(var, "merge_maps",          [expr.maps]),
    seq_to_set()          = mk_call(var, "seq_to_set",          [expr.seq]),
    seq_to_mset()         = mk_call(var, "seq_to_mset",         [expr.seq]),
    list_to_seq()         = mk_call(var, "list_to_seq",         [expr.list]),
    internal_sort()       = mk_call(var, "internal_sort",       [expr.set]),
    symb_to_str(e?)       = mk_call(var, "to_str",              [e]),
    get_new_input(a?)     = [to_c_var_name(var) & " = " & to_c_var_name(new_input(a)) & ";"],
    read_output()         = [mk_gen_call(var, output_get_method_name(expr.type, expr.output), ["&" & to_c_var_name(expr.var)])],
    add_attachment()      = mk_call(var, "add_attachment",      [expr.target, expr.data]),
    fetch_attachments(e?) = mk_call(var, "fetch_attachments",   [e]);

  ///////////////////////////////////////////////////////////////////////////////

  [String] compile_call_proc_to_c(Maybe[ObjVar] var, ObjFnName name, [<ObjExpr, BoundCls>] params, <Nat, nil> block_id)
  {
    pars_info = [gen_par_info(p) : p <- params];
    code_frags, args = unzip(pars_info);
    call_code = if var != nil
      then mk_fn_call(value(var), to_c_fn_name(name, length(params)), args)
      else mk_fn_call(to_c_fn_name(name, length(params)), args);
    return join(code_frags) & call_code;


    ([String], FnCallParam) gen_par_info(ObjExpr p) = ([], p);

    ([String], FnCallParam) gen_par_info(BoundCls p):
      ClsVar      = ([], p),
      // fn_ref()    = {
      //   par_id = _counter_(nil);
      //   par_var = cls_var(par_id);
      //   par_name = to_c_expr(par_var);
      //   code = [
      //     "CLS" & to_str(p.arity) & " " & par_name & ";",
      //     par_name & ".fn_ptr = " & to_c_fn_name(p.name) & ";",
      //     par_name & ".data = 0;"
      //   ];
      //   return (code, par_var);
      // },
      bound_cls() = {
        //## BAD: THE FIRST LINES OF CODE ARE THE SAME AS ABOVE...
        par_id = _counter_(nil);
        par_var = cls_var(par_id);
        par_name = to_c_expr(par_var);
        code = [
          "CLS" & to_str(p.cls.arity) & " " & par_name & ";",
          par_name & ".fn_ptr = " & "cls_" & to_str(cls2id(p.cls)) & ";"
        ];
        if (p.env != [])
          var_name = "cd_" & to_str(par_id);
          code = code & ["Obj " & var_name & "[" & to_str(length(p.env)) & "];"];
          for (v @ i : p.env)
            code = code & [var_name & "[" & to_str(i) & "] = " & to_c_expr(v) & ";"];
          ;
          code = code & [par_name & ".data = " & var_name & ";"];
        else
          code = code & [par_name & ".data = 0;"];
        ;
        return (code, par_var);
      };
  }


  [String] compile_branch_to_c(BoolExpr cond, [Instr] when_true, [Instr] when_false, <Nat, nil> block_id)
  {
    assert when_true != [];
    code = ["if (" & to_c_expr(cond) & ")", "{"]     &
           indent_lines(compile_to_c(when_true, block_id)) &
           ["}"];
    if (when_false != [])
      code = code & ["else", "{"] & indent_lines(compile_to_c(when_false, block_id)) & ["}"];
    ;
    return code;
  }


  //## HUGE BUG HERE: IF THE CODE IN ONE OF THE CASE STATEMENTS CONTAINS A BREAK
  //## THAT AFFECTS A LOOP THAT CONTAINS THE SWITCH STATEMENT, THEN THE BREAK WILL
  //## MISTAKINGLY TERMINATE THE SWITCH, NOT THE LOOP
  // [String] compile_symbol_switch_to_c(ObjExpr val, (vals: SymbObj+, instrs: [Instr])* cases, [Instr] default, <Nat, nil> block_id)
  // {
  //   code = ["switch (" & to_c_expr(val) & ")", "{"];
  //   for (c : rand_sort(cases))
  //     case_code = ["case S_" & _str_(_obj_(s)) & ":" : s <- rand_sort(c.vals)] & //## BAD
  //                  indent_lines(compile_to_c(c.instrs, block_id) & ["break;"]);
  //     code = code & indent_lines(case_code);
  //   ;
  //   if (default != [])
  //     code = code & ["default:"] & indent_lines(compile_to_c(default, block_id));
  //   ;
  //   return code & ["}"];
  // }


  [String] compile_cls_scope_to_c(NamedArg var, ClsDef cls, [Var] env, [Instr^] body, <Nat, nil> block_id)
  {
    scope_id = to_str(_counter_(nil));

    arity = cls.arity;
    env_size = length(env);

    var_str = _str_(_obj_(var)); //## BAD, DUPLICATED LOGIC
    arity_str = to_str(arity);
    env_size_str = to_str(env_size);

    fn_var = "env.n" & arity_str & "_" & var_str;  //## BAD, DUPLICATED LOGIC
    data_var = "env.C" & arity_str & "_" & var_str; //## BAD, DUPLICATED LOGIC
    fn_bk_var = "BF" & scope_id;
    data_bk_var = "BD" & scope_id;
    new_data_var = "ND" & scope_id;

    tmp = append(arity * ["Obj"] & ["const Obj *", "Env &"], ", ");

    code = [
      "Obj (*" & fn_bk_var & ")(" & tmp & ") = " & fn_var & ";",
      "const Obj *BD" & scope_id & " = " & data_var & ";"
    ];

    code = code & ["Obj " & new_data_var & "[" & env_size_str & "];"] if env_size > 0;

    //## HERE I'M ADDING THE add_ref/release PAIRS IN THE WRONG LAYERS
    for (i < env_size)
      code = code & [
        new_data_var & "[" & to_str(i) & "] = " & to_c_var_name(env[i]) & ";",
        "add_ref(" & new_data_var & "[" & to_str(i) & "]);"
      ];
    ;

    code = code & [
      fn_var & " = cls_" & to_str(cls2id(cls)) & ";",
      data_var & " = " & (if env_size > 0 then new_data_var else "0") & ";"
    ];

    code = code & compile_to_c(body, block_id);

    code = code & [
      fn_var & " = " & fn_bk_var & ";",
      data_var & " = " & data_bk_var & ";"
    ];

    for (i < env_size)
      code = code & ["release(" & new_data_var & "[" & to_str(i) & "]);"];
    ;

    code = ["{"] & indent_lines(code) & ["}"];

    return code;
  }


  [String] compile_runtime_check_to_c(AtomicExpr cond, String file, NzNat line, Maybe[String] text, <StdVar, NamedArg>* vars)
  {
    text_arg = if text != nil then quote(value(text)) else "0";
    header = [
      "if (" & to_c_expr(cond) & " == False_S)",
      "{",
      "  print_assertion_failed_msg(" & quote(file) & ", " & to_str(line) & ", " & text_arg & ");"
    ];
    vars_content = ["  dump_var(" & quote(_str_(name(v))) & ", " & to_c_var_name(v) & ");" : v <- rand_sort(vars)];
    footer = [
      "  hard_fail(0);",
      "}"
    ];
    return header & vars_content & footer;
  }

  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  String mk_gen_call(String fn_name, [String] leading_params, [FnCallParam] params, [String] trailing_params) =
    fn_name & "(" & append(leading_params & [to_c_expr(p) : p <- params] & trailing_params, ", ") & ");";

  String mk_gen_call(AnyVar var, String fn_name, [String] leading_params, [FnCallParam] params, [String] trailing_params) =
    to_c_var_name(var) & " = " & mk_gen_call(fn_name, leading_params, params, trailing_params);

  String mk_gen_call(AnyVar var, String fn_name, [String] params) = mk_gen_call(var, fn_name, params, [], []);

  [String] mk_call(String fn_name, [FnCallParam] params)             = [mk_gen_call(fn_name, [], params, [])];
  [String] mk_call(AnyVar var, String fn_name, [FnCallParam] params) = [mk_gen_call(var, fn_name, [], params, [])];

  [String] mk_fn_call(String fn_name, [FnCallParam] params)             = [mk_gen_call(fn_name, [], params, ["env"])];
  [String] mk_fn_call(AnyVar var, String fn_name, [FnCallParam] params) = [mk_gen_call(var, fn_name, [], params, ["env"])];

  //## AnyVar IS WRONG HERE, SHOULD ONLY BE OBJ/BOOL/INT VARS
  [String] mk_assignment(AnyVar var, AnyTypeExpr value) = [to_c_var_name(var) & " = " & to_c_expr(value) & ";"];


  [String] mk_cls_call(<ClsVar, NamedArg> cls_var, ObjVar var, [ObjExpr] params):
    cls_var(+ symb?) = { //## NO NEED FOR NOW TO HANDLE THE CASE cls_var(Nat), AS THOSE VARIABLES ARE NEVER "CALLED", ONLY PASSED ON
      name = to_c_var_name(cls_var);
      return [mk_gen_call(var, name & ".fn_ptr", [], params, [name & ".data", "env"])];
    },
    named_arg(symb?) = {
      name = to_str(length(params)) & "_" & _str_(_obj_(cls_var));
      return [mk_gen_call(var, "env.n" & name, [], params, ["env.C" & name, "env"])];
    };
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

using String typesymb2name(TypeSymbol)
{
  //## IT WOULD MUCH BETTER IF WE COULD USE mk_call HERE...
  String to_c_expr(ObjExpr expr):
    object(Atom a?)     = upper_camel_case(a) & "_S",
    object(Int n?)      = "to_obj(" & to_str(n) & ")",
    empty_set           = "empty_set",
    empty_seq           = "empty_seq",
    empty_map           = "empty_map",
    ObjVar              = to_c_var_name(expr),
    at()                = "at("                 & to_c_expr(expr.seq) & ", " & to_c_expr(expr.idx) & ")",
    get_tag(e?)         = "get_tag("            & to_c_expr(e)        & ")",
    get_inner_obj(e?)   = "get_inner_obj("      & to_c_expr(e)        & ")",
    to_obj(e?)          = "to_obj("             & to_c_expr(e)        & ")",
    obj_neg(e?)         = "obj_neg("            & to_c_expr(e)        & ")",
    to_symb(e?)         = "to_symb("            & to_c_expr(e)        & ")",
    get_curr_obj(v?)    = "get_curr_obj("       & to_c_var_name(v)    & ")",
    get_curr_key(v?)    = "get_curr_key("       & to_c_var_name(v)    & ")",
    get_curr_value(v?)  = "get_curr_value("     & to_c_var_name(v)    & ")",
    rand_elem(e?)       = "rand_set_elem("      & to_c_expr(e)        & ")";


  String to_c_expr(ObjExpr expr, Bool) = to_c_expr(expr);

  String to_c_expr(MembObjVar v)        = to_c_var_name(v);

  String to_c_expr(MembObjVar v, Bool)  = to_c_var_name(v);

  String to_c_expr(BoolExpr expr) = to_c_expr(expr, false);

  String to_c_expr(BoolExpr expr, Bool parentesised):
    true                  = "true",
    false                 = "false",
    BoolVar               = to_c_var_name(expr),
    is_symb(e?)           = "is_symb("    & to_c_expr(e) & ")",
    is_int(e?)            = "is_int("     & to_c_expr(e) & ")",
    is_float(e?)          = "is_float("   & to_c_expr(e) & ")",
    is_ne_set(e?)         = "is_ne_set("  & to_c_expr(e) & ")",
    is_ne_seq(e?)         = "is_ne_seq("  & to_c_expr(e) & ")",
    is_ne_map(e?)         = "is_ne_map("  & to_c_expr(e) & ")",
    is_tagged_obj(e?)     = "is_tag_obj(" & to_c_expr(e) & ")",

    has_elem()            = "has_elem(" & to_c_expr(expr.set) & ", " & to_c_expr(expr.elem) & ")",

    is_eq_bool()          = to_nary_op(" == ", [expr.expr1, expr.expr2], parentesised), //## BAD
    is_eq_int()           = to_nary_op(" == ", [expr.expr1, expr.expr2], parentesised), //## BAD

    is_eq()               = "are_eq(" & to_c_expr(expr.expr1) & ", " & to_c_expr(expr.expr2) & ")",

    //## BUG BUG BUG HUGE BUG HERE, NOT CHECKING THAT THE OPERANDS ARE INTEGERS
    is_gt()               = to_nary_op(" > ",  [expr.expr1, expr.expr2], parentesised), //## BAD
    is_ge()               = to_nary_op(" >= ", [expr.expr1, expr.expr2], parentesised), //## BAD
    is_lt()               = to_nary_op(" < ",  [expr.expr1, expr.expr2], parentesised), //## BAD
    is_le()               = to_nary_op(" <= ", [expr.expr1, expr.expr2], parentesised), //## BAD

    inline_is_eq()        = parentesize(to_c_expr(expr.expr) & " == " & to_c_expr(expr.value), parentesised),

    is_out_of_range(v?)   = "is_out_of_range(" & to_c_var_name(v) & ")",

    var_is_def(v?)        = parentesize(to_c_var_name(v) & " != null_obj", parentesised),

    output_is_def()       = parentesize(
                              to_c_var_name(expr.var) & "." & to_c_var_name(memb_var(expr.output), true) & " != null_obj",
                              parentesised
                            ),

    neg(e?)               = parentesize("!" & to_c_expr(e, true), parentesised),

    and(es?)              = to_nary_op(" & ",  es, parentesised),
    or(es?)               = to_nary_op(" | ",  es, parentesised),
    and_then(es?)         = to_nary_op(" && ", es, parentesised),
    or_else(es?)          = to_nary_op(" || ", es, parentesised),

    eval_bool_fn()        = to_c_fn_name(expr.name) & "(" & to_nary_op(", ", expr.params, false) & ")";


  String to_c_expr(IntExpr expr) = to_c_expr(expr, false);

  String to_c_expr(IntExpr expr, Bool parentesised):
    Int               = to_str(expr),
    IntVar            = to_c_var_name(expr),
    get_int_val(e?)   = "get_int_val("  & to_c_expr(e) & ")",
    get_set_size(e?)  = "get_set_size(" & to_c_expr(e) & ")",
    get_seq_len(e?)   = "get_seq_len("  & to_c_expr(e) & ")",
    get_map_size(e?)  = "get_map_size(" & to_c_expr(e) & ")",
    minus(e?)         = "-" & to_c_expr(e, true),
    add()             = to_nary_op(" + ", [expr.val1, expr.val2], parentesised),
    sub()             = to_nary_op(" - ", [expr.val1, expr.val2], parentesised),
    mult()            = to_nary_op(" * ", [expr.val1, expr.val2], parentesised),
    div()             = to_nary_op(" / ", [expr.val1, expr.val2], parentesised),
    mod()             = to_nary_op(" % ", [expr.val1, expr.val2], parentesised),
    mantissa(e?)      = "mantissa(" & to_c_expr(e) & ")",
    dec_exp(e?)       = "dec_exp(" & to_c_expr(e) & ")",
    rand_nat(e?)      = "rand_nat(" & to_c_expr(e) & ")",
    unique_nat        = "unique_nat()",
    ticks             = "get_tick_count()";


  String to_c_expr(<ElemVar, VecVar, ItVar, StreamVar> var) = to_c_var_name(var);

  String to_c_expr(<null_obj>) = "null_obj";

  String to_c_expr(ClsVar v) = to_c_var_name(v);

  String to_nary_op(String op, [AnyTypeExpr^] exprs, Bool parentesised)
  {
    expr = append([to_c_expr(e, true) : e <- exprs], op);
    expr = "(" & expr & ")" if length(exprs) > 1 and parentesised;
    return expr;
  }

  String input_set_method_name(AutoSymbol auto, Atom input)   = to_c_name(auto) & "_" & upper_camel_case(input) & "_set";

  String output_get_method_name(AutoSymbol auto, Atom output) = to_c_name(auto) & "_" & upper_camel_case(output) & "_get";

  String init_method_name(AutoSymbol name)    = to_c_name(name) & "_init";

  String update_method_name(AutoSymbol name)  = to_c_name(name) & "_update";

  String cleanup_method_name(AutoSymbol name) = to_c_name(name) & "_cleanup";

  String queue_update_method_name(Atom member, AutoSymbol auto) =
    to_c_name(auto) & "_" & upper_camel_case(member) & "_queue_update";

  String queue_update_method_name(Nat cond_id, AutoSymbol auto) =
    to_c_name(auto) & "_" & to_str(cond_id) & "_queue_update";

  //## USE AnyVar?
  String to_c_var_name(ObjVar v)      = to_c_var_name(v, false);
  String to_c_var_name(MembObjVar v)  = to_c_var_name(v, false);
  String to_c_var_name(VecVar v)      = "V" & to_str(v.id);
  String to_c_var_name(SetItVar v)    = "s" & to_str(_obj_(v));
  String to_c_var_name(SeqItVar v)    = "q" & to_str(_obj_(v));
  String to_c_var_name(MapItVar v)    = "m" & to_str(_obj_(v));
  String to_c_var_name(StreamVar v)   = "t" & to_str(_obj_(v));
  String to_c_var_name(BoolVar v)     = to_c_var_name(v, false);
  String to_c_var_name(IntVar v)      = to_c_var_name(v, false);

  String to_c_var_name(ClsVar v):
    cls_var(+ a?)  = upper_camel_case(a) & "_C",
    cls_var(* n?)  = "c" & to_str(n);


  String to_c_var_name(<ObjVar, MembObjVar> v, Bool decl) = to_c_var_name(v, if decl then "" else "self->");

  String to_c_var_name(<ObjVar, MembObjVar> v, String prefix):
    var(Atom a?)            = upper_camel_case(a) & "_V",
    fn_par(Nat n?)          = "p"   & to_str(n),
    named_arg(Atom a?)      = "env.n_"  & _str_(a),
    cls_ext_par(Nat n?)     = "C["  & to_str(n) & "]",
    memb_var(Atom a?)       = prefix & upper_camel_case(a),
    memb_copy_var(Atom a?)  = upper_camel_case(a) & "_O",
    lvar(Nat n?)            = "l"   & to_str(n),
    evar()                  = "V" & to_str(v.id) & "[" & to_c_expr(v.idx) & "]",
    new_input(Atom a?)      = prefix & upper_camel_case(a) & "_new";

  String to_c_var_name(AutoVar v) = upper_camel_case(name(v)) & "_A";
  String to_c_var_name(BoolVar v, Bool decl)
  {
    prefix = if decl then "" else "self->";
    return match (v)
      bvar(n?)                        = "b" & to_str(n),
      memb_has_changed(id?)           = upper_camel_case(id) & "_has_changed",
      invalidate_cond_expr_cache      = "inval_cache",
      cond_value_var(n?)              = prefix & "cond_" & to_str(n),
      cond_expr_up_to_date_var(n?)    = prefix & "cond_" & to_str(n) & "_expr_up_to_date",
      cond_expr_value_var(n?)         = prefix & "cond_" & to_str(n) & "_expr",
      cond_expr_is_def_var(n?)        = prefix & "cond_" & to_str(n) & "_expr_is_def",
      cond_is_def_var(n?)             = prefix & "cond_" & to_str(n) & "_is_def",
      marked_for_update_var(Atom a?)  = prefix & upper_camel_case(a) & "_marked_for_update",
      marked_for_update_var(Nat n?)   = prefix & "cond_" & to_str(n) & "_marked_for_update",
      is_new                          = prefix & "is_new";
  }


  String to_c_var_name(IntVar v, Bool decl)
  {
    prefix = if decl then "" else "self->";
    return match (v)
      ivar(n?)                = "i" & to_str(n),
      update_source_var(a?)   = prefix & upper_camel_case(a) & "_update_source",
      update_count_var(iv?)   = prefix & "update_count_" & to_c_expr(iv),
      nodes_to_update_var()   = {assert not decl; return prefix & "nodes_to_update_" & to_c_expr(v.level) & "[" & to_c_expr(v.index) & "]";};
  }


  String to_c_var_name(MembIntVectVar v, Bool decl)
  {
    assert decl;
    return "nodes_to_update_" & to_text(v.level) & "[" & to_text(v.size) & "]";
  }


  String var_c_type(ObjVar)         = "Obj";
  String var_c_type(MembObjVar)     = "Obj";
  String var_c_type(IntVar)         = "int";
  String var_c_type(MembIntVectVar) = "int";
  String var_c_type(BoolVar)        = "bool";

  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  String to_c_fn_name(FnSymbol fn_symb, Nat arity):
    fn_symbol(symb?)    = upper_camel_case(symb) & "_" & to_str(arity),
    op_symbol(op?)      = _str_(op),
    nested_fn_symbol()  = to_c_fn_name(fn_symb.outer, arity) & "__" & to_c_fn_name(fn_symb.inner, arity),
    unique_fn_symbol()  = to_c_fn_name(fn_symb.symbol, arity) & uppercase_encoding(fn_symb.id); //## IS THIS ENOUGHT TO AVOID CONFLICTS?

  String to_c_fn_name(BoolFnName n, Nat) = to_c_fn_name(n);
  String to_c_fn_name(BoolFnName): memb_test(ts?)   = "is_" & typesymb2name(ts); //## UGLY UGLY UGLY

  String to_c_fn_name(ProcSymbol s, Nat) = to_c_fn_name(s);
  String to_c_fn_name(ProcSymbol): proc_symbol(s?)  = upper_camel_case(s) & "_P"; //## UGLY UGLY UGLY

  ///////////////////////////////////////////////////////////////////////////////

  String to_c_name(AutoSymbol): auto_symbol(a?) = upper_camel_case(a);

  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  String fn_name_to_str(FnSymbol fn_symb):
    fn_symbol(symb?)    = _str_(symb),
    op_symbol(op?)      = _str_(op),
    //## BUG: THIS DOESN'T SPECIFY WHICH OF THE OUTER FUNCTIONS
    //## WITH THE SAME NAME THE NESTED FUNCTION BELONGS TO
    nested_fn_symbol()  = fn_name_to_str(fn_symb.outer) & ":" & fn_name_to_str(fn_symb.inner),
    unique_fn_symbol()  = fn_name_to_str(fn_symb.symbol); //## BAD: THE DISPATCH FUNCTION WILL APPEAR ON THE STACK, AND IT WILL BE INDISTINGUISHABLE FROM ONE OF THE REAL FUNCTIONS

  String fn_name_to_str(ProcSymbol proc_symbol): proc_symbol(s?) = capitalize(_str_(s), false); //## UGLY UGLY UGLY
}

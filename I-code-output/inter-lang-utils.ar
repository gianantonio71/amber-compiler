ParTypeSymbol* par_type_symbols(CompiledPrg prg)
{
  tss = [if mt :: <memb_test(TypeSymbol)> then _obj_(mt) else {fail;} : mt <- select(prg, $ :: <memb_test(TypeSymbol)>)];

  btss = [ts : ts <- tss, type_symbol()     << ts];
  ptss = [ts : ts <- tss, par_type_symbol() << ts];

  btss = rand_sort(btss);
  ptss = rand_sort(ptss);

  return ptss;
}


SymbObj+ used_symbols(CompiledPrg prg)
{
  fixed_symbs = (object(a) : a <- special_symbols);
  other_symbs = select(prg, $ :: SymbObj) - set(fixed_symbs);
  fail if not other_symbs :: [SymbObj];
  return nonempty(fixed_symbs & sort_set(other_symbs, $a < $b));
}


[ClsDef] cls_defs(CompiledPrg prg)
{
  cls_defs = select_rec(prg, $ :: ClsDef); //## TODO: THIS SHOULD BE TESTED
  fail if not cls_defs :: [ClsDef];
  return cls_defs;
}

type VarTypesNotToDeclare = FnPar,
                            NamedArg,
                            CaptVar,
                            ElemVar,
                            MembVar,
                            PendingStateVar,
                            AnyAutoVar,
                            MembBoolVar,
                            MembIntVar,
                            MembObjVar,
                            BoolArgVar,
                            IntArgVar;

//## BAD: THIS THING IS INCREDIBLY MESSY. I MUST IMPLEMENT A VERSION OF SELECT WITH A <STOP> GUARD
[AnyVar] vars_to_declare(Instr* instrs)
{
  vars = select(
    instrs,
    $ :: <AnyVar, ClsDef> and not $ :: <VarTypesNotToDeclare, ClsDef>
  );
  fail if not vars :: [AnyVar];
  vars = vars - [never_used_lvar]; //## THIS IS A REALLY, REALLY UGLY THING
  return vars;
}


[LocAutoVar -> AutoSymbol] auto_vars_to_decl_and_init(Instr* instrs)
{
  all_typed_vars = retrieve_from_nested_low_level_instrs(instrs, retrieve);
  res = [left(vt) -> right(vt) : vt <- all_typed_vars];
  fail if not res :: [LocAutoVar -> AutoSymbol]; //## BAD BAD BAD CHEATING
  return res;

  //## BUG BUG BUG: THIS DOES NOT CATCH ALL THE USAGES OF AUTOMATON VARIABLES. THE FOLLOWING ARE LEFT OUT:
  //##   read_output(var: AutoVar, type: AutoSymbol, output: Atom)
  [(AnyAutoVar, AutoSymbol)] retrieve(Instr instr):
    set_input()           = [(instr.var, instr.type)],
    prop_input_updates()  = [(instr.var, instr.type) if instr.var?],
    call_method()         = [(instr.auto_var, instr.type) if instr.auto_var?],
    _                     = retrieve_from_nested_low_level_instrs(instr, retrieve);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

String parentesize(String code, Bool parentesized) = if parentesized then "(" & code & ")" else code;


String uppercase_encoding(Nat n)
{
  m = n;
  chs = ();
  while m > 0 or chs == ():
    chs = (nat(ascii_upper_a + mod(n, 26))) & chs;
    m = m / 26;
  ;
  return string(chs);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[Any] select(Any obj, (Any -> Bool) cond) =
  if cond(obj)
    then [obj]
    else match (obj)
      +           = [],
      *           = [],
      ^           = [],
      [..]       = union([select(x, cond) : x <- obj]),
      (..)       = union([select(x, cond) : x <- set(obj)]),
      [->]       = union([select(k, cond) & select(v, cond) : v @ k <- obj]),
      tag @ iobj  = select(iobj, cond); //## SHOULD I EXTEND THE SEARCH TO THE TAG AS WELL?


[Any] select_rec(Any obj, (Any -> Bool) cond) =
  [obj if cond(obj)] &
  match (obj)
      +           = [],
      *           = [],
      ^           = [],
      [..]       = union([select_rec(x, cond) : x <- obj]),
      (..)       = union([select_rec(x, cond) : x <- set(obj)]),
      [->]       = union([select_rec(k, cond) & select_rec(v, cond) : v @ k <- obj]),
      tag @ iobj  = select_rec(iobj, cond); //## SHOULD I EXTEND THE SEARCH TO THE TAG AS WELL?


// Any replace(Any obj, (Any -> Bool) cond, (Any -> Any) eval) =
//   if cond(obj)
//     then eval(obj)
//     else match (obj)
//       +           = obj,
//       *           = obj, //## BAD
//       ^           = obj, //## BAD
//       {...}       = {replace(x, cond, eval) : x <- obj},
//       [...]       = [replace(x, cond, eval) : x <- obj],
//       (...)       = (replace(k, cond, eval) => replace(v, cond, eval) : v @ k <- obj),
//       tag @ iobj  = tag @ replace(iobj, cond, eval); //## SHOULD I EXTEND THE REPLACEMENT TO THE TAG AS WELL?

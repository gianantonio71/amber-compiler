[ParTypeSymbol] par_type_symbols(CompiledPrg prg)
{
  tss = {if mt :: <memb_test(TypeSymbol)> then _obj_(mt) else {fail;} : mt <- select(prg, $ :: <memb_test(TypeSymbol)>)};

  btss = {ts : ts <- tss, type_symbol()     << ts};
  ptss = {ts : ts <- tss, par_type_symbol() << ts};

  btss = rand_sort(btss);
  ptss = rand_sort(ptss);

  return ptss;
}


[SymbObj^] used_symbols(CompiledPrg prg)
{
  // symbs = (select SymbObj in prg end - {obj_true, obj_false}) & {:object(:string)};
  // symbs = [obj_true, obj_false] & sort_set(symbs, $a < $b);
  symbs = select(prg, $ :: SymbObj) & {obj_true, obj_false, :object(:string), :object(:just)};
  fail if not symbs :: SymbObj+;
  return nonempty(sort_set(symbs, $a < $b));
}


ClsDef* cls_defs(CompiledPrg prg)
{
  cls_defs = select_rec(prg, $ :: ClsDef); //## TODO: THIS SHOULD BE TESTED
  fail if not cls_defs :: ClsDef*;
  return cls_defs;
}

type VarTypesNotToDeclare = FnPar,
                            NamedArg,
                            CaptVar,
                            ElemVar,
                            MembVar,
                            AutoVar,
                            MembBoolVar,
                            MembIntVar,
                            SpecialLocVar;

//## BAD: THIS THING IS INCREDIBLY MESSY. I MUST IMPLEMENT A VERSION OF SELECT WITH A <STOP> GUARD
AnyVar* vars_to_declare([Instr] instrs)
{
  vars = select(
    instrs,
    $ :: <AnyVar, ClsDef> and not $ :: <VarTypesNotToDeclare, ClsDef>
  );
  fail if not vars :: AnyVar*;
  return vars;
}


(AutoVar => AutoSymbol) auto_vars_to_decl_and_init([Instr] instrs)
{
  all_typed_vars = retrieve_from_nested_low_level_instrs(instrs, retrieve);
  return (left(vt) => right(vt) : vt <- all_typed_vars);

  (AutoVar, AutoSymbol)* retrieve(Instr instr):
    update_inputs()   = {(instr.var, instr.type)},
    _                 = retrieve_from_nested_low_level_instrs(instr, retrieve);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

String parentesize(String code, Bool parentesized) = if parentesized then "(" & code & ")" else code;


String uppercase_encoding(Nat n)
{
  m = n;
  chs = [];
  while (m > 0 or chs == [])
    chs = [nat(ascii_upper_a + mod(n, 26))] & chs;
    m = m / 26;
  ;
  return string(chs);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Any* select(Any obj, (Any -> Bool) cond) =
  if cond(obj)
    then {obj}
    else match (obj)
      +           = {},
      *           = {},
      ^           = {},
      {...}       = union({select(x, cond) : x <- obj}),
      [...]       = union({select(x, cond) : x <- set(obj)}),
      (...)       = union({select(k, cond) & select(v, cond) : v @ k <- obj}),
      tag @ iobj  = select(iobj, cond); //## SHOULD I EXTEND THE SEARCH TO THE TAG AS WELL?


Any* select_rec(Any obj, (Any -> Bool) cond) =
  {obj if cond(obj)} &
  match (obj)
      +           = {},
      *           = {},
      ^           = {},
      {...}       = union({select_rec(x, cond) : x <- obj}),
      [...]       = union({select_rec(x, cond) : x <- set(obj)}),
      (...)       = union({select_rec(k, cond) & select_rec(v, cond) : v @ k <- obj}),
      tag @ iobj  = select_rec(iobj, cond); //## SHOULD I EXTEND THE SEARCH TO THE TAG AS WELL?


// Any replace(Any obj, (Any -> Bool) cond, (Any -> Any) eval) =
//   if cond(obj)
//     then eval(obj)
//     else match (obj)
//       +           = obj,
//       *           = obj, //## BAD
//       ^           = obj, //## BAD
//       {...}       = {replace(x, cond, eval) : x <- obj},
//       [...]       = [replace(x, cond, eval) : x <- obj],
//       (...)       = (replace(k, cond, eval) => replace(v, cond, eval) : v @ k <- obj),
//       tag @ iobj  = tag @ replace(iobj, cond, eval); //## SHOULD I EXTEND THE REPLACEMENT TO THE TAG AS WELL?

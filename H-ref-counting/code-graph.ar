type NodeInfo       = std_node(<BasicInstr, JumpInstr>),
                      branch_node(BoolExpr),
                      switch_node(IntExpr),
                      set_cls_par_node(var: NamedArg, cls: BoundCls);

type CodeTree       = std_node(Nat),
                      branch_node(idx: Nat, if_body: [CodeTree^], else_body: [CodeTree]),
                      switch_node(idx: Nat, cases: [[CodeTree]^]),
                      loop_node([CodeTree^]),
                      block_node([CodeTree^]),
                      cls_scope_node(idx: Nat, body: [CodeTree^]),
                      root_node([CodeTree^]);

type RCNodeInfo     = std_node([Instr]),
                      branch_node(cond: BoolExpr, if_post_instrs: [Instr], else_post_instrs: [Instr]),
                      switch_node(index: IntExpr, cases_instrs: [[Instr]^]),
                      set_cls_par_node(var: NamedArg, cls: BoundCls, post_instrs: [Instr]);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

NodeInfo std_node(<BasicInstr, JumpInstr> i)          = :std_node(i);
NodeInfo branch_node(BoolExpr e)                      = :branch_node(e);
NodeInfo switch_node(IntExpr e)                       = :switch_node(e);
NodeInfo set_cls_par_node(NamedArg var, BoundCls cls) = set_cls_par_node(var: var, cls: cls);


CodeTree std_node(Nat i)                                    = :std_node(i);
CodeTree branch_node(Nat i, [CodeTree^] ib, [CodeTree] eb)  = branch_node(idx: i, if_body: ib, else_body: eb);
CodeTree switch_node(Nat i, [[CodeTree]^] cs)               = switch_node(idx: i, cases: cs);
CodeTree loop_node([CodeTree^] b)                           = :loop_node(b);
CodeTree block_node([CodeTree^] b)                          = :block_node(b);
CodeTree cls_scope_node(Nat i, [CodeTree^] b)               = cls_scope_node(idx: i, body: b);
CodeTree root_node([CodeTree^] b)                           = :root_node(b);


RCNodeInfo std_node([Instr] instrs)                             = :std_node(instrs);
RCNodeInfo branch_node(BoolExpr c, [Instr] iis, [Instr] eis)    = branch_node(cond: c, if_post_instrs: iis, else_post_instrs: eis);
RCNodeInfo rc_switch_node(IntExpr e, [[Instr]^] is)             = switch_node(index: e, cases_instrs: is);
RCNodeInfo set_cls_par_node(NamedArg v, BoundCls c, [Instr] is) = set_cls_par_node(var: v, cls: c, post_instrs: is);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

([NodeInfo^], CodeTree) build_root_code_graph([Instr^] instrs)
{
  leaf_nodes, code_trees = build_code_graph(instrs, 0);
  return (leaf_nodes, root_node(code_trees));
}


([NodeInfo^], CodeTree) build_code_graph(Instr instr, Nat offset):
  <BasicInstr, JumpInstr> = ([std_node(instr)], std_node(offset)),
  branch()                = build_branch_code_graph(instr.cond, instr.when_true, instr.when_false, offset),
  switch_on_nat()         = build_switch_on_nat_code_graph(instr.value, instr.cases, offset),
  repeat(is?)             = build_loop_code_graph(is, offset),
  execute_block(is?)      = build_block_code_graph(is, offset),
  cls_scope()             = build_cls_scope_code_graph(instr.var, instr.bound_cls, instr.body, offset);


([NodeInfo^], CodeTree) build_branch_code_graph(BoolExpr cond, [Instr^] if_branch, [Instr] else_branch, Nat offset)
{
  if_branch_leaf_nodes, if_branch_code_trees = build_code_graph(if_branch, nat(offset+1));
  else_offset = nat(offset + 1 + length(if_branch_leaf_nodes));
  else_branch_leaf_nodes, else_branch_code_trees = safe_build_code_graph(else_branch, else_offset);
  leaf_nodes = [branch_node(cond)] & if_branch_leaf_nodes & else_branch_leaf_nodes;
  code_tree = branch_node(offset, if_branch_code_trees, else_branch_code_trees);
  return (nonempty(leaf_nodes), code_tree);
}


([NodeInfo^], CodeTree) build_switch_on_nat_code_graph(IntExpr value, [[Instr]^] cases, Nat offset)
{
  leaf_nodes = [switch_node(value)];
  code_trees = [];
  for (c : cases)
    case_leaf_nodes, case_code_trees = safe_build_code_graph(c, nat(offset + length(leaf_nodes)));
    leaf_nodes = leaf_nodes & case_leaf_nodes;
    code_trees = [code_trees | case_code_trees];
  ;
  return (nonempty(leaf_nodes), switch_node(offset, nonempty(code_trees)));
}


([NodeInfo^], CodeTree) build_loop_code_graph([Instr^] body, Nat offset)
{
  leaf_nodes, code_trees = build_code_graph(body, offset);
  return (leaf_nodes, loop_node(code_trees));
}


([NodeInfo^], CodeTree) build_block_code_graph([Instr^] body, Nat offset)
{
  leaf_nodes, code_trees = build_code_graph(body, offset);
  return (leaf_nodes, block_node(code_trees));
}


([NodeInfo^], CodeTree) build_cls_scope_code_graph(NamedArg var, BoundCls cls, [Instr^] body, Nat offset)
{
  leaf_nodes, code_trees = build_code_graph(body, nat(offset+1));
  head_node = set_cls_par_node(var, cls);
  return (nonempty([head_node] & leaf_nodes), cls_scope_node(offset, code_trees));
}


// (<[]>, <[]>) build_code_graph(<[]>, Nat) = ([], []); //## CANNOT USE THIS BECAUSE OF THE BUG IN THE TYPECHECKER
([NodeInfo], [CodeTree]) safe_build_code_graph([Instr] instrs, Nat initial_offset) =
  if instrs != [] then build_code_graph(instrs, initial_offset) else ([], []);

([NodeInfo^], [CodeTree^]) build_code_graph([Instr^] instrs, Nat initial_offset)
{
  offset = initial_offset;
  leaf_subnodes = [];
  code_trees = [];
  for (instr @ i : instrs)
    leaf_nodes, code_tree = build_code_graph(instr, offset);
    offset = nat(offset + length(leaf_nodes));
    leaf_subnodes = [leaf_subnodes | leaf_nodes];
    code_trees = [code_trees | code_tree];
  ;
  return (nonempty(join(leaf_subnodes)), nonempty(code_trees));
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[Instr] reconstruct(CodeTree code_tree, [RCNodeInfo^] rc_nodes):
  std_node(id?)     = (match (rc_nodes[id]) std_node(is?) = is), //## UGLY UGLY UGLY
  branch_node()     = [reconstruct_branch(code_tree.idx, code_tree.if_body, code_tree.else_body, rc_nodes)],
  switch_node()     = [reconstruct_switch(code_tree.idx, code_tree.cases, rc_nodes)],
  loop_node(ts?)    = [repeat(nonempty(reconstruct(ts, rc_nodes)))],
  block_node(ts?)   = [execute_block(nonempty(reconstruct(ts, rc_nodes)))],
  cls_scope_node()  = [reconstruct_cls_scope(code_tree.idx, code_tree.body, rc_nodes)],
  root_node(ts?)    = reconstruct(ts, rc_nodes);


Instr reconstruct_branch(Nat idx, [CodeTree^] if_code_trees, [CodeTree] else_code_trees, [RCNodeInfo^] rc_nodes)
{
  cond, if_instrs, else_instrs = match (rc_nodes[idx]) branch_node() n? = (n.cond, n.if_post_instrs, n.else_post_instrs); //## UGLY UGLY UGLY
  if_body = if_instrs & reconstruct(if_code_trees, rc_nodes);
  else_body = else_instrs & reconstruct(else_code_trees, rc_nodes);
  return branch(cond, if_body, else_body);
}


Instr reconstruct_switch(Nat idx, [[CodeTree]^] case_code_trees, [RCNodeInfo^] rc_nodes)
{
  index, instrs = match (rc_nodes[idx]) switch_node() n? = (n.index, n.cases_instrs); //## UGLY UGLY UGLY
  cases_code = [instrs[i] & reconstruct(ct, rc_nodes) : ct @ i <- case_code_trees];
  return switch_on_nat(index, cases_code);
}


Instr reconstruct_cls_scope(Nat idx, [CodeTree^] body, [RCNodeInfo^] rc_nodes)
{
  var, cls, post_instrs = match (rc_nodes[idx]) set_cls_par_node() n? = (n.var, n.cls, n.post_instrs); //## UGLY UGLY UGLY
  return cls_scope(var, cls, nonempty(post_instrs & reconstruct(body, rc_nodes)));
}


[Instr] reconstruct([CodeTree] code_trees, [RCNodeInfo^] rc_nodes) = join([reconstruct(t, rc_nodes) : t <- code_trees]);

T attach(T obj, Any data) {fail;} // Overridden in the generated code

Maybe[Any] fetch(T obj) {fail;}   // Overridden in the generated code

T1 transfer(T1 to, T2 from) =
  match (fetch(from))
    just(a?)  = attach(to, a),
    nil       = to;

////////////////////////////////////////////////////////////////////////////////

String* indent_lines(String* strs) = (if s != "" then "  " & s else "" : s <- strs);

////////////////////////////////////////////////////////////////////////////////

Nat uppercase(Nat ch) = if ch >= ascii_lower_a and ch <= ascii_lower_z then nat(ch - ascii_lower_a + ascii_upper_a) else ch;


String uppercase(Atom a) = string((uppercase(ch) : ch <- raw_str(_str_(a))));


String sentence_case(Atom a) = string((if i == 0 then uppercase(ch) else ch : ch @ i <- raw_str(_str_(a))));


String upper_camel_case(Atom a) = capitalize(_str_(a), false);


String capitalize(String s, Bool keep_underscores)
{
  first = true;
  res = ();
  for ch @ i <- _obj_(s):
    tr_ch = ch;
    if ch == ascii_underscore:
      first = true;
    else
      tr_ch  = nat(ch - ascii_lower_a + ascii_upper_a) if ch >= ascii_lower_a and ch <= ascii_lower_z and first; //## CREATE PRELUDE FUNCTION is_lower()/is_upper() AND to_lower()/to_upper()
      first = false;
    ;
    res = res & (tr_ch if tr_ch != ascii_underscore or keep_underscores);
  ;
  return string(res);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

String user_repr(Type type) = user_repr(type, false, false, false, false, false);

String user_repr(Type type, Bool inside_type_union, Bool incl_empty_seq, Bool incl_empty_set, Bool incl_empty_bin_rel, Bool incl_empty_tern_rel) =
  empty_type                = "</>",
  atom_type                 = "<+>",
  symb_type(object(a?))     = {res = _str_(a); res = "<" & res & ">" if not inside_type_union; return res;},
  integer                   = "<*..*>",
  low_ints()                = "<*.." & printed(type.max) & ">",
  high_ints()               = "<" & printed(type.min) & "..*>",
  int_range()               = "<" & printed(type.min) & ".." & printed(type.min + type.size - 1) & ">",
  float_type                = "<^>",
  empty_seq_type            = "()",
  empty_set_type            = "[]",
  empty_bin_rel_type        = "[:]",
  empty_tern_rel_type       = "[::]",
  type_var(Atom a?)         = upper_camel_case(a) & "'",
  type_var(* n?)            = "<" & printed(n) & "'>",
  type_ref(ts?)             = user_repr(ts),
  ne_seq_type()             = user_repr(type.elem_type) & if incl_empty_seq then "*" else "+",
  ne_set_type()             = "[" & {if incl_empty_set then "" else "+"} & user_repr(type.elem_type) & "]",
  ne_map_type()             = "[" & {if incl_empty_bin_rel then "" else "+"} &
                              user_repr(type.key_type) & " -> " & user_repr(type.value_type) & "]",
  ne_bin_rel_type()         = "[" & {if incl_empty_bin_rel then "" else "+"} &
                              append((append((user_repr(t) : t <- s), ", ") : s <- rand_sort(type.signatures)), " | ") & "]",
  ne_tern_rel_type()        = "[" & {if incl_empty_tern_rel then "" else "+"} &
                              append((append((user_repr(t) : t <- s), ", ") : s <- rand_sort(type.signatures)), " | ") & "]",
  ne_record_type(fs?)       = ne_record_type_user_repr(fs),
  tuple_type(ts?)           = "(" & append((user_repr(t) : t <- ts), ", ") & ")",
  tag_obj_type()            = tag_obj_type_user_repr(type.tag_type, type.obj_type),
  union_type(ts?)           = union_type_user_repr(ts);


String ne_record_type_user_repr(RecordTypeFields fields)
{
  field_reprs = [record_field_user_repr(l, f.type, f.optional) : l, f <- fields];
  return "(" & append(rand_sort(field_reprs), ", ") & ")";

  String record_field_user_repr(SymbObj label, NeType type, Bool optional) =
    _str_(match (label) object(a?) = a) & ": " & user_repr(type) & if optional then "?" else "";
}


String union_type_user_repr([+NeType] types)
{
  incl_empty_seq = in(empty_seq_type, types);
  incl_empty_set = in(empty_set_type, types);
  incl_empty_bin_rel = in(empty_bin_rel_type, types);
  incl_empty_tern_rel = in(empty_tern_rel_type, types);

  types_to_exclude = [
    empty_seq_type if (t <- types : match (t) ne_seq_type() = true, _ = false),
    empty_set_type if (t <- types : match (t) ne_set_type() = true, _ = false),
    empty_bin_rel_type if (t <- types : repr_includes_empty_bin_rel(t)),
    empty_tern_rel_type if (t <- types : match (t) ne_tern_rel_type() = true, _ = false)
  ];

  types_left_sorted = rand_sort(types - types_to_exclude);
  is_still_union = length(types_left_sorted) > 1;
  types_reprs = (
    user_repr(t, is_still_union, incl_empty_seq, incl_empty_set, incl_empty_bin_rel, incl_empty_tern_rel)
    : t <- types_left_sorted
  );
  repr_str = append(types_reprs, ", ");
  repr_str = "<" & repr_str & ">" if is_still_union;
  return repr_str;


  Bool repr_includes_empty_bin_rel(NeType type) =
    ne_map_type()         |
    ne_bin_rel_type()     = true,
    ne_record_type(fs?)   = not (l, f <- fs : not f.optional),
    _                     = false;
}


String tag_obj_type_user_repr(TagType tag_type, NeType obj_type)
{
  skip_pars = match (obj_type)
    tuple_type() | ne_record_type()   = true,
    _                                 = false;

  tag_repr = match (tag_type)
    atom_type               = "<+>",
    symb_type(object(tag?)) = _str_(tag);

  obj_repr = user_repr(obj_type);
  obj_repr = "(" & obj_repr & ")" if not skip_pars;

  return tag_repr & obj_repr;
}


String user_repr(TypeSymbol type_symb) =
  type_symbol(a?)           = upper_camel_case(a),
  builtin_type_symbol(a?)   = "#" & upper_camel_case(a),
  par_type_symbol()         = user_repr(type_symb.symbol) & "[" & append((user_repr(p) : p <- type_symb.params), ", ") & "]";


String user_repr(SymbObj) =
  object(a?)  = _str_(a);


String user_repr(Var v) =
  fn_par(n?)      = "$" & printed(n),
  impl_arg(a?)    = _str_(a),
  capt_var(n?)    = {fail;},
  var(a?)         = _str_(a);


String user_repr(AnyAutoVar v) = _str_(bare_id(v));


String user_repr(ProcSymbol) =
  proc_symbol(a?)   = upper_camel_case(a);


String user_repr(BuiltIn b) = "_" & _str_(b) & "_";


String user_repr(FnSymbol fn_symb, Nat arity) =
  fn_symbol(a?)         = _str_(a) & "/" & printed(arity),
  op_symbol(op?)        = user_repr(op),
  nested_fn_symbol()    = user_repr(fn_symb.outer) & ":" & user_repr(fn_symb.inner),
  unique_fn_symbol()    = {fail;};


String user_repr(ClsVar v) =
  cls_var(Atom a?)    = _str_(a);


String user_repr(ClsType type) = cls_type_user_repr(type.in_types, type.out_type);

String cls_type_user_repr(Type+ arg_types, Type ret_type) =
  "(" & append((user_repr(t) : t <- arg_types), ", ") & " -> " & user_repr(ret_type) & ")";

String user_repr(FnType type) = append((user_repr(t) : t <- type.args), ", ") & " -> " & user_repr(type.ret_type);


//## BUG BUG BUG: THIS IS PROBABLY ALL WRONG...
String user_repr(Pattern ptrn) =
  ptrn_symbol         = "+",
  ptrn_float          = "*",
  ptrn_empty_seq      = "()",
  ptrn_ne_seq         = "(?)",
  ptrn_empty_set      = "[]",
  ptrn_ne_set         = "[?]",
  ptrn_empty_bin_rel  = "[:]",
  ptrn_ne_map         = "[->]",
  ptrn_ne_bin_rel     = "[?:?]",
  ptrn_empty_tern_rel = "[::]",
  ptrn_ne_tern_rel    = "[?:?:?]",
  ptrn_any            = "_",
  ptrn_symbol(s?)     = _str_(match (s) object(a?) = a),
  ptrn_integer(t?)    = user_repr(t),
  ptrn_tuple(ps?)     = "(" & append((user_repr(p) : p <- ps), ", ") & ")",
  ptrn_tag_obj()      = ptrn_tag_obj_user_repr(ptrn.tag, ptrn.obj),
  ptrn_var()          = {if ptrn.ptrn != ptrn_any then user_repr(ptrn.ptrn) & " " else ""} & user_repr(ptrn.var) & "?",
  ptrn_union(ps?)     = append((user_repr(p) : p <- rand_sort(ps)), " | ");


String ptrn_tag_obj_user_repr(TagPtrn tag, Pattern obj) =
  ptrn_symbol               = "_ @ " & user_repr(obj),
  ptrn_symbol(object(s?))   = _str_(s) & "(" & user_repr(obj) & ")",
  ptrn_var()                = user_repr(tag.var) & " @ " & user_repr(obj);


String user_repr(FnSymbol fn_symb) =
  fn_symbol(a?)         = _str_(a),
  op_symbol(op?)        = user_repr(op),
  nested_fn_symbol()    = user_repr(fn_symb.outer) & ":" & user_repr(fn_symb.inner),
  unique_fn_symbol()    = {fail;};


String user_repr(MethodSymbol symb) = method_symbol(a?)  = _str_(a);

String user_repr(UpdateSymbol symb) = update_symbol(a?)  = _str_(a);

String user_repr(AutoSymbol) = auto_symbol(a?) = _str_(a);

String user_repr(DBSymbol) = db_symbol(a?) = upper_camel_case(a);


String user_repr(Operator) =
  unary_minus   = "(-_)",
  plus          = "(_+_)",
  minus         = "(_-_)",
  star          = "(_*_)",
  slash         = "(_/_)",
  exp           = "(_^_)",
  amp           = "(_&_)",
  lower         = "(_<_)",
  greater       = "(_>_)",
  lower_eq      = "(_<=_)",
  greater_eq    = "(_>=_)",
  brackets      = "(_[_])";

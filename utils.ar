T1 transfer_attachments(T1 to, T2 from)
{
  res = to;
  for obj <- rand_sort(_fetch_(from)):
    res = attach(res, obj);
  ;
  return res;

  T attach(T obj, Any data) = _attach_(obj, data);  //## BAD BAD BAD: THIS IS A WORKAROUND FOR A BUG IN THE TYPECHECKER
}


Atom+ special_symbols = (false, true, nil, :string, :just);


Bool (_<_) (SymbObj s1, SymbObj s2)
{
  return lower_than(_obj_(s1), _obj_(s2));

  Bool lower_than(Atom a1, Atom a2)
  {
    is_special_1 = in(a1, special_symbols);
    is_special_2 = in(a2, special_symbols);

    if is_special_1:
      if is_special_2:
        return index_first(a1, special_symbols) < index_first(a2, special_symbols);
      else
        return true;
      ;
    elif is_special_2:
      return false;
    ;

    str1 = _str_(a1);
    str2 = _str_(a2);

    len1 = length(str1);
    len2 = length(str2);

    return len1 < len2 if len1 != len2;

    for ch1 @ i <- _obj_(str1):
      ch2 = str2[i];
      return ch1 < ch2 if ch1 != ch2;
    ;

    fail;
  }
}

////////////////////////////////////////////////////////////////////////////////

String* indent_lines(String* strs) = (indent_line(s) : s <- strs);

String indent_line(String str) = "  " & str;

////////////////////////////////////////////////////////////////////////////////

Nat uppercase(Nat ch) = if ch >= ascii_lower_a and ch <= ascii_lower_z then nat(ch - ascii_lower_a + ascii_upper_a) else ch;


String uppercase(Atom a) = string((uppercase(ch) : ch <- raw_str(_str_(a))));


String upper_camel_case(Atom a) = capitalize(_str_(a), false);


String capitalize(String s, Bool keep_underscores)
{
  first = true;
  res = ();
  for ch @ i <- _obj_(s):
    tr_ch = ch;
    if ch == ascii_underscore:
      first = true;
    else
      tr_ch  = nat(ch - ascii_lower_a + ascii_upper_a) if ch >= ascii_lower_a and ch <= ascii_lower_z and first; //## CREATE PRELUDE FUNCTION is_lower()/is_upper() AND to_lower()/to_upper()
      first = false;
    ;
    res = res & (tr_ch if tr_ch != ascii_underscore or keep_underscores);
  ;
  return string(res);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

String user_repr(Type type) = user_repr(type, false, false, false, false);

String user_repr(Type type, Bool inside_type_union, Bool incl_empty_seq, Bool incl_empty_set, Bool incl_empty_map):
  empty_type                = "</>",
  atom_type                 = "<+>",
  symb_type(object(a?))     = {res = _str_(a); res = "<" & res & ">" if not inside_type_union; return res;},
  integer                   = "<*..*>",
  low_ints()                = "<*.." & printed(type.max) & ">",
  high_ints()               = "<" & printed(type.min) & "..*>",
  int_range()               = "<" & printed(type.min) & ".." & printed(type.min + type.size - 1) & ">",
  float_type                = "<^>",
  empty_seq_type            = "()",
  empty_set_type            = "[]",
  empty_map_type            = "[:]",
  type_var(Atom a?)         = uppercase(a),
  type_var()                = {fail;},
  type_ref(ts?)             = user_repr(ts),
  ne_seq_type()             = user_repr(type.elem_type) & if incl_empty_seq then "*" else "+",
  ne_set_type()             = "[" & {if incl_empty_set then "" else "+"} & user_repr(type.elem_type) & "]",
  ne_map_type()             = "[" & {if incl_empty_set then "" else "+"} & user_repr(type.key_type) & " -> " & user_repr(type.value_type) & "]",
  ne_record_type(fs?)       = ne_record_type_user_repr(fs),
  tuple_type(ts?)           = "(" & append((user_repr(t) : t <- ts), ", ") & ")",
  tag_obj_type()            = tag_obj_type_user_repr(type.tag_type, type.obj_type),
  union_type(ts?)           = union_type_user_repr(ts);


String ne_record_type_user_repr(RecordTypeFields fields)
{
  field_reprs = [record_field_user_repr(l, f.type, f.optional) : f @ l <- fields];
  return "[" & append(rand_sort(field_reprs), ", ") & "]";

  String record_field_user_repr(SymbObj label, NeType type, Bool optional) =
    _str_(match (label) object(a?) = a) & ": " & user_repr(type) & if optional then "?" else "";
}


String union_type_user_repr([+NeType] types)
{
  incl_empty_seq = in(empty_seq_type, types);
  incl_empty_set = in(empty_set_type, types);
  incl_empty_map = in(empty_map_type, types);

  types_to_exclude = [
    empty_seq_type if (? t <- types : match (t) ne_seq_type() = true, _ = false),
    empty_set_type if (? t <- types : match (t) ne_set_type() = true, _ = false),
    empty_map_type if (? t <- types : match (t) ne_map_type() = true, _ = false)
  ];

  types_left_sorted = rand_sort(types - types_to_exclude);
  is_still_union = length(types_left_sorted) > 1;
  types_reprs = (user_repr(t, is_still_union, incl_empty_seq, incl_empty_set, incl_empty_map) : t <- types_left_sorted);
  repr_str = append(types_reprs, ", ");
  repr_str = "<" & repr_str & ">" if is_still_union;
  return repr_str;
}


String tag_obj_type_user_repr(TagType tag_type, NeType obj_type):
  atom_type               = "(<+> @ " & user_repr(obj_type) & ")",
  symb_type(object(tag?)) = _str_(tag) & "(" & user_repr(obj_type) & ")";


String user_repr(TypeSymbol type_symb):
  type_symbol(a?)           = upper_camel_case(a),
  builtin_type_symbol(a?)   = "#" & upper_camel_case(a),
  par_type_symbol()         = user_repr(type_symb.symbol) & "[" & append((user_repr(p) : p <- type_symb.params), ", ") & "]";


String user_repr(SymbObj):
  object(a?)  = _str_(a);


String user_repr(Var v):
  fn_par(n?)        = "$" & printed(n),
  named_arg(a?)     = _str_(a),
  cls_ext_par(n?)   = {fail;},
  var(a?)           = _str_(a);


String user_repr(AnyAutoVar v) = _str_(name(v));


String user_repr(ProcSymbol):
  proc_symbol(a?)   = upper_camel_case(a);


String user_repr(BuiltIn b) = "_" & _str_(b) & "_";


String user_repr(FnSymbol fn_symb, Nat arity):
  fn_symbol(a?)         = _str_(a) & "/" & printed(arity),
  op_symbol(op?)        = user_repr(op, arity),
  nested_fn_symbol()    = user_repr(fn_symb.outer) & ":" & user_repr(fn_symb.inner),
  unique_fn_symbol()    = {fail;};


String user_repr(Operator, Nat arity):
  plus          = "(_+_)",
  minus         = if arity == 1 then "(-_)" else "(_-_)",
  star          = "(_*_)",
  slash         = "(_/_)",
  exp           = "(_^_)",
  amp           = "(_&_)",
  lower         = "(_<_)",
  greater       = "(_>_)",
  lower_eq      = "(_<=_)",
  greater_eq    = "(_>=_)",
  brackets      = "(_[_])";


String user_repr(ClsVar v):
  cls_var(Atom a?)    = _str_(a);


String user_repr(ClsType type) = "(" & append((user_repr(t) : t <- type.in_types), ", ") & " -> " & user_repr(type.out_type) & ")";


String user_repr(FnType type) = append((user_repr(t) : t <- type.params), ", ") & " -> " & user_repr(type.ret_type);


String user_repr(PseudoType pseudotype)
{
  bpts = match (pseudotype) pseudotype(pts?) = pts;
  return append((user_repr(pt) : pt <- rand_sort(bpts)), ", ");

  String user_repr(BasicPseudoType psuedotype):
    symbol(a?)        = _str_(a),
    integers          = "<*..*>",
    floats            = "<^>",
    empty_set         = "{}",
    ne_sets           = "{..}",
    empty_seq         = "[]",
    ne_seqs           = "[..]",
    empty_map         = "()",
    ne_maps           = "(..)",
    tag_obj(a?)       = _str_(a) & "()",
    symbols           = "<+>",
    tag_objs          = "*()";
}


String user_repr(Pattern ptrn):
  ptrn_symbol         = "+",
  ptrn_float          = "*",
  ptrn_empty_set      = "{...}",
  ptrn_ne_set         = "{...}",
  ptrn_empty_seq      = "[...]",
  ptrn_ne_seq         = "[...]",
  ptrn_empty_map      = "(...)",
  ptrn_ne_map         = "(...)",
  ptrn_any            = "_",
  ptrn_symbol(s?)     = _str_(match (s) object(a?) = a),
  ptrn_integer(t?)    = user_repr(t),
  ptrn_tag_obj()      = ptrn_tag_obj_user_repr(ptrn.tag, ptrn.obj),
  ptrn_var()          = {if ptrn.ptrn != ptrn_any then user_repr(ptrn.ptrn) & " " else ""} & user_repr(ptrn.var) & "?",
  ptrn_union(ps?)     = "<" & append((user_repr(p) : p <- rand_sort(ps)), ", ") & ">";


String ptrn_tag_obj_user_repr(TagPtrn tag, Pattern obj):
  ptrn_symbol               = "_ @ " & user_repr(obj),
  ptrn_symbol(object(s?))   = _str_(s) & "(" & user_repr(obj) & ")",
  ptrn_var()                = user_repr(tag.var) & " @ " & user_repr(obj);


String user_repr(FnSymbol fn_symb):
  fn_symbol(a?)         = _str_(a),
  op_symbol(op?)        = user_repr(op),
  nested_fn_symbol()    = user_repr(fn_symb.outer) & ":" & user_repr(fn_symb.inner),
  unique_fn_symbol()    = {fail;};


String user_repr(AutoSymbol): auto_symbol(a?) = _str_(a);


String user_repr(Operator):
  plus          = "(_+_)",
  minus         = "(_-_)", //## BUG BUG BUG: THIS IS WRONG, THERE ARE TWO OPERATORS HERE, THE UNARY AND THE BINARY ONE
  star          = "(_*_)",
  slash         = "(_/_)",
  exp           = "(_^_)",
  amp           = "(_&_)",
  lower         = "(_<_)",
  greater       = "(_>_)",
  lower_eq      = "(_<=_)",
  greater_eq    = "(_>=_)",
  brackets      = "(_[_])";
